/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 7);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/*!******************************************!*\
  !*** ./node_modules/js-base64/base64.js ***!
  \******************************************/
/*! dynamic exports provided */
/*! exports used: Base64 */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n *  base64.js\n *\n *  Licensed under the BSD 3-Clause License.\n *    http://opensource.org/licenses/BSD-3-Clause\n *\n *  References:\n *    http://en.wikipedia.org/wiki/Base64\n */\n;(function (global, factory) {\n     true\n        ? module.exports = factory(global)\n        : typeof define === 'function' && define.amd\n        ? define(factory) : factory(global)\n}((\n    typeof self !== 'undefined' ? self\n        : typeof window !== 'undefined' ? window\n        : typeof global !== 'undefined' ? global\n: this\n), function(global) {\n    'use strict';\n    // existing version for noConflict()\n    global = global || {};\n    var _Base64 = global.Base64;\n    var version = \"2.5.1\";\n    // if node.js and NOT React Native, we use Buffer\n    var buffer;\n    if (typeof module !== 'undefined' && module.exports) {\n        try {\n            buffer = eval(\"require('buffer').Buffer\");\n        } catch (err) {\n            buffer = undefined;\n        }\n    }\n    // constants\n    var b64chars\n        = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n    var b64tab = function(bin) {\n        var t = {};\n        for (var i = 0, l = bin.length; i < l; i++) t[bin.charAt(i)] = i;\n        return t;\n    }(b64chars);\n    var fromCharCode = String.fromCharCode;\n    // encoder stuff\n    var cb_utob = function(c) {\n        if (c.length < 2) {\n            var cc = c.charCodeAt(0);\n            return cc < 0x80 ? c\n                : cc < 0x800 ? (fromCharCode(0xc0 | (cc >>> 6))\n                                + fromCharCode(0x80 | (cc & 0x3f)))\n                : (fromCharCode(0xe0 | ((cc >>> 12) & 0x0f))\n                   + fromCharCode(0x80 | ((cc >>>  6) & 0x3f))\n                   + fromCharCode(0x80 | ( cc         & 0x3f)));\n        } else {\n            var cc = 0x10000\n                + (c.charCodeAt(0) - 0xD800) * 0x400\n                + (c.charCodeAt(1) - 0xDC00);\n            return (fromCharCode(0xf0 | ((cc >>> 18) & 0x07))\n                    + fromCharCode(0x80 | ((cc >>> 12) & 0x3f))\n                    + fromCharCode(0x80 | ((cc >>>  6) & 0x3f))\n                    + fromCharCode(0x80 | ( cc         & 0x3f)));\n        }\n    };\n    var re_utob = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFFF]|[^\\x00-\\x7F]/g;\n    var utob = function(u) {\n        return u.replace(re_utob, cb_utob);\n    };\n    var cb_encode = function(ccc) {\n        var padlen = [0, 2, 1][ccc.length % 3],\n        ord = ccc.charCodeAt(0) << 16\n            | ((ccc.length > 1 ? ccc.charCodeAt(1) : 0) << 8)\n            | ((ccc.length > 2 ? ccc.charCodeAt(2) : 0)),\n        chars = [\n            b64chars.charAt( ord >>> 18),\n            b64chars.charAt((ord >>> 12) & 63),\n            padlen >= 2 ? '=' : b64chars.charAt((ord >>> 6) & 63),\n            padlen >= 1 ? '=' : b64chars.charAt(ord & 63)\n        ];\n        return chars.join('');\n    };\n    var btoa = global.btoa ? function(b) {\n        return global.btoa(b);\n    } : function(b) {\n        return b.replace(/[\\s\\S]{1,3}/g, cb_encode);\n    };\n    var _encode = buffer ?\n        buffer.from && Uint8Array && buffer.from !== Uint8Array.from\n        ? function (u) {\n            return (u.constructor === buffer.constructor ? u : buffer.from(u))\n                .toString('base64')\n        }\n        :  function (u) {\n            return (u.constructor === buffer.constructor ? u : new  buffer(u))\n                .toString('base64')\n        }\n        : function (u) { return btoa(utob(u)) }\n    ;\n    var encode = function(u, urisafe) {\n        return !urisafe\n            ? _encode(String(u))\n            : _encode(String(u)).replace(/[+\\/]/g, function(m0) {\n                return m0 == '+' ? '-' : '_';\n            }).replace(/=/g, '');\n    };\n    var encodeURI = function(u) { return encode(u, true) };\n    // decoder stuff\n    var re_btou = new RegExp([\n        '[\\xC0-\\xDF][\\x80-\\xBF]',\n        '[\\xE0-\\xEF][\\x80-\\xBF]{2}',\n        '[\\xF0-\\xF7][\\x80-\\xBF]{3}'\n    ].join('|'), 'g');\n    var cb_btou = function(cccc) {\n        switch(cccc.length) {\n        case 4:\n            var cp = ((0x07 & cccc.charCodeAt(0)) << 18)\n                |    ((0x3f & cccc.charCodeAt(1)) << 12)\n                |    ((0x3f & cccc.charCodeAt(2)) <<  6)\n                |     (0x3f & cccc.charCodeAt(3)),\n            offset = cp - 0x10000;\n            return (fromCharCode((offset  >>> 10) + 0xD800)\n                    + fromCharCode((offset & 0x3FF) + 0xDC00));\n        case 3:\n            return fromCharCode(\n                ((0x0f & cccc.charCodeAt(0)) << 12)\n                    | ((0x3f & cccc.charCodeAt(1)) << 6)\n                    |  (0x3f & cccc.charCodeAt(2))\n            );\n        default:\n            return  fromCharCode(\n                ((0x1f & cccc.charCodeAt(0)) << 6)\n                    |  (0x3f & cccc.charCodeAt(1))\n            );\n        }\n    };\n    var btou = function(b) {\n        return b.replace(re_btou, cb_btou);\n    };\n    var cb_decode = function(cccc) {\n        var len = cccc.length,\n        padlen = len % 4,\n        n = (len > 0 ? b64tab[cccc.charAt(0)] << 18 : 0)\n            | (len > 1 ? b64tab[cccc.charAt(1)] << 12 : 0)\n            | (len > 2 ? b64tab[cccc.charAt(2)] <<  6 : 0)\n            | (len > 3 ? b64tab[cccc.charAt(3)]       : 0),\n        chars = [\n            fromCharCode( n >>> 16),\n            fromCharCode((n >>>  8) & 0xff),\n            fromCharCode( n         & 0xff)\n        ];\n        chars.length -= [0, 0, 2, 1][padlen];\n        return chars.join('');\n    };\n    var _atob = global.atob ? function(a) {\n        return global.atob(a);\n    } : function(a){\n        return a.replace(/\\S{1,4}/g, cb_decode);\n    };\n    var atob = function(a) {\n        return _atob(String(a).replace(/[^A-Za-z0-9\\+\\/]/g, ''));\n    };\n    var _decode = buffer ?\n        buffer.from && Uint8Array && buffer.from !== Uint8Array.from\n        ? function(a) {\n            return (a.constructor === buffer.constructor\n                    ? a : buffer.from(a, 'base64')).toString();\n        }\n        : function(a) {\n            return (a.constructor === buffer.constructor\n                    ? a : new buffer(a, 'base64')).toString();\n        }\n        : function(a) { return btou(_atob(a)) };\n    var decode = function(a){\n        return _decode(\n            String(a).replace(/[-_]/g, function(m0) { return m0 == '-' ? '+' : '/' })\n                .replace(/[^A-Za-z0-9\\+\\/]/g, '')\n        );\n    };\n    var noConflict = function() {\n        var Base64 = global.Base64;\n        global.Base64 = _Base64;\n        return Base64;\n    };\n    // export Base64\n    global.Base64 = {\n        VERSION: version,\n        atob: atob,\n        btoa: btoa,\n        fromBase64: decode,\n        toBase64: encode,\n        utob: utob,\n        encode: encode,\n        encodeURI: encodeURI,\n        btou: btou,\n        decode: decode,\n        noConflict: noConflict,\n        __buffer__: buffer\n    };\n    // if ES5 is available, make Base64.extendString() available\n    if (typeof Object.defineProperty === 'function') {\n        var noEnum = function(v){\n            return {value:v,enumerable:false,writable:true,configurable:true};\n        };\n        global.Base64.extendString = function () {\n            Object.defineProperty(\n                String.prototype, 'fromBase64', noEnum(function () {\n                    return decode(this)\n                }));\n            Object.defineProperty(\n                String.prototype, 'toBase64', noEnum(function (urisafe) {\n                    return encode(this, urisafe)\n                }));\n            Object.defineProperty(\n                String.prototype, 'toBase64URI', noEnum(function () {\n                    return encode(this, true)\n                }));\n        };\n    }\n    //\n    // export Base64 to the namespace\n    //\n    if (global['Meteor']) { // Meteor.js\n        Base64 = global.Base64;\n    }\n    // module.exports and AMD are mutually exclusive.\n    // module.exports has precedence.\n    if (typeof module !== 'undefined' && module.exports) {\n        module.exports.Base64 = global.Base64;\n    }\n    else if (true) {\n        // AMD. Register as an anonymous module.\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function(){ return global.Base64 }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    }\n    // that's it!\n    return {Base64: global.Base64}\n}));\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./../webpack/buildin/global.js */ 1)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcy1iYXNlNjQvYmFzZTY0LmpzP2M2YjQiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqICBiYXNlNjQuanNcbiAqXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIEJTRCAzLUNsYXVzZSBMaWNlbnNlLlxuICogICAgaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICpcbiAqICBSZWZlcmVuY2VzOlxuICogICAgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXNlNjRcbiAqL1xuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXG4gICAgICAgID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KGdsb2JhbClcbiAgICAgICAgOiB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWRcbiAgICAgICAgPyBkZWZpbmUoZmFjdG9yeSkgOiBmYWN0b3J5KGdsb2JhbClcbn0oKFxuICAgIHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGZcbiAgICAgICAgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvd1xuICAgICAgICA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsXG46IHRoaXNcbiksIGZ1bmN0aW9uKGdsb2JhbCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvLyBleGlzdGluZyB2ZXJzaW9uIGZvciBub0NvbmZsaWN0KClcbiAgICBnbG9iYWwgPSBnbG9iYWwgfHwge307XG4gICAgdmFyIF9CYXNlNjQgPSBnbG9iYWwuQmFzZTY0O1xuICAgIHZhciB2ZXJzaW9uID0gXCIyLjUuMVwiO1xuICAgIC8vIGlmIG5vZGUuanMgYW5kIE5PVCBSZWFjdCBOYXRpdmUsIHdlIHVzZSBCdWZmZXJcbiAgICB2YXIgYnVmZmVyO1xuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYnVmZmVyID0gZXZhbChcInJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlclwiKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBidWZmZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gY29uc3RhbnRzXG4gICAgdmFyIGI2NGNoYXJzXG4gICAgICAgID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xuICAgIHZhciBiNjR0YWIgPSBmdW5jdGlvbihiaW4pIHtcbiAgICAgICAgdmFyIHQgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBiaW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB0W2Jpbi5jaGFyQXQoaSldID0gaTtcbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfShiNjRjaGFycyk7XG4gICAgdmFyIGZyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG4gICAgLy8gZW5jb2RlciBzdHVmZlxuICAgIHZhciBjYl91dG9iID0gZnVuY3Rpb24oYykge1xuICAgICAgICBpZiAoYy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICB2YXIgY2MgPSBjLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICByZXR1cm4gY2MgPCAweDgwID8gY1xuICAgICAgICAgICAgICAgIDogY2MgPCAweDgwMCA/IChmcm9tQ2hhckNvZGUoMHhjMCB8IChjYyA+Pj4gNikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgZnJvbUNoYXJDb2RlKDB4ODAgfCAoY2MgJiAweDNmKSkpXG4gICAgICAgICAgICAgICAgOiAoZnJvbUNoYXJDb2RlKDB4ZTAgfCAoKGNjID4+PiAxMikgJiAweDBmKSlcbiAgICAgICAgICAgICAgICAgICArIGZyb21DaGFyQ29kZSgweDgwIHwgKChjYyA+Pj4gIDYpICYgMHgzZikpXG4gICAgICAgICAgICAgICAgICAgKyBmcm9tQ2hhckNvZGUoMHg4MCB8ICggY2MgICAgICAgICAmIDB4M2YpKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgY2MgPSAweDEwMDAwXG4gICAgICAgICAgICAgICAgKyAoYy5jaGFyQ29kZUF0KDApIC0gMHhEODAwKSAqIDB4NDAwXG4gICAgICAgICAgICAgICAgKyAoYy5jaGFyQ29kZUF0KDEpIC0gMHhEQzAwKTtcbiAgICAgICAgICAgIHJldHVybiAoZnJvbUNoYXJDb2RlKDB4ZjAgfCAoKGNjID4+PiAxOCkgJiAweDA3KSlcbiAgICAgICAgICAgICAgICAgICAgKyBmcm9tQ2hhckNvZGUoMHg4MCB8ICgoY2MgPj4+IDEyKSAmIDB4M2YpKVxuICAgICAgICAgICAgICAgICAgICArIGZyb21DaGFyQ29kZSgweDgwIHwgKChjYyA+Pj4gIDYpICYgMHgzZikpXG4gICAgICAgICAgICAgICAgICAgICsgZnJvbUNoYXJDb2RlKDB4ODAgfCAoIGNjICAgICAgICAgJiAweDNmKSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgcmVfdXRvYiA9IC9bXFx1RDgwMC1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZGXXxbXlxceDAwLVxceDdGXS9nO1xuICAgIHZhciB1dG9iID0gZnVuY3Rpb24odSkge1xuICAgICAgICByZXR1cm4gdS5yZXBsYWNlKHJlX3V0b2IsIGNiX3V0b2IpO1xuICAgIH07XG4gICAgdmFyIGNiX2VuY29kZSA9IGZ1bmN0aW9uKGNjYykge1xuICAgICAgICB2YXIgcGFkbGVuID0gWzAsIDIsIDFdW2NjYy5sZW5ndGggJSAzXSxcbiAgICAgICAgb3JkID0gY2NjLmNoYXJDb2RlQXQoMCkgPDwgMTZcbiAgICAgICAgICAgIHwgKChjY2MubGVuZ3RoID4gMSA/IGNjYy5jaGFyQ29kZUF0KDEpIDogMCkgPDwgOClcbiAgICAgICAgICAgIHwgKChjY2MubGVuZ3RoID4gMiA/IGNjYy5jaGFyQ29kZUF0KDIpIDogMCkpLFxuICAgICAgICBjaGFycyA9IFtcbiAgICAgICAgICAgIGI2NGNoYXJzLmNoYXJBdCggb3JkID4+PiAxOCksXG4gICAgICAgICAgICBiNjRjaGFycy5jaGFyQXQoKG9yZCA+Pj4gMTIpICYgNjMpLFxuICAgICAgICAgICAgcGFkbGVuID49IDIgPyAnPScgOiBiNjRjaGFycy5jaGFyQXQoKG9yZCA+Pj4gNikgJiA2MyksXG4gICAgICAgICAgICBwYWRsZW4gPj0gMSA/ICc9JyA6IGI2NGNoYXJzLmNoYXJBdChvcmQgJiA2MylcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIGNoYXJzLmpvaW4oJycpO1xuICAgIH07XG4gICAgdmFyIGJ0b2EgPSBnbG9iYWwuYnRvYSA/IGZ1bmN0aW9uKGIpIHtcbiAgICAgICAgcmV0dXJuIGdsb2JhbC5idG9hKGIpO1xuICAgIH0gOiBmdW5jdGlvbihiKSB7XG4gICAgICAgIHJldHVybiBiLnJlcGxhY2UoL1tcXHNcXFNdezEsM30vZywgY2JfZW5jb2RlKTtcbiAgICB9O1xuICAgIHZhciBfZW5jb2RlID0gYnVmZmVyID9cbiAgICAgICAgYnVmZmVyLmZyb20gJiYgVWludDhBcnJheSAmJiBidWZmZXIuZnJvbSAhPT0gVWludDhBcnJheS5mcm9tXG4gICAgICAgID8gZnVuY3Rpb24gKHUpIHtcbiAgICAgICAgICAgIHJldHVybiAodS5jb25zdHJ1Y3RvciA9PT0gYnVmZmVyLmNvbnN0cnVjdG9yID8gdSA6IGJ1ZmZlci5mcm9tKHUpKVxuICAgICAgICAgICAgICAgIC50b1N0cmluZygnYmFzZTY0JylcbiAgICAgICAgfVxuICAgICAgICA6ICBmdW5jdGlvbiAodSkge1xuICAgICAgICAgICAgcmV0dXJuICh1LmNvbnN0cnVjdG9yID09PSBidWZmZXIuY29uc3RydWN0b3IgPyB1IDogbmV3ICBidWZmZXIodSkpXG4gICAgICAgICAgICAgICAgLnRvU3RyaW5nKCdiYXNlNjQnKVxuICAgICAgICB9XG4gICAgICAgIDogZnVuY3Rpb24gKHUpIHsgcmV0dXJuIGJ0b2EodXRvYih1KSkgfVxuICAgIDtcbiAgICB2YXIgZW5jb2RlID0gZnVuY3Rpb24odSwgdXJpc2FmZSkge1xuICAgICAgICByZXR1cm4gIXVyaXNhZmVcbiAgICAgICAgICAgID8gX2VuY29kZShTdHJpbmcodSkpXG4gICAgICAgICAgICA6IF9lbmNvZGUoU3RyaW5nKHUpKS5yZXBsYWNlKC9bK1xcL10vZywgZnVuY3Rpb24obTApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbTAgPT0gJysnID8gJy0nIDogJ18nO1xuICAgICAgICAgICAgfSkucmVwbGFjZSgvPS9nLCAnJyk7XG4gICAgfTtcbiAgICB2YXIgZW5jb2RlVVJJID0gZnVuY3Rpb24odSkgeyByZXR1cm4gZW5jb2RlKHUsIHRydWUpIH07XG4gICAgLy8gZGVjb2RlciBzdHVmZlxuICAgIHZhciByZV9idG91ID0gbmV3IFJlZ0V4cChbXG4gICAgICAgICdbXFx4QzAtXFx4REZdW1xceDgwLVxceEJGXScsXG4gICAgICAgICdbXFx4RTAtXFx4RUZdW1xceDgwLVxceEJGXXsyfScsXG4gICAgICAgICdbXFx4RjAtXFx4RjddW1xceDgwLVxceEJGXXszfSdcbiAgICBdLmpvaW4oJ3wnKSwgJ2cnKTtcbiAgICB2YXIgY2JfYnRvdSA9IGZ1bmN0aW9uKGNjY2MpIHtcbiAgICAgICAgc3dpdGNoKGNjY2MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHZhciBjcCA9ICgoMHgwNyAmIGNjY2MuY2hhckNvZGVBdCgwKSkgPDwgMTgpXG4gICAgICAgICAgICAgICAgfCAgICAoKDB4M2YgJiBjY2NjLmNoYXJDb2RlQXQoMSkpIDw8IDEyKVxuICAgICAgICAgICAgICAgIHwgICAgKCgweDNmICYgY2NjYy5jaGFyQ29kZUF0KDIpKSA8PCAgNilcbiAgICAgICAgICAgICAgICB8ICAgICAoMHgzZiAmIGNjY2MuY2hhckNvZGVBdCgzKSksXG4gICAgICAgICAgICBvZmZzZXQgPSBjcCAtIDB4MTAwMDA7XG4gICAgICAgICAgICByZXR1cm4gKGZyb21DaGFyQ29kZSgob2Zmc2V0ICA+Pj4gMTApICsgMHhEODAwKVxuICAgICAgICAgICAgICAgICAgICArIGZyb21DaGFyQ29kZSgob2Zmc2V0ICYgMHgzRkYpICsgMHhEQzAwKSk7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiBmcm9tQ2hhckNvZGUoXG4gICAgICAgICAgICAgICAgKCgweDBmICYgY2NjYy5jaGFyQ29kZUF0KDApKSA8PCAxMilcbiAgICAgICAgICAgICAgICAgICAgfCAoKDB4M2YgJiBjY2NjLmNoYXJDb2RlQXQoMSkpIDw8IDYpXG4gICAgICAgICAgICAgICAgICAgIHwgICgweDNmICYgY2NjYy5jaGFyQ29kZUF0KDIpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiAgZnJvbUNoYXJDb2RlKFxuICAgICAgICAgICAgICAgICgoMHgxZiAmIGNjY2MuY2hhckNvZGVBdCgwKSkgPDwgNilcbiAgICAgICAgICAgICAgICAgICAgfCAgKDB4M2YgJiBjY2NjLmNoYXJDb2RlQXQoMSkpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgYnRvdSA9IGZ1bmN0aW9uKGIpIHtcbiAgICAgICAgcmV0dXJuIGIucmVwbGFjZShyZV9idG91LCBjYl9idG91KTtcbiAgICB9O1xuICAgIHZhciBjYl9kZWNvZGUgPSBmdW5jdGlvbihjY2NjKSB7XG4gICAgICAgIHZhciBsZW4gPSBjY2NjLmxlbmd0aCxcbiAgICAgICAgcGFkbGVuID0gbGVuICUgNCxcbiAgICAgICAgbiA9IChsZW4gPiAwID8gYjY0dGFiW2NjY2MuY2hhckF0KDApXSA8PCAxOCA6IDApXG4gICAgICAgICAgICB8IChsZW4gPiAxID8gYjY0dGFiW2NjY2MuY2hhckF0KDEpXSA8PCAxMiA6IDApXG4gICAgICAgICAgICB8IChsZW4gPiAyID8gYjY0dGFiW2NjY2MuY2hhckF0KDIpXSA8PCAgNiA6IDApXG4gICAgICAgICAgICB8IChsZW4gPiAzID8gYjY0dGFiW2NjY2MuY2hhckF0KDMpXSAgICAgICA6IDApLFxuICAgICAgICBjaGFycyA9IFtcbiAgICAgICAgICAgIGZyb21DaGFyQ29kZSggbiA+Pj4gMTYpLFxuICAgICAgICAgICAgZnJvbUNoYXJDb2RlKChuID4+PiAgOCkgJiAweGZmKSxcbiAgICAgICAgICAgIGZyb21DaGFyQ29kZSggbiAgICAgICAgICYgMHhmZilcbiAgICAgICAgXTtcbiAgICAgICAgY2hhcnMubGVuZ3RoIC09IFswLCAwLCAyLCAxXVtwYWRsZW5dO1xuICAgICAgICByZXR1cm4gY2hhcnMuam9pbignJyk7XG4gICAgfTtcbiAgICB2YXIgX2F0b2IgPSBnbG9iYWwuYXRvYiA/IGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgcmV0dXJuIGdsb2JhbC5hdG9iKGEpO1xuICAgIH0gOiBmdW5jdGlvbihhKXtcbiAgICAgICAgcmV0dXJuIGEucmVwbGFjZSgvXFxTezEsNH0vZywgY2JfZGVjb2RlKTtcbiAgICB9O1xuICAgIHZhciBhdG9iID0gZnVuY3Rpb24oYSkge1xuICAgICAgICByZXR1cm4gX2F0b2IoU3RyaW5nKGEpLnJlcGxhY2UoL1teQS1aYS16MC05XFwrXFwvXS9nLCAnJykpO1xuICAgIH07XG4gICAgdmFyIF9kZWNvZGUgPSBidWZmZXIgP1xuICAgICAgICBidWZmZXIuZnJvbSAmJiBVaW50OEFycmF5ICYmIGJ1ZmZlci5mcm9tICE9PSBVaW50OEFycmF5LmZyb21cbiAgICAgICAgPyBmdW5jdGlvbihhKSB7XG4gICAgICAgICAgICByZXR1cm4gKGEuY29uc3RydWN0b3IgPT09IGJ1ZmZlci5jb25zdHJ1Y3RvclxuICAgICAgICAgICAgICAgICAgICA/IGEgOiBidWZmZXIuZnJvbShhLCAnYmFzZTY0JykpLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgOiBmdW5jdGlvbihhKSB7XG4gICAgICAgICAgICByZXR1cm4gKGEuY29uc3RydWN0b3IgPT09IGJ1ZmZlci5jb25zdHJ1Y3RvclxuICAgICAgICAgICAgICAgICAgICA/IGEgOiBuZXcgYnVmZmVyKGEsICdiYXNlNjQnKSkudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICA6IGZ1bmN0aW9uKGEpIHsgcmV0dXJuIGJ0b3UoX2F0b2IoYSkpIH07XG4gICAgdmFyIGRlY29kZSA9IGZ1bmN0aW9uKGEpe1xuICAgICAgICByZXR1cm4gX2RlY29kZShcbiAgICAgICAgICAgIFN0cmluZyhhKS5yZXBsYWNlKC9bLV9dL2csIGZ1bmN0aW9uKG0wKSB7IHJldHVybiBtMCA9PSAnLScgPyAnKycgOiAnLycgfSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvW15BLVphLXowLTlcXCtcXC9dL2csICcnKVxuICAgICAgICApO1xuICAgIH07XG4gICAgdmFyIG5vQ29uZmxpY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIEJhc2U2NCA9IGdsb2JhbC5CYXNlNjQ7XG4gICAgICAgIGdsb2JhbC5CYXNlNjQgPSBfQmFzZTY0O1xuICAgICAgICByZXR1cm4gQmFzZTY0O1xuICAgIH07XG4gICAgLy8gZXhwb3J0IEJhc2U2NFxuICAgIGdsb2JhbC5CYXNlNjQgPSB7XG4gICAgICAgIFZFUlNJT046IHZlcnNpb24sXG4gICAgICAgIGF0b2I6IGF0b2IsXG4gICAgICAgIGJ0b2E6IGJ0b2EsXG4gICAgICAgIGZyb21CYXNlNjQ6IGRlY29kZSxcbiAgICAgICAgdG9CYXNlNjQ6IGVuY29kZSxcbiAgICAgICAgdXRvYjogdXRvYixcbiAgICAgICAgZW5jb2RlOiBlbmNvZGUsXG4gICAgICAgIGVuY29kZVVSSTogZW5jb2RlVVJJLFxuICAgICAgICBidG91OiBidG91LFxuICAgICAgICBkZWNvZGU6IGRlY29kZSxcbiAgICAgICAgbm9Db25mbGljdDogbm9Db25mbGljdCxcbiAgICAgICAgX19idWZmZXJfXzogYnVmZmVyXG4gICAgfTtcbiAgICAvLyBpZiBFUzUgaXMgYXZhaWxhYmxlLCBtYWtlIEJhc2U2NC5leHRlbmRTdHJpbmcoKSBhdmFpbGFibGVcbiAgICBpZiAodHlwZW9mIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgbm9FbnVtID0gZnVuY3Rpb24odil7XG4gICAgICAgICAgICByZXR1cm4ge3ZhbHVlOnYsZW51bWVyYWJsZTpmYWxzZSx3cml0YWJsZTp0cnVlLGNvbmZpZ3VyYWJsZTp0cnVlfTtcbiAgICAgICAgfTtcbiAgICAgICAgZ2xvYmFsLkJhc2U2NC5leHRlbmRTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAgICAgICAgICAgICAgU3RyaW5nLnByb3RvdHlwZSwgJ2Zyb21CYXNlNjQnLCBub0VudW0oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVjb2RlKHRoaXMpXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgICAgICAgICAgICAgIFN0cmluZy5wcm90b3R5cGUsICd0b0Jhc2U2NCcsIG5vRW51bShmdW5jdGlvbiAodXJpc2FmZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW5jb2RlKHRoaXMsIHVyaXNhZmUpXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgICAgICAgICAgICAgIFN0cmluZy5wcm90b3R5cGUsICd0b0Jhc2U2NFVSSScsIG5vRW51bShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbmNvZGUodGhpcywgdHJ1ZSlcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vXG4gICAgLy8gZXhwb3J0IEJhc2U2NCB0byB0aGUgbmFtZXNwYWNlXG4gICAgLy9cbiAgICBpZiAoZ2xvYmFsWydNZXRlb3InXSkgeyAvLyBNZXRlb3IuanNcbiAgICAgICAgQmFzZTY0ID0gZ2xvYmFsLkJhc2U2NDtcbiAgICB9XG4gICAgLy8gbW9kdWxlLmV4cG9ydHMgYW5kIEFNRCBhcmUgbXV0dWFsbHkgZXhjbHVzaXZlLlxuICAgIC8vIG1vZHVsZS5leHBvcnRzIGhhcyBwcmVjZWRlbmNlLlxuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cy5CYXNlNjQgPSBnbG9iYWwuQmFzZTY0O1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuICAgICAgICBkZWZpbmUoW10sIGZ1bmN0aW9uKCl7IHJldHVybiBnbG9iYWwuQmFzZTY0IH0pO1xuICAgIH1cbiAgICAvLyB0aGF0J3MgaXQhXG4gICAgcmV0dXJuIHtCYXNlNjQ6IGdsb2JhbC5CYXNlNjR9XG59KSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9qcy1iYXNlNjQvYmFzZTY0LmpzXG4vLyBtb2R1bGUgaWQgPSAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///0\n");

/***/ }),
/* 1 */
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports) {

eval("var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanM/MzY5OCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2goZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcclxuXHRcdGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanNcbi8vIG1vZHVsZSBpZCA9IDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1\n");

/***/ }),
/* 2 */
/*!**************************!*\
  !*** ./src/translate.js ***!
  \**************************/
/*! exports provided: default */
/*! exports used: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("var __ = wp.i18n.__;\n\n\nvar __tr__ = function __tr__(str) {\n  return __(str, 'mcw-custom-js-css-gutenberg');\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (__tr__);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy90cmFuc2xhdGUuanM/MWRmOSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX18gPSB3cC5pMThuLl9fO1xuXG5cbnZhciBfX3RyX18gPSBmdW5jdGlvbiBfX3RyX18oc3RyKSB7XG4gIHJldHVybiBfXyhzdHIsICdtY3ctY3VzdG9tLWpzLWNzcy1ndXRlbmJlcmcnKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IF9fdHJfXztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy90cmFuc2xhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2\n");

/***/ }),
/* 3 */
/*!*********************!*\
  !*** ./src/icon.js ***!
  \*********************/
/*! exports provided: default */
/*! exports used: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("\n// Block icon\nvar Icon = wp.element.createElement(\n  'svg',\n  { xmlns: 'http://www.w3.org/2000/svg', width: '128', height: '128', viewBox: '0 0 1024 1024' },\n  wp.element.createElement('path', { fill: '#ce280f', d: 'M831,333m3-183c30.713-.42,69.932-4.692,83,13,9.687,13.114,7,40.313,7,63V372c0,23.085,2.929,51.634-7,65-13.132,17.679-52.239,13.409-83,13V574c30.713-.42,69.932-4.692,83,13,9.687,13.114,7,40.313,7,63V796c0,23.085,2.929,51.634-7,65-13.132,17.679-52.239,13.409-83,13,0.313,36.721,8.838,104.988-13,121-16.042,11.76-100.252,5-129,5H343c-30.16,0-123.35,7.26-140-5-21.847-16.087-13.281-84.22-13-121-30.713.42-69.932,4.692-83-13-9.687-13.114-7-40.313-7-63V652c0-23.085-2.929-51.634,7-65,13.132-17.679,52.239-13.409,83-13V450c-30.713.42-69.932,4.692-83-13-9.687-13.114-7-40.313-7-63V228c0-23.085-2.929-51.634,7-65,13.132-17.679,52.239-13.409,83-13-0.313-36.721-8.838-104.988,13-121,16.042-11.762,100.252-5,129-5H681c30.16,0,123.35-7.261,140,5C842.847,45.087,834.281,113.22,834,150ZM260,94v56H764V94H260Zm92,109c-28.669,10.954-49.312,10.432-66,32-29.313,37.885-26.5,113.644,10,142,35.026,27.209,104.11,26.155,130-9-2.753-6.328-15.6-24.582-26-22l-18,12c-22.176,8.812-49.071-1.09-59-14-24.369-31.684-13.509-93.4,23-103,27.622-7.263,40.29,14.158,59,12l19-24C410.316,210.925,383.814,202.865,352,203Zm170,0c-14.6,5.8-26.961,5.7-38,14-21.6,16.234-28.452,64.968-4,84,16.143,12.564,56.742,13.16,66,32,5.092,8.339-.125,18.659-4,24-33.41,13.12-39.27-7.98-65-11-8.591,5.825-17.052,15.97-20,27,37.546,28.224,105.2,39.338,127-13,3.081-7.4,8.045-19.016,6-31-9.9-57.984-70.643-36.824-84-67-2.59-8.92,2.033-14.83,6-20,28.721-8.549,41.015,11.015,61,7l14-25C574.39,209.047,549.507,202.862,522,203Zm170,0c-14.6,5.8-26.961,5.7-38,14-21.6,16.234-28.452,64.968-4,84,16.143,12.564,56.742,13.16,66,32,5.092,8.339-.125,18.659-4,24-33.41,13.12-39.27-7.98-65-11-8.591,5.825-17.052,15.97-20,27,37.546,28.224,105.2,39.338,127-13,3.081-7.4,8.045-19.016,6-31-9.9-57.984-70.643-36.824-84-67-2.59-8.92,2.033-14.83,6-20,28.721-8.549,41.015,11.015,61,7l14-25C744.39,209.047,719.507,202.862,692,203ZM260,450V574H764V450H260ZM582,627c-14.6,5.8-26.961,5.7-38,14-21.6,16.234-28.452,64.968-4,84,16.143,12.564,56.742,13.16,66,32,5.092,8.339-.125,18.659-4,24-33.41,13.12-39.27-7.98-65-11-8.591,5.825-17.052,15.97-20,27,37.546,28.224,105.2,39.338,127-13,3.081-7.4,8.045-19.016,6-31-9.9-57.984-70.643-36.824-84-67-2.59-8.92,2.033-14.83,6-20,28.721-8.549,41.015,11.015,61,7l14-25C634.39,633.047,609.507,626.862,582,627Zm-156,2c0.432,29.027,4.855,133.374-5,148-8.134,12.072-23.916,6.036-38,8l-5,4c-0.782,8.3-4.63,25.683,0,29,8.58,4.135,28.041,4.16,39,2,57.392-11.311,53-59.964,53-128q-0.5-31.5-1-63H426ZM260,874v56H764V874H260Z' })\n);\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Icon);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9pY29uLmpzP2MxNDQiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vLyBCbG9jayBpY29uXG52YXIgSWNvbiA9IHdwLmVsZW1lbnQuY3JlYXRlRWxlbWVudChcbiAgJ3N2ZycsXG4gIHsgeG1sbnM6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsIHdpZHRoOiAnMTI4JywgaGVpZ2h0OiAnMTI4Jywgdmlld0JveDogJzAgMCAxMDI0IDEwMjQnIH0sXG4gIHdwLmVsZW1lbnQuY3JlYXRlRWxlbWVudCgncGF0aCcsIHsgZmlsbDogJyNjZTI4MGYnLCBkOiAnTTgzMSwzMzNtMy0xODNjMzAuNzEzLS40Miw2OS45MzItNC42OTIsODMsMTMsOS42ODcsMTMuMTE0LDcsNDAuMzEzLDcsNjNWMzcyYzAsMjMuMDg1LDIuOTI5LDUxLjYzNC03LDY1LTEzLjEzMiwxNy42NzktNTIuMjM5LDEzLjQwOS04MywxM1Y1NzRjMzAuNzEzLS40Miw2OS45MzItNC42OTIsODMsMTMsOS42ODcsMTMuMTE0LDcsNDAuMzEzLDcsNjNWNzk2YzAsMjMuMDg1LDIuOTI5LDUxLjYzNC03LDY1LTEzLjEzMiwxNy42NzktNTIuMjM5LDEzLjQwOS04MywxMywwLjMxMywzNi43MjEsOC44MzgsMTA0Ljk4OC0xMywxMjEtMTYuMDQyLDExLjc2LTEwMC4yNTIsNS0xMjksNUgzNDNjLTMwLjE2LDAtMTIzLjM1LDcuMjYtMTQwLTUtMjEuODQ3LTE2LjA4Ny0xMy4yODEtODQuMjItMTMtMTIxLTMwLjcxMy40Mi02OS45MzIsNC42OTItODMtMTMtOS42ODctMTMuMTE0LTctNDAuMzEzLTctNjNWNjUyYzAtMjMuMDg1LTIuOTI5LTUxLjYzNCw3LTY1LDEzLjEzMi0xNy42NzksNTIuMjM5LTEzLjQwOSw4My0xM1Y0NTBjLTMwLjcxMy40Mi02OS45MzIsNC42OTItODMtMTMtOS42ODctMTMuMTE0LTctNDAuMzEzLTctNjNWMjI4YzAtMjMuMDg1LTIuOTI5LTUxLjYzNCw3LTY1LDEzLjEzMi0xNy42NzksNTIuMjM5LTEzLjQwOSw4My0xMy0wLjMxMy0zNi43MjEtOC44MzgtMTA0Ljk4OCwxMy0xMjEsMTYuMDQyLTExLjc2MiwxMDAuMjUyLTUsMTI5LTVINjgxYzMwLjE2LDAsMTIzLjM1LTcuMjYxLDE0MCw1Qzg0Mi44NDcsNDUuMDg3LDgzNC4yODEsMTEzLjIyLDgzNCwxNTBaTTI2MCw5NHY1Nkg3NjRWOTRIMjYwWm05MiwxMDljLTI4LjY2OSwxMC45NTQtNDkuMzEyLDEwLjQzMi02NiwzMi0yOS4zMTMsMzcuODg1LTI2LjUsMTEzLjY0NCwxMCwxNDIsMzUuMDI2LDI3LjIwOSwxMDQuMTEsMjYuMTU1LDEzMC05LTIuNzUzLTYuMzI4LTE1LjYtMjQuNTgyLTI2LTIybC0xOCwxMmMtMjIuMTc2LDguODEyLTQ5LjA3MS0xLjA5LTU5LTE0LTI0LjM2OS0zMS42ODQtMTMuNTA5LTkzLjQsMjMtMTAzLDI3LjYyMi03LjI2Myw0MC4yOSwxNC4xNTgsNTksMTJsMTktMjRDNDEwLjMxNiwyMTAuOTI1LDM4My44MTQsMjAyLjg2NSwzNTIsMjAzWm0xNzAsMGMtMTQuNiw1LjgtMjYuOTYxLDUuNy0zOCwxNC0yMS42LDE2LjIzNC0yOC40NTIsNjQuOTY4LTQsODQsMTYuMTQzLDEyLjU2NCw1Ni43NDIsMTMuMTYsNjYsMzIsNS4wOTIsOC4zMzktLjEyNSwxOC42NTktNCwyNC0zMy40MSwxMy4xMi0zOS4yNy03Ljk4LTY1LTExLTguNTkxLDUuODI1LTE3LjA1MiwxNS45Ny0yMCwyNywzNy41NDYsMjguMjI0LDEwNS4yLDM5LjMzOCwxMjctMTMsMy4wODEtNy40LDguMDQ1LTE5LjAxNiw2LTMxLTkuOS01Ny45ODQtNzAuNjQzLTM2LjgyNC04NC02Ny0yLjU5LTguOTIsMi4wMzMtMTQuODMsNi0yMCwyOC43MjEtOC41NDksNDEuMDE1LDExLjAxNSw2MSw3bDE0LTI1QzU3NC4zOSwyMDkuMDQ3LDU0OS41MDcsMjAyLjg2Miw1MjIsMjAzWm0xNzAsMGMtMTQuNiw1LjgtMjYuOTYxLDUuNy0zOCwxNC0yMS42LDE2LjIzNC0yOC40NTIsNjQuOTY4LTQsODQsMTYuMTQzLDEyLjU2NCw1Ni43NDIsMTMuMTYsNjYsMzIsNS4wOTIsOC4zMzktLjEyNSwxOC42NTktNCwyNC0zMy40MSwxMy4xMi0zOS4yNy03Ljk4LTY1LTExLTguNTkxLDUuODI1LTE3LjA1MiwxNS45Ny0yMCwyNywzNy41NDYsMjguMjI0LDEwNS4yLDM5LjMzOCwxMjctMTMsMy4wODEtNy40LDguMDQ1LTE5LjAxNiw2LTMxLTkuOS01Ny45ODQtNzAuNjQzLTM2LjgyNC04NC02Ny0yLjU5LTguOTIsMi4wMzMtMTQuODMsNi0yMCwyOC43MjEtOC41NDksNDEuMDE1LDExLjAxNSw2MSw3bDE0LTI1Qzc0NC4zOSwyMDkuMDQ3LDcxOS41MDcsMjAyLjg2Miw2OTIsMjAzWk0yNjAsNDUwVjU3NEg3NjRWNDUwSDI2MFpNNTgyLDYyN2MtMTQuNiw1LjgtMjYuOTYxLDUuNy0zOCwxNC0yMS42LDE2LjIzNC0yOC40NTIsNjQuOTY4LTQsODQsMTYuMTQzLDEyLjU2NCw1Ni43NDIsMTMuMTYsNjYsMzIsNS4wOTIsOC4zMzktLjEyNSwxOC42NTktNCwyNC0zMy40MSwxMy4xMi0zOS4yNy03Ljk4LTY1LTExLTguNTkxLDUuODI1LTE3LjA1MiwxNS45Ny0yMCwyNywzNy41NDYsMjguMjI0LDEwNS4yLDM5LjMzOCwxMjctMTMsMy4wODEtNy40LDguMDQ1LTE5LjAxNiw2LTMxLTkuOS01Ny45ODQtNzAuNjQzLTM2LjgyNC04NC02Ny0yLjU5LTguOTIsMi4wMzMtMTQuODMsNi0yMCwyOC43MjEtOC41NDksNDEuMDE1LDExLjAxNSw2MSw3bDE0LTI1QzYzNC4zOSw2MzMuMDQ3LDYwOS41MDcsNjI2Ljg2Miw1ODIsNjI3Wm0tMTU2LDJjMC40MzIsMjkuMDI3LDQuODU1LDEzMy4zNzQtNSwxNDgtOC4xMzQsMTIuMDcyLTIzLjkxNiw2LjAzNi0zOCw4bC01LDRjLTAuNzgyLDguMy00LjYzLDI1LjY4MywwLDI5LDguNTgsNC4xMzUsMjguMDQxLDQuMTYsMzksMiw1Ny4zOTItMTEuMzExLDUzLTU5Ljk2NCw1My0xMjhxLTAuNS0zMS41LTEtNjNINDI2Wk0yNjAsODc0djU2SDc2NFY4NzRIMjYwWicgfSlcbik7XG5cbmV4cG9ydCBkZWZhdWx0IEljb247XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvaWNvbi5qc1xuLy8gbW9kdWxlIGlkID0gM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3\n");

/***/ }),
/* 4 */
/*!*********************************!*\
  !*** ./src/block/attributes.js ***!
  \*********************************/
/*! exports provided: default */
/*! exports used: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__translate__ = __webpack_require__(/*! ../translate */ 2);\n/**\r\n * BLOCK: custom-js-css-gutenberg\r\n */\n\n// Import translate\n\n\nvar attributes = {\n\t// Header Javascript\n\tjsHeaderEnable: {\n\t\ttype: 'boolean',\n\t\tdefault: false,\n\t\tlabel: Object(__WEBPACK_IMPORTED_MODULE_0__translate__[\"a\" /* default */])('Enable Head Javascript')\n\t},\n\n\tjsHeader: {\n\t\ttype: 'string',\n\t\tdefault: '',\n\t\tlabel: Object(__WEBPACK_IMPORTED_MODULE_0__translate__[\"a\" /* default */])('Javascript Code'),\n\t\tdescription: Object(__WEBPACK_IMPORTED_MODULE_0__translate__[\"a\" /* default */])('This parameter is the javascript code between head tags.')\n\t},\n\tjsHeaderParams: {\n\t\ttype: 'array',\n\t\tdefault: [{\n\t\t\tminEnabled: false,\n\t\t\tmin: '',\n\t\t\ttype: 'js'\n\t\t}]\n\t},\n\n\tjsHeaderUrl: {\n\t\ttype: 'string',\n\t\tdefault: '',\n\t\tlabel: Object(__WEBPACK_IMPORTED_MODULE_0__translate__[\"a\" /* default */])('Javascript URL'),\n\t\tdescription: Object(__WEBPACK_IMPORTED_MODULE_0__translate__[\"a\" /* default */])('This parameter adds the specified JS URL between head tags.')\n\t},\n\n\tjsHeaderUrlDep: {\n\t\ttype: 'string',\n\t\tdefault: '',\n\t\tlabel: Object(__WEBPACK_IMPORTED_MODULE_0__translate__[\"a\" /* default */])('Javascript URL Dependencies'),\n\t\tdescription: Object(__WEBPACK_IMPORTED_MODULE_0__translate__[\"a\" /* default */])('This parameter is the dependencies (comma seperated) for the JS URL.')\n\t},\n\n\t// Footer javascript\n\tjsFooterEnable: {\n\t\ttype: 'boolean',\n\t\tdefault: false,\n\t\tlabel: Object(__WEBPACK_IMPORTED_MODULE_0__translate__[\"a\" /* default */])('Enable Footer Javascript')\n\t},\n\n\tjsFooter: {\n\t\ttype: 'string',\n\t\tdefault: '',\n\t\tlabel: Object(__WEBPACK_IMPORTED_MODULE_0__translate__[\"a\" /* default */])('Javascript'),\n\t\tdescription: Object(__WEBPACK_IMPORTED_MODULE_0__translate__[\"a\" /* default */])('This parameter is the javascript code at the footer before closing body tag.')\n\t},\n\tjsFooterParams: {\n\t\ttype: 'array',\n\t\tdefault: [{\n\t\t\tminEnabled: false,\n\t\t\tmin: '',\n\t\t\ttype: 'js'\n\t\t}]\n\t},\n\n\tjsFooterUrl: {\n\t\ttype: 'string',\n\t\tdefault: '',\n\t\tlabel: Object(__WEBPACK_IMPORTED_MODULE_0__translate__[\"a\" /* default */])('Javascript URL'),\n\t\tdescription: Object(__WEBPACK_IMPORTED_MODULE_0__translate__[\"a\" /* default */])('This parameter adds the specified JS URL at the footer before closing body tag.')\n\t},\n\n\tjsFooterUrlDep: {\n\t\ttype: 'string',\n\t\tdefault: '',\n\t\tlabel: Object(__WEBPACK_IMPORTED_MODULE_0__translate__[\"a\" /* default */])('Javascript URL Dependencies'),\n\t\tdescription: Object(__WEBPACK_IMPORTED_MODULE_0__translate__[\"a\" /* default */])('This parameter is the dependencies (comma seperated) for the JS URL.')\n\t},\n\n\t// Header CSS\n\tcssHeaderEnable: {\n\t\ttype: 'boolean',\n\t\tdefault: false,\n\t\tlabel: Object(__WEBPACK_IMPORTED_MODULE_0__translate__[\"a\" /* default */])('Enable Head CSS')\n\t},\n\n\tcssHeader: {\n\t\ttype: 'string',\n\t\tdefault: '',\n\t\tlabel: Object(__WEBPACK_IMPORTED_MODULE_0__translate__[\"a\" /* default */])('CSS'),\n\t\tdescription: Object(__WEBPACK_IMPORTED_MODULE_0__translate__[\"a\" /* default */])('This parameter is the CSS code between head tags.')\n\t},\n\tcssHeaderParams: {\n\t\ttype: 'array',\n\t\tdefault: [{\n\t\t\tminEnabled: false,\n\t\t\tmin: '',\n\t\t\ttype: 'css'\n\t\t}]\n\t},\n\n\tcssHeaderUrl: {\n\t\ttype: 'string',\n\t\tdefault: '',\n\t\tlabel: Object(__WEBPACK_IMPORTED_MODULE_0__translate__[\"a\" /* default */])('CSS URL'),\n\t\tdescription: Object(__WEBPACK_IMPORTED_MODULE_0__translate__[\"a\" /* default */])('This parameter adds the specified CSS URL between head tags.')\n\t},\n\n\tcssHeaderUrlDep: {\n\t\ttype: 'string',\n\t\tdefault: '',\n\t\tlabel: Object(__WEBPACK_IMPORTED_MODULE_0__translate__[\"a\" /* default */])('CSS URL Dependencies'),\n\t\tdescription: Object(__WEBPACK_IMPORTED_MODULE_0__translate__[\"a\" /* default */])('This parameter is the dependencies (comma seperated) for the CSS URL.')\n\t},\n\n\t// Footer CSS\n\tcssFooterEnable: {\n\t\ttype: 'boolean',\n\t\tdefault: false,\n\t\tlabel: Object(__WEBPACK_IMPORTED_MODULE_0__translate__[\"a\" /* default */])('Enable Footer CSS')\n\t},\n\n\tcssFooter: {\n\t\ttype: 'string',\n\t\tdefault: '',\n\t\tlabel: Object(__WEBPACK_IMPORTED_MODULE_0__translate__[\"a\" /* default */])('CSS'),\n\t\tdescription: Object(__WEBPACK_IMPORTED_MODULE_0__translate__[\"a\" /* default */])('This parameter is the CSS code at the footer before closing body tag.')\n\t},\n\tcssFooterParams: {\n\t\ttype: 'array',\n\t\tdefault: [{\n\t\t\tminEnabled: false,\n\t\t\tmin: '',\n\t\t\ttype: 'css'\n\t\t}]\n\t},\n\n\tcssFooterUrl: {\n\t\ttype: 'string',\n\t\tdefault: '',\n\t\tlabel: Object(__WEBPACK_IMPORTED_MODULE_0__translate__[\"a\" /* default */])('CSS URL'),\n\t\tdescription: Object(__WEBPACK_IMPORTED_MODULE_0__translate__[\"a\" /* default */])('This parameter adds the specified CSS URL at the footer before closing body tag.')\n\t},\n\n\tcssFooterUrlDep: {\n\t\ttype: 'string',\n\t\tdefault: '',\n\t\tlabel: Object(__WEBPACK_IMPORTED_MODULE_0__translate__[\"a\" /* default */])('CSS URL Dependencies'),\n\t\tdescription: Object(__WEBPACK_IMPORTED_MODULE_0__translate__[\"a\" /* default */])('This parameter is the dependencies (comma seperated) for the CSS URL.')\n\t},\n\n\t// Inline JS\n\tjsInline: {\n\t\ttype: 'string',\n\t\tdefault: '',\n\t\tlabel: Object(__WEBPACK_IMPORTED_MODULE_0__translate__[\"a\" /* default */])('Javascript (Inline)'),\n\t\tdescription: Object(__WEBPACK_IMPORTED_MODULE_0__translate__[\"a\" /* default */])('This parameter adds the specified javascript code to the place of this block.')\n\t},\n\tjsInlineParams: {\n\t\ttype: 'array',\n\t\tdefault: [{\n\t\t\tminEnabled: false,\n\t\t\tmin: '',\n\t\t\ttype: 'js'\n\t\t}]\n\t},\n\n\t// Inline CSS\n\tcssInline: {\n\t\ttype: 'string',\n\t\tdefault: '',\n\t\tlabel: Object(__WEBPACK_IMPORTED_MODULE_0__translate__[\"a\" /* default */])('{{type}} (Inline)'),\n\t\tdescription: Object(__WEBPACK_IMPORTED_MODULE_0__translate__[\"a\" /* default */])('This parameter adds the specified CSS code to the place of this block.')\n\t},\n\tcssInlineParams: {\n\t\ttype: 'array',\n\t\tdefault: [{\n\t\t\tminEnabled: false,\n\t\t\tmin: '',\n\t\t\ttype: 'css'\n\t\t}]\n\t},\n\n\t// Meta\n\tmetaEnable: {\n\t\ttype: 'boolean',\n\t\tdefault: false,\n\t\tlabel: Object(__WEBPACK_IMPORTED_MODULE_0__translate__[\"a\" /* default */])('Enable Meta Tag'),\n\t\tdescription: Object(__WEBPACK_IMPORTED_MODULE_0__translate__[\"a\" /* default */])('This parameter enables adding the specified code between meta tags at the head.')\n\t},\n\n\tmeta: {\n\t\ttype: 'string',\n\t\tdefault: '',\n\t\tlabel: Object(__WEBPACK_IMPORTED_MODULE_0__translate__[\"a\" /* default */])('Meta Tag Content'),\n\t\tdescription: Object(__WEBPACK_IMPORTED_MODULE_0__translate__[\"a\" /* default */])('This parameter adds the specified code between meta tags at the head.')\n\t}\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (attributes);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9ibG9jay9hdHRyaWJ1dGVzLmpzPzg4MDEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIEJMT0NLOiBjdXN0b20tanMtY3NzLWd1dGVuYmVyZ1xyXG4gKi9cblxuLy8gSW1wb3J0IHRyYW5zbGF0ZVxuaW1wb3J0IF9fdHJfXyBmcm9tICcuLi90cmFuc2xhdGUnO1xuXG52YXIgYXR0cmlidXRlcyA9IHtcblx0Ly8gSGVhZGVyIEphdmFzY3JpcHRcblx0anNIZWFkZXJFbmFibGU6IHtcblx0XHR0eXBlOiAnYm9vbGVhbicsXG5cdFx0ZGVmYXVsdDogZmFsc2UsXG5cdFx0bGFiZWw6IF9fdHJfXygnRW5hYmxlIEhlYWQgSmF2YXNjcmlwdCcpXG5cdH0sXG5cblx0anNIZWFkZXI6IHtcblx0XHR0eXBlOiAnc3RyaW5nJyxcblx0XHRkZWZhdWx0OiAnJyxcblx0XHRsYWJlbDogX190cl9fKCdKYXZhc2NyaXB0IENvZGUnKSxcblx0XHRkZXNjcmlwdGlvbjogX190cl9fKCdUaGlzIHBhcmFtZXRlciBpcyB0aGUgamF2YXNjcmlwdCBjb2RlIGJldHdlZW4gaGVhZCB0YWdzLicpXG5cdH0sXG5cdGpzSGVhZGVyUGFyYW1zOiB7XG5cdFx0dHlwZTogJ2FycmF5Jyxcblx0XHRkZWZhdWx0OiBbe1xuXHRcdFx0bWluRW5hYmxlZDogZmFsc2UsXG5cdFx0XHRtaW46ICcnLFxuXHRcdFx0dHlwZTogJ2pzJ1xuXHRcdH1dXG5cdH0sXG5cblx0anNIZWFkZXJVcmw6IHtcblx0XHR0eXBlOiAnc3RyaW5nJyxcblx0XHRkZWZhdWx0OiAnJyxcblx0XHRsYWJlbDogX190cl9fKCdKYXZhc2NyaXB0IFVSTCcpLFxuXHRcdGRlc2NyaXB0aW9uOiBfX3RyX18oJ1RoaXMgcGFyYW1ldGVyIGFkZHMgdGhlIHNwZWNpZmllZCBKUyBVUkwgYmV0d2VlbiBoZWFkIHRhZ3MuJylcblx0fSxcblxuXHRqc0hlYWRlclVybERlcDoge1xuXHRcdHR5cGU6ICdzdHJpbmcnLFxuXHRcdGRlZmF1bHQ6ICcnLFxuXHRcdGxhYmVsOiBfX3RyX18oJ0phdmFzY3JpcHQgVVJMIERlcGVuZGVuY2llcycpLFxuXHRcdGRlc2NyaXB0aW9uOiBfX3RyX18oJ1RoaXMgcGFyYW1ldGVyIGlzIHRoZSBkZXBlbmRlbmNpZXMgKGNvbW1hIHNlcGVyYXRlZCkgZm9yIHRoZSBKUyBVUkwuJylcblx0fSxcblxuXHQvLyBGb290ZXIgamF2YXNjcmlwdFxuXHRqc0Zvb3RlckVuYWJsZToge1xuXHRcdHR5cGU6ICdib29sZWFuJyxcblx0XHRkZWZhdWx0OiBmYWxzZSxcblx0XHRsYWJlbDogX190cl9fKCdFbmFibGUgRm9vdGVyIEphdmFzY3JpcHQnKVxuXHR9LFxuXG5cdGpzRm9vdGVyOiB7XG5cdFx0dHlwZTogJ3N0cmluZycsXG5cdFx0ZGVmYXVsdDogJycsXG5cdFx0bGFiZWw6IF9fdHJfXygnSmF2YXNjcmlwdCcpLFxuXHRcdGRlc2NyaXB0aW9uOiBfX3RyX18oJ1RoaXMgcGFyYW1ldGVyIGlzIHRoZSBqYXZhc2NyaXB0IGNvZGUgYXQgdGhlIGZvb3RlciBiZWZvcmUgY2xvc2luZyBib2R5IHRhZy4nKVxuXHR9LFxuXHRqc0Zvb3RlclBhcmFtczoge1xuXHRcdHR5cGU6ICdhcnJheScsXG5cdFx0ZGVmYXVsdDogW3tcblx0XHRcdG1pbkVuYWJsZWQ6IGZhbHNlLFxuXHRcdFx0bWluOiAnJyxcblx0XHRcdHR5cGU6ICdqcydcblx0XHR9XVxuXHR9LFxuXG5cdGpzRm9vdGVyVXJsOiB7XG5cdFx0dHlwZTogJ3N0cmluZycsXG5cdFx0ZGVmYXVsdDogJycsXG5cdFx0bGFiZWw6IF9fdHJfXygnSmF2YXNjcmlwdCBVUkwnKSxcblx0XHRkZXNjcmlwdGlvbjogX190cl9fKCdUaGlzIHBhcmFtZXRlciBhZGRzIHRoZSBzcGVjaWZpZWQgSlMgVVJMIGF0IHRoZSBmb290ZXIgYmVmb3JlIGNsb3NpbmcgYm9keSB0YWcuJylcblx0fSxcblxuXHRqc0Zvb3RlclVybERlcDoge1xuXHRcdHR5cGU6ICdzdHJpbmcnLFxuXHRcdGRlZmF1bHQ6ICcnLFxuXHRcdGxhYmVsOiBfX3RyX18oJ0phdmFzY3JpcHQgVVJMIERlcGVuZGVuY2llcycpLFxuXHRcdGRlc2NyaXB0aW9uOiBfX3RyX18oJ1RoaXMgcGFyYW1ldGVyIGlzIHRoZSBkZXBlbmRlbmNpZXMgKGNvbW1hIHNlcGVyYXRlZCkgZm9yIHRoZSBKUyBVUkwuJylcblx0fSxcblxuXHQvLyBIZWFkZXIgQ1NTXG5cdGNzc0hlYWRlckVuYWJsZToge1xuXHRcdHR5cGU6ICdib29sZWFuJyxcblx0XHRkZWZhdWx0OiBmYWxzZSxcblx0XHRsYWJlbDogX190cl9fKCdFbmFibGUgSGVhZCBDU1MnKVxuXHR9LFxuXG5cdGNzc0hlYWRlcjoge1xuXHRcdHR5cGU6ICdzdHJpbmcnLFxuXHRcdGRlZmF1bHQ6ICcnLFxuXHRcdGxhYmVsOiBfX3RyX18oJ0NTUycpLFxuXHRcdGRlc2NyaXB0aW9uOiBfX3RyX18oJ1RoaXMgcGFyYW1ldGVyIGlzIHRoZSBDU1MgY29kZSBiZXR3ZWVuIGhlYWQgdGFncy4nKVxuXHR9LFxuXHRjc3NIZWFkZXJQYXJhbXM6IHtcblx0XHR0eXBlOiAnYXJyYXknLFxuXHRcdGRlZmF1bHQ6IFt7XG5cdFx0XHRtaW5FbmFibGVkOiBmYWxzZSxcblx0XHRcdG1pbjogJycsXG5cdFx0XHR0eXBlOiAnY3NzJ1xuXHRcdH1dXG5cdH0sXG5cblx0Y3NzSGVhZGVyVXJsOiB7XG5cdFx0dHlwZTogJ3N0cmluZycsXG5cdFx0ZGVmYXVsdDogJycsXG5cdFx0bGFiZWw6IF9fdHJfXygnQ1NTIFVSTCcpLFxuXHRcdGRlc2NyaXB0aW9uOiBfX3RyX18oJ1RoaXMgcGFyYW1ldGVyIGFkZHMgdGhlIHNwZWNpZmllZCBDU1MgVVJMIGJldHdlZW4gaGVhZCB0YWdzLicpXG5cdH0sXG5cblx0Y3NzSGVhZGVyVXJsRGVwOiB7XG5cdFx0dHlwZTogJ3N0cmluZycsXG5cdFx0ZGVmYXVsdDogJycsXG5cdFx0bGFiZWw6IF9fdHJfXygnQ1NTIFVSTCBEZXBlbmRlbmNpZXMnKSxcblx0XHRkZXNjcmlwdGlvbjogX190cl9fKCdUaGlzIHBhcmFtZXRlciBpcyB0aGUgZGVwZW5kZW5jaWVzIChjb21tYSBzZXBlcmF0ZWQpIGZvciB0aGUgQ1NTIFVSTC4nKVxuXHR9LFxuXG5cdC8vIEZvb3RlciBDU1Ncblx0Y3NzRm9vdGVyRW5hYmxlOiB7XG5cdFx0dHlwZTogJ2Jvb2xlYW4nLFxuXHRcdGRlZmF1bHQ6IGZhbHNlLFxuXHRcdGxhYmVsOiBfX3RyX18oJ0VuYWJsZSBGb290ZXIgQ1NTJylcblx0fSxcblxuXHRjc3NGb290ZXI6IHtcblx0XHR0eXBlOiAnc3RyaW5nJyxcblx0XHRkZWZhdWx0OiAnJyxcblx0XHRsYWJlbDogX190cl9fKCdDU1MnKSxcblx0XHRkZXNjcmlwdGlvbjogX190cl9fKCdUaGlzIHBhcmFtZXRlciBpcyB0aGUgQ1NTIGNvZGUgYXQgdGhlIGZvb3RlciBiZWZvcmUgY2xvc2luZyBib2R5IHRhZy4nKVxuXHR9LFxuXHRjc3NGb290ZXJQYXJhbXM6IHtcblx0XHR0eXBlOiAnYXJyYXknLFxuXHRcdGRlZmF1bHQ6IFt7XG5cdFx0XHRtaW5FbmFibGVkOiBmYWxzZSxcblx0XHRcdG1pbjogJycsXG5cdFx0XHR0eXBlOiAnY3NzJ1xuXHRcdH1dXG5cdH0sXG5cblx0Y3NzRm9vdGVyVXJsOiB7XG5cdFx0dHlwZTogJ3N0cmluZycsXG5cdFx0ZGVmYXVsdDogJycsXG5cdFx0bGFiZWw6IF9fdHJfXygnQ1NTIFVSTCcpLFxuXHRcdGRlc2NyaXB0aW9uOiBfX3RyX18oJ1RoaXMgcGFyYW1ldGVyIGFkZHMgdGhlIHNwZWNpZmllZCBDU1MgVVJMIGF0IHRoZSBmb290ZXIgYmVmb3JlIGNsb3NpbmcgYm9keSB0YWcuJylcblx0fSxcblxuXHRjc3NGb290ZXJVcmxEZXA6IHtcblx0XHR0eXBlOiAnc3RyaW5nJyxcblx0XHRkZWZhdWx0OiAnJyxcblx0XHRsYWJlbDogX190cl9fKCdDU1MgVVJMIERlcGVuZGVuY2llcycpLFxuXHRcdGRlc2NyaXB0aW9uOiBfX3RyX18oJ1RoaXMgcGFyYW1ldGVyIGlzIHRoZSBkZXBlbmRlbmNpZXMgKGNvbW1hIHNlcGVyYXRlZCkgZm9yIHRoZSBDU1MgVVJMLicpXG5cdH0sXG5cblx0Ly8gSW5saW5lIEpTXG5cdGpzSW5saW5lOiB7XG5cdFx0dHlwZTogJ3N0cmluZycsXG5cdFx0ZGVmYXVsdDogJycsXG5cdFx0bGFiZWw6IF9fdHJfXygnSmF2YXNjcmlwdCAoSW5saW5lKScpLFxuXHRcdGRlc2NyaXB0aW9uOiBfX3RyX18oJ1RoaXMgcGFyYW1ldGVyIGFkZHMgdGhlIHNwZWNpZmllZCBqYXZhc2NyaXB0IGNvZGUgdG8gdGhlIHBsYWNlIG9mIHRoaXMgYmxvY2suJylcblx0fSxcblx0anNJbmxpbmVQYXJhbXM6IHtcblx0XHR0eXBlOiAnYXJyYXknLFxuXHRcdGRlZmF1bHQ6IFt7XG5cdFx0XHRtaW5FbmFibGVkOiBmYWxzZSxcblx0XHRcdG1pbjogJycsXG5cdFx0XHR0eXBlOiAnanMnXG5cdFx0fV1cblx0fSxcblxuXHQvLyBJbmxpbmUgQ1NTXG5cdGNzc0lubGluZToge1xuXHRcdHR5cGU6ICdzdHJpbmcnLFxuXHRcdGRlZmF1bHQ6ICcnLFxuXHRcdGxhYmVsOiBfX3RyX18oJ3t7dHlwZX19IChJbmxpbmUpJyksXG5cdFx0ZGVzY3JpcHRpb246IF9fdHJfXygnVGhpcyBwYXJhbWV0ZXIgYWRkcyB0aGUgc3BlY2lmaWVkIENTUyBjb2RlIHRvIHRoZSBwbGFjZSBvZiB0aGlzIGJsb2NrLicpXG5cdH0sXG5cdGNzc0lubGluZVBhcmFtczoge1xuXHRcdHR5cGU6ICdhcnJheScsXG5cdFx0ZGVmYXVsdDogW3tcblx0XHRcdG1pbkVuYWJsZWQ6IGZhbHNlLFxuXHRcdFx0bWluOiAnJyxcblx0XHRcdHR5cGU6ICdjc3MnXG5cdFx0fV1cblx0fSxcblxuXHQvLyBNZXRhXG5cdG1ldGFFbmFibGU6IHtcblx0XHR0eXBlOiAnYm9vbGVhbicsXG5cdFx0ZGVmYXVsdDogZmFsc2UsXG5cdFx0bGFiZWw6IF9fdHJfXygnRW5hYmxlIE1ldGEgVGFnJyksXG5cdFx0ZGVzY3JpcHRpb246IF9fdHJfXygnVGhpcyBwYXJhbWV0ZXIgZW5hYmxlcyBhZGRpbmcgdGhlIHNwZWNpZmllZCBjb2RlIGJldHdlZW4gbWV0YSB0YWdzIGF0IHRoZSBoZWFkLicpXG5cdH0sXG5cblx0bWV0YToge1xuXHRcdHR5cGU6ICdzdHJpbmcnLFxuXHRcdGRlZmF1bHQ6ICcnLFxuXHRcdGxhYmVsOiBfX3RyX18oJ01ldGEgVGFnIENvbnRlbnQnKSxcblx0XHRkZXNjcmlwdGlvbjogX190cl9fKCdUaGlzIHBhcmFtZXRlciBhZGRzIHRoZSBzcGVjaWZpZWQgY29kZSBiZXR3ZWVuIG1ldGEgdGFncyBhdCB0aGUgaGVhZC4nKVxuXHR9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBhdHRyaWJ1dGVzO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2Jsb2NrL2F0dHJpYnV0ZXMuanNcbi8vIG1vZHVsZSBpZCA9IDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4\n");

/***/ }),
/* 5 */
/*!******************************************!*\
  !*** ./node_modules/classnames/index.js ***!
  \******************************************/
/*! dynamic exports provided */
/*! exports used: default */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n  Copyright (c) 2017 Jed Watson.\n  Licensed under the MIT License (MIT), see\n  http://jedwatson.github.io/classnames\n*/\n/* global define */\n\n(function () {\n\t'use strict';\n\n\tvar hasOwn = {}.hasOwnProperty;\n\n\tfunction classNames () {\n\t\tvar classes = [];\n\n\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\tvar arg = arguments[i];\n\t\t\tif (!arg) continue;\n\n\t\t\tvar argType = typeof arg;\n\n\t\t\tif (argType === 'string' || argType === 'number') {\n\t\t\t\tclasses.push(arg);\n\t\t\t} else if (Array.isArray(arg) && arg.length) {\n\t\t\t\tvar inner = classNames.apply(null, arg);\n\t\t\t\tif (inner) {\n\t\t\t\t\tclasses.push(inner);\n\t\t\t\t}\n\t\t\t} else if (argType === 'object') {\n\t\t\t\tfor (var key in arg) {\n\t\t\t\t\tif (hasOwn.call(arg, key) && arg[key]) {\n\t\t\t\t\t\tclasses.push(key);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn classes.join(' ');\n\t}\n\n\tif (typeof module !== 'undefined' && module.exports) {\n\t\tclassNames.default = classNames;\n\t\tmodule.exports = classNames;\n\t} else if (true) {\n\t\t// register as 'classnames', consistent with npm package name\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n\t\t\treturn classNames;\n\t\t}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t} else {\n\t\twindow.classNames = classNames;\n\t}\n}());\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jbGFzc25hbWVzL2luZGV4LmpzPzFkNmUiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gIENvcHlyaWdodCAoYykgMjAxNyBKZWQgV2F0c29uLlxuICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UgKE1JVCksIHNlZVxuICBodHRwOi8vamVkd2F0c29uLmdpdGh1Yi5pby9jbGFzc25hbWVzXG4qL1xuLyogZ2xvYmFsIGRlZmluZSAqL1xuXG4oZnVuY3Rpb24gKCkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0dmFyIGhhc093biA9IHt9Lmhhc093blByb3BlcnR5O1xuXG5cdGZ1bmN0aW9uIGNsYXNzTmFtZXMgKCkge1xuXHRcdHZhciBjbGFzc2VzID0gW107XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGFyZyA9IGFyZ3VtZW50c1tpXTtcblx0XHRcdGlmICghYXJnKSBjb250aW51ZTtcblxuXHRcdFx0dmFyIGFyZ1R5cGUgPSB0eXBlb2YgYXJnO1xuXG5cdFx0XHRpZiAoYXJnVHlwZSA9PT0gJ3N0cmluZycgfHwgYXJnVHlwZSA9PT0gJ251bWJlcicpIHtcblx0XHRcdFx0Y2xhc3Nlcy5wdXNoKGFyZyk7XG5cdFx0XHR9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSAmJiBhcmcubGVuZ3RoKSB7XG5cdFx0XHRcdHZhciBpbm5lciA9IGNsYXNzTmFtZXMuYXBwbHkobnVsbCwgYXJnKTtcblx0XHRcdFx0aWYgKGlubmVyKSB7XG5cdFx0XHRcdFx0Y2xhc3Nlcy5wdXNoKGlubmVyKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChhcmdUeXBlID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRmb3IgKHZhciBrZXkgaW4gYXJnKSB7XG5cdFx0XHRcdFx0aWYgKGhhc093bi5jYWxsKGFyZywga2V5KSAmJiBhcmdba2V5XSkge1xuXHRcdFx0XHRcdFx0Y2xhc3Nlcy5wdXNoKGtleSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNsYXNzZXMuam9pbignICcpO1xuXHR9XG5cblx0aWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG5cdFx0Y2xhc3NOYW1lcy5kZWZhdWx0ID0gY2xhc3NOYW1lcztcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGNsYXNzTmFtZXM7XG5cdH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PT0gJ29iamVjdCcgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIHJlZ2lzdGVyIGFzICdjbGFzc25hbWVzJywgY29uc2lzdGVudCB3aXRoIG5wbSBwYWNrYWdlIG5hbWVcblx0XHRkZWZpbmUoJ2NsYXNzbmFtZXMnLCBbXSwgZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIGNsYXNzTmFtZXM7XG5cdFx0fSk7XG5cdH0gZWxzZSB7XG5cdFx0d2luZG93LmNsYXNzTmFtZXMgPSBjbGFzc05hbWVzO1xuXHR9XG59KCkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY2xhc3NuYW1lcy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5\n");

/***/ }),
/* 6 */
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nvar base64 = __webpack_require__(/*! base64-js */ 14)\nvar ieee754 = __webpack_require__(/*! ieee754 */ 15)\nvar isArray = __webpack_require__(/*! isarray */ 16)\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./../webpack/buildin/global.js */ 1)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanM/MTJlMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBEdWUgdG8gdmFyaW91cyBicm93c2VyIGJ1Z3MsIHNvbWV0aW1lcyB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uIHdpbGwgYmUgdXNlZCBldmVuXG4gKiB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIHR5cGVkIGFycmF5cy5cbiAqXG4gKiBOb3RlOlxuICpcbiAqICAgLSBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMsXG4gKiAgICAgU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzguXG4gKlxuICogICAtIENocm9tZSA5LTEwIGlzIG1pc3NpbmcgdGhlIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24uXG4gKlxuICogICAtIElFMTAgaGFzIGEgYnJva2VuIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhcnJheXMgb2ZcbiAqICAgICBpbmNvcnJlY3QgbGVuZ3RoIGluIHNvbWUgc2l0dWF0aW9ucy5cblxuICogV2UgZGV0ZWN0IHRoZXNlIGJ1Z2d5IGJyb3dzZXJzIGFuZCBzZXQgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYCB0byBgZmFsc2VgIHNvIHRoZXlcbiAqIGdldCB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uLCB3aGljaCBpcyBzbG93ZXIgYnV0IGJlaGF2ZXMgY29ycmVjdGx5LlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUICE9PSB1bmRlZmluZWRcbiAgPyBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVFxuICA6IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuLypcbiAqIEV4cG9ydCBrTWF4TGVuZ3RoIGFmdGVyIHR5cGVkIGFycmF5IHN1cHBvcnQgaXMgZGV0ZXJtaW5lZC5cbiAqL1xuZXhwb3J0cy5rTWF4TGVuZ3RoID0ga01heExlbmd0aCgpXG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICBhcnIuX19wcm90b19fID0ge19fcHJvdG9fXzogVWludDhBcnJheS5wcm90b3R5cGUsIGZvbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfX1cbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MiAmJiAvLyB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZFxuICAgICAgICB0eXBlb2YgYXJyLnN1YmFycmF5ID09PSAnZnVuY3Rpb24nICYmIC8vIGNocm9tZSA5LTEwIGxhY2sgYHN1YmFycmF5YFxuICAgICAgICBhcnIuc3ViYXJyYXkoMSwgMSkuYnl0ZUxlbmd0aCA9PT0gMCAvLyBpZTEwIGhhcyBicm9rZW4gYHN1YmFycmF5YFxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24ga01heExlbmd0aCAoKSB7XG4gIHJldHVybiBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVFxuICAgID8gMHg3ZmZmZmZmZlxuICAgIDogMHgzZmZmZmZmZlxufVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKHRoYXQsIGxlbmd0aCkge1xuICBpZiAoa01heExlbmd0aCgpIDwgbGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgdHlwZWQgYXJyYXkgbGVuZ3RoJylcbiAgfVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICBpZiAodGhhdCA9PT0gbnVsbCkge1xuICAgICAgdGhhdCA9IG5ldyBCdWZmZXIobGVuZ3RoKVxuICAgIH1cbiAgICB0aGF0Lmxlbmd0aCA9IGxlbmd0aFxuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0lmIGVuY29kaW5nIGlzIHNwZWNpZmllZCB0aGVuIHRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUodGhpcywgYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKHRoaXMsIGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuLy8gVE9ETzogTGVnYWN5LCBub3QgbmVlZGVkIGFueW1vcmUuIFJlbW92ZSBpbiBuZXh0IG1ham9yIHZlcnNpb24uXG5CdWZmZXIuX2F1Z21lbnQgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIGFyci5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gZnJvbSAodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cblxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIHJldHVybiBmcm9tT2JqZWN0KHRoYXQsIHZhbHVlKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKG51bGwsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbmlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICBCdWZmZXIucHJvdG90eXBlLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlXG4gIEJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuc3BlY2llcyAmJlxuICAgICAgQnVmZmVyW1N5bWJvbC5zcGVjaWVzXSA9PT0gQnVmZmVyKSB7XG4gICAgLy8gRml4IHN1YmFycmF5KCkgaW4gRVMyMDE2LiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvOTdcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLCBTeW1ib2wuc3BlY2llcywge1xuICAgICAgdmFsdWU6IG51bGwsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG5lZ2F0aXZlJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAodGhhdCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2MobnVsbCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlICh0aGF0LCBzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgKytpKSB7XG4gICAgICB0aGF0W2ldID0gMFxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICovXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHRoYXQsIHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJlbmNvZGluZ1wiIG11c3QgYmUgYSB2YWxpZCBzdHJpbmcgZW5jb2RpbmcnKVxuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuXG4gIHZhciBhY3R1YWwgPSB0aGF0LndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICB0aGF0ID0gdGhhdC5zbGljZSgwLCBhY3R1YWwpXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlICh0aGF0LCBhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyICh0aGF0LCBhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGFycmF5LmJ5dGVMZW5ndGggLy8gdGhpcyB0aHJvd3MgaWYgYGFycmF5YCBpcyBub3QgYSB2YWxpZCBBcnJheUJ1ZmZlclxuXG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdvZmZzZXRcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ2xlbmd0aFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5KVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gYXJyYXlcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgdGhhdCA9IGZyb21BcnJheUxpa2UodGhhdCwgYXJyYXkpXG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAodGhhdCwgb2JqKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqKSkge1xuICAgIHZhciBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMFxuICAgIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuKVxuXG4gICAgaWYgKHRoYXQubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhhdFxuICAgIH1cblxuICAgIG9iai5jb3B5KHRoYXQsIDAsIDAsIGxlbilcbiAgICByZXR1cm4gdGhhdFxuICB9XG5cbiAgaWYgKG9iaikge1xuICAgIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICBvYmouYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8ICdsZW5ndGgnIGluIG9iaikge1xuICAgICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBpc25hbihvYmoubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIDApXG4gICAgICB9XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmopXG4gICAgfVxuXG4gICAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBpc0FycmF5KG9iai5kYXRhKSkge1xuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqLmRhdGEpXG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIG9yIGFycmF5LWxpa2Ugb2JqZWN0LicpXG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBrTWF4TGVuZ3RoKClgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0ga01heExlbmd0aCgpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIGtNYXhMZW5ndGgoKS50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuICEhKGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlcilcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIWlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfVxuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IHN0cmluZyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHN0cmluZyA9ICcnICsgc3RyaW5nXG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAobGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJzaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDBcbiAgc3RhcnQgPj4+PSAwXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoZSBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIGFuZCBgaXMtYnVmZmVyYCAoaW4gU2FmYXJpIDUtNykgdG8gZGV0ZWN0XG4vLyBCdWZmZXIgaW5zdGFuY2VzLlxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgdmFyIGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCB8IDBcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLm1hdGNoKC8uezJ9L2cpLmpvaW4oJyAnKVxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICB2YXIgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgdmFyIHkgPSBlbmQgLSBzdGFydFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgdmFyIHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0ICAvLyBDb2VyY2UgdG8gTnVtYmVyLlxuICBpZiAoaXNOYU4oYnl0ZU9mZnNldCkpIHtcbiAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcImZvb1wiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcbiAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IChidWZmZXIubGVuZ3RoIC0gMSlcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0XG4gIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBpZiAoZGlyKSByZXR1cm4gLTFcbiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMVxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDBcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICB9XG5cbiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJlxuICAgICAgICB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbIHZhbCBdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICB2YXIgaW5kZXhTaXplID0gMVxuICB2YXIgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxuICB2YXIgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyXG4gICAgICBhcnJMZW5ndGggLz0gMlxuICAgICAgdmFsTGVuZ3RoIC89IDJcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICB2YXIgaVxuICBpZiAoZGlyKSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGZvdW5kID0gdHJ1ZVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKHN0ckxlbiAlIDIgIT09IDApIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKGlzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBsYXRpbjFXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCB8IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICAvLyBsZWdhY3kgd3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpIC0gcmVtb3ZlIGluIHYwLjEzXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgdmFyIHJlcyA9IFtdXG5cbiAgdmFyIGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDJcbiAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJydcbiAgdmFyIGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1NilcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgICBuZXdCdWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIHZhciBzbGljZUxlbiA9IGVuZCAtIHN0YXJ0XG4gICAgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47ICsraSkge1xuICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgdmFyIG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDIpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlICYgKDB4ZmYgPDwgKDggKiAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSkpKSA+Pj5cbiAgICAgIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpICogOFxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCA0KTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSA+Pj4gKGxpdHRsZUVuZGlhbiA/IGkgOiAzIC0gaSkgKiA4KSAmIDB4ZmZcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcbiAgdmFyIGlcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHN0YXJ0IDwgdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0U3RhcnQgPCBlbmQpIHtcbiAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcbiAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSBpZiAobGVuIDwgMTAwMCB8fCAhQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBhc2NlbmRpbmcgY29weSBmcm9tIHN0YXJ0XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIGlmIChjb2RlIDwgMjU2KSB7XG4gICAgICAgIHZhbCA9IGNvZGVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTVcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiB1dGY4VG9CeXRlcyhuZXcgQnVmZmVyKHZhbCwgZW5jb2RpbmcpLnRvU3RyaW5nKCkpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teK1xcLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0cmluZ3RyaW0oc3RyKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgdmFyIGNvZGVQb2ludFxuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgdmFyIGJ5dGVzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIGlzbmFuICh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gdmFsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///6\n");

/***/ }),
/* 7 */
/*!***********************!*\
  !*** ./src/blocks.js ***!
  \***********************/
/*! no exports provided */
/*! all exports used */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__block_block_js__ = __webpack_require__(/*! ./block/block.js */ 8);\n/**\n * Gutenberg Blocks\n *\n * All blocks related JavaScript files should be imported here.\n * You can create a new block folder in this dir and include code\n * for that block here as well.\n *\n * All blocks should be included here since this is the file that\n * Webpack is compiling as the input file.\n */\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9ibG9ja3MuanM/N2I1YiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEd1dGVuYmVyZyBCbG9ja3NcbiAqXG4gKiBBbGwgYmxvY2tzIHJlbGF0ZWQgSmF2YVNjcmlwdCBmaWxlcyBzaG91bGQgYmUgaW1wb3J0ZWQgaGVyZS5cbiAqIFlvdSBjYW4gY3JlYXRlIGEgbmV3IGJsb2NrIGZvbGRlciBpbiB0aGlzIGRpciBhbmQgaW5jbHVkZSBjb2RlXG4gKiBmb3IgdGhhdCBibG9jayBoZXJlIGFzIHdlbGwuXG4gKlxuICogQWxsIGJsb2NrcyBzaG91bGQgYmUgaW5jbHVkZWQgaGVyZSBzaW5jZSB0aGlzIGlzIHRoZSBmaWxlIHRoYXRcbiAqIFdlYnBhY2sgaXMgY29tcGlsaW5nIGFzIHRoZSBpbnB1dCBmaWxlLlxuICovXG5cbmltcG9ydCAnLi9ibG9jay9ibG9jay5qcyc7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvYmxvY2tzLmpzXG4vLyBtb2R1bGUgaWQgPSA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7\n");

/***/ }),
/* 8 */
/*!****************************!*\
  !*** ./src/block/block.js ***!
  \****************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__style_scss__ = __webpack_require__(/*! ./style.scss */ 9);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__style_scss___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__style_scss__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__editor_scss__ = __webpack_require__(/*! ./editor.scss */ 10);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__editor_scss___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__editor_scss__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__translate__ = __webpack_require__(/*! ../translate */ 2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__icon__ = __webpack_require__(/*! ../icon */ 3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__attributes__ = __webpack_require__(/*! ./attributes */ 4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__edit__ = __webpack_require__(/*! ./edit */ 11);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__save__ = __webpack_require__(/*! ./save */ 22);\n/**\n * BLOCK: custom-js-css-gutenberg\n *\n * Custom JS and CSS for Gutenberg\n */\n\n//  Import CSS.\n\n\n\n// Import translate\n\n// Import Icon\n\n// Import attributes\n\n// Import Edit\n\n// Import Save\n\n\n// Internal block libraries\nvar registerBlockType = wp.blocks.registerBlockType;\n\n\nregisterBlockType('meceware/custom-js-css-gutenberg', {\n\t// Title\n\ttitle: Object(__WEBPACK_IMPORTED_MODULE_2__translate__[\"a\" /* default */])('Custom JS/CSS'),\n\t// Description\n\tdescription: Object(__WEBPACK_IMPORTED_MODULE_2__translate__[\"a\" /* default */])('Add custom JS and CSS code to the page.'),\n\t// Icon\n\ticon: __WEBPACK_IMPORTED_MODULE_3__icon__[\"a\" /* default */],\n\t// Category\n\tcategory: 'formatting',\n\t// Keywords\n\tkeywords: [Object(__WEBPACK_IMPORTED_MODULE_2__translate__[\"a\" /* default */])('Custom JS/CSS'), Object(__WEBPACK_IMPORTED_MODULE_2__translate__[\"a\" /* default */])('js css'), Object(__WEBPACK_IMPORTED_MODULE_2__translate__[\"a\" /* default */])('meceware')],\n\t// Supports\n\tsupports: {\n\t\talign: false,\n\t\talignWide: false,\n\t\tanchor: false,\n\t\tcustomClassName: false,\n\t\tclassName: false,\n\t\thtml: true,\n\t\tinserter: true,\n\t\tmultiple: true,\n\t\treusable: false\n\t},\n\n\t// Attributes\n\tattributes: __WEBPACK_IMPORTED_MODULE_4__attributes__[\"a\" /* default */],\n\n\t// Edit render\n\tedit: __WEBPACK_IMPORTED_MODULE_5__edit__[\"a\" /* default */],\n\n\t// Save render\n\tsave: __WEBPACK_IMPORTED_MODULE_6__save__[\"a\" /* default */]\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9ibG9jay9ibG9jay5qcz85MjFkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQkxPQ0s6IGN1c3RvbS1qcy1jc3MtZ3V0ZW5iZXJnXG4gKlxuICogQ3VzdG9tIEpTIGFuZCBDU1MgZm9yIEd1dGVuYmVyZ1xuICovXG5cbi8vICBJbXBvcnQgQ1NTLlxuaW1wb3J0ICcuL3N0eWxlLnNjc3MnO1xuaW1wb3J0ICcuL2VkaXRvci5zY3NzJztcblxuLy8gSW1wb3J0IHRyYW5zbGF0ZVxuaW1wb3J0IF9fdHJfXyBmcm9tICcuLi90cmFuc2xhdGUnO1xuLy8gSW1wb3J0IEljb25cbmltcG9ydCBJY29uIGZyb20gJy4uL2ljb24nO1xuLy8gSW1wb3J0IGF0dHJpYnV0ZXNcbmltcG9ydCBhdHRyaWJ1dGVzIGZyb20gJy4vYXR0cmlidXRlcyc7XG4vLyBJbXBvcnQgRWRpdFxuaW1wb3J0IGVkaXQgZnJvbSAnLi9lZGl0Jztcbi8vIEltcG9ydCBTYXZlXG5pbXBvcnQgc2F2ZSBmcm9tICcuL3NhdmUnO1xuXG4vLyBJbnRlcm5hbCBibG9jayBsaWJyYXJpZXNcbnZhciByZWdpc3RlckJsb2NrVHlwZSA9IHdwLmJsb2Nrcy5yZWdpc3RlckJsb2NrVHlwZTtcblxuXG5yZWdpc3RlckJsb2NrVHlwZSgnbWVjZXdhcmUvY3VzdG9tLWpzLWNzcy1ndXRlbmJlcmcnLCB7XG5cdC8vIFRpdGxlXG5cdHRpdGxlOiBfX3RyX18oJ0N1c3RvbSBKUy9DU1MnKSxcblx0Ly8gRGVzY3JpcHRpb25cblx0ZGVzY3JpcHRpb246IF9fdHJfXygnQWRkIGN1c3RvbSBKUyBhbmQgQ1NTIGNvZGUgdG8gdGhlIHBhZ2UuJyksXG5cdC8vIEljb25cblx0aWNvbjogSWNvbixcblx0Ly8gQ2F0ZWdvcnlcblx0Y2F0ZWdvcnk6ICdmb3JtYXR0aW5nJyxcblx0Ly8gS2V5d29yZHNcblx0a2V5d29yZHM6IFtfX3RyX18oJ0N1c3RvbSBKUy9DU1MnKSwgX190cl9fKCdqcyBjc3MnKSwgX190cl9fKCdtZWNld2FyZScpXSxcblx0Ly8gU3VwcG9ydHNcblx0c3VwcG9ydHM6IHtcblx0XHRhbGlnbjogZmFsc2UsXG5cdFx0YWxpZ25XaWRlOiBmYWxzZSxcblx0XHRhbmNob3I6IGZhbHNlLFxuXHRcdGN1c3RvbUNsYXNzTmFtZTogZmFsc2UsXG5cdFx0Y2xhc3NOYW1lOiBmYWxzZSxcblx0XHRodG1sOiB0cnVlLFxuXHRcdGluc2VydGVyOiB0cnVlLFxuXHRcdG11bHRpcGxlOiB0cnVlLFxuXHRcdHJldXNhYmxlOiBmYWxzZVxuXHR9LFxuXG5cdC8vIEF0dHJpYnV0ZXNcblx0YXR0cmlidXRlczogYXR0cmlidXRlcyxcblxuXHQvLyBFZGl0IHJlbmRlclxuXHRlZGl0OiBlZGl0LFxuXG5cdC8vIFNhdmUgcmVuZGVyXG5cdHNhdmU6IHNhdmVcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2Jsb2NrL2Jsb2NrLmpzXG4vLyBtb2R1bGUgaWQgPSA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///8\n");

/***/ }),
/* 9 */
/*!******************************!*\
  !*** ./src/block/style.scss ***!
  \******************************/
/*! dynamic exports provided */
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9ibG9jay9zdHlsZS5zY3NzPzgwZjMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9ibG9jay9zdHlsZS5zY3NzXG4vLyBtb2R1bGUgaWQgPSA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9\n");

/***/ }),
/* 10 */
/*!*******************************!*\
  !*** ./src/block/editor.scss ***!
  \*******************************/
/*! dynamic exports provided */
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYmxvY2svZWRpdG9yLnNjc3M/NDlkMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2Jsb2NrL2VkaXRvci5zY3NzXG4vLyBtb2R1bGUgaWQgPSAxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///10\n");

/***/ }),
/* 11 */
/*!***************************!*\
  !*** ./src/block/edit.js ***!
  \***************************/
/*! exports provided: default */
/*! exports used: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_js_base64__ = __webpack_require__(/*! js-base64 */ 0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_js_base64___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_js_base64__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__components_raw_textarea_raw_css_textarea__ = __webpack_require__(/*! ../components/raw-textarea/raw-css-textarea */ 12);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__components_raw_textarea_raw_js_textarea__ = __webpack_require__(/*! ../components/raw-textarea/raw-js-textarea */ 17);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__components_raw_textarea_raw_text__ = __webpack_require__(/*! ../components/raw-textarea/raw-text */ 19);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__components_block_with_description_block_with_description__ = __webpack_require__(/*! ../components/block-with-description/block-with-description */ 20);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__components_modal_modal__ = __webpack_require__(/*! ../components/modal/modal */ 21);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__translate__ = __webpack_require__(/*! ../translate */ 2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__icon__ = __webpack_require__(/*! ../icon */ 3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__attributes__ = __webpack_require__(/*! ./attributes */ 4);\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n// Import Base64\n\n// Import CSS Raw Textarea Control\n\n// Import JS Raw Textarea Control\n\n// Import Raw Text Control\n\n// Block with description\n\n// Import modal\n\n// Import translate\n\n// Import Icon\n\n// Import attributes\n\n\nvar _wp$element = wp.element,\n    Fragment = _wp$element.Fragment,\n    Component = _wp$element.Component;\nvar InspectorControls = wp.editor.InspectorControls;\nvar _wp$components = wp.components,\n    PanelBody = _wp$components.PanelBody,\n    TextControl = _wp$components.TextControl,\n    ToggleControl = _wp$components.ToggleControl;\n\nvar CustomJsAndCssEdit = function (_Component) {\n  _inherits(CustomJsAndCssEdit, _Component);\n\n  function CustomJsAndCssEdit() {\n    _classCallCheck(this, CustomJsAndCssEdit);\n\n    return _possibleConstructorReturn(this, (CustomJsAndCssEdit.__proto__ || Object.getPrototypeOf(CustomJsAndCssEdit)).apply(this, arguments));\n  }\n\n  _createClass(CustomJsAndCssEdit, [{\n    key: 'render',\n    value: function render() {\n      var _props = this.props,\n          _props$attributes = _props.attributes,\n          jsHeaderEnable = _props$attributes.jsHeaderEnable,\n          jsHeader = _props$attributes.jsHeader,\n          jsHeaderParams = _props$attributes.jsHeaderParams,\n          jsHeaderUrl = _props$attributes.jsHeaderUrl,\n          jsHeaderUrlDep = _props$attributes.jsHeaderUrlDep,\n          jsFooterEnable = _props$attributes.jsFooterEnable,\n          jsFooter = _props$attributes.jsFooter,\n          jsFooterParams = _props$attributes.jsFooterParams,\n          jsFooterUrl = _props$attributes.jsFooterUrl,\n          jsFooterUrlDep = _props$attributes.jsFooterUrlDep,\n          cssHeaderEnable = _props$attributes.cssHeaderEnable,\n          cssHeader = _props$attributes.cssHeader,\n          cssHeaderParams = _props$attributes.cssHeaderParams,\n          cssHeaderUrl = _props$attributes.cssHeaderUrl,\n          cssHeaderUrlDep = _props$attributes.cssHeaderUrlDep,\n          cssFooterEnable = _props$attributes.cssFooterEnable,\n          cssFooter = _props$attributes.cssFooter,\n          cssFooterParams = _props$attributes.cssFooterParams,\n          cssFooterUrl = _props$attributes.cssFooterUrl,\n          cssFooterUrlDep = _props$attributes.cssFooterUrlDep,\n          jsInline = _props$attributes.jsInline,\n          jsInlineParams = _props$attributes.jsInlineParams,\n          cssInline = _props$attributes.cssInline,\n          cssInlineParams = _props$attributes.cssInlineParams,\n          metaEnable = _props$attributes.metaEnable,\n          meta = _props$attributes.meta,\n          setAttributes = _props.setAttributes;\n\n\n      var src = '\\n  function deneme () {\\n    var foo = \\'bar\\'\\n    var baz = \\'qux\\'\\n    this.foo = foo + baz\\n  }\\n  console.log(\\'deneme\\');\\n';\n\n      // const { code, error } = uglify.minify(src);\n      // console.log(code);\n      // console.log(this.props.attributes);\n      // Babel.transform(d, { presets: ['es2015'] }).code\n\n      var jsControls = wp.element.createElement(\n        PanelBody,\n        { title: Object(__WEBPACK_IMPORTED_MODULE_6__translate__[\"a\" /* default */])('Javascript'), initialOpen: false },\n        wp.element.createElement(\n          __WEBPACK_IMPORTED_MODULE_4__components_block_with_description_block_with_description__[\"a\" /* default */],\n          { description: __WEBPACK_IMPORTED_MODULE_8__attributes__[\"a\" /* default */].jsInline.description },\n          wp.element.createElement(__WEBPACK_IMPORTED_MODULE_2__components_raw_textarea_raw_js_textarea__[\"a\" /* default */], {\n            label: __WEBPACK_IMPORTED_MODULE_8__attributes__[\"a\" /* default */].jsInline.label,\n            js: jsInline,\n            params: jsInlineParams[0],\n            onJSChange: function onJSChange(value) {\n              return setAttributes({ jsInline: value });\n            },\n            onParamsChange: function onParamsChange(value) {\n              return setAttributes({ jsInlineParams: [{ minEnabled: value.minEnabled, min: value.min, type: value.type }] });\n            },\n            minifyLabel: Object(__WEBPACK_IMPORTED_MODULE_6__translate__[\"a\" /* default */])('Min')\n          })\n        ),\n        wp.element.createElement(ToggleControl, {\n          label: __WEBPACK_IMPORTED_MODULE_8__attributes__[\"a\" /* default */].jsHeaderEnable.label,\n          checked: jsHeaderEnable,\n          onChange: function onChange(value) {\n            return setAttributes({ jsHeaderEnable: value });\n          }\n        }),\n        jsHeaderEnable && wp.element.createElement(\n          __WEBPACK_IMPORTED_MODULE_5__components_modal_modal__[\"a\" /* default */],\n          {\n            buttonText: Object(__WEBPACK_IMPORTED_MODULE_6__translate__[\"a\" /* default */])('Javascript Options (Head)'),\n            modalTitle: Object(__WEBPACK_IMPORTED_MODULE_6__translate__[\"a\" /* default */])('Javascript Options (Head)'),\n            modalButtonText: Object(__WEBPACK_IMPORTED_MODULE_6__translate__[\"a\" /* default */])('Save/Close')\n          },\n          wp.element.createElement(\n            __WEBPACK_IMPORTED_MODULE_4__components_block_with_description_block_with_description__[\"a\" /* default */],\n            { description: __WEBPACK_IMPORTED_MODULE_8__attributes__[\"a\" /* default */].jsHeader.description },\n            wp.element.createElement(__WEBPACK_IMPORTED_MODULE_2__components_raw_textarea_raw_js_textarea__[\"a\" /* default */], {\n              label: __WEBPACK_IMPORTED_MODULE_8__attributes__[\"a\" /* default */].jsHeader.label,\n              js: jsHeader,\n              params: jsHeaderParams[0],\n              onJSChange: function onJSChange(value) {\n                return setAttributes({ jsHeader: value });\n              },\n              onParamsChange: function onParamsChange(value) {\n                return setAttributes({ jsHeaderParams: [{ minEnabled: value.minEnabled, min: value.min, type: value.type }] });\n              },\n              minifyLabel: Object(__WEBPACK_IMPORTED_MODULE_6__translate__[\"a\" /* default */])('Min')\n            })\n          ),\n          wp.element.createElement(\n            __WEBPACK_IMPORTED_MODULE_4__components_block_with_description_block_with_description__[\"a\" /* default */],\n            { description: __WEBPACK_IMPORTED_MODULE_8__attributes__[\"a\" /* default */].jsHeaderUrl.description },\n            wp.element.createElement(TextControl, {\n              type: 'string',\n              label: __WEBPACK_IMPORTED_MODULE_8__attributes__[\"a\" /* default */].jsHeaderUrl.label,\n              placeholder: 'https://',\n              value: jsHeaderUrl,\n              onChange: function onChange(value) {\n                return setAttributes({ jsHeaderUrl: value });\n              }\n            })\n          ),\n          wp.element.createElement(\n            __WEBPACK_IMPORTED_MODULE_4__components_block_with_description_block_with_description__[\"a\" /* default */],\n            { description: __WEBPACK_IMPORTED_MODULE_8__attributes__[\"a\" /* default */].jsHeaderUrlDep.description },\n            wp.element.createElement(TextControl, {\n              type: 'string',\n              label: __WEBPACK_IMPORTED_MODULE_8__attributes__[\"a\" /* default */].jsHeaderUrlDep.label,\n              placeholder: 'jquery',\n              value: jsHeaderUrlDep,\n              onChange: function onChange(value) {\n                return setAttributes({ jsHeaderUrlDep: value });\n              }\n            })\n          )\n        ),\n        wp.element.createElement(ToggleControl, {\n          label: __WEBPACK_IMPORTED_MODULE_8__attributes__[\"a\" /* default */].jsFooterEnable.label,\n          checked: jsFooterEnable,\n          onChange: function onChange(value) {\n            return setAttributes({ jsFooterEnable: value });\n          }\n        }),\n        jsFooterEnable && wp.element.createElement(\n          __WEBPACK_IMPORTED_MODULE_5__components_modal_modal__[\"a\" /* default */],\n          {\n            buttonText: Object(__WEBPACK_IMPORTED_MODULE_6__translate__[\"a\" /* default */])('Javascript Options (Footer)'),\n            modalTitle: Object(__WEBPACK_IMPORTED_MODULE_6__translate__[\"a\" /* default */])('Javascript Options (Footer)'),\n            modalButtonText: Object(__WEBPACK_IMPORTED_MODULE_6__translate__[\"a\" /* default */])('Save/Close')\n          },\n          wp.element.createElement(\n            __WEBPACK_IMPORTED_MODULE_4__components_block_with_description_block_with_description__[\"a\" /* default */],\n            { description: __WEBPACK_IMPORTED_MODULE_8__attributes__[\"a\" /* default */].jsFooter.description },\n            wp.element.createElement(__WEBPACK_IMPORTED_MODULE_2__components_raw_textarea_raw_js_textarea__[\"a\" /* default */], {\n              label: __WEBPACK_IMPORTED_MODULE_8__attributes__[\"a\" /* default */].jsFooter.label,\n              js: jsFooter,\n              params: jsFooterParams[0],\n              onJSChange: function onJSChange(value) {\n                return setAttributes({ jsFooter: value });\n              },\n              onParamsChange: function onParamsChange(value) {\n                return setAttributes({ jsFooterParams: [{ minEnabled: value.minEnabled, min: value.min, type: value.type }] });\n              },\n              minifyLabel: Object(__WEBPACK_IMPORTED_MODULE_6__translate__[\"a\" /* default */])('Min')\n            })\n          ),\n          wp.element.createElement(\n            __WEBPACK_IMPORTED_MODULE_4__components_block_with_description_block_with_description__[\"a\" /* default */],\n            { description: __WEBPACK_IMPORTED_MODULE_8__attributes__[\"a\" /* default */].jsFooterUrl.description },\n            wp.element.createElement(TextControl, {\n              type: 'string',\n              label: __WEBPACK_IMPORTED_MODULE_8__attributes__[\"a\" /* default */].jsFooterUrl.label,\n              placeholder: 'https://',\n              value: jsFooterUrl,\n              onChange: function onChange(value) {\n                return setAttributes({ jsFooterUrl: value });\n              }\n            })\n          ),\n          wp.element.createElement(\n            __WEBPACK_IMPORTED_MODULE_4__components_block_with_description_block_with_description__[\"a\" /* default */],\n            { description: __WEBPACK_IMPORTED_MODULE_8__attributes__[\"a\" /* default */].jsFooterUrlDep.description },\n            wp.element.createElement(TextControl, {\n              type: 'string',\n              label: __WEBPACK_IMPORTED_MODULE_8__attributes__[\"a\" /* default */].jsFooterUrlDep.label,\n              placeholder: 'jquery',\n              value: jsFooterUrlDep,\n              onChange: function onChange(value) {\n                return setAttributes({ jsFooterUrlDep: value });\n              }\n            })\n          )\n        )\n      );\n\n      var cssControls = wp.element.createElement(\n        PanelBody,\n        { title: Object(__WEBPACK_IMPORTED_MODULE_6__translate__[\"a\" /* default */])('CSS'), initialOpen: false },\n        wp.element.createElement(\n          __WEBPACK_IMPORTED_MODULE_4__components_block_with_description_block_with_description__[\"a\" /* default */],\n          { description: __WEBPACK_IMPORTED_MODULE_8__attributes__[\"a\" /* default */].cssInline.description },\n          wp.element.createElement(__WEBPACK_IMPORTED_MODULE_1__components_raw_textarea_raw_css_textarea__[\"a\" /* default */], {\n            label: __WEBPACK_IMPORTED_MODULE_8__attributes__[\"a\" /* default */].cssInline.label,\n            css: cssInline,\n            params: cssInlineParams[0],\n            onCSSChange: function onCSSChange(value) {\n              return setAttributes({ cssInline: value });\n            },\n            onParamsChange: function onParamsChange(value) {\n              return setAttributes({ cssInlineParams: [{ minEnabled: value.minEnabled, min: value.min, type: value.type }] });\n            },\n            minifyLabel: Object(__WEBPACK_IMPORTED_MODULE_6__translate__[\"a\" /* default */])('Min')\n          })\n        ),\n        wp.element.createElement(ToggleControl, {\n          label: __WEBPACK_IMPORTED_MODULE_8__attributes__[\"a\" /* default */].cssHeaderEnable.label,\n          checked: cssHeaderEnable,\n          onChange: function onChange(value) {\n            return setAttributes({ cssHeaderEnable: value });\n          }\n        }),\n        cssHeaderEnable && wp.element.createElement(\n          __WEBPACK_IMPORTED_MODULE_5__components_modal_modal__[\"a\" /* default */],\n          {\n            buttonText: Object(__WEBPACK_IMPORTED_MODULE_6__translate__[\"a\" /* default */])('CSS Options (Head)'),\n            modalTitle: Object(__WEBPACK_IMPORTED_MODULE_6__translate__[\"a\" /* default */])('CSS Options (Head)'),\n            modalButtonText: Object(__WEBPACK_IMPORTED_MODULE_6__translate__[\"a\" /* default */])('Save/Close')\n          },\n          wp.element.createElement(\n            __WEBPACK_IMPORTED_MODULE_4__components_block_with_description_block_with_description__[\"a\" /* default */],\n            { description: __WEBPACK_IMPORTED_MODULE_8__attributes__[\"a\" /* default */].cssHeader.description },\n            wp.element.createElement(__WEBPACK_IMPORTED_MODULE_1__components_raw_textarea_raw_css_textarea__[\"a\" /* default */], {\n              label: __WEBPACK_IMPORTED_MODULE_8__attributes__[\"a\" /* default */].cssHeader.label,\n              css: cssHeader,\n              params: cssHeaderParams[0],\n              onCSSChange: function onCSSChange(value) {\n                return setAttributes({ cssHeader: value });\n              },\n              onParamsChange: function onParamsChange(value) {\n                return setAttributes({ cssHeaderParams: [{ minEnabled: value.minEnabled, min: value.min, type: value.type }] });\n              },\n              minifyLabel: Object(__WEBPACK_IMPORTED_MODULE_6__translate__[\"a\" /* default */])('Min')\n            })\n          ),\n          wp.element.createElement(\n            __WEBPACK_IMPORTED_MODULE_4__components_block_with_description_block_with_description__[\"a\" /* default */],\n            { description: __WEBPACK_IMPORTED_MODULE_8__attributes__[\"a\" /* default */].cssHeaderUrl.description },\n            wp.element.createElement(TextControl, {\n              type: 'string',\n              label: __WEBPACK_IMPORTED_MODULE_8__attributes__[\"a\" /* default */].cssHeaderUrl.label,\n              placeholder: 'https://',\n              value: cssHeaderUrl,\n              onChange: function onChange(value) {\n                return setAttributes({ cssHeaderUrl: value });\n              }\n            })\n          ),\n          wp.element.createElement(\n            __WEBPACK_IMPORTED_MODULE_4__components_block_with_description_block_with_description__[\"a\" /* default */],\n            { description: __WEBPACK_IMPORTED_MODULE_8__attributes__[\"a\" /* default */].cssHeaderUrlDep.description },\n            wp.element.createElement(TextControl, {\n              type: 'string',\n              label: __WEBPACK_IMPORTED_MODULE_8__attributes__[\"a\" /* default */].cssHeaderUrlDep.label,\n              placeholder: 'theme-css',\n              value: cssHeaderUrlDep,\n              onChange: function onChange(value) {\n                return setAttributes({ cssHeaderUrlDep: value });\n              }\n            })\n          )\n        ),\n        wp.element.createElement(ToggleControl, {\n          label: __WEBPACK_IMPORTED_MODULE_8__attributes__[\"a\" /* default */].cssFooterEnable.label,\n          checked: cssFooterEnable,\n          onChange: function onChange(value) {\n            return setAttributes({ cssFooterEnable: value });\n          }\n        }),\n        cssFooterEnable && wp.element.createElement(\n          __WEBPACK_IMPORTED_MODULE_5__components_modal_modal__[\"a\" /* default */],\n          {\n            buttonText: Object(__WEBPACK_IMPORTED_MODULE_6__translate__[\"a\" /* default */])('CSS Options (Footer)'),\n            modalTitle: Object(__WEBPACK_IMPORTED_MODULE_6__translate__[\"a\" /* default */])('CSS Options (Footer)'),\n            modalButtonText: Object(__WEBPACK_IMPORTED_MODULE_6__translate__[\"a\" /* default */])('Save/Close')\n          },\n          wp.element.createElement(\n            __WEBPACK_IMPORTED_MODULE_4__components_block_with_description_block_with_description__[\"a\" /* default */],\n            { description: __WEBPACK_IMPORTED_MODULE_8__attributes__[\"a\" /* default */].cssFooter.description },\n            wp.element.createElement(__WEBPACK_IMPORTED_MODULE_1__components_raw_textarea_raw_css_textarea__[\"a\" /* default */], {\n              label: __WEBPACK_IMPORTED_MODULE_8__attributes__[\"a\" /* default */].cssFooter.label,\n              css: cssFooter,\n              params: cssFooterParams[0],\n              onCSSChange: function onCSSChange(value) {\n                return setAttributes({ cssFooter: value });\n              },\n              onParamsChange: function onParamsChange(value) {\n                return setAttributes({ cssFooterParams: [{ minEnabled: value.minEnabled, min: value.min, type: value.type }] });\n              },\n              minifyLabel: Object(__WEBPACK_IMPORTED_MODULE_6__translate__[\"a\" /* default */])('Min')\n            })\n          ),\n          wp.element.createElement(\n            __WEBPACK_IMPORTED_MODULE_4__components_block_with_description_block_with_description__[\"a\" /* default */],\n            { description: __WEBPACK_IMPORTED_MODULE_8__attributes__[\"a\" /* default */].cssFooterUrl.description },\n            wp.element.createElement(TextControl, {\n              type: 'string',\n              label: __WEBPACK_IMPORTED_MODULE_8__attributes__[\"a\" /* default */].cssFooterUrl.label,\n              placeholder: 'https://',\n              value: cssFooterUrl,\n              onChange: function onChange(value) {\n                return setAttributes({ cssFooterUrl: value });\n              }\n            })\n          ),\n          wp.element.createElement(\n            __WEBPACK_IMPORTED_MODULE_4__components_block_with_description_block_with_description__[\"a\" /* default */],\n            { description: __WEBPACK_IMPORTED_MODULE_8__attributes__[\"a\" /* default */].cssFooterUrlDep.description },\n            wp.element.createElement(TextControl, {\n              type: 'string',\n              label: __WEBPACK_IMPORTED_MODULE_8__attributes__[\"a\" /* default */].cssFooterUrlDep.label,\n              placeholder: 'theme-css',\n              value: cssFooterUrlDep,\n              onChange: function onChange(value) {\n                return setAttributes({ cssFooterUrlDep: value });\n              }\n            })\n          )\n        )\n      );\n\n      var metaControls = wp.element.createElement(\n        PanelBody,\n        { title: Object(__WEBPACK_IMPORTED_MODULE_6__translate__[\"a\" /* default */])('Meta'), initialOpen: false },\n        wp.element.createElement(ToggleControl, {\n          label: __WEBPACK_IMPORTED_MODULE_8__attributes__[\"a\" /* default */].metaEnable.label,\n          checked: metaEnable,\n          onChange: function onChange(value) {\n            return setAttributes({ metaEnable: value });\n          }\n        }),\n        metaEnable && wp.element.createElement(\n          __WEBPACK_IMPORTED_MODULE_4__components_block_with_description_block_with_description__[\"a\" /* default */],\n          { description: __WEBPACK_IMPORTED_MODULE_8__attributes__[\"a\" /* default */].meta.description },\n          wp.element.createElement(__WEBPACK_IMPORTED_MODULE_3__components_raw_textarea_raw_text__[\"a\" /* default */], {\n            label: __WEBPACK_IMPORTED_MODULE_8__attributes__[\"a\" /* default */].meta.label,\n            beginning: '<meta',\n            ending: '/>',\n            value: __WEBPACK_IMPORTED_MODULE_0_js_base64__[\"Base64\"].decode(meta),\n            onChange: function onChange(value) {\n              return setAttributes({ meta: __WEBPACK_IMPORTED_MODULE_0_js_base64__[\"Base64\"].encode(value) });\n            }\n          })\n        )\n      );\n\n      return wp.element.createElement(\n        Fragment,\n        null,\n        wp.element.createElement(\n          InspectorControls,\n          null,\n          jsControls,\n          cssControls,\n          metaControls\n        ),\n        wp.element.createElement(\n          'div',\n          { className: 'mcw-js-css-wrapper' },\n          wp.element.createElement(\n            'div',\n            { className: 'mcw-js-css-selector-icon' },\n            __WEBPACK_IMPORTED_MODULE_7__icon__[\"a\" /* default */]\n          ),\n          wp.element.createElement(\n            'div',\n            { className: 'mcw-js-css-selector' },\n            Object(__WEBPACK_IMPORTED_MODULE_6__translate__[\"a\" /* default */])('Custom JS/CSS')\n          )\n        )\n      );\n    }\n  }]);\n\n  return CustomJsAndCssEdit;\n}(Component);\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (CustomJsAndCssEdit);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYmxvY2svZWRpdC5qcz8zZmUxIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLy8gSW1wb3J0IEJhc2U2NFxuaW1wb3J0IHsgQmFzZTY0IH0gZnJvbSAnanMtYmFzZTY0Jztcbi8vIEltcG9ydCBDU1MgUmF3IFRleHRhcmVhIENvbnRyb2xcbmltcG9ydCBSYXdDU1NUZXh0YXJlYUNvbnRyb2wgZnJvbSAnLi4vY29tcG9uZW50cy9yYXctdGV4dGFyZWEvcmF3LWNzcy10ZXh0YXJlYSc7XG4vLyBJbXBvcnQgSlMgUmF3IFRleHRhcmVhIENvbnRyb2xcbmltcG9ydCBSYXdKU1RleHRhcmVhQ29udHJvbCBmcm9tICcuLi9jb21wb25lbnRzL3Jhdy10ZXh0YXJlYS9yYXctanMtdGV4dGFyZWEnO1xuLy8gSW1wb3J0IFJhdyBUZXh0IENvbnRyb2xcbmltcG9ydCBSYXdUZXh0Q29udHJvbCBmcm9tICcuLi9jb21wb25lbnRzL3Jhdy10ZXh0YXJlYS9yYXctdGV4dCc7XG4vLyBCbG9jayB3aXRoIGRlc2NyaXB0aW9uXG5pbXBvcnQgQmxvY2tXaXRoRGVzY3JpcHRpb24gZnJvbSAnLi4vY29tcG9uZW50cy9ibG9jay13aXRoLWRlc2NyaXB0aW9uL2Jsb2NrLXdpdGgtZGVzY3JpcHRpb24nO1xuLy8gSW1wb3J0IG1vZGFsXG5pbXBvcnQgTW9kYWxTZXR0aW5ncyBmcm9tICcuLi9jb21wb25lbnRzL21vZGFsL21vZGFsJztcbi8vIEltcG9ydCB0cmFuc2xhdGVcbmltcG9ydCBfX3RyX18gZnJvbSAnLi4vdHJhbnNsYXRlJztcbi8vIEltcG9ydCBJY29uXG5pbXBvcnQgSWNvbiBmcm9tICcuLi9pY29uJztcbi8vIEltcG9ydCBhdHRyaWJ1dGVzXG5pbXBvcnQgQmxvY2tBdHRyaWJ1dGVzIGZyb20gJy4vYXR0cmlidXRlcyc7XG5cbnZhciBfd3AkZWxlbWVudCA9IHdwLmVsZW1lbnQsXG4gICAgRnJhZ21lbnQgPSBfd3AkZWxlbWVudC5GcmFnbWVudCxcbiAgICBDb21wb25lbnQgPSBfd3AkZWxlbWVudC5Db21wb25lbnQ7XG52YXIgSW5zcGVjdG9yQ29udHJvbHMgPSB3cC5lZGl0b3IuSW5zcGVjdG9yQ29udHJvbHM7XG52YXIgX3dwJGNvbXBvbmVudHMgPSB3cC5jb21wb25lbnRzLFxuICAgIFBhbmVsQm9keSA9IF93cCRjb21wb25lbnRzLlBhbmVsQm9keSxcbiAgICBUZXh0Q29udHJvbCA9IF93cCRjb21wb25lbnRzLlRleHRDb250cm9sLFxuICAgIFRvZ2dsZUNvbnRyb2wgPSBfd3AkY29tcG9uZW50cy5Ub2dnbGVDb250cm9sO1xuXG52YXIgQ3VzdG9tSnNBbmRDc3NFZGl0ID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgX2luaGVyaXRzKEN1c3RvbUpzQW5kQ3NzRWRpdCwgX0NvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gQ3VzdG9tSnNBbmRDc3NFZGl0KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDdXN0b21Kc0FuZENzc0VkaXQpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChDdXN0b21Kc0FuZENzc0VkaXQuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihDdXN0b21Kc0FuZENzc0VkaXQpKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhDdXN0b21Kc0FuZENzc0VkaXQsIFt7XG4gICAga2V5OiAncmVuZGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgX3Byb3BzJGF0dHJpYnV0ZXMgPSBfcHJvcHMuYXR0cmlidXRlcyxcbiAgICAgICAgICBqc0hlYWRlckVuYWJsZSA9IF9wcm9wcyRhdHRyaWJ1dGVzLmpzSGVhZGVyRW5hYmxlLFxuICAgICAgICAgIGpzSGVhZGVyID0gX3Byb3BzJGF0dHJpYnV0ZXMuanNIZWFkZXIsXG4gICAgICAgICAganNIZWFkZXJQYXJhbXMgPSBfcHJvcHMkYXR0cmlidXRlcy5qc0hlYWRlclBhcmFtcyxcbiAgICAgICAgICBqc0hlYWRlclVybCA9IF9wcm9wcyRhdHRyaWJ1dGVzLmpzSGVhZGVyVXJsLFxuICAgICAgICAgIGpzSGVhZGVyVXJsRGVwID0gX3Byb3BzJGF0dHJpYnV0ZXMuanNIZWFkZXJVcmxEZXAsXG4gICAgICAgICAganNGb290ZXJFbmFibGUgPSBfcHJvcHMkYXR0cmlidXRlcy5qc0Zvb3RlckVuYWJsZSxcbiAgICAgICAgICBqc0Zvb3RlciA9IF9wcm9wcyRhdHRyaWJ1dGVzLmpzRm9vdGVyLFxuICAgICAgICAgIGpzRm9vdGVyUGFyYW1zID0gX3Byb3BzJGF0dHJpYnV0ZXMuanNGb290ZXJQYXJhbXMsXG4gICAgICAgICAganNGb290ZXJVcmwgPSBfcHJvcHMkYXR0cmlidXRlcy5qc0Zvb3RlclVybCxcbiAgICAgICAgICBqc0Zvb3RlclVybERlcCA9IF9wcm9wcyRhdHRyaWJ1dGVzLmpzRm9vdGVyVXJsRGVwLFxuICAgICAgICAgIGNzc0hlYWRlckVuYWJsZSA9IF9wcm9wcyRhdHRyaWJ1dGVzLmNzc0hlYWRlckVuYWJsZSxcbiAgICAgICAgICBjc3NIZWFkZXIgPSBfcHJvcHMkYXR0cmlidXRlcy5jc3NIZWFkZXIsXG4gICAgICAgICAgY3NzSGVhZGVyUGFyYW1zID0gX3Byb3BzJGF0dHJpYnV0ZXMuY3NzSGVhZGVyUGFyYW1zLFxuICAgICAgICAgIGNzc0hlYWRlclVybCA9IF9wcm9wcyRhdHRyaWJ1dGVzLmNzc0hlYWRlclVybCxcbiAgICAgICAgICBjc3NIZWFkZXJVcmxEZXAgPSBfcHJvcHMkYXR0cmlidXRlcy5jc3NIZWFkZXJVcmxEZXAsXG4gICAgICAgICAgY3NzRm9vdGVyRW5hYmxlID0gX3Byb3BzJGF0dHJpYnV0ZXMuY3NzRm9vdGVyRW5hYmxlLFxuICAgICAgICAgIGNzc0Zvb3RlciA9IF9wcm9wcyRhdHRyaWJ1dGVzLmNzc0Zvb3RlcixcbiAgICAgICAgICBjc3NGb290ZXJQYXJhbXMgPSBfcHJvcHMkYXR0cmlidXRlcy5jc3NGb290ZXJQYXJhbXMsXG4gICAgICAgICAgY3NzRm9vdGVyVXJsID0gX3Byb3BzJGF0dHJpYnV0ZXMuY3NzRm9vdGVyVXJsLFxuICAgICAgICAgIGNzc0Zvb3RlclVybERlcCA9IF9wcm9wcyRhdHRyaWJ1dGVzLmNzc0Zvb3RlclVybERlcCxcbiAgICAgICAgICBqc0lubGluZSA9IF9wcm9wcyRhdHRyaWJ1dGVzLmpzSW5saW5lLFxuICAgICAgICAgIGpzSW5saW5lUGFyYW1zID0gX3Byb3BzJGF0dHJpYnV0ZXMuanNJbmxpbmVQYXJhbXMsXG4gICAgICAgICAgY3NzSW5saW5lID0gX3Byb3BzJGF0dHJpYnV0ZXMuY3NzSW5saW5lLFxuICAgICAgICAgIGNzc0lubGluZVBhcmFtcyA9IF9wcm9wcyRhdHRyaWJ1dGVzLmNzc0lubGluZVBhcmFtcyxcbiAgICAgICAgICBtZXRhRW5hYmxlID0gX3Byb3BzJGF0dHJpYnV0ZXMubWV0YUVuYWJsZSxcbiAgICAgICAgICBtZXRhID0gX3Byb3BzJGF0dHJpYnV0ZXMubWV0YSxcbiAgICAgICAgICBzZXRBdHRyaWJ1dGVzID0gX3Byb3BzLnNldEF0dHJpYnV0ZXM7XG5cblxuICAgICAgdmFyIHNyYyA9ICdcXG4gIGZ1bmN0aW9uIGRlbmVtZSAoKSB7XFxuICAgIHZhciBmb28gPSBcXCdiYXJcXCdcXG4gICAgdmFyIGJheiA9IFxcJ3F1eFxcJ1xcbiAgICB0aGlzLmZvbyA9IGZvbyArIGJhelxcbiAgfVxcbiAgY29uc29sZS5sb2coXFwnZGVuZW1lXFwnKTtcXG4nO1xuXG4gICAgICAvLyBjb25zdCB7IGNvZGUsIGVycm9yIH0gPSB1Z2xpZnkubWluaWZ5KHNyYyk7XG4gICAgICAvLyBjb25zb2xlLmxvZyhjb2RlKTtcbiAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMucHJvcHMuYXR0cmlidXRlcyk7XG4gICAgICAvLyBCYWJlbC50cmFuc2Zvcm0oZCwgeyBwcmVzZXRzOiBbJ2VzMjAxNSddIH0pLmNvZGVcblxuICAgICAgdmFyIGpzQ29udHJvbHMgPSB3cC5lbGVtZW50LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgIFBhbmVsQm9keSxcbiAgICAgICAgeyB0aXRsZTogX190cl9fKCdKYXZhc2NyaXB0JyksIGluaXRpYWxPcGVuOiBmYWxzZSB9LFxuICAgICAgICB3cC5lbGVtZW50LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgQmxvY2tXaXRoRGVzY3JpcHRpb24sXG4gICAgICAgICAgeyBkZXNjcmlwdGlvbjogQmxvY2tBdHRyaWJ1dGVzLmpzSW5saW5lLmRlc2NyaXB0aW9uIH0sXG4gICAgICAgICAgd3AuZWxlbWVudC5jcmVhdGVFbGVtZW50KFJhd0pTVGV4dGFyZWFDb250cm9sLCB7XG4gICAgICAgICAgICBsYWJlbDogQmxvY2tBdHRyaWJ1dGVzLmpzSW5saW5lLmxhYmVsLFxuICAgICAgICAgICAganM6IGpzSW5saW5lLFxuICAgICAgICAgICAgcGFyYW1zOiBqc0lubGluZVBhcmFtc1swXSxcbiAgICAgICAgICAgIG9uSlNDaGFuZ2U6IGZ1bmN0aW9uIG9uSlNDaGFuZ2UodmFsdWUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNldEF0dHJpYnV0ZXMoeyBqc0lubGluZTogdmFsdWUgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25QYXJhbXNDaGFuZ2U6IGZ1bmN0aW9uIG9uUGFyYW1zQ2hhbmdlKHZhbHVlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzZXRBdHRyaWJ1dGVzKHsganNJbmxpbmVQYXJhbXM6IFt7IG1pbkVuYWJsZWQ6IHZhbHVlLm1pbkVuYWJsZWQsIG1pbjogdmFsdWUubWluLCB0eXBlOiB2YWx1ZS50eXBlIH1dIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1pbmlmeUxhYmVsOiBfX3RyX18oJ01pbicpXG4gICAgICAgICAgfSlcbiAgICAgICAgKSxcbiAgICAgICAgd3AuZWxlbWVudC5jcmVhdGVFbGVtZW50KFRvZ2dsZUNvbnRyb2wsIHtcbiAgICAgICAgICBsYWJlbDogQmxvY2tBdHRyaWJ1dGVzLmpzSGVhZGVyRW5hYmxlLmxhYmVsLFxuICAgICAgICAgIGNoZWNrZWQ6IGpzSGVhZGVyRW5hYmxlLFxuICAgICAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiBvbkNoYW5nZSh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHNldEF0dHJpYnV0ZXMoeyBqc0hlYWRlckVuYWJsZTogdmFsdWUgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KSxcbiAgICAgICAganNIZWFkZXJFbmFibGUgJiYgd3AuZWxlbWVudC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgIE1vZGFsU2V0dGluZ3MsXG4gICAgICAgICAge1xuICAgICAgICAgICAgYnV0dG9uVGV4dDogX190cl9fKCdKYXZhc2NyaXB0IE9wdGlvbnMgKEhlYWQpJyksXG4gICAgICAgICAgICBtb2RhbFRpdGxlOiBfX3RyX18oJ0phdmFzY3JpcHQgT3B0aW9ucyAoSGVhZCknKSxcbiAgICAgICAgICAgIG1vZGFsQnV0dG9uVGV4dDogX190cl9fKCdTYXZlL0Nsb3NlJylcbiAgICAgICAgICB9LFxuICAgICAgICAgIHdwLmVsZW1lbnQuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgIEJsb2NrV2l0aERlc2NyaXB0aW9uLFxuICAgICAgICAgICAgeyBkZXNjcmlwdGlvbjogQmxvY2tBdHRyaWJ1dGVzLmpzSGVhZGVyLmRlc2NyaXB0aW9uIH0sXG4gICAgICAgICAgICB3cC5lbGVtZW50LmNyZWF0ZUVsZW1lbnQoUmF3SlNUZXh0YXJlYUNvbnRyb2wsIHtcbiAgICAgICAgICAgICAgbGFiZWw6IEJsb2NrQXR0cmlidXRlcy5qc0hlYWRlci5sYWJlbCxcbiAgICAgICAgICAgICAganM6IGpzSGVhZGVyLFxuICAgICAgICAgICAgICBwYXJhbXM6IGpzSGVhZGVyUGFyYW1zWzBdLFxuICAgICAgICAgICAgICBvbkpTQ2hhbmdlOiBmdW5jdGlvbiBvbkpTQ2hhbmdlKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNldEF0dHJpYnV0ZXMoeyBqc0hlYWRlcjogdmFsdWUgfSk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIG9uUGFyYW1zQ2hhbmdlOiBmdW5jdGlvbiBvblBhcmFtc0NoYW5nZSh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZXRBdHRyaWJ1dGVzKHsganNIZWFkZXJQYXJhbXM6IFt7IG1pbkVuYWJsZWQ6IHZhbHVlLm1pbkVuYWJsZWQsIG1pbjogdmFsdWUubWluLCB0eXBlOiB2YWx1ZS50eXBlIH1dIH0pO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBtaW5pZnlMYWJlbDogX190cl9fKCdNaW4nKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApLFxuICAgICAgICAgIHdwLmVsZW1lbnQuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgIEJsb2NrV2l0aERlc2NyaXB0aW9uLFxuICAgICAgICAgICAgeyBkZXNjcmlwdGlvbjogQmxvY2tBdHRyaWJ1dGVzLmpzSGVhZGVyVXJsLmRlc2NyaXB0aW9uIH0sXG4gICAgICAgICAgICB3cC5lbGVtZW50LmNyZWF0ZUVsZW1lbnQoVGV4dENvbnRyb2wsIHtcbiAgICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICAgIGxhYmVsOiBCbG9ja0F0dHJpYnV0ZXMuanNIZWFkZXJVcmwubGFiZWwsXG4gICAgICAgICAgICAgIHBsYWNlaG9sZGVyOiAnaHR0cHM6Ly8nLFxuICAgICAgICAgICAgICB2YWx1ZToganNIZWFkZXJVcmwsXG4gICAgICAgICAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiBvbkNoYW5nZSh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZXRBdHRyaWJ1dGVzKHsganNIZWFkZXJVcmw6IHZhbHVlIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICksXG4gICAgICAgICAgd3AuZWxlbWVudC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgQmxvY2tXaXRoRGVzY3JpcHRpb24sXG4gICAgICAgICAgICB7IGRlc2NyaXB0aW9uOiBCbG9ja0F0dHJpYnV0ZXMuanNIZWFkZXJVcmxEZXAuZGVzY3JpcHRpb24gfSxcbiAgICAgICAgICAgIHdwLmVsZW1lbnQuY3JlYXRlRWxlbWVudChUZXh0Q29udHJvbCwge1xuICAgICAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICAgICAgbGFiZWw6IEJsb2NrQXR0cmlidXRlcy5qc0hlYWRlclVybERlcC5sYWJlbCxcbiAgICAgICAgICAgICAgcGxhY2Vob2xkZXI6ICdqcXVlcnknLFxuICAgICAgICAgICAgICB2YWx1ZToganNIZWFkZXJVcmxEZXAsXG4gICAgICAgICAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiBvbkNoYW5nZSh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZXRBdHRyaWJ1dGVzKHsganNIZWFkZXJVcmxEZXA6IHZhbHVlIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgIClcbiAgICAgICAgKSxcbiAgICAgICAgd3AuZWxlbWVudC5jcmVhdGVFbGVtZW50KFRvZ2dsZUNvbnRyb2wsIHtcbiAgICAgICAgICBsYWJlbDogQmxvY2tBdHRyaWJ1dGVzLmpzRm9vdGVyRW5hYmxlLmxhYmVsLFxuICAgICAgICAgIGNoZWNrZWQ6IGpzRm9vdGVyRW5hYmxlLFxuICAgICAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiBvbkNoYW5nZSh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHNldEF0dHJpYnV0ZXMoeyBqc0Zvb3RlckVuYWJsZTogdmFsdWUgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KSxcbiAgICAgICAganNGb290ZXJFbmFibGUgJiYgd3AuZWxlbWVudC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgIE1vZGFsU2V0dGluZ3MsXG4gICAgICAgICAge1xuICAgICAgICAgICAgYnV0dG9uVGV4dDogX190cl9fKCdKYXZhc2NyaXB0IE9wdGlvbnMgKEZvb3RlciknKSxcbiAgICAgICAgICAgIG1vZGFsVGl0bGU6IF9fdHJfXygnSmF2YXNjcmlwdCBPcHRpb25zIChGb290ZXIpJyksXG4gICAgICAgICAgICBtb2RhbEJ1dHRvblRleHQ6IF9fdHJfXygnU2F2ZS9DbG9zZScpXG4gICAgICAgICAgfSxcbiAgICAgICAgICB3cC5lbGVtZW50LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICBCbG9ja1dpdGhEZXNjcmlwdGlvbixcbiAgICAgICAgICAgIHsgZGVzY3JpcHRpb246IEJsb2NrQXR0cmlidXRlcy5qc0Zvb3Rlci5kZXNjcmlwdGlvbiB9LFxuICAgICAgICAgICAgd3AuZWxlbWVudC5jcmVhdGVFbGVtZW50KFJhd0pTVGV4dGFyZWFDb250cm9sLCB7XG4gICAgICAgICAgICAgIGxhYmVsOiBCbG9ja0F0dHJpYnV0ZXMuanNGb290ZXIubGFiZWwsXG4gICAgICAgICAgICAgIGpzOiBqc0Zvb3RlcixcbiAgICAgICAgICAgICAgcGFyYW1zOiBqc0Zvb3RlclBhcmFtc1swXSxcbiAgICAgICAgICAgICAgb25KU0NoYW5nZTogZnVuY3Rpb24gb25KU0NoYW5nZSh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZXRBdHRyaWJ1dGVzKHsganNGb290ZXI6IHZhbHVlIH0pO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBvblBhcmFtc0NoYW5nZTogZnVuY3Rpb24gb25QYXJhbXNDaGFuZ2UodmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0QXR0cmlidXRlcyh7IGpzRm9vdGVyUGFyYW1zOiBbeyBtaW5FbmFibGVkOiB2YWx1ZS5taW5FbmFibGVkLCBtaW46IHZhbHVlLm1pbiwgdHlwZTogdmFsdWUudHlwZSB9XSB9KTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgbWluaWZ5TGFiZWw6IF9fdHJfXygnTWluJylcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKSxcbiAgICAgICAgICB3cC5lbGVtZW50LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICBCbG9ja1dpdGhEZXNjcmlwdGlvbixcbiAgICAgICAgICAgIHsgZGVzY3JpcHRpb246IEJsb2NrQXR0cmlidXRlcy5qc0Zvb3RlclVybC5kZXNjcmlwdGlvbiB9LFxuICAgICAgICAgICAgd3AuZWxlbWVudC5jcmVhdGVFbGVtZW50KFRleHRDb250cm9sLCB7XG4gICAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICBsYWJlbDogQmxvY2tBdHRyaWJ1dGVzLmpzRm9vdGVyVXJsLmxhYmVsLFxuICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogJ2h0dHBzOi8vJyxcbiAgICAgICAgICAgICAgdmFsdWU6IGpzRm9vdGVyVXJsLFxuICAgICAgICAgICAgICBvbkNoYW5nZTogZnVuY3Rpb24gb25DaGFuZ2UodmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0QXR0cmlidXRlcyh7IGpzRm9vdGVyVXJsOiB2YWx1ZSB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApLFxuICAgICAgICAgIHdwLmVsZW1lbnQuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgIEJsb2NrV2l0aERlc2NyaXB0aW9uLFxuICAgICAgICAgICAgeyBkZXNjcmlwdGlvbjogQmxvY2tBdHRyaWJ1dGVzLmpzRm9vdGVyVXJsRGVwLmRlc2NyaXB0aW9uIH0sXG4gICAgICAgICAgICB3cC5lbGVtZW50LmNyZWF0ZUVsZW1lbnQoVGV4dENvbnRyb2wsIHtcbiAgICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICAgIGxhYmVsOiBCbG9ja0F0dHJpYnV0ZXMuanNGb290ZXJVcmxEZXAubGFiZWwsXG4gICAgICAgICAgICAgIHBsYWNlaG9sZGVyOiAnanF1ZXJ5JyxcbiAgICAgICAgICAgICAgdmFsdWU6IGpzRm9vdGVyVXJsRGVwLFxuICAgICAgICAgICAgICBvbkNoYW5nZTogZnVuY3Rpb24gb25DaGFuZ2UodmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0QXR0cmlidXRlcyh7IGpzRm9vdGVyVXJsRGVwOiB2YWx1ZSB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgICk7XG5cbiAgICAgIHZhciBjc3NDb250cm9scyA9IHdwLmVsZW1lbnQuY3JlYXRlRWxlbWVudChcbiAgICAgICAgUGFuZWxCb2R5LFxuICAgICAgICB7IHRpdGxlOiBfX3RyX18oJ0NTUycpLCBpbml0aWFsT3BlbjogZmFsc2UgfSxcbiAgICAgICAgd3AuZWxlbWVudC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgIEJsb2NrV2l0aERlc2NyaXB0aW9uLFxuICAgICAgICAgIHsgZGVzY3JpcHRpb246IEJsb2NrQXR0cmlidXRlcy5jc3NJbmxpbmUuZGVzY3JpcHRpb24gfSxcbiAgICAgICAgICB3cC5lbGVtZW50LmNyZWF0ZUVsZW1lbnQoUmF3Q1NTVGV4dGFyZWFDb250cm9sLCB7XG4gICAgICAgICAgICBsYWJlbDogQmxvY2tBdHRyaWJ1dGVzLmNzc0lubGluZS5sYWJlbCxcbiAgICAgICAgICAgIGNzczogY3NzSW5saW5lLFxuICAgICAgICAgICAgcGFyYW1zOiBjc3NJbmxpbmVQYXJhbXNbMF0sXG4gICAgICAgICAgICBvbkNTU0NoYW5nZTogZnVuY3Rpb24gb25DU1NDaGFuZ2UodmFsdWUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNldEF0dHJpYnV0ZXMoeyBjc3NJbmxpbmU6IHZhbHVlIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uUGFyYW1zQ2hhbmdlOiBmdW5jdGlvbiBvblBhcmFtc0NoYW5nZSh2YWx1ZSkge1xuICAgICAgICAgICAgICByZXR1cm4gc2V0QXR0cmlidXRlcyh7IGNzc0lubGluZVBhcmFtczogW3sgbWluRW5hYmxlZDogdmFsdWUubWluRW5hYmxlZCwgbWluOiB2YWx1ZS5taW4sIHR5cGU6IHZhbHVlLnR5cGUgfV0gfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWluaWZ5TGFiZWw6IF9fdHJfXygnTWluJylcbiAgICAgICAgICB9KVxuICAgICAgICApLFxuICAgICAgICB3cC5lbGVtZW50LmNyZWF0ZUVsZW1lbnQoVG9nZ2xlQ29udHJvbCwge1xuICAgICAgICAgIGxhYmVsOiBCbG9ja0F0dHJpYnV0ZXMuY3NzSGVhZGVyRW5hYmxlLmxhYmVsLFxuICAgICAgICAgIGNoZWNrZWQ6IGNzc0hlYWRlckVuYWJsZSxcbiAgICAgICAgICBvbkNoYW5nZTogZnVuY3Rpb24gb25DaGFuZ2UodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBzZXRBdHRyaWJ1dGVzKHsgY3NzSGVhZGVyRW5hYmxlOiB2YWx1ZSB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgICBjc3NIZWFkZXJFbmFibGUgJiYgd3AuZWxlbWVudC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgIE1vZGFsU2V0dGluZ3MsXG4gICAgICAgICAge1xuICAgICAgICAgICAgYnV0dG9uVGV4dDogX190cl9fKCdDU1MgT3B0aW9ucyAoSGVhZCknKSxcbiAgICAgICAgICAgIG1vZGFsVGl0bGU6IF9fdHJfXygnQ1NTIE9wdGlvbnMgKEhlYWQpJyksXG4gICAgICAgICAgICBtb2RhbEJ1dHRvblRleHQ6IF9fdHJfXygnU2F2ZS9DbG9zZScpXG4gICAgICAgICAgfSxcbiAgICAgICAgICB3cC5lbGVtZW50LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICBCbG9ja1dpdGhEZXNjcmlwdGlvbixcbiAgICAgICAgICAgIHsgZGVzY3JpcHRpb246IEJsb2NrQXR0cmlidXRlcy5jc3NIZWFkZXIuZGVzY3JpcHRpb24gfSxcbiAgICAgICAgICAgIHdwLmVsZW1lbnQuY3JlYXRlRWxlbWVudChSYXdDU1NUZXh0YXJlYUNvbnRyb2wsIHtcbiAgICAgICAgICAgICAgbGFiZWw6IEJsb2NrQXR0cmlidXRlcy5jc3NIZWFkZXIubGFiZWwsXG4gICAgICAgICAgICAgIGNzczogY3NzSGVhZGVyLFxuICAgICAgICAgICAgICBwYXJhbXM6IGNzc0hlYWRlclBhcmFtc1swXSxcbiAgICAgICAgICAgICAgb25DU1NDaGFuZ2U6IGZ1bmN0aW9uIG9uQ1NTQ2hhbmdlKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNldEF0dHJpYnV0ZXMoeyBjc3NIZWFkZXI6IHZhbHVlIH0pO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBvblBhcmFtc0NoYW5nZTogZnVuY3Rpb24gb25QYXJhbXNDaGFuZ2UodmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0QXR0cmlidXRlcyh7IGNzc0hlYWRlclBhcmFtczogW3sgbWluRW5hYmxlZDogdmFsdWUubWluRW5hYmxlZCwgbWluOiB2YWx1ZS5taW4sIHR5cGU6IHZhbHVlLnR5cGUgfV0gfSk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIG1pbmlmeUxhYmVsOiBfX3RyX18oJ01pbicpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICksXG4gICAgICAgICAgd3AuZWxlbWVudC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgQmxvY2tXaXRoRGVzY3JpcHRpb24sXG4gICAgICAgICAgICB7IGRlc2NyaXB0aW9uOiBCbG9ja0F0dHJpYnV0ZXMuY3NzSGVhZGVyVXJsLmRlc2NyaXB0aW9uIH0sXG4gICAgICAgICAgICB3cC5lbGVtZW50LmNyZWF0ZUVsZW1lbnQoVGV4dENvbnRyb2wsIHtcbiAgICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICAgIGxhYmVsOiBCbG9ja0F0dHJpYnV0ZXMuY3NzSGVhZGVyVXJsLmxhYmVsLFxuICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogJ2h0dHBzOi8vJyxcbiAgICAgICAgICAgICAgdmFsdWU6IGNzc0hlYWRlclVybCxcbiAgICAgICAgICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uIG9uQ2hhbmdlKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNldEF0dHJpYnV0ZXMoeyBjc3NIZWFkZXJVcmw6IHZhbHVlIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICksXG4gICAgICAgICAgd3AuZWxlbWVudC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgQmxvY2tXaXRoRGVzY3JpcHRpb24sXG4gICAgICAgICAgICB7IGRlc2NyaXB0aW9uOiBCbG9ja0F0dHJpYnV0ZXMuY3NzSGVhZGVyVXJsRGVwLmRlc2NyaXB0aW9uIH0sXG4gICAgICAgICAgICB3cC5lbGVtZW50LmNyZWF0ZUVsZW1lbnQoVGV4dENvbnRyb2wsIHtcbiAgICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICAgIGxhYmVsOiBCbG9ja0F0dHJpYnV0ZXMuY3NzSGVhZGVyVXJsRGVwLmxhYmVsLFxuICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogJ3RoZW1lLWNzcycsXG4gICAgICAgICAgICAgIHZhbHVlOiBjc3NIZWFkZXJVcmxEZXAsXG4gICAgICAgICAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiBvbkNoYW5nZSh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZXRBdHRyaWJ1dGVzKHsgY3NzSGVhZGVyVXJsRGVwOiB2YWx1ZSB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApXG4gICAgICAgICksXG4gICAgICAgIHdwLmVsZW1lbnQuY3JlYXRlRWxlbWVudChUb2dnbGVDb250cm9sLCB7XG4gICAgICAgICAgbGFiZWw6IEJsb2NrQXR0cmlidXRlcy5jc3NGb290ZXJFbmFibGUubGFiZWwsXG4gICAgICAgICAgY2hlY2tlZDogY3NzRm9vdGVyRW5hYmxlLFxuICAgICAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiBvbkNoYW5nZSh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHNldEF0dHJpYnV0ZXMoeyBjc3NGb290ZXJFbmFibGU6IHZhbHVlIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSksXG4gICAgICAgIGNzc0Zvb3RlckVuYWJsZSAmJiB3cC5lbGVtZW50LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgTW9kYWxTZXR0aW5ncyxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBidXR0b25UZXh0OiBfX3RyX18oJ0NTUyBPcHRpb25zIChGb290ZXIpJyksXG4gICAgICAgICAgICBtb2RhbFRpdGxlOiBfX3RyX18oJ0NTUyBPcHRpb25zIChGb290ZXIpJyksXG4gICAgICAgICAgICBtb2RhbEJ1dHRvblRleHQ6IF9fdHJfXygnU2F2ZS9DbG9zZScpXG4gICAgICAgICAgfSxcbiAgICAgICAgICB3cC5lbGVtZW50LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICBCbG9ja1dpdGhEZXNjcmlwdGlvbixcbiAgICAgICAgICAgIHsgZGVzY3JpcHRpb246IEJsb2NrQXR0cmlidXRlcy5jc3NGb290ZXIuZGVzY3JpcHRpb24gfSxcbiAgICAgICAgICAgIHdwLmVsZW1lbnQuY3JlYXRlRWxlbWVudChSYXdDU1NUZXh0YXJlYUNvbnRyb2wsIHtcbiAgICAgICAgICAgICAgbGFiZWw6IEJsb2NrQXR0cmlidXRlcy5jc3NGb290ZXIubGFiZWwsXG4gICAgICAgICAgICAgIGNzczogY3NzRm9vdGVyLFxuICAgICAgICAgICAgICBwYXJhbXM6IGNzc0Zvb3RlclBhcmFtc1swXSxcbiAgICAgICAgICAgICAgb25DU1NDaGFuZ2U6IGZ1bmN0aW9uIG9uQ1NTQ2hhbmdlKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNldEF0dHJpYnV0ZXMoeyBjc3NGb290ZXI6IHZhbHVlIH0pO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBvblBhcmFtc0NoYW5nZTogZnVuY3Rpb24gb25QYXJhbXNDaGFuZ2UodmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0QXR0cmlidXRlcyh7IGNzc0Zvb3RlclBhcmFtczogW3sgbWluRW5hYmxlZDogdmFsdWUubWluRW5hYmxlZCwgbWluOiB2YWx1ZS5taW4sIHR5cGU6IHZhbHVlLnR5cGUgfV0gfSk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIG1pbmlmeUxhYmVsOiBfX3RyX18oJ01pbicpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICksXG4gICAgICAgICAgd3AuZWxlbWVudC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgQmxvY2tXaXRoRGVzY3JpcHRpb24sXG4gICAgICAgICAgICB7IGRlc2NyaXB0aW9uOiBCbG9ja0F0dHJpYnV0ZXMuY3NzRm9vdGVyVXJsLmRlc2NyaXB0aW9uIH0sXG4gICAgICAgICAgICB3cC5lbGVtZW50LmNyZWF0ZUVsZW1lbnQoVGV4dENvbnRyb2wsIHtcbiAgICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICAgIGxhYmVsOiBCbG9ja0F0dHJpYnV0ZXMuY3NzRm9vdGVyVXJsLmxhYmVsLFxuICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogJ2h0dHBzOi8vJyxcbiAgICAgICAgICAgICAgdmFsdWU6IGNzc0Zvb3RlclVybCxcbiAgICAgICAgICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uIG9uQ2hhbmdlKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNldEF0dHJpYnV0ZXMoeyBjc3NGb290ZXJVcmw6IHZhbHVlIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICksXG4gICAgICAgICAgd3AuZWxlbWVudC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgQmxvY2tXaXRoRGVzY3JpcHRpb24sXG4gICAgICAgICAgICB7IGRlc2NyaXB0aW9uOiBCbG9ja0F0dHJpYnV0ZXMuY3NzRm9vdGVyVXJsRGVwLmRlc2NyaXB0aW9uIH0sXG4gICAgICAgICAgICB3cC5lbGVtZW50LmNyZWF0ZUVsZW1lbnQoVGV4dENvbnRyb2wsIHtcbiAgICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICAgIGxhYmVsOiBCbG9ja0F0dHJpYnV0ZXMuY3NzRm9vdGVyVXJsRGVwLmxhYmVsLFxuICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogJ3RoZW1lLWNzcycsXG4gICAgICAgICAgICAgIHZhbHVlOiBjc3NGb290ZXJVcmxEZXAsXG4gICAgICAgICAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiBvbkNoYW5nZSh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZXRBdHRyaWJ1dGVzKHsgY3NzRm9vdGVyVXJsRGVwOiB2YWx1ZSB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgICk7XG5cbiAgICAgIHZhciBtZXRhQ29udHJvbHMgPSB3cC5lbGVtZW50LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgIFBhbmVsQm9keSxcbiAgICAgICAgeyB0aXRsZTogX190cl9fKCdNZXRhJyksIGluaXRpYWxPcGVuOiBmYWxzZSB9LFxuICAgICAgICB3cC5lbGVtZW50LmNyZWF0ZUVsZW1lbnQoVG9nZ2xlQ29udHJvbCwge1xuICAgICAgICAgIGxhYmVsOiBCbG9ja0F0dHJpYnV0ZXMubWV0YUVuYWJsZS5sYWJlbCxcbiAgICAgICAgICBjaGVja2VkOiBtZXRhRW5hYmxlLFxuICAgICAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiBvbkNoYW5nZSh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHNldEF0dHJpYnV0ZXMoeyBtZXRhRW5hYmxlOiB2YWx1ZSB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgICBtZXRhRW5hYmxlICYmIHdwLmVsZW1lbnQuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICBCbG9ja1dpdGhEZXNjcmlwdGlvbixcbiAgICAgICAgICB7IGRlc2NyaXB0aW9uOiBCbG9ja0F0dHJpYnV0ZXMubWV0YS5kZXNjcmlwdGlvbiB9LFxuICAgICAgICAgIHdwLmVsZW1lbnQuY3JlYXRlRWxlbWVudChSYXdUZXh0Q29udHJvbCwge1xuICAgICAgICAgICAgbGFiZWw6IEJsb2NrQXR0cmlidXRlcy5tZXRhLmxhYmVsLFxuICAgICAgICAgICAgYmVnaW5uaW5nOiAnPG1ldGEnLFxuICAgICAgICAgICAgZW5kaW5nOiAnLz4nLFxuICAgICAgICAgICAgdmFsdWU6IEJhc2U2NC5kZWNvZGUobWV0YSksXG4gICAgICAgICAgICBvbkNoYW5nZTogZnVuY3Rpb24gb25DaGFuZ2UodmFsdWUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNldEF0dHJpYnV0ZXMoeyBtZXRhOiBCYXNlNjQuZW5jb2RlKHZhbHVlKSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICApO1xuXG4gICAgICByZXR1cm4gd3AuZWxlbWVudC5jcmVhdGVFbGVtZW50KFxuICAgICAgICBGcmFnbWVudCxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgd3AuZWxlbWVudC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgIEluc3BlY3RvckNvbnRyb2xzLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAganNDb250cm9scyxcbiAgICAgICAgICBjc3NDb250cm9scyxcbiAgICAgICAgICBtZXRhQ29udHJvbHNcbiAgICAgICAgKSxcbiAgICAgICAgd3AuZWxlbWVudC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICdkaXYnLFxuICAgICAgICAgIHsgY2xhc3NOYW1lOiAnbWN3LWpzLWNzcy13cmFwcGVyJyB9LFxuICAgICAgICAgIHdwLmVsZW1lbnQuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICdkaXYnLFxuICAgICAgICAgICAgeyBjbGFzc05hbWU6ICdtY3ctanMtY3NzLXNlbGVjdG9yLWljb24nIH0sXG4gICAgICAgICAgICBJY29uXG4gICAgICAgICAgKSxcbiAgICAgICAgICB3cC5lbGVtZW50LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICAgIHsgY2xhc3NOYW1lOiAnbWN3LWpzLWNzcy1zZWxlY3RvcicgfSxcbiAgICAgICAgICAgIF9fdHJfXygnQ3VzdG9tIEpTL0NTUycpXG4gICAgICAgICAgKVxuICAgICAgICApXG4gICAgICApO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDdXN0b21Kc0FuZENzc0VkaXQ7XG59KENvbXBvbmVudCk7XG5cbmV4cG9ydCBkZWZhdWx0IEN1c3RvbUpzQW5kQ3NzRWRpdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9ibG9jay9lZGl0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///11\n");

/***/ }),
/* 12 */
/*!*********************************************************!*\
  !*** ./src/components/raw-textarea/raw-css-textarea.js ***!
  \*********************************************************/
/*! exports provided: default */
/*! exports used: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_js_base64__ = __webpack_require__(/*! js-base64 */ 0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_js_base64___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_js_base64__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_classnames__ = __webpack_require__(/*! classnames */ 5);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_classnames___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_classnames__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_less__ = __webpack_require__(/*! less */ 13);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_less___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_less__);\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n// Import Base64\n\n// Import classnames\n\n// LESS\n\n\nvar _wp$element = wp.element,\n    Component = _wp$element.Component,\n    Fragment = _wp$element.Fragment;\nvar _wp$components = wp.components,\n    TextareaControl = _wp$components.TextareaControl,\n    ButtonGroup = _wp$components.ButtonGroup,\n    Button = _wp$components.Button;\n\nvar RawCSSTextareaControl = function (_Component) {\n  _inherits(RawCSSTextareaControl, _Component);\n\n  function RawCSSTextareaControl() {\n    _classCallCheck(this, RawCSSTextareaControl);\n\n    var _this = _possibleConstructorReturn(this, (RawCSSTextareaControl.__proto__ || Object.getPrototypeOf(RawCSSTextareaControl)).apply(this, arguments));\n\n    _this.state = {\n      err: false\n    };\n    return _this;\n  }\n\n  _createClass(RawCSSTextareaControl, [{\n    key: 'render',\n    value: function render() {\n      var _this2 = this;\n\n      var cssStyleTypes = {\n        css: 'CSS',\n        sass: 'SASS',\n        less: 'LESS'\n      };\n\n      var setError = function setError(err) {\n        return _this2.setState({ err: err });\n      };\n\n      var minify = function minify(css) {\n        if (!css) return css;\n\n        var minified = new CleanCSS({}).minify(css);\n        if (minified.styles) {\n          return minified.styles;\n        }\n        // console.error( 'minify error', minified );\n        setError(true);\n        return css;\n      };\n\n      var onParamUpdate = function onParamUpdate(css) {\n        _this2.props.params.min = __WEBPACK_IMPORTED_MODULE_0_js_base64__[\"Base64\"].encode(_this2.props.params.minEnabled ? minify(css) : css);\n\n        _this2.props.onParamsChange(_this2.props.params);\n      };\n\n      var onParamChange = function onParamChange(css) {\n        if (!css) {\n          onParamUpdate(css);\n          return;\n        }\n\n        if (_this2.props.params.type === 'sass') {\n          // SASS\n          Sass.compile(css, function (result) {\n            if (result.status) {\n              // console.error( 'sass error: ', result.formatted );\n              setError(true);\n            } else {\n              setError(false);\n            }\n\n            onParamUpdate(!result.status ? result.text : css);\n          });\n        } else if (_this2.props.params.type === 'less') {\n          __WEBPACK_IMPORTED_MODULE_2_less___default.a.render(css).then(function (output) {\n            setError(false);\n            onParamUpdate(output.css);\n          }, function (error) {\n            // console.error( 'less error: ', error );\n            setError(true);\n            onParamUpdate(css);\n          });\n        } else {\n          setError(false);\n          onParamUpdate(css);\n        }\n      };\n\n      var onCSSChange = function onCSSChange(css) {\n        _this2.props.onCSSChange(__WEBPACK_IMPORTED_MODULE_0_js_base64__[\"Base64\"].encode(css));\n\n        onParamChange(css);\n      };\n\n      var onMinifyToggle = function onMinifyToggle() {\n        _this2.props.params.minEnabled = !_this2.props.params.minEnabled;\n        onParamChange(__WEBPACK_IMPORTED_MODULE_0_js_base64__[\"Base64\"].decode(_this2.props.css));\n      };\n\n      var onStyleChange = function onStyleChange(type) {\n        _this2.props.params.type = type;\n        onParamChange(__WEBPACK_IMPORTED_MODULE_0_js_base64__[\"Base64\"].decode(_this2.props.css));\n      };\n\n      var styleType = Object.keys(cssStyleTypes).indexOf(this.props.params.type) > -1 ? this.props.params.type : 'css';\n\n      return wp.element.createElement(\n        Fragment,\n        null,\n        wp.element.createElement(\n          'div',\n          { className: 'components-base-control mcw-textarea-comp' },\n          wp.element.createElement(\n            'label',\n            null,\n            this.props.label.replace('{{type}}', cssStyleTypes[styleType])\n          ),\n          wp.element.createElement(\n            ButtonGroup,\n            { className: 'mcw-textarea-button-group' },\n            wp.element.createElement(\n              Button,\n              {\n                className: 'mcw-textarea-btn mcw-textarea-btn-margright',\n                isSmall: true,\n                isPrimary: this.props.params.minEnabled,\n                'aria-pressed': this.props.params.minEnabled,\n                onClick: function onClick() {\n                  return onMinifyToggle();\n                }\n              },\n              this.props.minifyLabel\n            ),\n            Object.keys(cssStyleTypes).map(function (key) {\n              return wp.element.createElement(\n                Button,\n                {\n                  key: key,\n                  className: 'mcw-textarea-btn',\n                  isSmall: true,\n                  isPrimary: styleType === key,\n                  'aria-pressed': styleType === key,\n                  onClick: function onClick() {\n                    return onStyleChange(key);\n                  }\n                },\n                cssStyleTypes[key]\n              );\n            })\n          ),\n          wp.element.createElement(\n            'div',\n            { className: __WEBPACK_IMPORTED_MODULE_1_classnames___default()('mcw-textarea-comp-inner', { 'mcw-textarea-comp-error': this.state.err }) },\n            wp.element.createElement(\n              'p',\n              { className: 'mcw-textarea-def' },\n              '<style type=\"text/css\">'\n            ),\n            wp.element.createElement(TextareaControl, {\n              rows: 12,\n              value: __WEBPACK_IMPORTED_MODULE_0_js_base64__[\"Base64\"].decode(this.props.css),\n              onChange: function onChange(value) {\n                return onCSSChange(value);\n              }\n            }),\n            wp.element.createElement(\n              'p',\n              { className: 'mcw-textarea-def' },\n              '</style>'\n            )\n          )\n        )\n      );\n    }\n  }]);\n\n  return RawCSSTextareaControl;\n}(Component);\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (RawCSSTextareaControl);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9yYXctdGV4dGFyZWEvcmF3LWNzcy10ZXh0YXJlYS5qcz80ZTk0Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLy8gSW1wb3J0IEJhc2U2NFxuaW1wb3J0IHsgQmFzZTY0IH0gZnJvbSAnanMtYmFzZTY0Jztcbi8vIEltcG9ydCBjbGFzc25hbWVzXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbi8vIExFU1NcbmltcG9ydCBsZXNzIGZyb20gJ2xlc3MnO1xuXG52YXIgX3dwJGVsZW1lbnQgPSB3cC5lbGVtZW50LFxuICAgIENvbXBvbmVudCA9IF93cCRlbGVtZW50LkNvbXBvbmVudCxcbiAgICBGcmFnbWVudCA9IF93cCRlbGVtZW50LkZyYWdtZW50O1xudmFyIF93cCRjb21wb25lbnRzID0gd3AuY29tcG9uZW50cyxcbiAgICBUZXh0YXJlYUNvbnRyb2wgPSBfd3AkY29tcG9uZW50cy5UZXh0YXJlYUNvbnRyb2wsXG4gICAgQnV0dG9uR3JvdXAgPSBfd3AkY29tcG9uZW50cy5CdXR0b25Hcm91cCxcbiAgICBCdXR0b24gPSBfd3AkY29tcG9uZW50cy5CdXR0b247XG5cbnZhciBSYXdDU1NUZXh0YXJlYUNvbnRyb2wgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoUmF3Q1NTVGV4dGFyZWFDb250cm9sLCBfQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBSYXdDU1NUZXh0YXJlYUNvbnRyb2woKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJhd0NTU1RleHRhcmVhQ29udHJvbCk7XG5cbiAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoUmF3Q1NTVGV4dGFyZWFDb250cm9sLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoUmF3Q1NTVGV4dGFyZWFDb250cm9sKSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG5cbiAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGVycjogZmFsc2VcbiAgICB9O1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhSYXdDU1NUZXh0YXJlYUNvbnRyb2wsIFt7XG4gICAga2V5OiAncmVuZGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBjc3NTdHlsZVR5cGVzID0ge1xuICAgICAgICBjc3M6ICdDU1MnLFxuICAgICAgICBzYXNzOiAnU0FTUycsXG4gICAgICAgIGxlc3M6ICdMRVNTJ1xuICAgICAgfTtcblxuICAgICAgdmFyIHNldEVycm9yID0gZnVuY3Rpb24gc2V0RXJyb3IoZXJyKSB7XG4gICAgICAgIHJldHVybiBfdGhpczIuc2V0U3RhdGUoeyBlcnI6IGVyciB9KTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBtaW5pZnkgPSBmdW5jdGlvbiBtaW5pZnkoY3NzKSB7XG4gICAgICAgIGlmICghY3NzKSByZXR1cm4gY3NzO1xuXG4gICAgICAgIHZhciBtaW5pZmllZCA9IG5ldyBDbGVhbkNTUyh7fSkubWluaWZ5KGNzcyk7XG4gICAgICAgIGlmIChtaW5pZmllZC5zdHlsZXMpIHtcbiAgICAgICAgICByZXR1cm4gbWluaWZpZWQuc3R5bGVzO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvbnNvbGUuZXJyb3IoICdtaW5pZnkgZXJyb3InLCBtaW5pZmllZCApO1xuICAgICAgICBzZXRFcnJvcih0cnVlKTtcbiAgICAgICAgcmV0dXJuIGNzcztcbiAgICAgIH07XG5cbiAgICAgIHZhciBvblBhcmFtVXBkYXRlID0gZnVuY3Rpb24gb25QYXJhbVVwZGF0ZShjc3MpIHtcbiAgICAgICAgX3RoaXMyLnByb3BzLnBhcmFtcy5taW4gPSBCYXNlNjQuZW5jb2RlKF90aGlzMi5wcm9wcy5wYXJhbXMubWluRW5hYmxlZCA/IG1pbmlmeShjc3MpIDogY3NzKTtcblxuICAgICAgICBfdGhpczIucHJvcHMub25QYXJhbXNDaGFuZ2UoX3RoaXMyLnByb3BzLnBhcmFtcyk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgb25QYXJhbUNoYW5nZSA9IGZ1bmN0aW9uIG9uUGFyYW1DaGFuZ2UoY3NzKSB7XG4gICAgICAgIGlmICghY3NzKSB7XG4gICAgICAgICAgb25QYXJhbVVwZGF0ZShjc3MpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfdGhpczIucHJvcHMucGFyYW1zLnR5cGUgPT09ICdzYXNzJykge1xuICAgICAgICAgIC8vIFNBU1NcbiAgICAgICAgICBTYXNzLmNvbXBpbGUoY3NzLCBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0LnN0YXR1cykge1xuICAgICAgICAgICAgICAvLyBjb25zb2xlLmVycm9yKCAnc2FzcyBlcnJvcjogJywgcmVzdWx0LmZvcm1hdHRlZCApO1xuICAgICAgICAgICAgICBzZXRFcnJvcih0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNldEVycm9yKGZhbHNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb25QYXJhbVVwZGF0ZSghcmVzdWx0LnN0YXR1cyA/IHJlc3VsdC50ZXh0IDogY3NzKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChfdGhpczIucHJvcHMucGFyYW1zLnR5cGUgPT09ICdsZXNzJykge1xuICAgICAgICAgIGxlc3MucmVuZGVyKGNzcykudGhlbihmdW5jdGlvbiAob3V0cHV0KSB7XG4gICAgICAgICAgICBzZXRFcnJvcihmYWxzZSk7XG4gICAgICAgICAgICBvblBhcmFtVXBkYXRlKG91dHB1dC5jc3MpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgLy8gY29uc29sZS5lcnJvciggJ2xlc3MgZXJyb3I6ICcsIGVycm9yICk7XG4gICAgICAgICAgICBzZXRFcnJvcih0cnVlKTtcbiAgICAgICAgICAgIG9uUGFyYW1VcGRhdGUoY3NzKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXRFcnJvcihmYWxzZSk7XG4gICAgICAgICAgb25QYXJhbVVwZGF0ZShjc3MpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB2YXIgb25DU1NDaGFuZ2UgPSBmdW5jdGlvbiBvbkNTU0NoYW5nZShjc3MpIHtcbiAgICAgICAgX3RoaXMyLnByb3BzLm9uQ1NTQ2hhbmdlKEJhc2U2NC5lbmNvZGUoY3NzKSk7XG5cbiAgICAgICAgb25QYXJhbUNoYW5nZShjc3MpO1xuICAgICAgfTtcblxuICAgICAgdmFyIG9uTWluaWZ5VG9nZ2xlID0gZnVuY3Rpb24gb25NaW5pZnlUb2dnbGUoKSB7XG4gICAgICAgIF90aGlzMi5wcm9wcy5wYXJhbXMubWluRW5hYmxlZCA9ICFfdGhpczIucHJvcHMucGFyYW1zLm1pbkVuYWJsZWQ7XG4gICAgICAgIG9uUGFyYW1DaGFuZ2UoQmFzZTY0LmRlY29kZShfdGhpczIucHJvcHMuY3NzKSk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgb25TdHlsZUNoYW5nZSA9IGZ1bmN0aW9uIG9uU3R5bGVDaGFuZ2UodHlwZSkge1xuICAgICAgICBfdGhpczIucHJvcHMucGFyYW1zLnR5cGUgPSB0eXBlO1xuICAgICAgICBvblBhcmFtQ2hhbmdlKEJhc2U2NC5kZWNvZGUoX3RoaXMyLnByb3BzLmNzcykpO1xuICAgICAgfTtcblxuICAgICAgdmFyIHN0eWxlVHlwZSA9IE9iamVjdC5rZXlzKGNzc1N0eWxlVHlwZXMpLmluZGV4T2YodGhpcy5wcm9wcy5wYXJhbXMudHlwZSkgPiAtMSA/IHRoaXMucHJvcHMucGFyYW1zLnR5cGUgOiAnY3NzJztcblxuICAgICAgcmV0dXJuIHdwLmVsZW1lbnQuY3JlYXRlRWxlbWVudChcbiAgICAgICAgRnJhZ21lbnQsXG4gICAgICAgIG51bGwsXG4gICAgICAgIHdwLmVsZW1lbnQuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICB7IGNsYXNzTmFtZTogJ2NvbXBvbmVudHMtYmFzZS1jb250cm9sIG1jdy10ZXh0YXJlYS1jb21wJyB9LFxuICAgICAgICAgIHdwLmVsZW1lbnQuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICdsYWJlbCcsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgdGhpcy5wcm9wcy5sYWJlbC5yZXBsYWNlKCd7e3R5cGV9fScsIGNzc1N0eWxlVHlwZXNbc3R5bGVUeXBlXSlcbiAgICAgICAgICApLFxuICAgICAgICAgIHdwLmVsZW1lbnQuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgIEJ1dHRvbkdyb3VwLFxuICAgICAgICAgICAgeyBjbGFzc05hbWU6ICdtY3ctdGV4dGFyZWEtYnV0dG9uLWdyb3VwJyB9LFxuICAgICAgICAgICAgd3AuZWxlbWVudC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICBCdXR0b24sXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdtY3ctdGV4dGFyZWEtYnRuIG1jdy10ZXh0YXJlYS1idG4tbWFyZ3JpZ2h0JyxcbiAgICAgICAgICAgICAgICBpc1NtYWxsOiB0cnVlLFxuICAgICAgICAgICAgICAgIGlzUHJpbWFyeTogdGhpcy5wcm9wcy5wYXJhbXMubWluRW5hYmxlZCxcbiAgICAgICAgICAgICAgICAnYXJpYS1wcmVzc2VkJzogdGhpcy5wcm9wcy5wYXJhbXMubWluRW5hYmxlZCxcbiAgICAgICAgICAgICAgICBvbkNsaWNrOiBmdW5jdGlvbiBvbkNsaWNrKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG9uTWluaWZ5VG9nZ2xlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB0aGlzLnByb3BzLm1pbmlmeUxhYmVsXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgT2JqZWN0LmtleXMoY3NzU3R5bGVUeXBlcykubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHdwLmVsZW1lbnQuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICBCdXR0b24sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdtY3ctdGV4dGFyZWEtYnRuJyxcbiAgICAgICAgICAgICAgICAgIGlzU21hbGw6IHRydWUsXG4gICAgICAgICAgICAgICAgICBpc1ByaW1hcnk6IHN0eWxlVHlwZSA9PT0ga2V5LFxuICAgICAgICAgICAgICAgICAgJ2FyaWEtcHJlc3NlZCc6IHN0eWxlVHlwZSA9PT0ga2V5LFxuICAgICAgICAgICAgICAgICAgb25DbGljazogZnVuY3Rpb24gb25DbGljaygpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9uU3R5bGVDaGFuZ2Uoa2V5KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNzc1N0eWxlVHlwZXNba2V5XVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICApLFxuICAgICAgICAgIHdwLmVsZW1lbnQuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICdkaXYnLFxuICAgICAgICAgICAgeyBjbGFzc05hbWU6IGNsYXNzbmFtZXMoJ21jdy10ZXh0YXJlYS1jb21wLWlubmVyJywgeyAnbWN3LXRleHRhcmVhLWNvbXAtZXJyb3InOiB0aGlzLnN0YXRlLmVyciB9KSB9LFxuICAgICAgICAgICAgd3AuZWxlbWVudC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAncCcsXG4gICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiAnbWN3LXRleHRhcmVhLWRlZicgfSxcbiAgICAgICAgICAgICAgJzxzdHlsZSB0eXBlPVwidGV4dC9jc3NcIj4nXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgd3AuZWxlbWVudC5jcmVhdGVFbGVtZW50KFRleHRhcmVhQ29udHJvbCwge1xuICAgICAgICAgICAgICByb3dzOiAxMixcbiAgICAgICAgICAgICAgdmFsdWU6IEJhc2U2NC5kZWNvZGUodGhpcy5wcm9wcy5jc3MpLFxuICAgICAgICAgICAgICBvbkNoYW5nZTogZnVuY3Rpb24gb25DaGFuZ2UodmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb25DU1NDaGFuZ2UodmFsdWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHdwLmVsZW1lbnQuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgJ3AnLFxuICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogJ21jdy10ZXh0YXJlYS1kZWYnIH0sXG4gICAgICAgICAgICAgICc8L3N0eWxlPidcbiAgICAgICAgICAgIClcbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFJhd0NTU1RleHRhcmVhQ29udHJvbDtcbn0oQ29tcG9uZW50KTtcblxuZXhwb3J0IGRlZmF1bHQgUmF3Q1NTVGV4dGFyZWFDb250cm9sO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2NvbXBvbmVudHMvcmF3LXRleHRhcmVhL3Jhdy1jc3MtdGV4dGFyZWEuanNcbi8vIG1vZHVsZSBpZCA9IDEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///12\n");

/***/ }),
/* 13 */
/*!****************************************!*\
  !*** ./node_modules/less/dist/less.js ***!
  \****************************************/
/*! dynamic exports provided */
/*! exports used: default */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, Buffer) {var require;var require;/*!\n * Less - Leaner CSS v3.9.0\n * http://lesscss.org\n *\n * Copyright (c) 2009-2018, Alexis Sellier <self@cloudhead.net>\n * Licensed under the Apache-2.0 License.\n *\n */\n\n /** * @license Apache-2.0\n */\n\n(function(f){if(true){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.less = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return require(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\nvar addDataAttr = require('./utils').addDataAttr,\n    browser = require('./browser');\n\nmodule.exports = function(window, options) {\n\n    // use options from the current script tag data attribues\n    addDataAttr(options, browser.currentScript(window));\n\n    if (options.isFileProtocol === undefined) {\n        options.isFileProtocol = /^(file|(chrome|safari)(-extension)?|resource|qrc|app):/.test(window.location.protocol);\n    }\n\n    // Load styles asynchronously (default: false)\n    //\n    // This is set to `false` by default, so that the body\n    // doesn't start loading before the stylesheets are parsed.\n    // Setting this to `true` can result in flickering.\n    //\n    options.async = options.async || false;\n    options.fileAsync = options.fileAsync || false;\n\n    // Interval between watch polls\n    options.poll = options.poll || (options.isFileProtocol ? 1000 : 1500);\n\n    options.env = options.env || (window.location.hostname == '127.0.0.1' ||\n        window.location.hostname == '0.0.0.0'   ||\n        window.location.hostname == 'localhost' ||\n        (window.location.port &&\n            window.location.port.length > 0)      ||\n        options.isFileProtocol                   ? 'development'\n        : 'production');\n\n    var dumpLineNumbers = /!dumpLineNumbers:(comments|mediaquery|all)/.exec(window.location.hash);\n    if (dumpLineNumbers) {\n        options.dumpLineNumbers = dumpLineNumbers[1];\n    }\n\n    if (options.useFileCache === undefined) {\n        options.useFileCache = true;\n    }\n\n    if (options.onReady === undefined) {\n        options.onReady = true;\n    }\n\n    if (options.relativeUrls) {\n        options.rewriteUrls = 'all';\n    }\n};\n\n},{\"./browser\":3,\"./utils\":11}],2:[function(require,module,exports){\n/**\n * Kicks off less and compiles any stylesheets\n * used in the browser distributed version of less\n * to kick-start less using the browser api\n */\n/* global window, document */\n\n// TODO - consider switching this out for a recommendation for this polyfill?\n// <script src=\"https://cdn.polyfill.io/v2/polyfill.min.js\"></script>\n// Browsers have good Promise support\nrequire('promise/polyfill');\n\nvar options = require('../less/default-options')();\n\nif (window.less) {\n    for (key in window.less) {\n        if (window.less.hasOwnProperty(key)) {\n            options[key] = window.less[key];\n        }\n    }\n}\nrequire('./add-default-options')(window, options);\n\noptions.plugins = options.plugins || [];\n\nif (window.LESS_PLUGINS) {\n    options.plugins = options.plugins.concat(window.LESS_PLUGINS);\n}\n\nvar less = module.exports = require('./index')(window, options);\n\nwindow.less = less;\n\nvar css, head, style;\n\n// Always restore page visibility\nfunction resolveOrReject(data) {\n    if (data.filename) {\n        console.warn(data);\n    }\n    if (!options.async) {\n        head.removeChild(style);\n    }\n}\n\nif (options.onReady) {\n    if (/!watch/.test(window.location.hash)) {\n        less.watch();\n    }\n    // Simulate synchronous stylesheet loading by hiding page rendering\n    if (!options.async) {\n        css = 'body { display: none !important }';\n        head = document.head || document.getElementsByTagName('head')[0];\n        style = document.createElement('style');\n\n        style.type = 'text/css';\n        if (style.styleSheet) {\n            style.styleSheet.cssText = css;\n        } else {\n            style.appendChild(document.createTextNode(css));\n        }\n\n        head.appendChild(style);\n    }\n    less.registerStylesheetsImmediately();\n    less.pageLoadFinished = less.refresh(less.env === 'development').then(resolveOrReject, resolveOrReject);\n}\n\n},{\"../less/default-options\":17,\"./add-default-options\":1,\"./index\":8,\"promise/polyfill\":104}],3:[function(require,module,exports){\nvar utils = require('./utils');\nmodule.exports = {\n    createCSS: function (document, styles, sheet) {\n        // Strip the query-string\n        var href = sheet.href || '';\n\n        // If there is no title set, use the filename, minus the extension\n        var id = 'less:' + (sheet.title || utils.extractId(href));\n\n        // If this has already been inserted into the DOM, we may need to replace it\n        var oldStyleNode = document.getElementById(id);\n        var keepOldStyleNode = false;\n\n        // Create a new stylesheet node for insertion or (if necessary) replacement\n        var styleNode = document.createElement('style');\n        styleNode.setAttribute('type', 'text/css');\n        if (sheet.media) {\n            styleNode.setAttribute('media', sheet.media);\n        }\n        styleNode.id = id;\n\n        if (!styleNode.styleSheet) {\n            styleNode.appendChild(document.createTextNode(styles));\n\n            // If new contents match contents of oldStyleNode, don't replace oldStyleNode\n            keepOldStyleNode = (oldStyleNode !== null && oldStyleNode.childNodes.length > 0 && styleNode.childNodes.length > 0 &&\n                oldStyleNode.firstChild.nodeValue === styleNode.firstChild.nodeValue);\n        }\n\n        var head = document.getElementsByTagName('head')[0];\n\n        // If there is no oldStyleNode, just append; otherwise, only append if we need\n        // to replace oldStyleNode with an updated stylesheet\n        if (oldStyleNode === null || keepOldStyleNode === false) {\n            var nextEl = sheet && sheet.nextSibling || null;\n            if (nextEl) {\n                nextEl.parentNode.insertBefore(styleNode, nextEl);\n            } else {\n                head.appendChild(styleNode);\n            }\n        }\n        if (oldStyleNode && keepOldStyleNode === false) {\n            oldStyleNode.parentNode.removeChild(oldStyleNode);\n        }\n\n        // For IE.\n        // This needs to happen *after* the style element is added to the DOM, otherwise IE 7 and 8 may crash.\n        // See http://social.msdn.microsoft.com/Forums/en-US/7e081b65-878a-4c22-8e68-c10d39c2ed32/internet-explorer-crashes-appending-style-element-to-head\n        if (styleNode.styleSheet) {\n            try {\n                styleNode.styleSheet.cssText = styles;\n            } catch (e) {\n                throw new Error('Couldn\\'t reassign styleSheet.cssText.');\n            }\n        }\n    },\n    currentScript: function(window) {\n        var document = window.document;\n        return document.currentScript || (function() {\n            var scripts = document.getElementsByTagName('script');\n            return scripts[scripts.length - 1];\n        })();\n    }\n};\n\n},{\"./utils\":11}],4:[function(require,module,exports){\n// Cache system is a bit outdated and could do with work\n\nmodule.exports = function(window, options, logger) {\n    var cache = null;\n    if (options.env !== 'development') {\n        try {\n            cache = (typeof window.localStorage === 'undefined') ? null : window.localStorage;\n        } catch (_) {}\n    }\n    return {\n        setCSS: function(path, lastModified, modifyVars, styles) {\n            if (cache) {\n                logger.info('saving ' + path + ' to cache.');\n                try {\n                    cache.setItem(path, styles);\n                    cache.setItem(path + ':timestamp', lastModified);\n                    if (modifyVars) {\n                        cache.setItem(path + ':vars', JSON.stringify(modifyVars));\n                    }\n                } catch (e) {\n                    // TODO - could do with adding more robust error handling\n                    logger.error('failed to save \"' + path + '\" to local storage for caching.');\n                }\n            }\n        },\n        getCSS: function(path, webInfo, modifyVars) {\n            var css       = cache && cache.getItem(path),\n                timestamp = cache && cache.getItem(path + ':timestamp'),\n                vars      = cache && cache.getItem(path + ':vars');\n\n            modifyVars = modifyVars || {};\n            vars = vars || \"{}\"; // if not set, treat as the JSON representation of an empty object\n\n            if (timestamp && webInfo.lastModified &&\n                (new Date(webInfo.lastModified).valueOf() ===\n                    new Date(timestamp).valueOf()) &&\n                JSON.stringify(modifyVars) === vars) {\n                // Use local copy\n                return css;\n            }\n        }\n    };\n};\n\n},{}],5:[function(require,module,exports){\nvar utils = require('./utils'),\n    browser = require('./browser');\n\nmodule.exports = function(window, less, options) {\n\n    function errorHTML(e, rootHref) {\n        var id = 'less-error-message:' + utils.extractId(rootHref || '');\n        var template = '<li><label>{line}</label><pre class=\"{class}\">{content}</pre></li>';\n        var elem = window.document.createElement('div'), timer, content, errors = [];\n        var filename = e.filename || rootHref;\n        var filenameNoPath = filename.match(/([^\\/]+(\\?.*)?)$/)[1];\n\n        elem.id        = id;\n        elem.className = 'less-error-message';\n\n        content = '<h3>'  + (e.type || 'Syntax') + 'Error: ' + (e.message || 'There is an error in your .less file') +\n            '</h3>' + '<p>in <a href=\"' + filename   + '\">' + filenameNoPath + '</a> ';\n\n        var errorline = function (e, i, classname) {\n            if (e.extract[i] !== undefined) {\n                errors.push(template.replace(/\\{line\\}/, (parseInt(e.line, 10) || 0) + (i - 1))\n                    .replace(/\\{class\\}/, classname)\n                    .replace(/\\{content\\}/, e.extract[i]));\n            }\n        };\n\n        if (e.line) {\n            errorline(e, 0, '');\n            errorline(e, 1, 'line');\n            errorline(e, 2, '');\n            content += 'on line ' + e.line + ', column ' + (e.column + 1) + ':</p>' +\n                '<ul>' + errors.join('') + '</ul>';\n        }\n        if (e.stack && (e.extract || options.logLevel >= 4)) {\n            content += '<br/>Stack Trace</br />' + e.stack.split('\\n').slice(1).join('<br/>');\n        }\n        elem.innerHTML = content;\n\n        // CSS for error messages\n        browser.createCSS(window.document, [\n            '.less-error-message ul, .less-error-message li {',\n            'list-style-type: none;',\n            'margin-right: 15px;',\n            'padding: 4px 0;',\n            'margin: 0;',\n            '}',\n            '.less-error-message label {',\n            'font-size: 12px;',\n            'margin-right: 15px;',\n            'padding: 4px 0;',\n            'color: #cc7777;',\n            '}',\n            '.less-error-message pre {',\n            'color: #dd6666;',\n            'padding: 4px 0;',\n            'margin: 0;',\n            'display: inline-block;',\n            '}',\n            '.less-error-message pre.line {',\n            'color: #ff0000;',\n            '}',\n            '.less-error-message h3 {',\n            'font-size: 20px;',\n            'font-weight: bold;',\n            'padding: 15px 0 5px 0;',\n            'margin: 0;',\n            '}',\n            '.less-error-message a {',\n            'color: #10a',\n            '}',\n            '.less-error-message .error {',\n            'color: red;',\n            'font-weight: bold;',\n            'padding-bottom: 2px;',\n            'border-bottom: 1px dashed red;',\n            '}'\n        ].join('\\n'), { title: 'error-message' });\n\n        elem.style.cssText = [\n            'font-family: Arial, sans-serif',\n            'border: 1px solid #e00',\n            'background-color: #eee',\n            'border-radius: 5px',\n            '-webkit-border-radius: 5px',\n            '-moz-border-radius: 5px',\n            'color: #e00',\n            'padding: 15px',\n            'margin-bottom: 15px'\n        ].join(';');\n\n        if (options.env === 'development') {\n            timer = setInterval(function () {\n                var document = window.document,\n                    body = document.body;\n                if (body) {\n                    if (document.getElementById(id)) {\n                        body.replaceChild(elem, document.getElementById(id));\n                    } else {\n                        body.insertBefore(elem, body.firstChild);\n                    }\n                    clearInterval(timer);\n                }\n            }, 10);\n        }\n    }\n\n    function removeErrorHTML(path) {\n        var node = window.document.getElementById('less-error-message:' + utils.extractId(path));\n        if (node) {\n            node.parentNode.removeChild(node);\n        }\n    }\n\n    function removeErrorConsole(path) {\n        // no action\n    }\n\n    function removeError(path) {\n        if (!options.errorReporting || options.errorReporting === 'html') {\n            removeErrorHTML(path);\n        } else if (options.errorReporting === 'console') {\n            removeErrorConsole(path);\n        } else if (typeof options.errorReporting === 'function') {\n            options.errorReporting('remove', path);\n        }\n    }\n\n    function errorConsole(e, rootHref) {\n        var template = '{line} {content}';\n        var filename = e.filename || rootHref;\n        var errors = [];\n        var content = (e.type || 'Syntax') + 'Error: ' + (e.message || 'There is an error in your .less file') +\n            ' in ' + filename;\n\n        var errorline = function (e, i, classname) {\n            if (e.extract[i] !== undefined) {\n                errors.push(template.replace(/\\{line\\}/, (parseInt(e.line, 10) || 0) + (i - 1))\n                    .replace(/\\{class\\}/, classname)\n                    .replace(/\\{content\\}/, e.extract[i]));\n            }\n        };\n\n        if (e.line) {\n            errorline(e, 0, '');\n            errorline(e, 1, 'line');\n            errorline(e, 2, '');\n            content += ' on line ' + e.line + ', column ' + (e.column + 1) + ':\\n' +\n                errors.join('\\n');\n        }\n        if (e.stack && (e.extract || options.logLevel >= 4)) {\n            content += '\\nStack Trace\\n' + e.stack;\n        }\n        less.logger.error(content);\n    }\n\n    function error(e, rootHref) {\n        if (!options.errorReporting || options.errorReporting === 'html') {\n            errorHTML(e, rootHref);\n        } else if (options.errorReporting === 'console') {\n            errorConsole(e, rootHref);\n        } else if (typeof options.errorReporting === 'function') {\n            options.errorReporting('add', e, rootHref);\n        }\n    }\n\n    return {\n        add: error,\n        remove: removeError\n    };\n};\n\n},{\"./browser\":3,\"./utils\":11}],6:[function(require,module,exports){\n/* global window, XMLHttpRequest */\n\nmodule.exports = function(options, logger) {\n\n    var AbstractFileManager = require('../less/environment/abstract-file-manager.js');\n\n    var fileCache = {};\n\n    // TODOS - move log somewhere. pathDiff and doing something similar in node. use pathDiff in the other browser file for the initial load\n    var FileManager = function() {\n    };\n\n    FileManager.prototype = new AbstractFileManager();\n\n    FileManager.prototype.alwaysMakePathsAbsolute = function alwaysMakePathsAbsolute() {\n        return true;\n    };\n    FileManager.prototype.join = function join(basePath, laterPath) {\n        if (!basePath) {\n            return laterPath;\n        }\n        return this.extractUrlParts(laterPath, basePath).path;\n    };\n    FileManager.prototype.doXHR = function doXHR(url, type, callback, errback) {\n\n        var xhr = new XMLHttpRequest();\n        var async = options.isFileProtocol ? options.fileAsync : true;\n\n        if (typeof xhr.overrideMimeType === 'function') {\n            xhr.overrideMimeType('text/css');\n        }\n        logger.debug('XHR: Getting \\'' + url + '\\'');\n        xhr.open('GET', url, async);\n        xhr.setRequestHeader('Accept', type || 'text/x-less, text/css; q=0.9, */*; q=0.5');\n        xhr.send(null);\n\n        function handleResponse(xhr, callback, errback) {\n            if (xhr.status >= 200 && xhr.status < 300) {\n                callback(xhr.responseText,\n                    xhr.getResponseHeader('Last-Modified'));\n            } else if (typeof errback === 'function') {\n                errback(xhr.status, url);\n            }\n        }\n\n        if (options.isFileProtocol && !options.fileAsync) {\n            if (xhr.status === 0 || (xhr.status >= 200 && xhr.status < 300)) {\n                callback(xhr.responseText);\n            } else {\n                errback(xhr.status, url);\n            }\n        } else if (async) {\n            xhr.onreadystatechange = function () {\n                if (xhr.readyState == 4) {\n                    handleResponse(xhr, callback, errback);\n                }\n            };\n        } else {\n            handleResponse(xhr, callback, errback);\n        }\n    };\n    FileManager.prototype.supports = function(filename, currentDirectory, options, environment) {\n        return true;\n    };\n\n    FileManager.prototype.clearFileCache = function() {\n        fileCache = {};\n    };\n\n    FileManager.prototype.loadFile = function loadFile(filename, currentDirectory, options, environment) {\n        // TODO: Add prefix support like less-node?\n        // What about multiple paths?\n\n        if (currentDirectory && !this.isPathAbsolute(filename)) {\n            filename = currentDirectory + filename;\n        }\n\n        filename = options.ext ? this.tryAppendExtension(filename, options.ext) : filename;\n\n        options = options || {};\n\n        // sheet may be set to the stylesheet for the initial load or a collection of properties including\n        // some context variables for imports\n        var hrefParts = this.extractUrlParts(filename, window.location.href);\n        var href      = hrefParts.url;\n        var self      = this;\n        \n        return new Promise(function(resolve, reject) {\n            if (options.useFileCache && fileCache[href]) {\n                try {\n                    var lessText = fileCache[href];\n                    return resolve({ contents: lessText, filename: href, webInfo: { lastModified: new Date() }});\n                } catch (e) {\n                    return reject({ filename: href, message: 'Error loading file ' + href + ' error was ' + e.message });\n                }\n            }\n\n            self.doXHR(href, options.mime, function doXHRCallback(data, lastModified) {\n                // per file cache\n                fileCache[href] = data;\n\n                // Use remote copy (re-parse)\n                resolve({ contents: data, filename: href, webInfo: { lastModified: lastModified }});\n            }, function doXHRError(status, url) {\n                reject({ type: 'File', message: '\\'' + url + '\\' wasn\\'t found (' + status + ')', href: href });\n            });\n        });\n    };\n\n    return FileManager;\n};\n\n},{\"../less/environment/abstract-file-manager.js\":18}],7:[function(require,module,exports){\nmodule.exports = function() {\n\n    var functionRegistry = require('./../less/functions/function-registry');\n\n    function imageSize() {\n        throw {\n            type: 'Runtime',\n            message: 'Image size functions are not supported in browser version of less'\n        };\n    }\n\n    var imageFunctions = {\n        'image-size': function(filePathNode) {\n            imageSize(this, filePathNode);\n            return -1;\n        },\n        'image-width': function(filePathNode) {\n            imageSize(this, filePathNode);\n            return -1;\n        },\n        'image-height': function(filePathNode) {\n            imageSize(this, filePathNode);\n            return -1;\n        }\n    };\n\n    functionRegistry.addMultiple(imageFunctions);\n};\n\n},{\"./../less/functions/function-registry\":27}],8:[function(require,module,exports){\n//\n// index.js\n// Should expose the additional browser functions on to the less object\n//\nvar addDataAttr = require('./utils').addDataAttr,\n    browser = require('./browser');\n\nmodule.exports = function(window, options) {\n    var document = window.document;\n    var less = require('../less')();\n    \n    less.options = options;\n    var environment = less.environment,\n        FileManager = require('./file-manager')(options, less.logger),\n        fileManager = new FileManager();\n    environment.addFileManager(fileManager);\n    less.FileManager = FileManager;\n    less.PluginLoader = require('./plugin-loader');\n\n    require('./log-listener')(less, options);\n    var errors = require('./error-reporting')(window, less, options);\n    var cache = less.cache = options.cache || require('./cache')(window, options, less.logger);\n    require('./image-size')(less.environment);\n\n    // Setup user functions - Deprecate?\n    if (options.functions) {\n        less.functions.functionRegistry.addMultiple(options.functions);\n    }\n\n    var typePattern = /^text\\/(x-)?less$/;\n\n    function clone(obj) {\n        var cloned = {};\n        for (var prop in obj) {\n            if (obj.hasOwnProperty(prop)) {\n                cloned[prop] = obj[prop];\n            }\n        }\n        return cloned;\n    }\n\n    // only really needed for phantom\n    function bind(func, thisArg) {\n        var curryArgs = Array.prototype.slice.call(arguments, 2);\n        return function() {\n            var args = curryArgs.concat(Array.prototype.slice.call(arguments, 0));\n            return func.apply(thisArg, args);\n        };\n    }\n\n    function loadStyles(modifyVars) {\n        var styles = document.getElementsByTagName('style'),\n            style;\n\n        for (var i = 0; i < styles.length; i++) {\n            style = styles[i];\n            if (style.type.match(typePattern)) {\n                var instanceOptions = clone(options);\n                instanceOptions.modifyVars = modifyVars;\n                var lessText = style.innerHTML || '';\n                instanceOptions.filename = document.location.href.replace(/#.*$/, '');\n\n                /* jshint loopfunc:true */\n                // use closure to store current style\n                less.render(lessText, instanceOptions,\n                        bind(function(style, e, result) {\n                            if (e) {\n                                errors.add(e, 'inline');\n                            } else {\n                                style.type = 'text/css';\n                                if (style.styleSheet) {\n                                    style.styleSheet.cssText = result.css;\n                                } else {\n                                    style.innerHTML = result.css;\n                                }\n                            }\n                        }, null, style));\n            }\n        }\n    }\n\n    function loadStyleSheet(sheet, callback, reload, remaining, modifyVars) {\n\n        var instanceOptions = clone(options);\n        addDataAttr(instanceOptions, sheet);\n        instanceOptions.mime = sheet.type;\n\n        if (modifyVars) {\n            instanceOptions.modifyVars = modifyVars;\n        }\n\n        function loadInitialFileCallback(loadedFile) {\n\n            var data = loadedFile.contents,\n                path = loadedFile.filename,\n                webInfo = loadedFile.webInfo;\n\n            var newFileInfo = {\n                currentDirectory: fileManager.getPath(path),\n                filename: path,\n                rootFilename: path,\n                rewriteUrls: instanceOptions.rewriteUrls\n            };\n\n            newFileInfo.entryPath = newFileInfo.currentDirectory;\n            newFileInfo.rootpath = instanceOptions.rootpath || newFileInfo.currentDirectory;\n\n            if (webInfo) {\n                webInfo.remaining = remaining;\n\n                var css = cache.getCSS(path, webInfo, instanceOptions.modifyVars);\n                if (!reload && css) {\n                    webInfo.local = true;\n                    callback(null, css, data, sheet, webInfo, path);\n                    return;\n                }\n\n            }\n\n            // TODO add tests around how this behaves when reloading\n            errors.remove(path);\n\n            instanceOptions.rootFileInfo = newFileInfo;\n            less.render(data, instanceOptions, function(e, result) {\n                if (e) {\n                    e.href = path;\n                    callback(e);\n                } else {\n                    cache.setCSS(sheet.href, webInfo.lastModified, instanceOptions.modifyVars, result.css);\n                    callback(null, result.css, data, sheet, webInfo, path);\n                }\n            });\n        }\n\n        fileManager.loadFile(sheet.href, null, instanceOptions, environment)\n            .then(function(loadedFile) {\n                loadInitialFileCallback(loadedFile);\n            }).catch(function(err) {\n                console.log(err);\n                callback(err);\n            });\n\n    }\n\n    function loadStyleSheets(callback, reload, modifyVars) {\n        for (var i = 0; i < less.sheets.length; i++) {\n            loadStyleSheet(less.sheets[i], callback, reload, less.sheets.length - (i + 1), modifyVars);\n        }\n    }\n\n    function initRunningMode() {\n        if (less.env === 'development') {\n            less.watchTimer = setInterval(function () {\n                if (less.watchMode) {\n                    fileManager.clearFileCache();\n                    loadStyleSheets(function (e, css, _, sheet, webInfo) {\n                        if (e) {\n                            errors.add(e, e.href || sheet.href);\n                        } else if (css) {\n                            browser.createCSS(window.document, css, sheet);\n                        }\n                    });\n                }\n            }, options.poll);\n        }\n    }\n\n    //\n    // Watch mode\n    //\n    less.watch   = function () {\n        if (!less.watchMode ) {\n            less.env = 'development';\n            initRunningMode();\n        }\n        this.watchMode = true;\n        return true;\n    };\n\n    less.unwatch = function () {clearInterval(less.watchTimer); this.watchMode = false; return false; };\n\n    //\n    // Synchronously get all <link> tags with the 'rel' attribute set to\n    // \"stylesheet/less\".\n    //\n    less.registerStylesheetsImmediately = function() {\n        var links = document.getElementsByTagName('link');\n        less.sheets = [];\n\n        for (var i = 0; i < links.length; i++) {\n            if (links[i].rel === 'stylesheet/less' || (links[i].rel.match(/stylesheet/) &&\n                (links[i].type.match(typePattern)))) {\n                less.sheets.push(links[i]);\n            }\n        }\n    };\n\n    //\n    // Asynchronously get all <link> tags with the 'rel' attribute set to\n    // \"stylesheet/less\", returning a Promise.\n    //\n    less.registerStylesheets = function() {\n        return new Promise(function(resolve, reject) {\n            less.registerStylesheetsImmediately();\n            resolve();\n        });\n    };\n\n    //\n    // With this function, it's possible to alter variables and re-render\n    // CSS without reloading less-files\n    //\n    less.modifyVars = function(record) {\n        return less.refresh(true, record, false);\n    };\n\n    less.refresh = function (reload, modifyVars, clearFileCache) {\n        if ((reload || clearFileCache) && clearFileCache !== false) {\n            fileManager.clearFileCache();\n        }\n        return new Promise(function (resolve, reject) {\n            var startTime, endTime, totalMilliseconds, remainingSheets;\n            startTime = endTime = new Date();\n\n            // Set counter for remaining unprocessed sheets\n            remainingSheets = less.sheets.length;\n\n            if (remainingSheets === 0) {\n\n                endTime = new Date();\n                totalMilliseconds = endTime - startTime;\n                less.logger.info('Less has finished and no sheets were loaded.');\n                resolve({\n                    startTime: startTime,\n                    endTime: endTime,\n                    totalMilliseconds: totalMilliseconds,\n                    sheets: less.sheets.length\n                });\n\n            } else {\n                // Relies on less.sheets array, callback seems to be guaranteed to be called for every element of the array\n                loadStyleSheets(function (e, css, _, sheet, webInfo) {\n                    if (e) {\n                        errors.add(e, e.href || sheet.href);\n                        reject(e);\n                        return;\n                    }\n                    if (webInfo.local) {\n                        less.logger.info('Loading ' + sheet.href + ' from cache.');\n                    } else {\n                        less.logger.info('Rendered ' + sheet.href + ' successfully.');\n                    }\n                    browser.createCSS(window.document, css, sheet);\n                    less.logger.info('CSS for ' + sheet.href + ' generated in ' + (new Date() - endTime) + 'ms');\n\n                    // Count completed sheet\n                    remainingSheets--;\n\n                    // Check if the last remaining sheet was processed and then call the promise\n                    if (remainingSheets === 0) {\n                        totalMilliseconds = new Date() - startTime;\n                        less.logger.info('Less has finished. CSS generated in ' + totalMilliseconds + 'ms');\n                        resolve({\n                            startTime: startTime,\n                            endTime: endTime,\n                            totalMilliseconds: totalMilliseconds,\n                            sheets: less.sheets.length\n                        });\n                    }\n                    endTime = new Date();\n                }, reload, modifyVars);\n            }\n\n            loadStyles(modifyVars);\n        });\n    };\n\n    less.refreshStyles = loadStyles;\n    return less;\n};\n\n},{\"../less\":37,\"./browser\":3,\"./cache\":4,\"./error-reporting\":5,\"./file-manager\":6,\"./image-size\":7,\"./log-listener\":9,\"./plugin-loader\":10,\"./utils\":11}],9:[function(require,module,exports){\nmodule.exports = function(less, options) {\n\n    var logLevel_debug = 4,\n        logLevel_info = 3,\n        logLevel_warn = 2,\n        logLevel_error = 1;\n\n    // The amount of logging in the javascript console.\n    // 3 - Debug, information and errors\n    // 2 - Information and errors\n    // 1 - Errors\n    // 0 - None\n    // Defaults to 2\n    options.logLevel = typeof options.logLevel !== 'undefined' ? options.logLevel : (options.env === 'development' ?  logLevel_info : logLevel_error);\n\n    if (!options.loggers) {\n        options.loggers = [{\n            debug: function(msg) {\n                if (options.logLevel >= logLevel_debug) {\n                    console.log(msg);\n                }\n            },\n            info: function(msg) {\n                if (options.logLevel >= logLevel_info) {\n                    console.log(msg);\n                }\n            },\n            warn: function(msg) {\n                if (options.logLevel >= logLevel_warn) {\n                    console.warn(msg);\n                }\n            },\n            error: function(msg) {\n                if (options.logLevel >= logLevel_error) {\n                    console.error(msg);\n                }\n            }\n        }];\n    }\n    for (var i = 0; i < options.loggers.length; i++) {\n        less.logger.addListener(options.loggers[i]);\n    }\n};\n\n},{}],10:[function(require,module,exports){\n// TODO: Add tests for browser @plugin\n/* global window */\n\nvar AbstractPluginLoader = require('../less/environment/abstract-plugin-loader.js');\n\n/**\n * Browser Plugin Loader\n */\nvar PluginLoader = function(less) {\n    this.less = less;\n    // Should we shim this.require for browser? Probably not?\n};\n\nPluginLoader.prototype = new AbstractPluginLoader();\n\nPluginLoader.prototype.loadPlugin = function(filename, basePath, context, environment, fileManager) {\n    return new Promise(function(fulfill, reject) {\n        fileManager.loadFile(filename, basePath, context, environment)\n            .then(fulfill).catch(reject);\n    });\n};\n\nmodule.exports = PluginLoader;\n\n\n},{\"../less/environment/abstract-plugin-loader.js\":19}],11:[function(require,module,exports){\nmodule.exports = {\n    extractId: function(href) {\n        return href.replace(/^[a-z-]+:\\/+?[^\\/]+/, '')  // Remove protocol & domain\n            .replace(/[\\?\\&]livereload=\\w+/, '')        // Remove LiveReload cachebuster\n            .replace(/^\\//, '')                         // Remove root /\n            .replace(/\\.[a-zA-Z]+$/, '')                // Remove simple extension\n            .replace(/[^\\.\\w-]+/g, '-')                 // Replace illegal characters\n            .replace(/\\./g, ':');                       // Replace dots with colons(for valid id)\n    },\n    addDataAttr: function(options, tag) {\n        for (var opt in tag.dataset) {\n            if (tag.dataset.hasOwnProperty(opt)) {\n                if (opt === 'env' || opt === 'dumpLineNumbers' || opt === 'rootpath' || opt === 'errorReporting') {\n                    options[opt] = tag.dataset[opt];\n                } else {\n                    try {\n                        options[opt] = JSON.parse(tag.dataset[opt]);\n                    }\n                    catch (_) {}\n                }\n            }\n        }\n    }\n};\n\n},{}],12:[function(require,module,exports){\nmodule.exports = {\n    Math: {\n        ALWAYS: 0,\n        PARENS_DIVISION: 1,\n        PARENS: 2,\n        STRICT_LEGACY: 3\n    },\n    RewriteUrls: {\n        OFF: 0,\n        LOCAL: 1,\n        ALL: 2\n    }\n};\n},{}],13:[function(require,module,exports){\nvar contexts = {};\nmodule.exports = contexts;\nvar Constants = require('./constants');\n\nvar copyFromOriginal = function copyFromOriginal(original, destination, propertiesToCopy) {\n    if (!original) { return; }\n\n    for (var i = 0; i < propertiesToCopy.length; i++) {\n        if (original.hasOwnProperty(propertiesToCopy[i])) {\n            destination[propertiesToCopy[i]] = original[propertiesToCopy[i]];\n        }\n    }\n};\n\n/*\n parse is used whilst parsing\n */\nvar parseCopyProperties = [\n    // options\n    'paths',            // option - unmodified - paths to search for imports on\n    'rewriteUrls',      // option - whether to adjust URL's to be relative\n    'rootpath',         // option - rootpath to append to URL's\n    'strictImports',    // option -\n    'insecure',         // option - whether to allow imports from insecure ssl hosts\n    'dumpLineNumbers',  // option - whether to dump line numbers\n    'compress',         // option - whether to compress\n    'syncImport',       // option - whether to import synchronously\n    'chunkInput',       // option - whether to chunk input. more performant but causes parse issues.\n    'mime',             // browser only - mime type for sheet import\n    'useFileCache',     // browser only - whether to use the per file session cache\n    // context\n    'processImports',   // option & context - whether to process imports. if false then imports will not be imported.\n                        // Used by the import manager to stop multiple import visitors being created.\n    'pluginManager'     // Used as the plugin manager for the session\n];\n\ncontexts.Parse = function(options) {\n    copyFromOriginal(options, this, parseCopyProperties);\n\n    if (typeof this.paths === 'string') { this.paths = [this.paths]; }\n};\n\nvar evalCopyProperties = [\n    'paths',             // additional include paths\n    'compress',          // whether to compress\n    'ieCompat',          // whether to enforce IE compatibility (IE8 data-uri)\n    'math',              // whether math has to be within parenthesis\n    'strictUnits',       // whether units need to evaluate correctly\n    'sourceMap',         // whether to output a source map\n    'importMultiple',    // whether we are currently importing multiple copies\n    'urlArgs',           // whether to add args into url tokens\n    'javascriptEnabled', // option - whether Inline JavaScript is enabled. if undefined, defaults to false\n    'pluginManager',     // Used as the plugin manager for the session\n    'importantScope',    // used to bubble up !important statements\n    'rewriteUrls'        // option - whether to adjust URL's to be relative\n];\n\ncontexts.Eval = function(options, frames) {\n    copyFromOriginal(options, this, evalCopyProperties);\n\n    if (typeof this.paths === 'string') { this.paths = [this.paths]; }\n\n    this.frames = frames || [];\n    this.importantScope = this.importantScope || [];\n};\n\ncontexts.Eval.prototype.enterCalc = function () {\n    if (!this.calcStack) {\n        this.calcStack = [];\n    }\n    this.calcStack.push(true);\n    this.inCalc = true;\n};\n\ncontexts.Eval.prototype.exitCalc = function () {\n    this.calcStack.pop();\n    if (!this.calcStack) {\n        this.inCalc = false;\n    }\n};\n\ncontexts.Eval.prototype.inParenthesis = function () {\n    if (!this.parensStack) {\n        this.parensStack = [];\n    }\n    this.parensStack.push(true);\n};\n\ncontexts.Eval.prototype.outOfParenthesis = function () {\n    this.parensStack.pop();\n};\n\ncontexts.Eval.prototype.inCalc = false;\ncontexts.Eval.prototype.mathOn = true;\ncontexts.Eval.prototype.isMathOn = function (op) {\n    if (!this.mathOn) {\n        return false;\n    }\n    if (op === '/' && this.math !== Constants.Math.ALWAYS && (!this.parensStack || !this.parensStack.length)) {\n        return false;\n    }\n    if (this.math > Constants.Math.PARENS_DIVISION) {\n        return this.parensStack && this.parensStack.length;\n    }\n    return true;\n};\n\ncontexts.Eval.prototype.pathRequiresRewrite = function (path) {\n    var isRelative = this.rewriteUrls === Constants.RewriteUrls.LOCAL ? isPathLocalRelative : isPathRelative;\n\n    return isRelative(path);\n};\n\ncontexts.Eval.prototype.rewritePath = function (path, rootpath) {\n    var newPath;\n\n    rootpath = rootpath ||'';\n    newPath = this.normalizePath(rootpath + path);\n\n    // If a path was explicit relative and the rootpath was not an absolute path\n    // we must ensure that the new path is also explicit relative.\n    if (isPathLocalRelative(path) &&\n        isPathRelative(rootpath) &&\n        isPathLocalRelative(newPath) === false) {\n        newPath = './' + newPath;\n    }\n\n    return newPath;\n};\n\ncontexts.Eval.prototype.normalizePath = function (path) {\n    var\n        segments = path.split('/').reverse(),\n        segment;\n\n    path = [];\n    while (segments.length !== 0) {\n        segment = segments.pop();\n        switch ( segment ) {\n            case '.':\n                break;\n            case '..':\n                if ((path.length === 0) || (path[path.length - 1] === '..')) {\n                    path.push( segment );\n                } else {\n                    path.pop();\n                }\n                break;\n            default:\n                path.push(segment);\n                break;\n        }\n    }\n\n    return path.join('/');\n};\n\nfunction isPathRelative(path) {\n    return !/^(?:[a-z-]+:|\\/|#)/i.test(path);\n}\n\nfunction isPathLocalRelative(path) {\n    return path.charAt(0) === '.';\n}\n\n// todo - do the same for the toCSS ?\n\n},{\"./constants\":12}],14:[function(require,module,exports){\nmodule.exports = {\n    'aliceblue':'#f0f8ff',\n    'antiquewhite':'#faebd7',\n    'aqua':'#00ffff',\n    'aquamarine':'#7fffd4',\n    'azure':'#f0ffff',\n    'beige':'#f5f5dc',\n    'bisque':'#ffe4c4',\n    'black':'#000000',\n    'blanchedalmond':'#ffebcd',\n    'blue':'#0000ff',\n    'blueviolet':'#8a2be2',\n    'brown':'#a52a2a',\n    'burlywood':'#deb887',\n    'cadetblue':'#5f9ea0',\n    'chartreuse':'#7fff00',\n    'chocolate':'#d2691e',\n    'coral':'#ff7f50',\n    'cornflowerblue':'#6495ed',\n    'cornsilk':'#fff8dc',\n    'crimson':'#dc143c',\n    'cyan':'#00ffff',\n    'darkblue':'#00008b',\n    'darkcyan':'#008b8b',\n    'darkgoldenrod':'#b8860b',\n    'darkgray':'#a9a9a9',\n    'darkgrey':'#a9a9a9',\n    'darkgreen':'#006400',\n    'darkkhaki':'#bdb76b',\n    'darkmagenta':'#8b008b',\n    'darkolivegreen':'#556b2f',\n    'darkorange':'#ff8c00',\n    'darkorchid':'#9932cc',\n    'darkred':'#8b0000',\n    'darksalmon':'#e9967a',\n    'darkseagreen':'#8fbc8f',\n    'darkslateblue':'#483d8b',\n    'darkslategray':'#2f4f4f',\n    'darkslategrey':'#2f4f4f',\n    'darkturquoise':'#00ced1',\n    'darkviolet':'#9400d3',\n    'deeppink':'#ff1493',\n    'deepskyblue':'#00bfff',\n    'dimgray':'#696969',\n    'dimgrey':'#696969',\n    'dodgerblue':'#1e90ff',\n    'firebrick':'#b22222',\n    'floralwhite':'#fffaf0',\n    'forestgreen':'#228b22',\n    'fuchsia':'#ff00ff',\n    'gainsboro':'#dcdcdc',\n    'ghostwhite':'#f8f8ff',\n    'gold':'#ffd700',\n    'goldenrod':'#daa520',\n    'gray':'#808080',\n    'grey':'#808080',\n    'green':'#008000',\n    'greenyellow':'#adff2f',\n    'honeydew':'#f0fff0',\n    'hotpink':'#ff69b4',\n    'indianred':'#cd5c5c',\n    'indigo':'#4b0082',\n    'ivory':'#fffff0',\n    'khaki':'#f0e68c',\n    'lavender':'#e6e6fa',\n    'lavenderblush':'#fff0f5',\n    'lawngreen':'#7cfc00',\n    'lemonchiffon':'#fffacd',\n    'lightblue':'#add8e6',\n    'lightcoral':'#f08080',\n    'lightcyan':'#e0ffff',\n    'lightgoldenrodyellow':'#fafad2',\n    'lightgray':'#d3d3d3',\n    'lightgrey':'#d3d3d3',\n    'lightgreen':'#90ee90',\n    'lightpink':'#ffb6c1',\n    'lightsalmon':'#ffa07a',\n    'lightseagreen':'#20b2aa',\n    'lightskyblue':'#87cefa',\n    'lightslategray':'#778899',\n    'lightslategrey':'#778899',\n    'lightsteelblue':'#b0c4de',\n    'lightyellow':'#ffffe0',\n    'lime':'#00ff00',\n    'limegreen':'#32cd32',\n    'linen':'#faf0e6',\n    'magenta':'#ff00ff',\n    'maroon':'#800000',\n    'mediumaquamarine':'#66cdaa',\n    'mediumblue':'#0000cd',\n    'mediumorchid':'#ba55d3',\n    'mediumpurple':'#9370d8',\n    'mediumseagreen':'#3cb371',\n    'mediumslateblue':'#7b68ee',\n    'mediumspringgreen':'#00fa9a',\n    'mediumturquoise':'#48d1cc',\n    'mediumvioletred':'#c71585',\n    'midnightblue':'#191970',\n    'mintcream':'#f5fffa',\n    'mistyrose':'#ffe4e1',\n    'moccasin':'#ffe4b5',\n    'navajowhite':'#ffdead',\n    'navy':'#000080',\n    'oldlace':'#fdf5e6',\n    'olive':'#808000',\n    'olivedrab':'#6b8e23',\n    'orange':'#ffa500',\n    'orangered':'#ff4500',\n    'orchid':'#da70d6',\n    'palegoldenrod':'#eee8aa',\n    'palegreen':'#98fb98',\n    'paleturquoise':'#afeeee',\n    'palevioletred':'#d87093',\n    'papayawhip':'#ffefd5',\n    'peachpuff':'#ffdab9',\n    'peru':'#cd853f',\n    'pink':'#ffc0cb',\n    'plum':'#dda0dd',\n    'powderblue':'#b0e0e6',\n    'purple':'#800080',\n    'rebeccapurple':'#663399',\n    'red':'#ff0000',\n    'rosybrown':'#bc8f8f',\n    'royalblue':'#4169e1',\n    'saddlebrown':'#8b4513',\n    'salmon':'#fa8072',\n    'sandybrown':'#f4a460',\n    'seagreen':'#2e8b57',\n    'seashell':'#fff5ee',\n    'sienna':'#a0522d',\n    'silver':'#c0c0c0',\n    'skyblue':'#87ceeb',\n    'slateblue':'#6a5acd',\n    'slategray':'#708090',\n    'slategrey':'#708090',\n    'snow':'#fffafa',\n    'springgreen':'#00ff7f',\n    'steelblue':'#4682b4',\n    'tan':'#d2b48c',\n    'teal':'#008080',\n    'thistle':'#d8bfd8',\n    'tomato':'#ff6347',\n    'turquoise':'#40e0d0',\n    'violet':'#ee82ee',\n    'wheat':'#f5deb3',\n    'white':'#ffffff',\n    'whitesmoke':'#f5f5f5',\n    'yellow':'#ffff00',\n    'yellowgreen':'#9acd32'\n};\n},{}],15:[function(require,module,exports){\nmodule.exports = {\n    colors: require('./colors'),\n    unitConversions: require('./unit-conversions')\n};\n\n},{\"./colors\":14,\"./unit-conversions\":16}],16:[function(require,module,exports){\nmodule.exports = {\n    length: {\n        'm': 1,\n        'cm': 0.01,\n        'mm': 0.001,\n        'in': 0.0254,\n        'px': 0.0254 / 96,\n        'pt': 0.0254 / 72,\n        'pc': 0.0254 / 72 * 12\n    },\n    duration: {\n        's': 1,\n        'ms': 0.001\n    },\n    angle: {\n        'rad': 1 / (2 * Math.PI),\n        'deg': 1 / 360,\n        'grad': 1 / 400,\n        'turn': 1\n    }\n};\n},{}],17:[function(require,module,exports){\n// Export a new default each time\nmodule.exports = function() {\n    return {\n        /* Inline Javascript - @plugin still allowed */\n        javascriptEnabled: false,\n\n        /* Outputs a makefile import dependency list to stdout. */\n        depends: false,\n\n        /* (DEPRECATED) Compress using less built-in compression. \n         * This does an okay job but does not utilise all the tricks of \n         * dedicated css compression. */\n        compress: false,\n\n        /* Runs the less parser and just reports errors without any output. */\n        lint: false,\n\n        /* Sets available include paths.\n         * If the file in an @import rule does not exist at that exact location, \n         * less will look for it at the location(s) passed to this option. \n         * You might use this for instance to specify a path to a library which \n         * you want to be referenced simply and relatively in the less files. */\n        paths: [],\n\n        /* color output in the terminal */\n        color: true,\n\n        /* The strictImports controls whether the compiler will allow an @import inside of either \n         * @media blocks or (a later addition) other selector blocks.\n         * See: https://github.com/less/less.js/issues/656 */\n        strictImports: false,\n\n        /* Allow Imports from Insecure HTTPS Hosts */\n        insecure: false,\n\n        /* Allows you to add a path to every generated import and url in your css. \n         * This does not affect less import statements that are processed, just ones \n         * that are left in the output css. */\n        rootpath: '',\n\n        /* By default URLs are kept as-is, so if you import a file in a sub-directory \n         * that references an image, exactly the same URL will be output in the css. \n         * This option allows you to re-write URL's in imported files so that the \n         * URL is always relative to the base imported file */\n        rewriteUrls: false,\n\n        /* Compatibility with IE8. Used for limiting data-uri length */\n        ieCompat: false,  // true until 3.0\n\n        /* How to process math \n         *   0 always           - eagerly try to solve all operations\n         *   1 parens-division  - require parens for division \"/\"\n         *   2 parens | strict  - require parens for all operations\n         *   3 strict-legacy    - legacy strict behavior (super-strict)\n         */\n        math: 0,\n\n        /* Without this option, less attempts to guess at the output unit when it does maths. */\n        strictUnits: false,\n\n        /* Effectively the declaration is put at the top of your base Less file, \n         * meaning it can be used but it also can be overridden if this variable \n         * is defined in the file. */\n        globalVars: null,\n\n        /* As opposed to the global variable option, this puts the declaration at the\n         * end of your base file, meaning it will override anything defined in your Less file. */\n        modifyVars: null,\n\n        /* This option allows you to specify a argument to go on to every URL.  */\n        urlArgs: ''\n    }\n}\n},{}],18:[function(require,module,exports){\nvar abstractFileManager = function() {\n};\n\nabstractFileManager.prototype.getPath = function (filename) {\n    var j = filename.lastIndexOf('?');\n    if (j > 0) {\n        filename = filename.slice(0, j);\n    }\n    j = filename.lastIndexOf('/');\n    if (j < 0) {\n        j = filename.lastIndexOf('\\\\');\n    }\n    if (j < 0) {\n        return '';\n    }\n    return filename.slice(0, j + 1);\n};\n\nabstractFileManager.prototype.tryAppendExtension = function(path, ext) {\n    return /(\\.[a-z]*$)|([\\?;].*)$/.test(path) ? path : path + ext;\n};\n\nabstractFileManager.prototype.tryAppendLessExtension = function(path) {\n    return this.tryAppendExtension(path, '.less');\n};\n\nabstractFileManager.prototype.supportsSync = function() {\n    return false;\n};\n\nabstractFileManager.prototype.alwaysMakePathsAbsolute = function() {\n    return false;\n};\n\nabstractFileManager.prototype.isPathAbsolute = function(filename) {\n    return (/^(?:[a-z-]+:|\\/|\\\\|#)/i).test(filename);\n};\n// TODO: pull out / replace?\nabstractFileManager.prototype.join = function(basePath, laterPath) {\n    if (!basePath) {\n        return laterPath;\n    }\n    return basePath + laterPath;\n};\n\nabstractFileManager.prototype.pathDiff = function pathDiff(url, baseUrl) {\n    // diff between two paths to create a relative path\n\n    var urlParts = this.extractUrlParts(url),\n        baseUrlParts = this.extractUrlParts(baseUrl),\n        i, max, urlDirectories, baseUrlDirectories, diff = '';\n    if (urlParts.hostPart !== baseUrlParts.hostPart) {\n        return '';\n    }\n    max = Math.max(baseUrlParts.directories.length, urlParts.directories.length);\n    for (i = 0; i < max; i++) {\n        if (baseUrlParts.directories[i] !== urlParts.directories[i]) { break; }\n    }\n    baseUrlDirectories = baseUrlParts.directories.slice(i);\n    urlDirectories = urlParts.directories.slice(i);\n    for (i = 0; i < baseUrlDirectories.length - 1; i++) {\n        diff += '../';\n    }\n    for (i = 0; i < urlDirectories.length - 1; i++) {\n        diff += urlDirectories[i] + '/';\n    }\n    return diff;\n};\n// helper function, not part of API\nabstractFileManager.prototype.extractUrlParts = function extractUrlParts(url, baseUrl) {\n    // urlParts[1] = protocol://hostname/ OR /\n    // urlParts[2] = / if path relative to host base\n    // urlParts[3] = directories\n    // urlParts[4] = filename\n    // urlParts[5] = parameters\n\n    var urlPartsRegex = /^((?:[a-z-]+:)?\\/{2}(?:[^\\/\\?#]*\\/)|([\\/\\\\]))?((?:[^\\/\\\\\\?#]*[\\/\\\\])*)([^\\/\\\\\\?#]*)([#\\?].*)?$/i,\n        urlParts = url.match(urlPartsRegex),\n        returner = {}, rawDirectories = [], directories = [], i, baseUrlParts;\n\n    if (!urlParts) {\n        throw new Error('Could not parse sheet href - \\'' + url + '\\'');\n    }\n\n    // Stylesheets in IE don't always return the full path\n    if (baseUrl && (!urlParts[1] || urlParts[2])) {\n        baseUrlParts = baseUrl.match(urlPartsRegex);\n        if (!baseUrlParts) {\n            throw new Error('Could not parse page url - \\'' + baseUrl + '\\'');\n        }\n        urlParts[1] = urlParts[1] || baseUrlParts[1] || '';\n        if (!urlParts[2]) {\n            urlParts[3] = baseUrlParts[3] + urlParts[3];\n        }\n    }\n\n    if (urlParts[3]) {\n        rawDirectories = urlParts[3].replace(/\\\\/g, '/').split('/');\n\n        // collapse '..' and skip '.'\n        for (i = 0; i < rawDirectories.length; i++) {\n\n            if (rawDirectories[i] === '..') {\n                directories.pop();\n            }\n            else if (rawDirectories[i] !== '.') {\n                directories.push(rawDirectories[i]);\n            }\n        \n        }\n    }\n\n    returner.hostPart = urlParts[1];\n    returner.directories = directories;\n    returner.rawPath = (urlParts[1] || '') + rawDirectories.join('/');\n    returner.path = (urlParts[1] || '') + directories.join('/');\n    returner.filename = urlParts[4];\n    returner.fileUrl = returner.path + (urlParts[4] || '');\n    returner.url = returner.fileUrl + (urlParts[5] || '');\n    return returner;\n};\n\nmodule.exports = abstractFileManager;\n\n},{}],19:[function(require,module,exports){\nvar functionRegistry = require('../functions/function-registry'),\n    LessError = require('../less-error');\n\nvar AbstractPluginLoader = function() {\n    // Implemented by Node.js plugin loader\n    this.require = function() {\n        return null;\n    }\n};\n\nAbstractPluginLoader.prototype.evalPlugin = function(contents, context, imports, pluginOptions, fileInfo) {\n\n    var loader,\n        registry,\n        pluginObj,\n        localModule,\n        pluginManager,\n        filename,\n        result;\n\n    pluginManager = context.pluginManager;\n\n    if (fileInfo) {\n        if (typeof fileInfo === 'string') {\n            filename = fileInfo;\n        }\n        else {\n            filename = fileInfo.filename;\n        }\n    }\n    var shortname = (new this.less.FileManager()).extractUrlParts(filename).filename;\n\n    if (filename) {\n        pluginObj = pluginManager.get(filename);\n\n        if (pluginObj) {\n            result = this.trySetOptions(pluginObj, filename, shortname, pluginOptions);\n            if (result) {\n                return result;\n            }\n            try {\n                if (pluginObj.use) {\n                    pluginObj.use.call(this.context, pluginObj);\n                }\n            }\n            catch (e) {\n                e.message = e.message || 'Error during @plugin call';\n                return new LessError(e, imports, filename);\n            }\n            return pluginObj;\n        }\n    }\n    localModule = {\n        exports: {},\n        pluginManager: pluginManager,\n        fileInfo: fileInfo\n    };\n    registry = functionRegistry.create();\n\n    var registerPlugin = function(obj) {\n        pluginObj = obj;\n    };\n\n    try {\n        loader = new Function('module', 'require', 'registerPlugin', 'functions', 'tree', 'less', 'fileInfo', contents);\n        loader(localModule, this.require(filename), registerPlugin, registry, this.less.tree, this.less, fileInfo);\n    }\n    catch (e) {\n        return new LessError(e, imports, filename);\n    }\n\n    if (!pluginObj) {\n        pluginObj = localModule.exports;\n    }\n    pluginObj = this.validatePlugin(pluginObj, filename, shortname);\n\n    if (pluginObj instanceof LessError) {\n        return pluginObj;\n    }\n\n    if (pluginObj) {\n        pluginObj.imports = imports;\n        pluginObj.filename = filename;\n\n        // For < 3.x (or unspecified minVersion) - setOptions() before install()\n        if (!pluginObj.minVersion || this.compareVersion('3.0.0', pluginObj.minVersion) < 0) {\n            result = this.trySetOptions(pluginObj, filename, shortname, pluginOptions);\n\n            if (result) {\n                return result;\n            }\n        }\n\n        // Run on first load\n        pluginManager.addPlugin(pluginObj, fileInfo.filename, registry);\n        pluginObj.functions = registry.getLocalFunctions();\n\n        // Need to call setOptions again because the pluginObj might have functions\n        result = this.trySetOptions(pluginObj, filename, shortname, pluginOptions);\n        if (result) {\n            return result;\n        }\n\n        // Run every @plugin call\n        try {\n            if (pluginObj.use) {\n                pluginObj.use.call(this.context, pluginObj);\n            }\n        }\n        catch (e) {\n            e.message = e.message || 'Error during @plugin call';\n            return new LessError(e, imports, filename);\n        }\n\n    }\n    else {\n        return new LessError({ message: 'Not a valid plugin' }, imports, filename);\n    }\n\n    return pluginObj;\n\n};\n\nAbstractPluginLoader.prototype.trySetOptions = function(plugin, filename, name, options) {\n    if (options && !plugin.setOptions) {\n        return new LessError({\n            message: 'Options have been provided but the plugin ' +\n                name + ' does not support any options.'\n        });\n    }\n    try {\n        plugin.setOptions && plugin.setOptions(options);\n    }\n    catch (e) {\n        return new LessError(e);\n    }\n};\n\nAbstractPluginLoader.prototype.validatePlugin = function(plugin, filename, name) {\n    if (plugin) {\n        // support plugins being a function\n        // so that the plugin can be more usable programmatically\n        if (typeof plugin === 'function') {\n            plugin = new plugin();\n        }\n\n        if (plugin.minVersion) {\n            if (this.compareVersion(plugin.minVersion, this.less.version) < 0) {\n                return new LessError({\n                    message: 'Plugin ' + name + ' requires version ' +\n                        this.versionToString(plugin.minVersion)\n                });\n            }\n        }\n        return plugin;\n    }\n    return null;\n};\n\nAbstractPluginLoader.prototype.compareVersion = function(aVersion, bVersion) {\n    if (typeof aVersion === 'string') {\n        aVersion = aVersion.match(/^(\\d+)\\.?(\\d+)?\\.?(\\d+)?/);\n        aVersion.shift();\n    }\n    for (var i = 0; i < aVersion.length; i++) {\n        if (aVersion[i] !== bVersion[i]) {\n            return parseInt(aVersion[i]) > parseInt(bVersion[i]) ? -1 : 1;\n        }\n    }\n    return 0;\n};\nAbstractPluginLoader.prototype.versionToString = function(version) {\n    var versionString = '';\n    for (var i = 0; i < version.length; i++) {\n        versionString += (versionString ? '.' : '') + version[i];\n    }\n    return versionString;\n};\nAbstractPluginLoader.prototype.printUsage = function(plugins) {\n    for (var i = 0; i < plugins.length; i++) {\n        var plugin = plugins[i];\n        if (plugin.printUsage) {\n            plugin.printUsage();\n        }\n    }\n};\n\nmodule.exports = AbstractPluginLoader;\n\n\n},{\"../functions/function-registry\":27,\"../less-error\":38}],20:[function(require,module,exports){\n/**\n * @todo Document why this abstraction exists, and the relationship between\n *       environment, file managers, and plugin manager\n */\n\nvar logger = require('../logger');\nvar environment = function(externalEnvironment, fileManagers) {\n    this.fileManagers = fileManagers || [];\n    externalEnvironment = externalEnvironment || {};\n\n    var optionalFunctions = ['encodeBase64', 'mimeLookup', 'charsetLookup', 'getSourceMapGenerator'],\n        requiredFunctions = [],\n        functions = requiredFunctions.concat(optionalFunctions);\n\n    for (var i = 0; i < functions.length; i++) {\n        var propName = functions[i],\n            environmentFunc = externalEnvironment[propName];\n        if (environmentFunc) {\n            this[propName] = environmentFunc.bind(externalEnvironment);\n        } else if (i < requiredFunctions.length) {\n            this.warn('missing required function in environment - ' + propName);\n        }\n    }\n};\n\nenvironment.prototype.getFileManager = function (filename, currentDirectory, options, environment, isSync) {\n\n    if (!filename) {\n        logger.warn('getFileManager called with no filename.. Please report this issue. continuing.');\n    }\n    if (currentDirectory == null) {\n        logger.warn('getFileManager called with null directory.. Please report this issue. continuing.');\n    }\n\n    var fileManagers = this.fileManagers;\n    if (options.pluginManager) {\n        fileManagers = [].concat(fileManagers).concat(options.pluginManager.getFileManagers());\n    }\n    for (var i = fileManagers.length - 1; i >= 0 ; i--) {\n        var fileManager = fileManagers[i];\n        if (fileManager[isSync ? 'supportsSync' : 'supports'](filename, currentDirectory, options, environment)) {\n            return fileManager;\n        }\n    }\n    return null;\n};\n\nenvironment.prototype.addFileManager = function (fileManager) {\n    this.fileManagers.push(fileManager);\n};\n\nenvironment.prototype.clearFileManagers = function () {\n    this.fileManagers = [];\n};\n\nmodule.exports = environment;\n\n},{\"../logger\":39}],21:[function(require,module,exports){\n\nvar functionRegistry = require('./function-registry'),\n    Anonymous = require('../tree/anonymous'),\n    Keyword = require('../tree/keyword');\n\nfunctionRegistry.addMultiple({\n    boolean: function(condition) {\n        return condition ? Keyword.True : Keyword.False;\n    },\n\n    'if': function(condition, trueValue, falseValue) {\n        return condition ? trueValue\n            : (falseValue || new Anonymous);\n    }\n});\n\n},{\"../tree/anonymous\":50,\"../tree/keyword\":70,\"./function-registry\":27}],22:[function(require,module,exports){\nvar Color = require('../tree/color'),\n    functionRegistry = require('./function-registry');\n\n// Color Blending\n// ref: http://www.w3.org/TR/compositing-1\n\nfunction colorBlend(mode, color1, color2) {\n    var ab = color1.alpha, cb, // backdrop\n        as = color2.alpha, cs, // source\n        ar, cr, r = [];        // result\n\n    ar = as + ab * (1 - as);\n    for (var i = 0; i < 3; i++) {\n        cb = color1.rgb[i] / 255;\n        cs = color2.rgb[i] / 255;\n        cr = mode(cb, cs);\n        if (ar) {\n            cr = (as * cs + ab * (cb -\n                  as * (cb + cs - cr))) / ar;\n        }\n        r[i] = cr * 255;\n    }\n\n    return new Color(r, ar);\n}\n\nvar colorBlendModeFunctions = {\n    multiply: function(cb, cs) {\n        return cb * cs;\n    },\n    screen: function(cb, cs) {\n        return cb + cs - cb * cs;\n    },\n    overlay: function(cb, cs) {\n        cb *= 2;\n        return (cb <= 1) ?\n            colorBlendModeFunctions.multiply(cb, cs) :\n            colorBlendModeFunctions.screen(cb - 1, cs);\n    },\n    softlight: function(cb, cs) {\n        var d = 1, e = cb;\n        if (cs > 0.5) {\n            e = 1;\n            d = (cb > 0.25) ? Math.sqrt(cb)\n                : ((16 * cb - 12) * cb + 4) * cb;\n        }\n        return cb - (1 - 2 * cs) * e * (d - cb);\n    },\n    hardlight: function(cb, cs) {\n        return colorBlendModeFunctions.overlay(cs, cb);\n    },\n    difference: function(cb, cs) {\n        return Math.abs(cb - cs);\n    },\n    exclusion: function(cb, cs) {\n        return cb + cs - 2 * cb * cs;\n    },\n\n    // non-w3c functions:\n    average: function(cb, cs) {\n        return (cb + cs) / 2;\n    },\n    negation: function(cb, cs) {\n        return 1 - Math.abs(cb + cs - 1);\n    }\n};\n\nfor (var f in colorBlendModeFunctions) {\n    if (colorBlendModeFunctions.hasOwnProperty(f)) {\n        colorBlend[f] = colorBlend.bind(null, colorBlendModeFunctions[f]);\n    }\n}\n\nfunctionRegistry.addMultiple(colorBlend);\n\n},{\"../tree/color\":55,\"./function-registry\":27}],23:[function(require,module,exports){\nvar Dimension = require('../tree/dimension'),\n    Color = require('../tree/color'),\n    Quoted = require('../tree/quoted'),\n    Anonymous = require('../tree/anonymous'),\n    functionRegistry = require('./function-registry'),\n    colorFunctions;\n\nfunction clamp(val) {\n    return Math.min(1, Math.max(0, val));\n}\nfunction hsla(origColor, hsl) {\n    var color = colorFunctions.hsla(hsl.h, hsl.s, hsl.l, hsl.a);\n    if (color) {\n        if (origColor.value && \n            /^(rgb|hsl)/.test(origColor.value)) {\n            color.value = origColor.value;\n        } else {\n            color.value = 'rgb';\n        }\n        return color;\n    }\n}\nfunction number(n) {\n    if (n instanceof Dimension) {\n        return parseFloat(n.unit.is('%') ? n.value / 100 : n.value);\n    } else if (typeof n === 'number') {\n        return n;\n    } else {\n        throw {\n            type: 'Argument',\n            message: 'color functions take numbers as parameters'\n        };\n    }\n}\nfunction scaled(n, size) {\n    if (n instanceof Dimension && n.unit.is('%')) {\n        return parseFloat(n.value * size / 100);\n    } else {\n        return number(n);\n    }\n}\ncolorFunctions = {\n    rgb: function (r, g, b) {\n        var color = colorFunctions.rgba(r, g, b, 1.0);\n        if (color) {\n            color.value = 'rgb';\n            return color;\n        }\n    },\n    rgba: function (r, g, b, a) {\n        try {\n            if (r instanceof Color) {\n                if (g) {\n                    a = number(g);\n                } else {\n                    a = r.alpha;\n                }\n                return new Color(r.rgb, a, 'rgba');\n            }\n            var rgb = [r, g, b].map(function (c) { return scaled(c, 255); });\n            a = number(a);\n            return new Color(rgb, a, 'rgba');\n        }\n        catch (e) {}\n    },\n    hsl: function (h, s, l) {\n        var color = colorFunctions.hsla(h, s, l, 1.0);\n        if (color) {\n            color.value = 'hsl';\n            return color;\n        }\n    },\n    hsla: function (h, s, l, a) {\n        try {\n            if (h instanceof Color) {\n                if (s) {\n                    a = number(s);\n                } else {\n                    a = h.alpha;\n                }\n                return new Color(h.rgb, a, 'hsla');\n            }\n\n            var m1, m2;\n\n            function hue(h) {\n                h = h < 0 ? h + 1 : (h > 1 ? h - 1 : h);\n                if (h * 6 < 1) {\n                    return m1 + (m2 - m1) * h * 6;\n                }\n                else if (h * 2 < 1) {\n                    return m2;\n                }\n                else if (h * 3 < 2) {\n                    return m1 + (m2 - m1) * (2 / 3 - h) * 6;\n                }\n                else {\n                    return m1;\n                }\n            }\n\n            h = (number(h) % 360) / 360;\n            s = clamp(number(s)); l = clamp(number(l)); a = clamp(number(a));\n\n            m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;\n            m1 = l * 2 - m2;\n\n            var rgb = [\n                hue(h + 1 / 3) * 255,\n                hue(h)       * 255,\n                hue(h - 1 / 3) * 255\n            ];\n            a = number(a);\n            return new Color(rgb, a, 'hsla');\n        }\n        catch (e) {}\n    },\n\n    hsv: function(h, s, v) {\n        return colorFunctions.hsva(h, s, v, 1.0);\n    },\n\n    hsva: function(h, s, v, a) {\n        h = ((number(h) % 360) / 360) * 360;\n        s = number(s); v = number(v); a = number(a);\n\n        var i, f;\n        i = Math.floor((h / 60) % 6);\n        f = (h / 60) - i;\n\n        var vs = [v,\n            v * (1 - s),\n            v * (1 - f * s),\n            v * (1 - (1 - f) * s)];\n        var perm = [[0, 3, 1],\n            [2, 0, 1],\n            [1, 0, 3],\n            [1, 2, 0],\n            [3, 1, 0],\n            [0, 1, 2]];\n\n        return colorFunctions.rgba(vs[perm[i][0]] * 255,\n            vs[perm[i][1]] * 255,\n            vs[perm[i][2]] * 255,\n            a);\n    },\n\n    hue: function (color) {\n        return new Dimension(color.toHSL().h);\n    },\n    saturation: function (color) {\n        return new Dimension(color.toHSL().s * 100, '%');\n    },\n    lightness: function (color) {\n        return new Dimension(color.toHSL().l * 100, '%');\n    },\n    hsvhue: function(color) {\n        return new Dimension(color.toHSV().h);\n    },\n    hsvsaturation: function (color) {\n        return new Dimension(color.toHSV().s * 100, '%');\n    },\n    hsvvalue: function (color) {\n        return new Dimension(color.toHSV().v * 100, '%');\n    },\n    red: function (color) {\n        return new Dimension(color.rgb[0]);\n    },\n    green: function (color) {\n        return new Dimension(color.rgb[1]);\n    },\n    blue: function (color) {\n        return new Dimension(color.rgb[2]);\n    },\n    alpha: function (color) {\n        return new Dimension(color.toHSL().a);\n    },\n    luma: function (color) {\n        return new Dimension(color.luma() * color.alpha * 100, '%');\n    },\n    luminance: function (color) {\n        var luminance =\n            (0.2126 * color.rgb[0] / 255) +\n                (0.7152 * color.rgb[1] / 255) +\n                (0.0722 * color.rgb[2] / 255);\n\n        return new Dimension(luminance * color.alpha * 100, '%');\n    },\n    saturate: function (color, amount, method) {\n        // filter: saturate(3.2);\n        // should be kept as is, so check for color\n        if (!color.rgb) {\n            return null;\n        }\n        var hsl = color.toHSL();\n\n        if (typeof method !== 'undefined' && method.value === 'relative') {\n            hsl.s +=  hsl.s * amount.value / 100;\n        }\n        else {\n            hsl.s += amount.value / 100;\n        }\n        hsl.s = clamp(hsl.s);\n        return hsla(color, hsl);\n    },\n    desaturate: function (color, amount, method) {\n        var hsl = color.toHSL();\n\n        if (typeof method !== 'undefined' && method.value === 'relative') {\n            hsl.s -=  hsl.s * amount.value / 100;\n        }\n        else {\n            hsl.s -= amount.value / 100;\n        }\n        hsl.s = clamp(hsl.s);\n        return hsla(color, hsl);\n    },\n    lighten: function (color, amount, method) {\n        var hsl = color.toHSL();\n\n        if (typeof method !== 'undefined' && method.value === 'relative') {\n            hsl.l +=  hsl.l * amount.value / 100;\n        }\n        else {\n            hsl.l += amount.value / 100;\n        }\n        hsl.l = clamp(hsl.l);\n        return hsla(color, hsl);\n    },\n    darken: function (color, amount, method) {\n        var hsl = color.toHSL();\n\n        if (typeof method !== 'undefined' && method.value === 'relative') {\n            hsl.l -=  hsl.l * amount.value / 100;\n        }\n        else {\n            hsl.l -= amount.value / 100;\n        }\n        hsl.l = clamp(hsl.l);\n        return hsla(color, hsl);\n    },\n    fadein: function (color, amount, method) {\n        var hsl = color.toHSL();\n\n        if (typeof method !== 'undefined' && method.value === 'relative') {\n            hsl.a +=  hsl.a * amount.value / 100;\n        }\n        else {\n            hsl.a += amount.value / 100;\n        }\n        hsl.a = clamp(hsl.a);\n        return hsla(color, hsl);\n    },\n    fadeout: function (color, amount, method) {\n        var hsl = color.toHSL();\n\n        if (typeof method !== 'undefined' && method.value === 'relative') {\n            hsl.a -=  hsl.a * amount.value / 100;\n        }\n        else {\n            hsl.a -= amount.value / 100;\n        }\n        hsl.a = clamp(hsl.a);\n        return hsla(color, hsl);\n    },\n    fade: function (color, amount) {\n        var hsl = color.toHSL();\n\n        hsl.a = amount.value / 100;\n        hsl.a = clamp(hsl.a);\n        return hsla(color, hsl);\n    },\n    spin: function (color, amount) {\n        var hsl = color.toHSL();\n        var hue = (hsl.h + amount.value) % 360;\n\n        hsl.h = hue < 0 ? 360 + hue : hue;\n\n        return hsla(color, hsl);\n    },\n    //\n    // Copyright (c) 2006-2009 Hampton Catlin, Natalie Weizenbaum, and Chris Eppstein\n    // http://sass-lang.com\n    //\n    mix: function (color1, color2, weight) {\n        if (!color1.toHSL || !color2.toHSL) {\n            console.log(color2.type);\n            console.dir(color2);\n        }\n        if (!weight) {\n            weight = new Dimension(50);\n        }\n        var p = weight.value / 100.0;\n        var w = p * 2 - 1;\n        var a = color1.toHSL().a - color2.toHSL().a;\n\n        var w1 = (((w * a == -1) ? w : (w + a) / (1 + w * a)) + 1) / 2.0;\n        var w2 = 1 - w1;\n\n        var rgb = [color1.rgb[0] * w1 + color2.rgb[0] * w2,\n            color1.rgb[1] * w1 + color2.rgb[1] * w2,\n            color1.rgb[2] * w1 + color2.rgb[2] * w2];\n\n        var alpha = color1.alpha * p + color2.alpha * (1 - p);\n\n        return new Color(rgb, alpha);\n    },\n    greyscale: function (color) {\n        return colorFunctions.desaturate(color, new Dimension(100));\n    },\n    contrast: function (color, dark, light, threshold) {\n        // filter: contrast(3.2);\n        // should be kept as is, so check for color\n        if (!color.rgb) {\n            return null;\n        }\n        if (typeof light === 'undefined') {\n            light = colorFunctions.rgba(255, 255, 255, 1.0);\n        }\n        if (typeof dark === 'undefined') {\n            dark = colorFunctions.rgba(0, 0, 0, 1.0);\n        }\n        // Figure out which is actually light and dark:\n        if (dark.luma() > light.luma()) {\n            var t = light;\n            light = dark;\n            dark = t;\n        }\n        if (typeof threshold === 'undefined') {\n            threshold = 0.43;\n        } else {\n            threshold = number(threshold);\n        }\n        if (color.luma() < threshold) {\n            return light;\n        } else {\n            return dark;\n        }\n    },\n    // Changes made in 2.7.0 - Reverted in 3.0.0\n    // contrast: function (color, color1, color2, threshold) {\n    //     // Return which of `color1` and `color2` has the greatest contrast with `color`\n    //     // according to the standard WCAG contrast ratio calculation.\n    //     // http://www.w3.org/TR/WCAG20/#contrast-ratiodef\n    //     // The threshold param is no longer used, in line with SASS.\n    //     // filter: contrast(3.2);\n    //     // should be kept as is, so check for color\n    //     if (!color.rgb) {\n    //         return null;\n    //     }\n    //     if (typeof color1 === 'undefined') {\n    //         color1 = colorFunctions.rgba(0, 0, 0, 1.0);\n    //     }\n    //     if (typeof color2 === 'undefined') {\n    //         color2 = colorFunctions.rgba(255, 255, 255, 1.0);\n    //     }\n    //     var contrast1, contrast2;\n    //     var luma = color.luma();\n    //     var luma1 = color1.luma();\n    //     var luma2 = color2.luma();\n    //     // Calculate contrast ratios for each color\n    //     if (luma > luma1) {\n    //         contrast1 = (luma + 0.05) / (luma1 + 0.05);\n    //     } else {\n    //         contrast1 = (luma1 + 0.05) / (luma + 0.05);\n    //     }\n    //     if (luma > luma2) {\n    //         contrast2 = (luma + 0.05) / (luma2 + 0.05);\n    //     } else {\n    //         contrast2 = (luma2 + 0.05) / (luma + 0.05);\n    //     }\n    //     if (contrast1 > contrast2) {\n    //         return color1;\n    //     } else {\n    //         return color2;\n    //     }\n    // },\n    argb: function (color) {\n        return new Anonymous(color.toARGB());\n    },\n    color: function(c) {\n        if ((c instanceof Quoted) &&\n            (/^#([A-Fa-f0-9]{8}|[A-Fa-f0-9]{6}|[A-Fa-f0-9]{3,4})$/i.test(c.value))) {\n            var val = c.value.slice(1);\n            return new Color(val, undefined, '#' + val);\n        }\n        if ((c instanceof Color) || (c = Color.fromKeyword(c.value))) {\n            c.value = undefined;\n            return c;\n        }\n        throw {\n            type:    'Argument',\n            message: 'argument must be a color keyword or 3|4|6|8 digit hex e.g. #FFF'\n        };\n    },\n    tint: function(color, amount) {\n        return colorFunctions.mix(colorFunctions.rgb(255, 255, 255), color, amount);\n    },\n    shade: function(color, amount) {\n        return colorFunctions.mix(colorFunctions.rgb(0, 0, 0), color, amount);\n    }\n};\nfunctionRegistry.addMultiple(colorFunctions);\n\n},{\"../tree/anonymous\":50,\"../tree/color\":55,\"../tree/dimension\":62,\"../tree/quoted\":80,\"./function-registry\":27}],24:[function(require,module,exports){\nmodule.exports = function(environment) {\n    var Quoted = require('../tree/quoted'),\n        URL = require('../tree/url'),\n        utils = require('../utils'),\n        functionRegistry = require('./function-registry'),\n        fallback = function(functionThis, node) {\n            return new URL(node, functionThis.index, functionThis.currentFileInfo).eval(functionThis.context);\n        },\n        logger = require('../logger');\n\n    functionRegistry.add('data-uri', function(mimetypeNode, filePathNode) {\n\n        if (!filePathNode) {\n            filePathNode = mimetypeNode;\n            mimetypeNode = null;\n        }\n\n        var mimetype = mimetypeNode && mimetypeNode.value;\n        var filePath = filePathNode.value;\n        var currentFileInfo = this.currentFileInfo;\n        var currentDirectory = currentFileInfo.rewriteUrls ?\n            currentFileInfo.currentDirectory : currentFileInfo.entryPath;\n\n        var fragmentStart = filePath.indexOf('#');\n        var fragment = '';\n        if (fragmentStart !== -1) {\n            fragment = filePath.slice(fragmentStart);\n            filePath = filePath.slice(0, fragmentStart);\n        }\n        var context = utils.clone(this.context);\n        context.rawBuffer = true;\n\n        var fileManager = environment.getFileManager(filePath, currentDirectory, context, environment, true);\n\n        if (!fileManager) {\n            return fallback(this, filePathNode);\n        }\n\n        var useBase64 = false;\n\n        // detect the mimetype if not given\n        if (!mimetypeNode) {\n\n            mimetype = environment.mimeLookup(filePath);\n\n            if (mimetype === 'image/svg+xml') {\n                useBase64 = false;\n            } else {\n                // use base 64 unless it's an ASCII or UTF-8 format\n                var charset = environment.charsetLookup(mimetype);\n                useBase64 = ['US-ASCII', 'UTF-8'].indexOf(charset) < 0;\n            }\n            if (useBase64) { mimetype += ';base64'; }\n        }\n        else {\n            useBase64 = /;base64$/.test(mimetype);\n        }\n\n        var fileSync = fileManager.loadFileSync(filePath, currentDirectory, context, environment);\n        if (!fileSync.contents) {\n            logger.warn('Skipped data-uri embedding of ' + filePath + ' because file not found');\n            return fallback(this, filePathNode || mimetypeNode);\n        }\n        var buf = fileSync.contents;\n        if (useBase64 && !environment.encodeBase64) {\n            return fallback(this, filePathNode);\n        }\n\n        buf = useBase64 ? environment.encodeBase64(buf) : encodeURIComponent(buf);\n\n        var uri = 'data:' + mimetype + ',' + buf + fragment;\n\n        // IE8 cannot handle a data-uri larger than 32,768 characters. If this is exceeded\n        // and the --ieCompat flag is enabled, return a normal url() instead.\n        var DATA_URI_MAX = 32768;\n        if (uri.length >= DATA_URI_MAX) {\n\n            if (this.context.ieCompat !== false) {\n                logger.warn('Skipped data-uri embedding of ' + filePath + ' because its size (' + uri.length +\n                    ' characters) exceeds IE8-safe ' + DATA_URI_MAX + ' characters!');\n\n                return fallback(this, filePathNode || mimetypeNode);\n            }\n        }\n\n        return new URL(new Quoted('\"' + uri + '\"', uri, false, this.index, this.currentFileInfo), this.index, this.currentFileInfo);\n    });\n};\n\n},{\"../logger\":39,\"../tree/quoted\":80,\"../tree/url\":85,\"../utils\":89,\"./function-registry\":27}],25:[function(require,module,exports){\nvar Keyword = require('../tree/keyword'),\n    functionRegistry = require('./function-registry');\n\nvar defaultFunc = {\n    eval: function () {\n        var v = this.value_, e = this.error_;\n        if (e) {\n            throw e;\n        }\n        if (v != null) {\n            return v ? Keyword.True : Keyword.False;\n        }\n    },\n    value: function (v) {\n        this.value_ = v;\n    },\n    error: function (e) {\n        this.error_ = e;\n    },\n    reset: function () {\n        this.value_ = this.error_ = null;\n    }\n};\n\nfunctionRegistry.add('default', defaultFunc.eval.bind(defaultFunc));\n\nmodule.exports = defaultFunc;\n\n},{\"../tree/keyword\":70,\"./function-registry\":27}],26:[function(require,module,exports){\nvar Expression = require('../tree/expression');\n\nvar functionCaller = function(name, context, index, currentFileInfo) {\n    this.name = name.toLowerCase();\n    this.index = index;\n    this.context = context;\n    this.currentFileInfo = currentFileInfo;\n\n    this.func = context.frames[0].functionRegistry.get(this.name);\n};\nfunctionCaller.prototype.isValid = function() {\n    return Boolean(this.func);\n};\n\nfunctionCaller.prototype.call = function(args) {\n    // This code is terrible and should be replaced as per this issue...\n    // https://github.com/less/less.js/issues/2477\n    if (Array.isArray(args)) {\n        args = args.filter(function (item) {\n            if (item.type === 'Comment') {\n                return false;\n            }\n            return true;\n        })\n        .map(function(item) {\n            if (item.type === 'Expression') {\n                var subNodes = item.value.filter(function (item) {\n                    if (item.type === 'Comment') {\n                        return false;\n                    }\n                    return true;\n                });\n                if (subNodes.length === 1) {\n                    return subNodes[0];\n                } else {\n                    return new Expression(subNodes);\n                }\n            }\n            return item;\n        });\n    }\n\n    return this.func.apply(this, args);\n};\n\nmodule.exports = functionCaller;\n\n},{\"../tree/expression\":64}],27:[function(require,module,exports){\nfunction makeRegistry( base ) {\n    return {\n        _data: {},\n        add: function(name, func) {\n            // precautionary case conversion, as later querying of\n            // the registry by function-caller uses lower case as well.\n            name = name.toLowerCase();\n\n            if (this._data.hasOwnProperty(name)) {\n                // TODO warn\n            }\n            this._data[name] = func;\n        },\n        addMultiple: function(functions) {\n            Object.keys(functions).forEach(\n                function(name) {\n                    this.add(name, functions[name]);\n                }.bind(this));\n        },\n        get: function(name) {\n            return this._data[name] || ( base && base.get( name ));\n        },\n        getLocalFunctions: function() {\n            return this._data;\n        },\n        inherit: function() {\n            return makeRegistry( this );\n        },\n        create: function(base) {\n            return makeRegistry(base);\n        }\n    };\n}\n\nmodule.exports = makeRegistry( null );\n},{}],28:[function(require,module,exports){\nmodule.exports = function(environment) {\n    var functions = {\n        functionRegistry: require('./function-registry'),\n        functionCaller: require('./function-caller')\n    };\n\n    // register functions\n    require('./boolean');\n    require('./default');\n    require('./color');\n    require('./color-blending');\n    require('./data-uri')(environment);\n    require('./list');\n    require('./math');\n    require('./number');\n    require('./string');\n    require('./svg')(environment);\n    require('./types');\n\n    return functions;\n};\n\n},{\"./boolean\":21,\"./color\":23,\"./color-blending\":22,\"./data-uri\":24,\"./default\":25,\"./function-caller\":26,\"./function-registry\":27,\"./list\":29,\"./math\":31,\"./number\":32,\"./string\":33,\"./svg\":34,\"./types\":35}],29:[function(require,module,exports){\nvar Comment = require('../tree/comment'),\n    Dimension = require('../tree/dimension'),\n    Declaration = require('../tree/declaration'),\n    Expression = require('../tree/expression'),\n    Ruleset = require('../tree/ruleset'),\n    Selector = require('../tree/selector'),\n    Element = require('../tree/element'),\n    functionRegistry = require('./function-registry');\n\nvar getItemsFromNode = function(node) {\n    // handle non-array values as an array of length 1\n    // return 'undefined' if index is invalid\n    var items = Array.isArray(node.value) ?\n        node.value : Array(node);\n\n    return items;\n};\n\nfunctionRegistry.addMultiple({\n    _SELF: function(n) {\n        return n;\n    },\n    extract: function(values, index) {\n        index = index.value - 1; // (1-based index)\n\n        return getItemsFromNode(values)[index];\n    },\n    length: function(values) {\n        return new Dimension(getItemsFromNode(values).length);\n    },\n    /**\n     * Creates a Less list of incremental values.\n     * Modeled after Lodash's range function, also exists natively in PHP\n     * \n     * @param {Dimension} [start=1]\n     * @param {Dimension} end  - e.g. 10 or 10px - unit is added to output\n     * @param {Dimension} [step=1] \n     */\n    range: function(start, end, step) {\n        var from, to, stepValue = 1, list = [];\n        if (end) {\n            to = end;\n            from = start.value;\n            if (step) {\n                stepValue = step.value;\n            }\n        }\n        else {\n            from = 1;\n            to = start;\n        }\n\n        for (var i = from; i <= to.value; i += stepValue) {\n            list.push(new Dimension(i, to.unit));\n        }\n\n        return new Expression(list);\n    },\n    each: function(list, rs) {\n        var rules = [], newRules, iterator;\n\n        if (list.value) {\n            if (Array.isArray(list.value)) {\n                iterator = list.value;\n            } else {\n                iterator = [list.value];\n            }\n        } else if (list.ruleset) {\n            iterator = list.ruleset.rules;\n        } else if (list.rules) {\n            iterator = list.rules;\n        } else if (Array.isArray(list)) {\n            iterator = list;\n        } else {\n            iterator = [list];\n        }\n\n        var valueName = '@value',\n            keyName = '@key',\n            indexName = '@index';\n\n        if (rs.params) {\n            valueName = rs.params[0] && rs.params[0].name;\n            keyName = rs.params[1] && rs.params[1].name;\n            indexName = rs.params[2] && rs.params[2].name;\n            rs = rs.rules;\n        } else {\n            rs = rs.ruleset;\n        }\n\n        for (var i = 0; i < iterator.length; i++) {\n            var key, value, item = iterator[i];\n            if (item instanceof Declaration) {\n                key = typeof item.name === 'string' ? item.name : item.name[0].value;\n                value = item.value;\n            } else {\n                key = new Dimension(i + 1);\n                value = item;\n            }\n            \n            if (item instanceof Comment) {\n                continue;\n            }\n\n            newRules = rs.rules.slice(0);\n            if (valueName) {\n                newRules.push(new Declaration(valueName,\n                    value,\n                    false, false, this.index, this.currentFileInfo));\n            }\n            if (indexName) {\n                newRules.push(new Declaration(indexName,\n                    new Dimension(i + 1),\n                    false, false, this.index, this.currentFileInfo));\n            }\n            if (keyName) {\n                newRules.push(new Declaration(keyName,\n                    key,\n                    false, false, this.index, this.currentFileInfo));\n            }\n        \n            rules.push(new Ruleset([ new(Selector)([ new Element(\"\", '&') ]) ],\n                newRules,\n                rs.strictImports,\n                rs.visibilityInfo()\n            ));\n        }\n\n        return new Ruleset([ new(Selector)([ new Element(\"\", '&') ]) ],\n                rules,\n                rs.strictImports,\n                rs.visibilityInfo()\n            ).eval(this.context);\n\n    }\n});\n\n},{\"../tree/comment\":57,\"../tree/declaration\":60,\"../tree/dimension\":62,\"../tree/element\":63,\"../tree/expression\":64,\"../tree/ruleset\":81,\"../tree/selector\":82,\"./function-registry\":27}],30:[function(require,module,exports){\nvar Dimension = require('../tree/dimension');\n\nvar MathHelper = function() {\n};\nMathHelper._math = function (fn, unit, n) {\n    if (!(n instanceof Dimension)) {\n        throw { type: 'Argument', message: 'argument must be a number' };\n    }\n    if (unit == null) {\n        unit = n.unit;\n    } else {\n        n = n.unify();\n    }\n    return new Dimension(fn(parseFloat(n.value)), unit);\n};\nmodule.exports = MathHelper;\n},{\"../tree/dimension\":62}],31:[function(require,module,exports){\nvar functionRegistry = require('./function-registry'),\n    mathHelper = require('./math-helper.js');\n\nvar mathFunctions = {\n    // name,  unit\n    ceil:  null,\n    floor: null,\n    sqrt:  null,\n    abs:   null,\n    tan:   '',\n    sin:   '',\n    cos:   '',\n    atan:  'rad',\n    asin:  'rad',\n    acos:  'rad'\n};\n\nfor (var f in mathFunctions) {\n    if (mathFunctions.hasOwnProperty(f)) {\n        mathFunctions[f] = mathHelper._math.bind(null, Math[f], mathFunctions[f]);\n    }\n}\n\nmathFunctions.round = function (n, f) {\n    var fraction = typeof f === 'undefined' ? 0 : f.value;\n    return mathHelper._math(function(num) { return num.toFixed(fraction); }, null, n);\n};\n\nfunctionRegistry.addMultiple(mathFunctions);\n\n},{\"./function-registry\":27,\"./math-helper.js\":30}],32:[function(require,module,exports){\nvar Dimension = require('../tree/dimension'),\n    Anonymous = require('../tree/anonymous'),\n    functionRegistry = require('./function-registry'),\n    mathHelper = require('./math-helper.js');\n\nvar minMax = function (isMin, args) {\n    args = Array.prototype.slice.call(args);\n    switch (args.length) {\n        case 0: throw { type: 'Argument', message: 'one or more arguments required' };\n    }\n    var i, j, current, currentUnified, referenceUnified, unit, unitStatic, unitClone,\n        order  = [], // elems only contains original argument values.\n        values = {}; // key is the unit.toString() for unified Dimension values,\n    // value is the index into the order array.\n    for (i = 0; i < args.length; i++) {\n        current = args[i];\n        if (!(current instanceof Dimension)) {\n            if (Array.isArray(args[i].value)) {\n                Array.prototype.push.apply(args, Array.prototype.slice.call(args[i].value));\n            }\n            continue;\n        }\n        currentUnified = current.unit.toString() === '' && unitClone !== undefined ? new Dimension(current.value, unitClone).unify() : current.unify();\n        unit = currentUnified.unit.toString() === '' && unitStatic !== undefined ? unitStatic : currentUnified.unit.toString();\n        unitStatic = unit !== '' && unitStatic === undefined || unit !== '' && order[0].unify().unit.toString() === '' ? unit : unitStatic;\n        unitClone = unit !== '' && unitClone === undefined ? current.unit.toString() : unitClone;\n        j = values[''] !== undefined && unit !== '' && unit === unitStatic ? values[''] : values[unit];\n        if (j === undefined) {\n            if (unitStatic !== undefined && unit !== unitStatic) {\n                throw { type: 'Argument', message: 'incompatible types' };\n            }\n            values[unit] = order.length;\n            order.push(current);\n            continue;\n        }\n        referenceUnified = order[j].unit.toString() === '' && unitClone !== undefined ? new Dimension(order[j].value, unitClone).unify() : order[j].unify();\n        if ( isMin && currentUnified.value < referenceUnified.value ||\n            !isMin && currentUnified.value > referenceUnified.value) {\n            order[j] = current;\n        }\n    }\n    if (order.length == 1) {\n        return order[0];\n    }\n    args = order.map(function (a) { return a.toCSS(this.context); }).join(this.context.compress ? ',' : ', ');\n    return new Anonymous((isMin ? 'min' : 'max') + '(' + args + ')');\n};\nfunctionRegistry.addMultiple({\n    min: function () {\n        return minMax(true, arguments);\n    },\n    max: function () {\n        return minMax(false, arguments);\n    },\n    convert: function (val, unit) {\n        return val.convertTo(unit.value);\n    },\n    pi: function () {\n        return new Dimension(Math.PI);\n    },\n    mod: function(a, b) {\n        return new Dimension(a.value % b.value, a.unit);\n    },\n    pow: function(x, y) {\n        if (typeof x === 'number' && typeof y === 'number') {\n            x = new Dimension(x);\n            y = new Dimension(y);\n        } else if (!(x instanceof Dimension) || !(y instanceof Dimension)) {\n            throw { type: 'Argument', message: 'arguments must be numbers' };\n        }\n\n        return new Dimension(Math.pow(x.value, y.value), x.unit);\n    },\n    percentage: function (n) {\n        var result = mathHelper._math(function(num) {\n            return num * 100;\n        }, '%', n);\n\n        return result;\n    }\n});\n\n},{\"../tree/anonymous\":50,\"../tree/dimension\":62,\"./function-registry\":27,\"./math-helper.js\":30}],33:[function(require,module,exports){\nvar Quoted = require('../tree/quoted'),\n    Anonymous = require('../tree/anonymous'),\n    JavaScript = require('../tree/javascript'),\n    functionRegistry = require('./function-registry');\n\nfunctionRegistry.addMultiple({\n    e: function (str) {\n        return new Anonymous(str instanceof JavaScript ? str.evaluated : str.value);\n    },\n    escape: function (str) {\n        return new Anonymous(\n            encodeURI(str.value).replace(/=/g, '%3D').replace(/:/g, '%3A').replace(/#/g, '%23').replace(/;/g, '%3B')\n                .replace(/\\(/g, '%28').replace(/\\)/g, '%29'));\n    },\n    replace: function (string, pattern, replacement, flags) {\n        var result = string.value;\n        replacement = (replacement.type === 'Quoted') ?\n            replacement.value : replacement.toCSS();\n        result = result.replace(new RegExp(pattern.value, flags ? flags.value : ''), replacement);\n        return new Quoted(string.quote || '', result, string.escaped);\n    },\n    '%': function (string /* arg, arg, ... */) {\n        var args = Array.prototype.slice.call(arguments, 1),\n            result = string.value;\n\n        for (var i = 0; i < args.length; i++) {\n            /* jshint loopfunc:true */\n            result = result.replace(/%[sda]/i, function(token) {\n                var value = ((args[i].type === 'Quoted') &&\n                    token.match(/s/i)) ? args[i].value : args[i].toCSS();\n                return token.match(/[A-Z]$/) ? encodeURIComponent(value) : value;\n            });\n        }\n        result = result.replace(/%%/g, '%');\n        return new Quoted(string.quote || '', result, string.escaped);\n    }\n});\n\n},{\"../tree/anonymous\":50,\"../tree/javascript\":68,\"../tree/quoted\":80,\"./function-registry\":27}],34:[function(require,module,exports){\nmodule.exports = function(environment) {\n    var Dimension = require('../tree/dimension'),\n        Color = require('../tree/color'),\n        Expression = require('../tree/expression'),\n        Quoted = require('../tree/quoted'),\n        URL = require('../tree/url'),\n        functionRegistry = require('./function-registry');\n\n    functionRegistry.add('svg-gradient', function(direction) {\n\n        var stops,\n            gradientDirectionSvg,\n            gradientType = 'linear',\n            rectangleDimension = 'x=\"0\" y=\"0\" width=\"1\" height=\"1\"',\n            renderEnv = {compress: false},\n            returner,\n            directionValue = direction.toCSS(renderEnv),\n            i, color, position, positionValue, alpha;\n\n        function throwArgumentDescriptor() {\n            throw { type: 'Argument',\n                message: 'svg-gradient expects direction, start_color [start_position], [color position,]...,' +\n                            ' end_color [end_position] or direction, color list' };\n        }\n\n        if (arguments.length == 2) {\n            if (arguments[1].value.length < 2) {\n                throwArgumentDescriptor();\n            }\n            stops = arguments[1].value;\n        } else if (arguments.length < 3) {\n            throwArgumentDescriptor();\n        } else {\n            stops = Array.prototype.slice.call(arguments, 1);\n        }\n\n        switch (directionValue) {\n            case 'to bottom':\n                gradientDirectionSvg = 'x1=\"0%\" y1=\"0%\" x2=\"0%\" y2=\"100%\"';\n                break;\n            case 'to right':\n                gradientDirectionSvg = 'x1=\"0%\" y1=\"0%\" x2=\"100%\" y2=\"0%\"';\n                break;\n            case 'to bottom right':\n                gradientDirectionSvg = 'x1=\"0%\" y1=\"0%\" x2=\"100%\" y2=\"100%\"';\n                break;\n            case 'to top right':\n                gradientDirectionSvg = 'x1=\"0%\" y1=\"100%\" x2=\"100%\" y2=\"0%\"';\n                break;\n            case 'ellipse':\n            case 'ellipse at center':\n                gradientType = 'radial';\n                gradientDirectionSvg = 'cx=\"50%\" cy=\"50%\" r=\"75%\"';\n                rectangleDimension = 'x=\"-50\" y=\"-50\" width=\"101\" height=\"101\"';\n                break;\n            default:\n                throw { type: 'Argument', message: 'svg-gradient direction must be \\'to bottom\\', \\'to right\\',' +\n                    ' \\'to bottom right\\', \\'to top right\\' or \\'ellipse at center\\'' };\n        }\n        returner = '<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 1 1\">' +\n            '<' + gradientType + 'Gradient id=\"g\" ' + gradientDirectionSvg + '>';\n\n        for (i = 0; i < stops.length; i += 1) {\n            if (stops[i] instanceof Expression) {\n                color = stops[i].value[0];\n                position = stops[i].value[1];\n            } else {\n                color = stops[i];\n                position = undefined;\n            }\n\n            if (!(color instanceof Color) || (!((i === 0 || i + 1 === stops.length) && position === undefined) && !(position instanceof Dimension))) {\n                throwArgumentDescriptor();\n            }\n            positionValue = position ? position.toCSS(renderEnv) : i === 0 ? '0%' : '100%';\n            alpha = color.alpha;\n            returner += '<stop offset=\"' + positionValue + '\" stop-color=\"' + color.toRGB() + '\"' + (alpha < 1 ? ' stop-opacity=\"' + alpha + '\"' : '') + '/>';\n        }\n        returner += '</' + gradientType + 'Gradient>' +\n            '<rect ' + rectangleDimension + ' fill=\"url(#g)\" /></svg>';\n\n        returner = encodeURIComponent(returner);\n\n        returner = 'data:image/svg+xml,' + returner;\n        return new URL(new Quoted('\\'' + returner + '\\'', returner, false, this.index, this.currentFileInfo), this.index, this.currentFileInfo);\n    });\n};\n\n},{\"../tree/color\":55,\"../tree/dimension\":62,\"../tree/expression\":64,\"../tree/quoted\":80,\"../tree/url\":85,\"./function-registry\":27}],35:[function(require,module,exports){\nvar Keyword = require('../tree/keyword'),\n    DetachedRuleset = require('../tree/detached-ruleset'),\n    Dimension = require('../tree/dimension'),\n    Color = require('../tree/color'),\n    Quoted = require('../tree/quoted'),\n    Anonymous = require('../tree/anonymous'),\n    URL = require('../tree/url'),\n    Operation = require('../tree/operation'),\n    functionRegistry = require('./function-registry');\n\nvar isa = function (n, Type) {\n        return (n instanceof Type) ? Keyword.True : Keyword.False;\n    },\n    isunit = function (n, unit) {\n        if (unit === undefined) {\n            throw { type: 'Argument', message: 'missing the required second argument to isunit.' };\n        }\n        unit = typeof unit.value === 'string' ? unit.value : unit;\n        if (typeof unit !== 'string') {\n            throw { type: 'Argument', message: 'Second argument to isunit should be a unit or a string.' };\n        }\n        return (n instanceof Dimension) && n.unit.is(unit) ? Keyword.True : Keyword.False;\n    };\n\nfunctionRegistry.addMultiple({\n    isruleset: function (n) {\n        return isa(n, DetachedRuleset);\n    },\n    iscolor: function (n) {\n        return isa(n, Color);\n    },\n    isnumber: function (n) {\n        return isa(n, Dimension);\n    },\n    isstring: function (n) {\n        return isa(n, Quoted);\n    },\n    iskeyword: function (n) {\n        return isa(n, Keyword);\n    },\n    isurl: function (n) {\n        return isa(n, URL);\n    },\n    ispixel: function (n) {\n        return isunit(n, 'px');\n    },\n    ispercentage: function (n) {\n        return isunit(n, '%');\n    },\n    isem: function (n) {\n        return isunit(n, 'em');\n    },\n    isunit: isunit,\n    unit: function (val, unit) {\n        if (!(val instanceof Dimension)) {\n            throw { type: 'Argument',\n                message: 'the first argument to unit must be a number' +\n                    (val instanceof Operation ? '. Have you forgotten parenthesis?' : '') };\n        }\n        if (unit) {\n            if (unit instanceof Keyword) {\n                unit = unit.value;\n            } else {\n                unit = unit.toCSS();\n            }\n        } else {\n            unit = '';\n        }\n        return new Dimension(val.value, unit);\n    },\n    'get-unit': function (n) {\n        return new Anonymous(n.unit);\n    }\n});\n\n},{\"../tree/anonymous\":50,\"../tree/color\":55,\"../tree/detached-ruleset\":61,\"../tree/dimension\":62,\"../tree/keyword\":70,\"../tree/operation\":77,\"../tree/quoted\":80,\"../tree/url\":85,\"./function-registry\":27}],36:[function(require,module,exports){\nvar contexts = require('./contexts'),\n    Parser = require('./parser/parser'),\n    LessError = require('./less-error'),\n    utils = require('./utils'),\n    PromiseConstructor = typeof Promise === 'undefined' ? require('promise') : Promise,\n    logger = require('./logger');\n\nmodule.exports = function(environment) {\n\n    // FileInfo = {\n    //  'rewriteUrls' - option - whether to adjust URL's to be relative\n    //  'filename' - full resolved filename of current file\n    //  'rootpath' - path to append to normal URLs for this node\n    //  'currentDirectory' - path to the current file, absolute\n    //  'rootFilename' - filename of the base file\n    //  'entryPath' - absolute path to the entry file\n    //  'reference' - whether the file should not be output and only output parts that are referenced\n\n    var ImportManager = function(less, context, rootFileInfo) {\n        this.less = less;\n        this.rootFilename = rootFileInfo.filename;\n        this.paths = context.paths || [];  // Search paths, when importing\n        this.contents = {};             // map - filename to contents of all the files\n        this.contentsIgnoredChars = {}; // map - filename to lines at the beginning of each file to ignore\n        this.mime = context.mime;\n        this.error = null;\n        this.context = context;\n        // Deprecated? Unused outside of here, could be useful.\n        this.queue = [];        // Files which haven't been imported yet\n        this.files = {};        // Holds the imported parse trees.\n    };\n\n    /**\n     * Add an import to be imported\n     * @param path - the raw path\n     * @param tryAppendExtension - whether to try appending a file extension (.less or .js if the path has no extension)\n     * @param currentFileInfo - the current file info (used for instance to work out relative paths)\n     * @param importOptions - import options\n     * @param callback - callback for when it is imported\n     */\n    ImportManager.prototype.push = function (path, tryAppendExtension, currentFileInfo, importOptions, callback) {\n        var importManager = this,\n            pluginLoader = this.context.pluginManager.Loader;\n\n        this.queue.push(path);\n\n        var fileParsedFunc = function (e, root, fullPath) {\n            importManager.queue.splice(importManager.queue.indexOf(path), 1); // Remove the path from the queue\n\n            var importedEqualsRoot = fullPath === importManager.rootFilename;\n            if (importOptions.optional && e) {\n                callback(null, {rules:[]}, false, null);\n                logger.info('The file ' + fullPath + ' was skipped because it was not found and the import was marked optional.');\n            }\n            else {\n                // Inline imports aren't cached here.\n                // If we start to cache them, please make sure they won't conflict with non-inline imports of the\n                // same name as they used to do before this comment and the condition below have been added.\n                if (!importManager.files[fullPath] && !importOptions.inline) {\n                    importManager.files[fullPath] = { root: root, options: importOptions };\n                }\n                if (e && !importManager.error) { importManager.error = e; }\n                callback(e, root, importedEqualsRoot, fullPath);\n            }\n        };\n\n        var newFileInfo = {\n            rewriteUrls: this.context.rewriteUrls,\n            entryPath: currentFileInfo.entryPath,\n            rootpath: currentFileInfo.rootpath,\n            rootFilename: currentFileInfo.rootFilename\n        };\n\n        var fileManager = environment.getFileManager(path, currentFileInfo.currentDirectory, this.context, environment);\n\n        if (!fileManager) {\n            fileParsedFunc({ message: 'Could not find a file-manager for ' + path });\n            return;\n        }\n\n        var loadFileCallback = function(loadedFile) {\n            var plugin,\n                resolvedFilename = loadedFile.filename,\n                contents = loadedFile.contents.replace(/^\\uFEFF/, '');\n\n            // Pass on an updated rootpath if path of imported file is relative and file\n            // is in a (sub|sup) directory\n            //\n            // Examples:\n            // - If path of imported file is 'module/nav/nav.less' and rootpath is 'less/',\n            //   then rootpath should become 'less/module/nav/'\n            // - If path of imported file is '../mixins.less' and rootpath is 'less/',\n            //   then rootpath should become 'less/../'\n            newFileInfo.currentDirectory = fileManager.getPath(resolvedFilename);\n            if (newFileInfo.rewriteUrls) {\n                newFileInfo.rootpath = fileManager.join(\n                    (importManager.context.rootpath || ''),\n                    fileManager.pathDiff(newFileInfo.currentDirectory, newFileInfo.entryPath));\n\n                if (!fileManager.isPathAbsolute(newFileInfo.rootpath) && fileManager.alwaysMakePathsAbsolute()) {\n                    newFileInfo.rootpath = fileManager.join(newFileInfo.entryPath, newFileInfo.rootpath);\n                }\n            }\n            newFileInfo.filename = resolvedFilename;\n\n            var newEnv = new contexts.Parse(importManager.context);\n\n            newEnv.processImports = false;\n            importManager.contents[resolvedFilename] = contents;\n\n            if (currentFileInfo.reference || importOptions.reference) {\n                newFileInfo.reference = true;\n            }\n\n            if (importOptions.isPlugin) {\n                plugin = pluginLoader.evalPlugin(contents, newEnv, importManager, importOptions.pluginArgs, newFileInfo);\n                if (plugin instanceof LessError) {\n                    fileParsedFunc(plugin, null, resolvedFilename);\n                }\n                else {\n                    fileParsedFunc(null, plugin, resolvedFilename);\n                }\n            } else if (importOptions.inline) {\n                fileParsedFunc(null, contents, resolvedFilename);\n            } else {\n\n                // import (multiple) parse trees apparently get altered and can't be cached.\n                // TODO: investigate why this is\n                if (importManager.files[resolvedFilename]\n                    && !importManager.files[resolvedFilename].options.multiple\n                    && !importOptions.multiple) {\n\n                    fileParsedFunc(null, importManager.files[resolvedFilename].root, resolvedFilename);\n                }\n                else {\n                    new Parser(newEnv, importManager, newFileInfo).parse(contents, function (e, root) {\n                        fileParsedFunc(e, root, resolvedFilename);\n                    });\n                }\n            }\n        };\n        var promise, context = utils.clone(this.context);\n\n        if (tryAppendExtension) {\n            context.ext = importOptions.isPlugin ? '.js' : '.less';\n        }\n\n        if (importOptions.isPlugin) {\n            promise = pluginLoader.loadPlugin(path, currentFileInfo.currentDirectory, context, environment, fileManager);\n        }\n        else {\n            promise = fileManager.loadFile(path, currentFileInfo.currentDirectory, context, environment,\n                function(err, loadedFile) {\n                    if (err) {\n                        fileParsedFunc(err);\n                    } else {\n                        loadFileCallback(loadedFile);\n                    }\n                });\n        }\n        if (promise) {\n            promise.then(loadFileCallback, fileParsedFunc);\n        }\n\n    };\n    return ImportManager;\n};\n\n},{\"./contexts\":13,\"./less-error\":38,\"./logger\":39,\"./parser/parser\":44,\"./utils\":89,\"promise\":undefined}],37:[function(require,module,exports){\nmodule.exports = function(environment, fileManagers) {\n    var SourceMapOutput, SourceMapBuilder, ParseTree, ImportManager, Environment;\n\n    var initial = {\n        version: [3, 9, 0],\n        data: require('./data'),\n        tree: require('./tree'),\n        Environment: (Environment = require('./environment/environment')),\n        AbstractFileManager: require('./environment/abstract-file-manager'),\n        AbstractPluginLoader: require('./environment/abstract-plugin-loader'),\n        environment: (environment = new Environment(environment, fileManagers)),\n        visitors: require('./visitors'),\n        Parser: require('./parser/parser'),\n        functions: require('./functions')(environment),\n        contexts: require('./contexts'),\n        SourceMapOutput: (SourceMapOutput = require('./source-map-output')(environment)),\n        SourceMapBuilder: (SourceMapBuilder = require('./source-map-builder')(SourceMapOutput, environment)),\n        ParseTree: (ParseTree = require('./parse-tree')(SourceMapBuilder)),\n        ImportManager: (ImportManager = require('./import-manager')(environment)),\n        render: require('./render')(environment, ParseTree, ImportManager),\n        parse: require('./parse')(environment, ParseTree, ImportManager),\n        LessError: require('./less-error'),\n        transformTree: require('./transform-tree'),\n        utils: require('./utils'),\n        PluginManager: require('./plugin-manager'),\n        logger: require('./logger')\n    };\n\n    // Create a public API\n\n    var ctor = function(t) {\n        return function() {\n            var obj = Object.create(t.prototype);\n            t.apply(obj, Array.prototype.slice.call(arguments, 0));\n            return obj;\n        };\n    };\n    var t, api = Object.create(initial);\n    for (var n in initial.tree) {\n        /* eslint guard-for-in: 0 */\n        t = initial.tree[n];\n        if (typeof t === 'function') {\n            api[n.toLowerCase()] = ctor(t);\n        }\n        else {\n            api[n] = Object.create(null);\n            for (var o in t) {\n                /* eslint guard-for-in: 0 */\n                api[n][o.toLowerCase()] = ctor(t[o]);\n            }\n        }\n    }\n\n    return api;\n};\n\n},{\"./contexts\":13,\"./data\":15,\"./environment/abstract-file-manager\":18,\"./environment/abstract-plugin-loader\":19,\"./environment/environment\":20,\"./functions\":28,\"./import-manager\":36,\"./less-error\":38,\"./logger\":39,\"./parse\":41,\"./parse-tree\":40,\"./parser/parser\":44,\"./plugin-manager\":45,\"./render\":46,\"./source-map-builder\":47,\"./source-map-output\":48,\"./transform-tree\":49,\"./tree\":67,\"./utils\":89,\"./visitors\":93}],38:[function(require,module,exports){\nvar utils = require('./utils');\n/**\n * This is a centralized class of any error that could be thrown internally (mostly by the parser).\n * Besides standard .message it keeps some additional data like a path to the file where the error\n * occurred along with line and column numbers.\n *\n * @class\n * @extends Error\n * @type {module.LessError}\n *\n * @prop {string} type\n * @prop {string} filename\n * @prop {number} index\n * @prop {number} line\n * @prop {number} column\n * @prop {number} callLine\n * @prop {number} callExtract\n * @prop {string[]} extract\n *\n * @param {Object} e              - An error object to wrap around or just a descriptive object\n * @param {Object} fileContentMap - An object with file contents in 'contents' property (like importManager) @todo - move to fileManager?\n * @param {string} [currentFilename]\n */\nvar LessError = module.exports = function LessError(e, fileContentMap, currentFilename) {\n    Error.call(this);\n\n    var filename = e.filename || currentFilename;\n\n    this.message = e.message;\n    this.stack = e.stack;\n\n    if (fileContentMap && filename) {\n        var input = fileContentMap.contents[filename],\n            loc = utils.getLocation(e.index, input),\n            line = loc.line,\n            col  = loc.column,\n            callLine = e.call && utils.getLocation(e.call, input).line,\n            lines = input ? input.split('\\n') : '';\n\n        this.type = e.type || 'Syntax';\n        this.filename = filename;\n        this.index = e.index;\n        this.line = typeof line === 'number' ? line + 1 : null;\n        this.column = col;\n\n        if (!this.line && this.stack) {\n            var found = this.stack.match(/(<anonymous>|Function):(\\d+):(\\d+)/);\n\n            if (found) {\n                if (found[2]) {\n                    this.line = parseInt(found[2]) - 2;\n                }\n                if (found[3]) {\n                    this.column = parseInt(found[3]);\n                }\n            }\n        }\n\n        this.callLine = callLine + 1;\n        this.callExtract = lines[callLine];\n\n        this.extract = [\n            lines[this.line - 2],\n            lines[this.line - 1],\n            lines[this.line]\n        ];\n\n    }\n\n};\n\nif (typeof Object.create === 'undefined') {\n    var F = function () {};\n    F.prototype = Error.prototype;\n    LessError.prototype = new F();\n} else {\n    LessError.prototype = Object.create(Error.prototype);\n}\n\nLessError.prototype.constructor = LessError;\n\n/**\n * An overridden version of the default Object.prototype.toString\n * which uses additional information to create a helpful message.\n *\n * @param {Object} options\n * @returns {string}\n */\nLessError.prototype.toString = function(options) {\n    options = options || {};\n\n    var message = '';\n    var extract = this.extract || [];\n    var error = [];\n    var stylize = function (str) { return str; };\n    if (options.stylize) {\n        var type = typeof options.stylize;\n        if (type !== 'function') {\n            throw Error('options.stylize should be a function, got a ' + type + '!');\n        }\n        stylize = options.stylize;\n    }\n\n    if (this.line !== null) {\n        if (typeof extract[0] === 'string') {\n            error.push(stylize((this.line - 1) + ' ' + extract[0], 'grey'));\n        }\n\n        if (typeof extract[1] === 'string') {\n            var errorTxt = this.line + ' ';\n            if (extract[1]) {\n                errorTxt += extract[1].slice(0, this.column) +\n                    stylize(stylize(stylize(extract[1].substr(this.column, 1), 'bold') +\n                        extract[1].slice(this.column + 1), 'red'), 'inverse');\n            }\n            error.push(errorTxt);\n        }\n\n        if (typeof extract[2] === 'string') {\n            error.push(stylize((this.line + 1) + ' ' + extract[2], 'grey'));\n        }\n        error = error.join('\\n') + stylize('', 'reset') + '\\n';\n    }\n\n    message += stylize(this.type + 'Error: ' + this.message, 'red');\n    if (this.filename) {\n        message += stylize(' in ', 'red') + this.filename;\n    }\n    if (this.line) {\n        message += stylize(' on line ' + this.line + ', column ' + (this.column + 1) + ':', 'grey');\n    }\n\n    message += '\\n' + error;\n\n    if (this.callLine) {\n        message += stylize('from ', 'red') + (this.filename || '') + '/n';\n        message += stylize(this.callLine, 'grey') + ' ' + this.callExtract + '/n';\n    }\n\n    return message;\n};\n\n},{\"./utils\":89}],39:[function(require,module,exports){\nmodule.exports = {\n    error: function(msg) {\n        this._fireEvent('error', msg);\n    },\n    warn: function(msg) {\n        this._fireEvent('warn', msg);\n    },\n    info: function(msg) {\n        this._fireEvent('info', msg);\n    },\n    debug: function(msg) {\n        this._fireEvent('debug', msg);\n    },\n    addListener: function(listener) {\n        this._listeners.push(listener);\n    },\n    removeListener: function(listener) {\n        for (var i = 0; i < this._listeners.length; i++) {\n            if (this._listeners[i] === listener) {\n                this._listeners.splice(i, 1);\n                return;\n            }\n        }\n    },\n    _fireEvent: function(type, msg) {\n        for (var i = 0; i < this._listeners.length; i++) {\n            var logFunction = this._listeners[i][type];\n            if (logFunction) {\n                logFunction(msg);\n            }\n        }\n    },\n    _listeners: []\n};\n\n},{}],40:[function(require,module,exports){\nvar LessError = require('./less-error'),\n    transformTree = require('./transform-tree'),\n    logger = require('./logger');\n\nmodule.exports = function(SourceMapBuilder) {\n    var ParseTree = function(root, imports) {\n        this.root = root;\n        this.imports = imports;\n    };\n\n    ParseTree.prototype.toCSS = function(options) {\n        var evaldRoot, result = {}, sourceMapBuilder;\n        try {\n            evaldRoot = transformTree(this.root, options);\n        } catch (e) {\n            throw new LessError(e, this.imports);\n        }\n\n        try {\n            var compress = Boolean(options.compress);\n            if (compress) {\n                logger.warn('The compress option has been deprecated. We recommend you use a dedicated css minifier, for instance see less-plugin-clean-css.');\n            }\n\n            var toCSSOptions = {\n                compress: compress,\n                dumpLineNumbers: options.dumpLineNumbers,\n                strictUnits: Boolean(options.strictUnits),\n                numPrecision: 8};\n\n            if (options.sourceMap) {\n                sourceMapBuilder = new SourceMapBuilder(options.sourceMap);\n                result.css = sourceMapBuilder.toCSS(evaldRoot, toCSSOptions, this.imports);\n            } else {\n                result.css = evaldRoot.toCSS(toCSSOptions);\n            }\n        } catch (e) {\n            throw new LessError(e, this.imports);\n        }\n\n        if (options.pluginManager) {\n            var postProcessors = options.pluginManager.getPostProcessors();\n            for (var i = 0; i < postProcessors.length; i++) {\n                result.css = postProcessors[i].process(result.css, { sourceMap: sourceMapBuilder, options: options, imports: this.imports });\n            }\n        }\n        if (options.sourceMap) {\n            result.map = sourceMapBuilder.getExternalSourceMap();\n        }\n\n        result.imports = [];\n        for (var file in this.imports.files) {\n            if (this.imports.files.hasOwnProperty(file) && file !== this.imports.rootFilename) {\n                result.imports.push(file);\n            }\n        }\n        return result;\n    };\n    return ParseTree;\n};\n\n},{\"./less-error\":38,\"./logger\":39,\"./transform-tree\":49}],41:[function(require,module,exports){\nvar PromiseConstructor,\n    contexts = require('./contexts'),\n    Parser = require('./parser/parser'),\n    PluginManager = require('./plugin-manager'),\n    LessError = require('./less-error'),\n    utils = require('./utils');\n\nmodule.exports = function(environment, ParseTree, ImportManager) {\n    var parse = function (input, options, callback) {\n\n        if (typeof options === 'function') {\n            callback = options;\n            options = utils.copyOptions(this.options, {});\n        }\n        else {\n            options = utils.copyOptions(this.options, options || {});\n        }\n\n        if (!callback) {\n            if (!PromiseConstructor) {\n                PromiseConstructor = typeof Promise === 'undefined' ? require('promise') : Promise;\n            }\n            var self = this;\n            return new PromiseConstructor(function (resolve, reject) {\n                parse.call(self, input, options, function(err, output) {\n                    if (err) {\n                        reject(err);\n                    } else {\n                        resolve(output);\n                    }\n                });\n            });\n        } else {\n            var context,\n                rootFileInfo,\n                pluginManager = new PluginManager(this, !options.reUsePluginManager);\n\n            options.pluginManager = pluginManager;\n\n            context = new contexts.Parse(options);\n\n            if (options.rootFileInfo) {\n                rootFileInfo = options.rootFileInfo;\n            } else {\n                var filename = options.filename || 'input';\n                var entryPath = filename.replace(/[^\\/\\\\]*$/, '');\n                rootFileInfo = {\n                    filename: filename,\n                    rewriteUrls: context.rewriteUrls,\n                    rootpath: context.rootpath || '',\n                    currentDirectory: entryPath,\n                    entryPath: entryPath,\n                    rootFilename: filename\n                };\n                // add in a missing trailing slash\n                if (rootFileInfo.rootpath && rootFileInfo.rootpath.slice(-1) !== '/') {\n                    rootFileInfo.rootpath += '/';\n                }\n            }\n\n            var imports = new ImportManager(this, context, rootFileInfo);\n            this.importManager = imports;\n\n            // TODO: allow the plugins to be just a list of paths or names\n            // Do an async plugin queue like lessc\n\n            if (options.plugins) {\n                options.plugins.forEach(function(plugin) {\n                    var evalResult, contents;\n                    if (plugin.fileContent) {\n                        contents = plugin.fileContent.replace(/^\\uFEFF/, '');\n                        evalResult = pluginManager.Loader.evalPlugin(contents, context, imports, plugin.options, plugin.filename);\n                        if (evalResult instanceof LessError) {\n                            return callback(evalResult);\n                        }\n                    }\n                    else {\n                        pluginManager.addPlugin(plugin);\n                    }\n                });\n            }\n\n            new Parser(context, imports, rootFileInfo)\n                .parse(input, function (e, root) {\n                    if (e) { return callback(e); }\n                    callback(null, root, imports, options);\n                }, options);\n        }\n    };\n    return parse;\n};\n\n},{\"./contexts\":13,\"./less-error\":38,\"./parser/parser\":44,\"./plugin-manager\":45,\"./utils\":89,\"promise\":undefined}],42:[function(require,module,exports){\n// Split the input into chunks.\nmodule.exports = function (input, fail) {\n    var len = input.length, level = 0, parenLevel = 0,\n        lastOpening, lastOpeningParen, lastMultiComment, lastMultiCommentEndBrace,\n        chunks = [], emitFrom = 0,\n        chunkerCurrentIndex, currentChunkStartIndex, cc, cc2, matched;\n\n    function emitChunk(force) {\n        var len = chunkerCurrentIndex - emitFrom;\n        if (((len < 512) && !force) || !len) {\n            return;\n        }\n        chunks.push(input.slice(emitFrom, chunkerCurrentIndex + 1));\n        emitFrom = chunkerCurrentIndex + 1;\n    }\n\n    for (chunkerCurrentIndex = 0; chunkerCurrentIndex < len; chunkerCurrentIndex++) {\n        cc = input.charCodeAt(chunkerCurrentIndex);\n        if (((cc >= 97) && (cc <= 122)) || (cc < 34)) {\n            // a-z or whitespace\n            continue;\n        }\n\n        switch (cc) {\n            case 40:                        // (\n                parenLevel++;\n                lastOpeningParen = chunkerCurrentIndex;\n                continue;\n            case 41:                        // )\n                if (--parenLevel < 0) {\n                    return fail('missing opening `(`', chunkerCurrentIndex);\n                }\n                continue;\n            case 59:                        // ;\n                if (!parenLevel) { emitChunk(); }\n                continue;\n            case 123:                       // {\n                level++;\n                lastOpening = chunkerCurrentIndex;\n                continue;\n            case 125:                       // }\n                if (--level < 0) {\n                    return fail('missing opening `{`', chunkerCurrentIndex);\n                }\n                if (!level && !parenLevel) { emitChunk(); }\n                continue;\n            case 92:                        // \\\n                if (chunkerCurrentIndex < len - 1) { chunkerCurrentIndex++; continue; }\n                return fail('unescaped `\\\\`', chunkerCurrentIndex);\n            case 34:\n            case 39:\n            case 96:                        // \", ' and `\n                matched = 0;\n                currentChunkStartIndex = chunkerCurrentIndex;\n                for (chunkerCurrentIndex = chunkerCurrentIndex + 1; chunkerCurrentIndex < len; chunkerCurrentIndex++) {\n                    cc2 = input.charCodeAt(chunkerCurrentIndex);\n                    if (cc2 > 96) { continue; }\n                    if (cc2 == cc) { matched = 1; break; }\n                    if (cc2 == 92) {        // \\\n                        if (chunkerCurrentIndex == len - 1) {\n                            return fail('unescaped `\\\\`', chunkerCurrentIndex);\n                        }\n                        chunkerCurrentIndex++;\n                    }\n                }\n                if (matched) { continue; }\n                return fail('unmatched `' + String.fromCharCode(cc) + '`', currentChunkStartIndex);\n            case 47:                        // /, check for comment\n                if (parenLevel || (chunkerCurrentIndex == len - 1)) { continue; }\n                cc2 = input.charCodeAt(chunkerCurrentIndex + 1);\n                if (cc2 == 47) {\n                    // //, find lnfeed\n                    for (chunkerCurrentIndex = chunkerCurrentIndex + 2; chunkerCurrentIndex < len; chunkerCurrentIndex++) {\n                        cc2 = input.charCodeAt(chunkerCurrentIndex);\n                        if ((cc2 <= 13) && ((cc2 == 10) || (cc2 == 13))) { break; }\n                    }\n                } else if (cc2 == 42) {\n                    // /*, find */\n                    lastMultiComment = currentChunkStartIndex = chunkerCurrentIndex;\n                    for (chunkerCurrentIndex = chunkerCurrentIndex + 2; chunkerCurrentIndex < len - 1; chunkerCurrentIndex++) {\n                        cc2 = input.charCodeAt(chunkerCurrentIndex);\n                        if (cc2 == 125) { lastMultiCommentEndBrace = chunkerCurrentIndex; }\n                        if (cc2 != 42) { continue; }\n                        if (input.charCodeAt(chunkerCurrentIndex + 1) == 47) { break; }\n                    }\n                    if (chunkerCurrentIndex == len - 1) {\n                        return fail('missing closing `*/`', currentChunkStartIndex);\n                    }\n                    chunkerCurrentIndex++;\n                }\n                continue;\n            case 42:                       // *, check for unmatched */\n                if ((chunkerCurrentIndex < len - 1) && (input.charCodeAt(chunkerCurrentIndex + 1) == 47)) {\n                    return fail('unmatched `/*`', chunkerCurrentIndex);\n                }\n                continue;\n        }\n    }\n\n    if (level !== 0) {\n        if ((lastMultiComment > lastOpening) && (lastMultiCommentEndBrace > lastMultiComment)) {\n            return fail('missing closing `}` or `*/`', lastOpening);\n        } else {\n            return fail('missing closing `}`', lastOpening);\n        }\n    } else if (parenLevel !== 0) {\n        return fail('missing closing `)`', lastOpeningParen);\n    }\n\n    emitChunk(true);\n    return chunks;\n};\n\n},{}],43:[function(require,module,exports){\nvar chunker = require('./chunker');\n\nmodule.exports = function() {\n    var input,       // Less input string\n        j,           // current chunk\n        saveStack = [],   // holds state for backtracking\n        furthest,    // furthest index the parser has gone to\n        furthestPossibleErrorMessage, // if this is furthest we got to, this is the probably cause\n        chunks,      // chunkified input\n        current,     // current chunk\n        currentPos,  // index of current chunk, in `input`\n        parserInput = {};\n\n    var CHARCODE_SPACE = 32,\n        CHARCODE_TAB = 9,\n        CHARCODE_LF = 10,\n        CHARCODE_CR = 13,\n        CHARCODE_PLUS = 43,\n        CHARCODE_COMMA = 44,\n        CHARCODE_FORWARD_SLASH = 47,\n        CHARCODE_9 = 57;\n\n    function skipWhitespace(length) {\n        var oldi = parserInput.i, oldj = j,\n            curr = parserInput.i - currentPos,\n            endIndex = parserInput.i + current.length - curr,\n            mem = (parserInput.i += length),\n            inp = input,\n            c, nextChar, comment;\n\n        for (; parserInput.i < endIndex; parserInput.i++) {\n            c = inp.charCodeAt(parserInput.i);\n\n            if (parserInput.autoCommentAbsorb && c === CHARCODE_FORWARD_SLASH) {\n                nextChar = inp.charAt(parserInput.i + 1);\n                if (nextChar === '/') {\n                    comment = {index: parserInput.i, isLineComment: true};\n                    var nextNewLine = inp.indexOf('\\n', parserInput.i + 2);\n                    if (nextNewLine < 0) {\n                        nextNewLine = endIndex;\n                    }\n                    parserInput.i = nextNewLine;\n                    comment.text = inp.substr(comment.index, parserInput.i - comment.index);\n                    parserInput.commentStore.push(comment);\n                    continue;\n                } else if (nextChar === '*') {\n                    var nextStarSlash = inp.indexOf('*/', parserInput.i + 2);\n                    if (nextStarSlash >= 0) {\n                        comment = {\n                            index: parserInput.i,\n                            text: inp.substr(parserInput.i, nextStarSlash + 2 - parserInput.i),\n                            isLineComment: false\n                        };\n                        parserInput.i += comment.text.length - 1;\n                        parserInput.commentStore.push(comment);\n                        continue;\n                    }\n                }\n                break;\n            }\n\n            if ((c !== CHARCODE_SPACE) && (c !== CHARCODE_LF) && (c !== CHARCODE_TAB) && (c !== CHARCODE_CR)) {\n                break;\n            }\n        }\n\n        current = current.slice(length + parserInput.i - mem + curr);\n        currentPos = parserInput.i;\n\n        if (!current.length) {\n            if (j < chunks.length - 1) {\n                current = chunks[++j];\n                skipWhitespace(0); // skip space at the beginning of a chunk\n                return true; // things changed\n            }\n            parserInput.finished = true;\n        }\n\n        return oldi !== parserInput.i || oldj !== j;\n    }\n\n    parserInput.save = function() {\n        currentPos = parserInput.i;\n        saveStack.push( { current: current, i: parserInput.i, j: j });\n    };\n    parserInput.restore = function(possibleErrorMessage) {\n\n        if (parserInput.i > furthest || (parserInput.i === furthest && possibleErrorMessage && !furthestPossibleErrorMessage)) {\n            furthest = parserInput.i;\n            furthestPossibleErrorMessage = possibleErrorMessage;\n        }\n        var state = saveStack.pop();\n        current = state.current;\n        currentPos = parserInput.i = state.i;\n        j = state.j;\n    };\n    parserInput.forget = function() {\n        saveStack.pop();\n    };\n    parserInput.isWhitespace = function (offset) {\n        var pos = parserInput.i + (offset || 0),\n            code = input.charCodeAt(pos);\n        return (code === CHARCODE_SPACE || code === CHARCODE_CR || code === CHARCODE_TAB || code === CHARCODE_LF);\n    };\n\n    // Specialization of $(tok)\n    parserInput.$re = function(tok) {\n        if (parserInput.i > currentPos) {\n            current = current.slice(parserInput.i - currentPos);\n            currentPos = parserInput.i;\n        }\n\n        var m = tok.exec(current);\n        if (!m) {\n            return null;\n        }\n\n        skipWhitespace(m[0].length);\n        if (typeof m === 'string') {\n            return m;\n        }\n\n        return m.length === 1 ? m[0] : m;\n    };\n\n    parserInput.$char = function(tok) {\n        if (input.charAt(parserInput.i) !== tok) {\n            return null;\n        }\n        skipWhitespace(1);\n        return tok;\n    };\n\n    parserInput.$str = function(tok) {\n        var tokLength = tok.length;\n\n        // https://jsperf.com/string-startswith/21\n        for (var i = 0; i < tokLength; i++) {\n            if (input.charAt(parserInput.i + i) !== tok.charAt(i)) {\n                return null;\n            }\n        }\n\n        skipWhitespace(tokLength);\n        return tok;\n    };\n\n    parserInput.$quoted = function(loc) {\n        var pos = loc || parserInput.i,\n            startChar = input.charAt(pos);\n\n        if (startChar !== '\\'' && startChar !== '\"') {\n            return;\n        }\n        var length = input.length,\n            currentPosition = pos;\n\n        for (var i = 1; i + currentPosition < length; i++) {\n            var nextChar = input.charAt(i + currentPosition);\n            switch (nextChar) {\n                case '\\\\':\n                    i++;\n                    continue;\n                case '\\r':\n                case '\\n':\n                    break;\n                case startChar:\n                    var str = input.substr(currentPosition, i + 1);\n                    if (!loc && loc !== 0) {\n                        skipWhitespace(i + 1);\n                        return str\n                    }\n                    return [startChar, str];\n                default:\n            }\n        }\n        return null;\n    };\n\n    /**\n     * Permissive parsing. Ignores everything except matching {} [] () and quotes\n     * until matching token (outside of blocks)\n     */\n    parserInput.$parseUntil = function(tok) {\n        var quote = '',\n            returnVal = null,\n            inComment = false,\n            blockDepth = 0,\n            blockStack = [],\n            parseGroups = [],\n            length = input.length,\n            startPos = parserInput.i,\n            lastPos = parserInput.i,\n            i = parserInput.i,\n            loop = true,\n            testChar;\n\n        if (typeof tok === 'string') {\n            testChar = function(char) {\n                return char === tok;\n            }\n        } else {\n            testChar = function(char) {\n                return tok.test(char);\n            }\n        }\n\n        do {\n            var prevChar, nextChar = input.charAt(i);\n            if (blockDepth === 0 && testChar(nextChar)) {\n                returnVal = input.substr(lastPos, i - lastPos);\n                if (returnVal) {\n                    parseGroups.push(returnVal);\n                }\n                else {\n                    parseGroups.push(' ');\n                }\n                returnVal = parseGroups;\n                skipWhitespace(i - startPos);\n                loop = false\n            } else {\n                if (inComment) {\n                    if (nextChar === '*' && \n                        input.charAt(i + 1) === '/') {\n                        i++;\n                        blockDepth--;\n                        inComment = false;\n                    }\n                    i++;\n                    continue;\n                }\n                switch (nextChar) {\n                    case '\\\\':\n                        i++;\n                        nextChar = input.charAt(i);\n                        parseGroups.push(input.substr(lastPos, i - lastPos + 1));\n                        lastPos = i + 1;\n                        break;\n                    case '/':\n                        if (input.charAt(i + 1) === '*') {\n                            i++;\n                            inComment = true;\n                            blockDepth++;\n                        }\n                        break;\n                    case '\\'':\n                    case '\"':\n                        quote = parserInput.$quoted(i);\n                        if (quote) {\n                            parseGroups.push(input.substr(lastPos, i - lastPos), quote);\n                            i += quote[1].length - 1;\n                            lastPos = i + 1;\n                        }\n                        else {\n                            skipWhitespace(i - startPos);\n                            returnVal = nextChar;\n                            loop = false;\n                        }\n                        break;\n                    case '{':\n                        blockStack.push('}');\n                        blockDepth++;\n                        break;\n                    case '(':\n                        blockStack.push(')');\n                        blockDepth++;\n                        break;\n                    case '[':\n                        blockStack.push(']');\n                        blockDepth++;\n                        break;\n                    case '}':\n                    case ')':\n                    case ']':\n                        var expected = blockStack.pop();\n                        if (nextChar === expected) {\n                            blockDepth--;\n                        } else {\n                            // move the parser to the error and return expected\n                            skipWhitespace(i - startPos);\n                            returnVal = expected;\n                            loop = false;\n                        }\n                }\n                i++;\n                if (i > length) {\n                    loop = false;\n                }\n            }\n            prevChar = nextChar;\n        } while (loop);\n\n        return returnVal ? returnVal : null;\n    }\n\n    parserInput.autoCommentAbsorb = true;\n    parserInput.commentStore = [];\n    parserInput.finished = false;\n\n    // Same as $(), but don't change the state of the parser,\n    // just return the match.\n    parserInput.peek = function(tok) {\n        if (typeof tok === 'string') {\n            // https://jsperf.com/string-startswith/21\n            for (var i = 0; i < tok.length; i++) {\n                if (input.charAt(parserInput.i + i) !== tok.charAt(i)) {\n                    return false;\n                }\n            }\n            return true;\n        } else {\n            return tok.test(current);\n        }\n    };\n\n    // Specialization of peek()\n    // TODO remove or change some currentChar calls to peekChar\n    parserInput.peekChar = function(tok) {\n        return input.charAt(parserInput.i) === tok;\n    };\n\n    parserInput.currentChar = function() {\n        return input.charAt(parserInput.i);\n    };\n\n    parserInput.prevChar = function() {\n        return input.charAt(parserInput.i - 1);\n    };\n\n    parserInput.getInput = function() {\n        return input;\n    };\n\n    parserInput.peekNotNumeric = function() {\n        var c = input.charCodeAt(parserInput.i);\n        // Is the first char of the dimension 0-9, '.', '+' or '-'\n        return (c > CHARCODE_9 || c < CHARCODE_PLUS) || c === CHARCODE_FORWARD_SLASH || c === CHARCODE_COMMA;\n    };\n\n    parserInput.start = function(str, chunkInput, failFunction) {\n        input = str;\n        parserInput.i = j = currentPos = furthest = 0;\n\n        // chunking apparently makes things quicker (but my tests indicate\n        // it might actually make things slower in node at least)\n        // and it is a non-perfect parse - it can't recognise\n        // unquoted urls, meaning it can't distinguish comments\n        // meaning comments with quotes or {}() in them get 'counted'\n        // and then lead to parse errors.\n        // In addition if the chunking chunks in the wrong place we might\n        // not be able to parse a parser statement in one go\n        // this is officially deprecated but can be switched on via an option\n        // in the case it causes too much performance issues.\n        if (chunkInput) {\n            chunks = chunker(str, failFunction);\n        } else {\n            chunks = [str];\n        }\n\n        current = chunks[0];\n\n        skipWhitespace(0);\n    };\n\n    parserInput.end = function() {\n        var message,\n            isFinished = parserInput.i >= input.length;\n\n        if (parserInput.i < furthest) {\n            message = furthestPossibleErrorMessage;\n            parserInput.i = furthest;\n        }\n        return {\n            isFinished: isFinished,\n            furthest: parserInput.i,\n            furthestPossibleErrorMessage: message,\n            furthestReachedEnd: parserInput.i >= input.length - 1,\n            furthestChar: input[parserInput.i]\n        };\n    };\n\n    return parserInput;\n};\n\n},{\"./chunker\":42}],44:[function(require,module,exports){\nvar LessError = require('../less-error'),\n    tree = require('../tree'),\n    visitors = require('../visitors'),\n    getParserInput = require('./parser-input'),\n    utils = require('../utils'),\n    functionRegistry = require('../functions/function-registry');\n\n//\n// less.js - parser\n//\n//    A relatively straight-forward predictive parser.\n//    There is no tokenization/lexing stage, the input is parsed\n//    in one sweep.\n//\n//    To make the parser fast enough to run in the browser, several\n//    optimization had to be made:\n//\n//    - Matching and slicing on a huge input is often cause of slowdowns.\n//      The solution is to chunkify the input into smaller strings.\n//      The chunks are stored in the `chunks` var,\n//      `j` holds the current chunk index, and `currentPos` holds\n//      the index of the current chunk in relation to `input`.\n//      This gives us an almost 4x speed-up.\n//\n//    - In many cases, we don't need to match individual tokens;\n//      for example, if a value doesn't hold any variables, operations\n//      or dynamic references, the parser can effectively 'skip' it,\n//      treating it as a literal.\n//      An example would be '1px solid #000' - which evaluates to itself,\n//      we don't need to know what the individual components are.\n//      The drawback, of course is that you don't get the benefits of\n//      syntax-checking on the CSS. This gives us a 50% speed-up in the parser,\n//      and a smaller speed-up in the code-gen.\n//\n//\n//    Token matching is done with the `$` function, which either takes\n//    a terminal string or regexp, or a non-terminal function to call.\n//    It also takes care of moving all the indices forwards.\n//\n\nvar Parser = function Parser(context, imports, fileInfo) {\n    var parsers,\n        parserInput = getParserInput();\n\n    function error(msg, type) {\n        throw new LessError(\n            {\n                index: parserInput.i,\n                filename: fileInfo.filename,\n                type: type || 'Syntax',\n                message: msg\n            },\n            imports\n        );\n    }\n\n    function expect(arg, msg) {\n        // some older browsers return typeof 'function' for RegExp\n        var result = (arg instanceof Function) ? arg.call(parsers) : parserInput.$re(arg);\n        if (result) {\n            return result;\n        }\n        \n        error(msg || (typeof arg === 'string'\n            ? 'expected \\'' + arg + '\\' got \\'' + parserInput.currentChar() + '\\''\n            : 'unexpected token'));\n    }\n\n    // Specialization of expect()\n    function expectChar(arg, msg) {\n        if (parserInput.$char(arg)) {\n            return arg;\n        }\n        error(msg || 'expected \\'' + arg + '\\' got \\'' + parserInput.currentChar() + '\\'');\n    }\n\n    function getDebugInfo(index) {\n        var filename = fileInfo.filename;\n\n        return {\n            lineNumber: utils.getLocation(index, parserInput.getInput()).line + 1,\n            fileName: filename\n        };\n    }\n\n    /**\n     *  Used after initial parsing to create nodes on the fly\n     * \n     *  @param {String} str          - string to parse \n     *  @param {Array}  parseList    - array of parsers to run input through e.g. [\"value\", \"important\"]\n     *  @param {Number} currentIndex - start number to begin indexing\n     *  @param {Object} fileInfo     - fileInfo to attach to created nodes\n     */\n    function parseNode(str, parseList, currentIndex, fileInfo, callback) {\n        var result, returnNodes = [];\n        var parser = parserInput;\n\n        try {\n            parser.start(str, false, function fail(msg, index) {\n                callback({\n                    message: msg,\n                    index: index + currentIndex\n                });\n            });\n            for (var x = 0, p, i; (p = parseList[x]); x++) {\n                i = parser.i;\n                result = parsers[p]();\n                if (result) {\n                    result._index = i + currentIndex;\n                    result._fileInfo = fileInfo;\n                    returnNodes.push(result);\n                }\n                else {\n                    returnNodes.push(null);\n                }\n            }\n\n            var endInfo = parser.end();\n            if (endInfo.isFinished) {\n                callback(null, returnNodes);\n            }\n            else {\n                callback(true, null);\n            }\n        } catch (e) {\n            throw new LessError({\n                index: e.index + currentIndex,\n                message: e.message\n            }, imports, fileInfo.filename);\n        }\n    }\n    \n    //\n    // The Parser\n    //\n    return {\n        parserInput: parserInput,\n        imports: imports,\n        fileInfo: fileInfo,\n        parseNode: parseNode,\n        //\n        // Parse an input string into an abstract syntax tree,\n        // @param str A string containing 'less' markup\n        // @param callback call `callback` when done.\n        // @param [additionalData] An optional map which can contains vars - a map (key, value) of variables to apply\n        //\n        parse: function (str, callback, additionalData) {\n            var root, error = null, globalVars, modifyVars, ignored, preText = '';\n\n            globalVars = (additionalData && additionalData.globalVars) ? Parser.serializeVars(additionalData.globalVars) + '\\n' : '';\n            modifyVars = (additionalData && additionalData.modifyVars) ? '\\n' + Parser.serializeVars(additionalData.modifyVars) : '';\n\n            if (context.pluginManager) {\n                var preProcessors = context.pluginManager.getPreProcessors();\n                for (var i = 0; i < preProcessors.length; i++) {\n                    str = preProcessors[i].process(str, { context: context, imports: imports, fileInfo: fileInfo });\n                }\n            }\n\n            if (globalVars || (additionalData && additionalData.banner)) {\n                preText = ((additionalData && additionalData.banner) ? additionalData.banner : '') + globalVars;\n                ignored = imports.contentsIgnoredChars;\n                ignored[fileInfo.filename] = ignored[fileInfo.filename] || 0;\n                ignored[fileInfo.filename] += preText.length;\n            }\n\n            str = str.replace(/\\r\\n?/g, '\\n');\n            // Remove potential UTF Byte Order Mark\n            str = preText + str.replace(/^\\uFEFF/, '') + modifyVars;\n            imports.contents[fileInfo.filename] = str;\n\n            // Start with the primary rule.\n            // The whole syntax tree is held under a Ruleset node,\n            // with the `root` property set to true, so no `{}` are\n            // output. The callback is called when the input is parsed.\n            try {\n                parserInput.start(str, context.chunkInput, function fail(msg, index) {\n                    throw new LessError({\n                        index: index,\n                        type: 'Parse',\n                        message: msg,\n                        filename: fileInfo.filename\n                    }, imports);\n                });\n\n                tree.Node.prototype.parse = this;\n                root = new tree.Ruleset(null, this.parsers.primary());\n                tree.Node.prototype.rootNode = root;\n                root.root = true;\n                root.firstRoot = true;\n                root.functionRegistry = functionRegistry.inherit();\n                \n            } catch (e) {\n                return callback(new LessError(e, imports, fileInfo.filename));\n            }\n\n            // If `i` is smaller than the `input.length - 1`,\n            // it means the parser wasn't able to parse the whole\n            // string, so we've got a parsing error.\n            //\n            // We try to extract a \\n delimited string,\n            // showing the line where the parse error occurred.\n            // We split it up into two parts (the part which parsed,\n            // and the part which didn't), so we can color them differently.\n            var endInfo = parserInput.end();\n            if (!endInfo.isFinished) {\n\n                var message = endInfo.furthestPossibleErrorMessage;\n\n                if (!message) {\n                    message = 'Unrecognised input';\n                    if (endInfo.furthestChar === '}') {\n                        message += '. Possibly missing opening \\'{\\'';\n                    } else if (endInfo.furthestChar === ')') {\n                        message += '. Possibly missing opening \\'(\\'';\n                    } else if (endInfo.furthestReachedEnd) {\n                        message += '. Possibly missing something';\n                    }\n                }\n\n                error = new LessError({\n                    type: 'Parse',\n                    message: message,\n                    index: endInfo.furthest,\n                    filename: fileInfo.filename\n                }, imports);\n            }\n\n            var finish = function (e) {\n                e = error || e || imports.error;\n\n                if (e) {\n                    if (!(e instanceof LessError)) {\n                        e = new LessError(e, imports, fileInfo.filename);\n                    }\n\n                    return callback(e);\n                }\n                else {\n                    return callback(null, root);\n                }\n            };\n\n            if (context.processImports !== false) {\n                new visitors.ImportVisitor(imports, finish)\n                    .run(root);\n            } else {\n                return finish();\n            }\n        },\n\n        //\n        // Here in, the parsing rules/functions\n        //\n        // The basic structure of the syntax tree generated is as follows:\n        //\n        //   Ruleset ->  Declaration -> Value -> Expression -> Entity\n        //\n        // Here's some Less code:\n        //\n        //    .class {\n        //      color: #fff;\n        //      border: 1px solid #000;\n        //      width: @w + 4px;\n        //      > .child {...}\n        //    }\n        //\n        // And here's what the parse tree might look like:\n        //\n        //     Ruleset (Selector '.class', [\n        //         Declaration (\"color\",  Value ([Expression [Color #fff]]))\n        //         Declaration (\"border\", Value ([Expression [Dimension 1px][Keyword \"solid\"][Color #000]]))\n        //         Declaration (\"width\",  Value ([Expression [Operation \" + \" [Variable \"@w\"][Dimension 4px]]]))\n        //         Ruleset (Selector [Element '>', '.child'], [...])\n        //     ])\n        //\n        //  In general, most rules will try to parse a token with the `$re()` function, and if the return\n        //  value is truly, will return a new node, of the relevant type. Sometimes, we need to check\n        //  first, before parsing, that's when we use `peek()`.\n        //\n        parsers: parsers = {\n            //\n            // The `primary` rule is the *entry* and *exit* point of the parser.\n            // The rules here can appear at any level of the parse tree.\n            //\n            // The recursive nature of the grammar is an interplay between the `block`\n            // rule, which represents `{ ... }`, the `ruleset` rule, and this `primary` rule,\n            // as represented by this simplified grammar:\n            //\n            //     primary    (ruleset | declaration)+\n            //     ruleset    selector+ block\n            //     block      '{' primary '}'\n            //\n            // Only at one point is the primary rule not called from the\n            // block rule: at the root level.\n            //\n            primary: function () {\n                var mixin = this.mixin, root = [], node;\n\n                while (true) {\n                    while (true) {\n                        node = this.comment();\n                        if (!node) { break; }\n                        root.push(node);\n                    }\n                    // always process comments before deciding if finished\n                    if (parserInput.finished) {\n                        break;\n                    }\n                    if (parserInput.peek('}')) {\n                        break;\n                    }\n\n                    node = this.extendRule();\n                    if (node) {\n                        root = root.concat(node);\n                        continue;\n                    }\n\n                    node = mixin.definition() || this.declaration() || this.ruleset() ||\n                        mixin.call(false, false) || this.variableCall() || this.entities.call() || this.atrule();\n                    if (node) {\n                        root.push(node);\n                    } else {\n                        var foundSemiColon = false;\n                        while (parserInput.$char(';')) {\n                            foundSemiColon = true;\n                        }\n                        if (!foundSemiColon) {\n                            break;\n                        }\n                    }\n                }\n\n                return root;\n            },\n\n            // comments are collected by the main parsing mechanism and then assigned to nodes\n            // where the current structure allows it\n            comment: function () {\n                if (parserInput.commentStore.length) {\n                    var comment = parserInput.commentStore.shift();\n                    return new(tree.Comment)(comment.text, comment.isLineComment, comment.index, fileInfo);\n                }\n            },\n\n            //\n            // Entities are tokens which can be found inside an Expression\n            //\n            entities: {\n                mixinLookup: function() {\n                    return parsers.mixin.call(true, true);\n                },\n                //\n                // A string, which supports escaping \" and '\n                //\n                //     \"milky way\" 'he\\'s the one!'\n                //\n                quoted: function (forceEscaped) {\n                    var str, index = parserInput.i, isEscaped = false;\n\n                    parserInput.save();\n                    if (parserInput.$char('~')) {\n                        isEscaped = true;\n                    } else if (forceEscaped) {\n                        parserInput.restore();\n                        return;\n                    }\n\n                    str = parserInput.$quoted();\n                    if (!str) {\n                        parserInput.restore();\n                        return;\n                    }\n                    parserInput.forget();\n\n                    return new(tree.Quoted)(str.charAt(0), str.substr(1, str.length - 2), isEscaped, index, fileInfo);\n                },\n\n                //\n                // A catch-all word, such as:\n                //\n                //     black border-collapse\n                //\n                keyword: function () {\n                    var k = parserInput.$char('%') || parserInput.$re(/^\\[?(?:[\\w-]|\\\\(?:[A-Fa-f0-9]{1,6} ?|[^A-Fa-f0-9]))+\\]?/);\n                    if (k) {\n                        return tree.Color.fromKeyword(k) || new(tree.Keyword)(k);\n                    }\n                },\n\n                //\n                // A function call\n                //\n                //     rgb(255, 0, 255)\n                //\n                // The arguments are parsed with the `entities.arguments` parser.\n                //\n                call: function () {\n                    var name, args, func, index = parserInput.i;\n\n                    // http://jsperf.com/case-insensitive-regex-vs-strtolower-then-regex/18\n                    if (parserInput.peek(/^url\\(/i)) {\n                        return;\n                    }\n\n                    parserInput.save();\n\n                    name = parserInput.$re(/^([\\w-]+|%|progid:[\\w\\.]+)\\(/);\n                    if (!name) {\n                        parserInput.forget(); \n                        return;\n                    }\n\n                    name = name[1];\n                    func = this.customFuncCall(name);\n                    if (func) {\n                        args = func.parse();\n                        if (args && func.stop) {\n                            parserInput.forget();\n                            return args;\n                        }\n                    }\n\n                    args = this.arguments(args);\n\n                    if (!parserInput.$char(')')) {\n                        parserInput.restore('Could not parse call arguments or missing \\')\\'');\n                        return;\n                    }\n\n                    parserInput.forget();\n                    \n                    return new(tree.Call)(name, args, index, fileInfo);\n                },\n                \n                //\n                // Parsing rules for functions with non-standard args, e.g.:\n                //\n                //     boolean(not(2 > 1))\n                //\n                //     This is a quick prototype, to be modified/improved when\n                //     more custom-parsed funcs come (e.g. `selector(...)`)\n                //\n\n                customFuncCall: function (name) {\n                    /* Ideally the table is to be moved out of here for faster perf.,\n                       but it's quite tricky since it relies on all these `parsers`\n                       and `expect` available only here */\n                    return {\n                        alpha:   f(parsers.ieAlpha, true),\n                        boolean: f(condition),\n                        'if':    f(condition)\n                    }[name.toLowerCase()];\n\n                    function f(parse, stop) {\n                        return {\n                            parse: parse, // parsing function\n                            stop:  stop   // when true - stop after parse() and return its result, \n                                          // otherwise continue for plain args\n                        };\n                    }\n                \n                    function condition() {\n                        return [expect(parsers.condition, 'expected condition')];\n                    }\n                },\n\n                arguments: function (prevArgs) {\n                    var argsComma = prevArgs || [],\n                        argsSemiColon = [],\n                        isSemiColonSeparated, value;\n\n                    parserInput.save();\n\n                    while (true) {\n                        if (prevArgs) {\n                            prevArgs = false;\n                        } else {\n                            value = parsers.detachedRuleset() || this.assignment() || parsers.expression();\n                            if (!value) {\n                                break;\n                            }\n\n                            if (value.value && value.value.length == 1) {\n                                value = value.value[0];\n                            }\n\n                            argsComma.push(value);\n                        }\n\n                        if (parserInput.$char(',')) {\n                            continue;\n                        }\n\n                        if (parserInput.$char(';') || isSemiColonSeparated) {\n                            isSemiColonSeparated = true;\n                            value = (argsComma.length < 1) ? argsComma[0]\n                                : new tree.Value(argsComma);\n                            argsSemiColon.push(value);\n                            argsComma = [];\n                        }\n                    }\n\n                    parserInput.forget();\n                    return isSemiColonSeparated ? argsSemiColon : argsComma;\n                },\n                literal: function () {\n                    return this.dimension() ||\n                           this.color() ||\n                           this.quoted() ||\n                           this.unicodeDescriptor();\n                },\n\n                // Assignments are argument entities for calls.\n                // They are present in ie filter properties as shown below.\n                //\n                //     filter: progid:DXImageTransform.Microsoft.Alpha( *opacity=50* )\n                //\n\n                assignment: function () {\n                    var key, value;\n                    parserInput.save();\n                    key = parserInput.$re(/^\\w+(?=\\s?=)/i);\n                    if (!key) {\n                        parserInput.restore();\n                        return;\n                    }\n                    if (!parserInput.$char('=')) {\n                        parserInput.restore();\n                        return;\n                    }\n                    value = parsers.entity();\n                    if (value) {\n                        parserInput.forget();\n                        return new(tree.Assignment)(key, value);\n                    } else {\n                        parserInput.restore();\n                    }\n                },\n\n                //\n                // Parse url() tokens\n                //\n                // We use a specific rule for urls, because they don't really behave like\n                // standard function calls. The difference is that the argument doesn't have\n                // to be enclosed within a string, so it can't be parsed as an Expression.\n                //\n                url: function () {\n                    var value, index = parserInput.i;\n\n                    parserInput.autoCommentAbsorb = false;\n\n                    if (!parserInput.$str('url(')) {\n                        parserInput.autoCommentAbsorb = true;\n                        return;\n                    }\n\n                    value = this.quoted() || this.variable() || this.property() ||\n                            parserInput.$re(/^(?:(?:\\\\[\\(\\)'\"])|[^\\(\\)'\"])+/) || '';\n\n                    parserInput.autoCommentAbsorb = true;\n\n                    expectChar(')');\n\n                    return new(tree.URL)((value.value != null || \n                        value instanceof tree.Variable || \n                        value instanceof tree.Property) ?\n                        value : new(tree.Anonymous)(value, index), index, fileInfo);\n                },\n\n                //\n                // A Variable entity, such as `@fink`, in\n                //\n                //     width: @fink + 2px\n                //\n                // We use a different parser for variable definitions,\n                // see `parsers.variable`.\n                //\n                variable: function () {\n                    var ch, name, index = parserInput.i;\n\n                    parserInput.save();\n                    if (parserInput.currentChar() === '@' && (name = parserInput.$re(/^@@?[\\w-]+/))) {\n                        ch = parserInput.currentChar();\n                        if (ch === '(' || ch === '[' && !parserInput.prevChar().match(/^\\s/)) {\n                            // this may be a VariableCall lookup\n                            var result = parsers.variableCall(name);\n                            if (result) {\n                                parserInput.forget();\n                                return result;\n                            }\n                        }\n                        parserInput.forget();\n                        return new(tree.Variable)(name, index, fileInfo);\n                    }\n                    parserInput.restore();\n                },\n\n                // A variable entity using the protective {} e.g. @{var}\n                variableCurly: function () {\n                    var curly, index = parserInput.i;\n\n                    if (parserInput.currentChar() === '@' && (curly = parserInput.$re(/^@\\{([\\w-]+)\\}/))) {\n                        return new(tree.Variable)('@' + curly[1], index, fileInfo);\n                    }\n                },\n                //\n                // A Property accessor, such as `$color`, in\n                //\n                //     background-color: $color\n                //\n                property: function () {\n                    var name, index = parserInput.i;\n\n                    if (parserInput.currentChar() === '$' && (name = parserInput.$re(/^\\$[\\w-]+/))) {\n                        return new(tree.Property)(name, index, fileInfo);\n                    }\n                },\n\n                // A property entity useing the protective {} e.g. ${prop}\n                propertyCurly: function () {\n                    var curly, index = parserInput.i;\n\n                    if (parserInput.currentChar() === '$' && (curly = parserInput.$re(/^\\$\\{([\\w-]+)\\}/))) {\n                        return new(tree.Property)('$' + curly[1], index, fileInfo);\n                    }\n                },\n                //\n                // A Hexadecimal color\n                //\n                //     #4F3C2F\n                //\n                // `rgb` and `hsl` colors are parsed through the `entities.call` parser.\n                //\n                color: function () {\n                    var rgb;\n\n                    if (parserInput.currentChar() === '#' && (rgb = parserInput.$re(/^#([A-Fa-f0-9]{8}|[A-Fa-f0-9]{6}|[A-Fa-f0-9]{3,4})/))) {\n                        return new(tree.Color)(rgb[1], undefined, rgb[0]);\n                    }\n                },\n\n                colorKeyword: function () {\n                    parserInput.save();\n                    var autoCommentAbsorb = parserInput.autoCommentAbsorb;\n                    parserInput.autoCommentAbsorb = false;\n                    var k = parserInput.$re(/^[_A-Za-z-][_A-Za-z0-9-]+/);\n                    parserInput.autoCommentAbsorb = autoCommentAbsorb;\n                    if (!k) {\n                        parserInput.forget();\n                        return;\n                    }\n                    parserInput.restore();\n                    var color = tree.Color.fromKeyword(k);\n                    if (color) {\n                        parserInput.$str(k);\n                        return color;\n                    }\n                },\n\n                //\n                // A Dimension, that is, a number and a unit\n                //\n                //     0.5em 95%\n                //\n                dimension: function () {\n                    if (parserInput.peekNotNumeric()) {\n                        return;\n                    }\n\n                    var value = parserInput.$re(/^([+-]?\\d*\\.?\\d+)(%|[a-z_]+)?/i);\n                    if (value) {\n                        return new(tree.Dimension)(value[1], value[2]);\n                    }\n                },\n\n                //\n                // A unicode descriptor, as is used in unicode-range\n                //\n                // U+0??  or U+00A1-00A9\n                //\n                unicodeDescriptor: function () {\n                    var ud;\n\n                    ud = parserInput.$re(/^U\\+[0-9a-fA-F?]+(\\-[0-9a-fA-F?]+)?/);\n                    if (ud) {\n                        return new(tree.UnicodeDescriptor)(ud[0]);\n                    }\n                },\n\n                //\n                // JavaScript code to be evaluated\n                //\n                //     `window.location.href`\n                //\n                javascript: function () {\n                    var js, index = parserInput.i;\n\n                    parserInput.save();\n\n                    var escape = parserInput.$char('~');\n                    var jsQuote = parserInput.$char('`');\n\n                    if (!jsQuote) {\n                        parserInput.restore();\n                        return;\n                    }\n\n                    js = parserInput.$re(/^[^`]*`/);\n                    if (js) {\n                        parserInput.forget();\n                        return new(tree.JavaScript)(js.substr(0, js.length - 1), Boolean(escape), index, fileInfo);\n                    }\n                    parserInput.restore('invalid javascript definition');\n                }\n            },\n\n            //\n            // The variable part of a variable definition. Used in the `rule` parser\n            //\n            //     @fink:\n            //\n            variable: function () {\n                var name;\n\n                if (parserInput.currentChar() === '@' && (name = parserInput.$re(/^(@[\\w-]+)\\s*:/))) { return name[1]; }\n            },\n\n            //\n            // Call a variable value to retrieve a detached ruleset\n            // or a value from a detached ruleset's rules.\n            //\n            //     @fink();\n            //     @fink;\n            //     color: @fink[@color];\n            //\n            variableCall: function (parsedName) {\n                var lookups, important, i = parserInput.i,\n                    inValue = !!parsedName, name = parsedName;\n\n                parserInput.save();\n\n                if (name || (parserInput.currentChar() === '@'\n                    && (name = parserInput.$re(/^(@[\\w-]+)(\\(\\s*\\))?/)))) {\n\n                    lookups = this.mixin.ruleLookups();\n\n                    if (!lookups && ((inValue && parserInput.$str('()') !== '()') || (name[2] !== '()'))) {\n                        parserInput.restore('Missing \\'[...]\\' lookup in variable call');\n                        return;\n                    }\n\n                    if (!inValue) {\n                        name = name[1];\n                    }\n\n                    if (lookups && parsers.important()) {\n                        important = true;\n                    }\n\n                    var call = new tree.VariableCall(name, i, fileInfo);\n                    if (!inValue && parsers.end()) {\n                        parserInput.forget();\n                        return call;\n                    }\n                    else {\n                        parserInput.forget();\n                        return new tree.NamespaceValue(call, lookups, important, i, fileInfo);\n                    }\n                }\n\n                parserInput.restore();\n            },\n\n            //\n            // extend syntax - used to extend selectors\n            //\n            extend: function(isRule) {\n                var elements, e, index = parserInput.i, option, extendList, extend;\n\n                if (!parserInput.$str(isRule ? '&:extend(' : ':extend(')) {\n                    return;\n                }\n\n                do {\n                    option = null;\n                    elements = null;\n                    while (!(option = parserInput.$re(/^(all)(?=\\s*(\\)|,))/))) {\n                        e = this.element();\n                        if (!e) {\n                            break;\n                        }\n                        if (elements) {\n                            elements.push(e);\n                        } else {\n                            elements = [ e ];\n                        }\n                    }\n\n                    option = option && option[1];\n                    if (!elements) {\n                        error('Missing target selector for :extend().');\n                    }\n                    extend = new(tree.Extend)(new(tree.Selector)(elements), option, index, fileInfo);\n                    if (extendList) {\n                        extendList.push(extend);\n                    } else {\n                        extendList = [ extend ];\n                    }\n                } while (parserInput.$char(','));\n\n                expect(/^\\)/);\n\n                if (isRule) {\n                    expect(/^;/);\n                }\n\n                return extendList;\n            },\n\n            //\n            // extendRule - used in a rule to extend all the parent selectors\n            //\n            extendRule: function() {\n                return this.extend(true);\n            },\n\n            //\n            // Mixins\n            //\n            mixin: {\n                //\n                // A Mixin call, with an optional argument list\n                //\n                //     #mixins > .square(#fff);\n                //     #mixins.square(#fff);\n                //     .rounded(4px, black);\n                //     .button;\n                //\n                // We can lookup / return a value using the lookup syntax:\n                //\n                //     color: #mixin.square(#fff)[@color];\n                //\n                // The `while` loop is there because mixins can be\n                // namespaced, but we only support the child and descendant\n                // selector for now.\n                //\n                call: function (inValue, getLookup) {\n                    var s = parserInput.currentChar(), important = false, lookups,\n                        index = parserInput.i, elements, args, hasParens;\n\n                    if (s !== '.' && s !== '#') { return; }\n\n                    parserInput.save(); // stop us absorbing part of an invalid selector\n\n                    elements = this.elements();\n\n                    if (elements) {\n                        if (parserInput.$char('(')) {\n                            args = this.args(true).args;\n                            expectChar(')');\n                            hasParens = true;\n                        }\n\n                        if (getLookup !== false) {\n                            lookups = this.ruleLookups();\n                        }\n                        if (getLookup === true && !lookups) {\n                            parserInput.restore();\n                            return;\n                        }\n\n                        if (inValue && !lookups && !hasParens) {\n                            // This isn't a valid in-value mixin call\n                            parserInput.restore();\n                            return;\n                        }\n\n                        if (!inValue && parsers.important()) {\n                            important = true;\n                        }\n\n                        if (inValue || parsers.end()) {\n                            parserInput.forget();\n                            var mixin = new(tree.mixin.Call)(elements, args, index, fileInfo, !lookups && important);\n                            if (lookups) {\n                                return new tree.NamespaceValue(mixin, lookups, important);\n                            }\n                            else {\n                                return mixin;\n                            }\n                        }\n                    }\n\n                    parserInput.restore();\n                },\n                /**\n                 * Matching elements for mixins\n                 * (Start with . or # and can have > )\n                 */\n                elements: function() {\n                    var elements, e, c, elem, elemIndex,\n                        re = /^[#.](?:[\\w-]|\\\\(?:[A-Fa-f0-9]{1,6} ?|[^A-Fa-f0-9]))+/;\n                    while (true) {\n                        elemIndex = parserInput.i;\n                        e = parserInput.$re(re);\n                        \n                        if (!e) {\n                            break;\n                        }\n                        elem = new(tree.Element)(c, e, false, elemIndex, fileInfo);\n                        if (elements) {\n                            elements.push(elem);\n                        } else {\n                            elements = [ elem ];\n                        }\n                        c = parserInput.$char('>');\n                    }\n                    return elements;\n                },\n                args: function (isCall) {\n                    var entities = parsers.entities,\n                        returner = { args:null, variadic: false },\n                        expressions = [], argsSemiColon = [], argsComma = [],\n                        isSemiColonSeparated, expressionContainsNamed, name, nameLoop,\n                        value, arg, expand, hasSep = true; \n\n                    parserInput.save();\n\n                    while (true) {\n                        if (isCall) {\n                            arg = parsers.detachedRuleset() || parsers.expression();\n                        } else {\n                            parserInput.commentStore.length = 0;\n                            if (parserInput.$str('...')) {\n                                returner.variadic = true;\n                                if (parserInput.$char(';') && !isSemiColonSeparated) {\n                                    isSemiColonSeparated = true;\n                                }\n                                (isSemiColonSeparated ? argsSemiColon : argsComma)\n                                    .push({ variadic: true });\n                                break;\n                            }\n                            arg = entities.variable() || entities.property() || entities.literal() || entities.keyword() || this.call(true);\n                        }\n\n                        if (!arg || !hasSep) {\n                            break;\n                        }\n\n                        nameLoop = null;\n                        if (arg.throwAwayComments) {\n                            arg.throwAwayComments();\n                        }\n                        value = arg;\n                        var val = null;\n\n                        if (isCall) {\n                            // Variable\n                            if (arg.value && arg.value.length == 1) {\n                                val = arg.value[0];\n                            }\n                        } else {\n                            val = arg;\n                        }\n\n                        if (val && (val instanceof tree.Variable || val instanceof tree.Property)) {\n                            if (parserInput.$char(':')) {\n                                if (expressions.length > 0) {\n                                    if (isSemiColonSeparated) {\n                                        error('Cannot mix ; and , as delimiter types');\n                                    }\n                                    expressionContainsNamed = true;\n                                }\n\n                                value = parsers.detachedRuleset() || parsers.expression();\n\n                                if (!value) {\n                                    if (isCall) {\n                                        error('could not understand value for named argument');\n                                    } else {\n                                        parserInput.restore();\n                                        returner.args = [];\n                                        return returner;\n                                    }\n                                }\n                                nameLoop = (name = val.name);\n                            } else if (parserInput.$str('...')) {\n                                if (!isCall) {\n                                    returner.variadic = true;\n                                    if (parserInput.$char(';') && !isSemiColonSeparated) {\n                                        isSemiColonSeparated = true;\n                                    }\n                                    (isSemiColonSeparated ? argsSemiColon : argsComma)\n                                        .push({ name: arg.name, variadic: true });\n                                    break;\n                                } else {\n                                    expand = true;\n                                }\n                            } else if (!isCall) {\n                                name = nameLoop = val.name;\n                                value = null;\n                            }\n                        }\n\n                        if (value) {\n                            expressions.push(value);\n                        }\n\n                        argsComma.push({ name:nameLoop, value:value, expand:expand });\n\n                        if (parserInput.$char(',')) {\n                            hasSep = true;\n                            continue;\n                        }\n                        hasSep = parserInput.$char(';') === ';';\n\n                        if (hasSep || isSemiColonSeparated) {\n\n                            if (expressionContainsNamed) {\n                                error('Cannot mix ; and , as delimiter types');\n                            }\n\n                            isSemiColonSeparated = true;\n\n                            if (expressions.length > 1) {\n                                value = new(tree.Value)(expressions);\n                            }\n                            argsSemiColon.push({ name:name, value:value, expand:expand });\n\n                            name = null;\n                            expressions = [];\n                            expressionContainsNamed = false;\n                        }\n                    }\n\n                    parserInput.forget();\n                    returner.args = isSemiColonSeparated ? argsSemiColon : argsComma;\n                    return returner;\n                },\n                //\n                // A Mixin definition, with a list of parameters\n                //\n                //     .rounded (@radius: 2px, @color) {\n                //        ...\n                //     }\n                //\n                // Until we have a finer grained state-machine, we have to\n                // do a look-ahead, to make sure we don't have a mixin call.\n                // See the `rule` function for more information.\n                //\n                // We start by matching `.rounded (`, and then proceed on to\n                // the argument list, which has optional default values.\n                // We store the parameters in `params`, with a `value` key,\n                // if there is a value, such as in the case of `@radius`.\n                //\n                // Once we've got our params list, and a closing `)`, we parse\n                // the `{...}` block.\n                //\n                definition: function () {\n                    var name, params = [], match, ruleset, cond, variadic = false;\n                    if ((parserInput.currentChar() !== '.' && parserInput.currentChar() !== '#') ||\n                        parserInput.peek(/^[^{]*\\}/)) {\n                        return;\n                    }\n\n                    parserInput.save();\n\n                    match = parserInput.$re(/^([#.](?:[\\w-]|\\\\(?:[A-Fa-f0-9]{1,6} ?|[^A-Fa-f0-9]))+)\\s*\\(/);\n                    if (match) {\n                        name = match[1];\n\n                        var argInfo = this.args(false);\n                        params = argInfo.args;\n                        variadic = argInfo.variadic;\n\n                        // .mixincall(\"@{a}\");\n                        // looks a bit like a mixin definition..\n                        // also\n                        // .mixincall(@a: {rule: set;});\n                        // so we have to be nice and restore\n                        if (!parserInput.$char(')')) {\n                            parserInput.restore('Missing closing \\')\\'');\n                            return;\n                        }\n\n                        parserInput.commentStore.length = 0;\n\n                        if (parserInput.$str('when')) { // Guard\n                            cond = expect(parsers.conditions, 'expected condition');\n                        }\n\n                        ruleset = parsers.block();\n\n                        if (ruleset) {\n                            parserInput.forget();\n                            return new(tree.mixin.Definition)(name, params, ruleset, cond, variadic);\n                        } else {\n                            parserInput.restore();\n                        }\n                    } else {\n                        parserInput.forget();\n                    }\n                },\n            \n                ruleLookups: function() {\n                    var rule, args, lookups = [];\n\n                    if (parserInput.currentChar() !== '[') { \n                        return;\n                    }\n                    \n                    while (true) {\n                        parserInput.save();\n                        args = null;\n                        rule = this.lookupValue();\n                        if (!rule && rule !== '') {\n                            parserInput.restore();\n                            break;\n                        }\n                        lookups.push(rule);\n                        parserInput.forget();\n                    }\n                    if (lookups.length > 0) {\n                        return lookups;\n                    }\n                },\n    \n                lookupValue: function() {\n                    parserInput.save();\n    \n                    if (!parserInput.$char('[')) { \n                        parserInput.restore();\n                        return;\n                    }\n    \n                    var name = parserInput.$re(/^(?:[@$]{0,2})[_a-zA-Z0-9-]*/);\n    \n                    if (!parserInput.$char(']')) {\n                        parserInput.restore();\n                        return;\n                    } \n\n                    if (name || name === '') {\n                        parserInput.forget();\n                        return name;\n                    }\n    \n                    parserInput.restore();\n                }\n            },\n            //\n            // Entities are the smallest recognized token,\n            // and can be found inside a rule's value.\n            //\n            entity: function () {\n                var entities = this.entities;\n\n                return this.comment() || entities.literal() || entities.variable() || entities.url() ||\n                    entities.property() || entities.call() || entities.keyword() || this.mixin.call(true) ||\n                    entities.javascript();\n            },\n\n            //\n            // A Declaration terminator. Note that we use `peek()` to check for '}',\n            // because the `block` rule will be expecting it, but we still need to make sure\n            // it's there, if ';' was omitted.\n            //\n            end: function () {\n                return parserInput.$char(';') || parserInput.peek('}');\n            },\n\n            //\n            // IE's alpha function\n            //\n            //     alpha(opacity=88)\n            //\n            ieAlpha: function () {\n                var value;\n\n                // http://jsperf.com/case-insensitive-regex-vs-strtolower-then-regex/18\n                if (!parserInput.$re(/^opacity=/i)) { return; }\n                value = parserInput.$re(/^\\d+/);\n                if (!value) {\n                    value = expect(parsers.entities.variable, 'Could not parse alpha');\n                    value = '@{' + value.name.slice(1) + '}';\n                }\n                expectChar(')');\n                return new tree.Quoted('', 'alpha(opacity=' + value + ')');\n            },\n\n            //\n            // A Selector Element\n            //\n            //     div\n            //     + h1\n            //     #socks\n            //     input[type=\"text\"]\n            //\n            // Elements are the building blocks for Selectors,\n            // they are made out of a `Combinator` (see combinator rule),\n            // and an element name, such as a tag a class, or `*`.\n            //\n            element: function () {\n                var e, c, v, index = parserInput.i;\n\n                c = this.combinator();\n\n                e = parserInput.$re(/^(?:\\d+\\.\\d+|\\d+)%/) ||\n                    parserInput.$re(/^(?:[.#]?|:*)(?:[\\w-]|[^\\x00-\\x9f]|\\\\(?:[A-Fa-f0-9]{1,6} ?|[^A-Fa-f0-9]))+/) ||\n                    parserInput.$char('*') || parserInput.$char('&') || this.attribute() ||\n                    parserInput.$re(/^\\([^&()@]+\\)/) ||  parserInput.$re(/^[\\.#:](?=@)/) ||\n                    this.entities.variableCurly();\n\n                if (!e) {\n                    parserInput.save();\n                    if (parserInput.$char('(')) {\n                        if ((v = this.selector(false)) && parserInput.$char(')')) {\n                            e = new(tree.Paren)(v);\n                            parserInput.forget();\n                        } else {\n                            parserInput.restore('Missing closing \\')\\'');\n                        }\n                    } else {\n                        parserInput.forget();\n                    }\n                }\n\n                if (e) { return new(tree.Element)(c, e, e instanceof tree.Variable, index, fileInfo); }\n            },\n\n            //\n            // Combinators combine elements together, in a Selector.\n            //\n            // Because our parser isn't white-space sensitive, special care\n            // has to be taken, when parsing the descendant combinator, ` `,\n            // as it's an empty space. We have to check the previous character\n            // in the input, to see if it's a ` ` character. More info on how\n            // we deal with this in *combinator.js*.\n            //\n            combinator: function () {\n                var c = parserInput.currentChar();\n\n                if (c === '/') {\n                    parserInput.save();\n                    var slashedCombinator = parserInput.$re(/^\\/[a-z]+\\//i);\n                    if (slashedCombinator) {\n                        parserInput.forget();\n                        return new(tree.Combinator)(slashedCombinator);\n                    }\n                    parserInput.restore();\n                }\n\n                if (c === '>' || c === '+' || c === '~' || c === '|' || c === '^') {\n                    parserInput.i++;\n                    if (c === '^' && parserInput.currentChar() === '^') {\n                        c = '^^';\n                        parserInput.i++;\n                    }\n                    while (parserInput.isWhitespace()) { parserInput.i++; }\n                    return new(tree.Combinator)(c);\n                } else if (parserInput.isWhitespace(-1)) {\n                    return new(tree.Combinator)(' ');\n                } else {\n                    return new(tree.Combinator)(null);\n                }\n            },\n            //\n            // A CSS Selector\n            // with less extensions e.g. the ability to extend and guard\n            //\n            //     .class > div + h1\n            //     li a:hover\n            //\n            // Selectors are made out of one or more Elements, see above.\n            //\n            selector: function (isLess) {\n                var index = parserInput.i, elements, extendList, c, e, allExtends, when, condition;\n                isLess = isLess !== false;\n                while ((isLess && (extendList = this.extend())) || (isLess && (when = parserInput.$str('when'))) || (e = this.element())) {\n                    if (when) {\n                        condition = expect(this.conditions, 'expected condition');\n                    } else if (condition) {\n                        error('CSS guard can only be used at the end of selector');\n                    } else if (extendList) {\n                        if (allExtends) {\n                            allExtends = allExtends.concat(extendList);\n                        } else {\n                            allExtends = extendList;\n                        }\n                    } else {\n                        if (allExtends) { error('Extend can only be used at the end of selector'); }\n                        c = parserInput.currentChar();\n                        if (elements) {\n                            elements.push(e);\n                        } else {\n                            elements = [ e ];\n                        }\n                        e = null;\n                    }\n                    if (c === '{' || c === '}' || c === ';' || c === ',' || c === ')') {\n                        break;\n                    }\n                }\n\n                if (elements) { return new(tree.Selector)(elements, allExtends, condition, index, fileInfo); }\n                if (allExtends) { error('Extend must be used to extend a selector, it cannot be used on its own'); }\n            },\n            selectors: function () {\n                var s, selectors;\n                while (true) {\n                    s = this.selector();\n                    if (!s) {\n                        break;\n                    }\n                    if (selectors) {\n                        selectors.push(s);\n                    } else {\n                        selectors = [ s ];\n                    }\n                    parserInput.commentStore.length = 0;\n                    if (s.condition && selectors.length > 1) {\n                        error(\"Guards are only currently allowed on a single selector.\");\n                    }\n                    if (!parserInput.$char(',')) { break; }\n                    if (s.condition) {\n                        error(\"Guards are only currently allowed on a single selector.\");\n                    }\n                    parserInput.commentStore.length = 0;\n                }\n                return selectors;\n            },\n            attribute: function () {\n                if (!parserInput.$char('[')) { return; }\n\n                var entities = this.entities,\n                    key, val, op;\n\n                if (!(key = entities.variableCurly())) {\n                    key = expect(/^(?:[_A-Za-z0-9-\\*]*\\|)?(?:[_A-Za-z0-9-]|\\\\.)+/);\n                }\n\n                op = parserInput.$re(/^[|~*$^]?=/);\n                if (op) {\n                    val = entities.quoted() || parserInput.$re(/^[0-9]+%/) || parserInput.$re(/^[\\w-]+/) || entities.variableCurly();\n                }\n\n                expectChar(']');\n\n                return new(tree.Attribute)(key, op, val);\n            },\n\n            //\n            // The `block` rule is used by `ruleset` and `mixin.definition`.\n            // It's a wrapper around the `primary` rule, with added `{}`.\n            //\n            block: function () {\n                var content;\n                if (parserInput.$char('{') && (content = this.primary()) && parserInput.$char('}')) {\n                    return content;\n                }\n            },\n\n            blockRuleset: function() {\n                var block = this.block();\n\n                if (block) {\n                    block = new tree.Ruleset(null, block);\n                }\n                return block;\n            },\n\n            detachedRuleset: function() {\n                var argInfo, params, variadic;\n\n                parserInput.save();\n                if (parserInput.$re(/^[.#]\\(/)) {\n                    /**\n                     * DR args currently only implemented for each() function, and not \n                     * yet settable as `@dr: #(@arg) {}`\n                     * This should be done when DRs are merged with mixins.\n                     * See: https://github.com/less/less-meta/issues/16\n                     */\n                    argInfo = this.mixin.args(false);\n                    params = argInfo.args;\n                    variadic = argInfo.variadic;\n                    if (!parserInput.$char(')')) {\n                        parserInput.restore();\n                        return;\n                    }\n                }\n                var blockRuleset = this.blockRuleset();\n                if (blockRuleset) {\n                    parserInput.forget();\n                    if (params) {\n                        return new tree.mixin.Definition(null, params, blockRuleset, null, variadic);\n                    }\n                    return new tree.DetachedRuleset(blockRuleset);\n                }\n                parserInput.restore();\n            },\n\n            //\n            // div, .class, body > p {...}\n            //\n            ruleset: function () {\n                var selectors, rules, debugInfo;\n\n                parserInput.save();\n\n                if (context.dumpLineNumbers) {\n                    debugInfo = getDebugInfo(parserInput.i);\n                }\n\n                selectors = this.selectors();\n\n                if (selectors && (rules = this.block())) {\n                    parserInput.forget();\n                    var ruleset = new(tree.Ruleset)(selectors, rules, context.strictImports);\n                    if (context.dumpLineNumbers) {\n                        ruleset.debugInfo = debugInfo;\n                    }\n                    return ruleset;\n                } else {\n                    parserInput.restore();\n                }\n            },\n            declaration: function () {\n                var name, value, index = parserInput.i, hasDR,\n                    c = parserInput.currentChar(), important, merge, isVariable;\n\n                if (c === '.' || c === '#' || c === '&' || c === ':') { return; }\n\n                parserInput.save();\n\n                name = this.variable() || this.ruleProperty();\n                if (name) {\n                    isVariable = typeof name === 'string';\n\n                    if (isVariable) {\n                        value = this.detachedRuleset();\n                        if (value) {\n                            hasDR = true;\n                        }\n                    }\n\n                    parserInput.commentStore.length = 0;\n                    if (!value) {\n                        // a name returned by this.ruleProperty() is always an array of the form:\n                        // [string-1, ..., string-n, \"\"] or [string-1, ..., string-n, \"+\"]\n                        // where each item is a tree.Keyword or tree.Variable\n                        merge = !isVariable && name.length > 1 && name.pop().value;\n\n                        // Custom property values get permissive parsing\n                        if (name[0].value && name[0].value.slice(0, 2) === '--') {\n                            value = this.permissiveValue();\n                        }\n                        // Try to store values as anonymous\n                        // If we need the value later we'll re-parse it in ruleset.parseValue\n                        else {\n                            value = this.anonymousValue();\n                        }\n                        if (value) {\n                            parserInput.forget();\n                            // anonymous values absorb the end ';' which is required for them to work\n                            return new (tree.Declaration)(name, value, false, merge, index, fileInfo);\n                        }\n\n                        if (!value) {\n                            value = this.value();\n                        }\n\n                        if (value) {\n                            important = this.important();\n                        } else if (isVariable) {\n                            // As a last resort, try permissiveValue\n                            value = this.permissiveValue();\n                        }\n                    }\n\n                    if (value && (this.end() || hasDR)) {\n                        parserInput.forget();\n                        return new (tree.Declaration)(name, value, important, merge, index, fileInfo);\n                    }\n                    else {\n                        parserInput.restore();\n                    }\n                } else {\n                    parserInput.restore();\n                }\n            },\n            anonymousValue: function () {\n                var index = parserInput.i;\n                var match = parserInput.$re(/^([^.#@\\$+\\/'\"*`(;{}-]*);/);\n                if (match) {\n                    return new(tree.Anonymous)(match[1], index);\n                }\n            },\n            /**\n             * Used for custom properties, at-rules, and variables (as fallback)\n             * Parses almost anything inside of {} [] () \"\" blocks\n             * until it reaches outer-most tokens.\n             * \n             * First, it will try to parse comments and entities to reach\n             * the end. This is mostly like the Expression parser except no\n             * math is allowed.\n             */\n            permissiveValue: function (untilTokens) {\n                var i, e, done, value, \n                    tok = untilTokens || ';',\n                    index = parserInput.i, result = [];\n\n                function testCurrentChar() {\n                    var char = parserInput.currentChar();\n                    if (typeof tok === 'string') {\n                        return char === tok;\n                    } else {\n                        return tok.test(char);\n                    }\n                }\n                if (testCurrentChar()) {\n                    return;\n                }\n                value = [];\n                do {\n                    e = this.comment();\n                    if (e) {\n                        value.push(e);\n                        continue;\n                    }\n                    e = this.entity();\n                    if (e) {\n                        value.push(e);\n                    }\n                } while (e);\n\n                done = testCurrentChar();\n                \n                if (value.length > 0) {\n                    value = new(tree.Expression)(value);\n                    if (done) {\n                        return value;\n                    }\n                    else {\n                        result.push(value);\n                    }\n                    // Preserve space before $parseUntil as it will not\n                    if (parserInput.prevChar() === ' ') {\n                        result.push(new tree.Anonymous(' ', index));\n                    }\n                }\n                parserInput.save();\n                \n                value = parserInput.$parseUntil(tok);\n\n                if (value) {\n                    if (typeof value === 'string') {\n                        error('Expected \\'' + value + '\\'', 'Parse');\n                    }\n                    if (value.length === 1 && value[0] === ' ') {\n                        parserInput.forget();\n                        return new tree.Anonymous('', index);\n                    }\n                    var item;\n                    for (i = 0; i < value.length; i++) {\n                        item = value[i];\n                        if (Array.isArray(item)) {\n                            // Treat actual quotes as normal quoted values\n                            result.push(new tree.Quoted(item[0], item[1], true, index, fileInfo));\n                        }\n                        else {\n                            if (i === value.length - 1) {\n                                item = item.trim();\n                            }\n                            // Treat like quoted values, but replace vars like unquoted expressions\n                            var quote = new tree.Quoted('\\'', item, true, index, fileInfo);\n                            quote.variableRegex = /@([\\w-]+)/g;\n                            quote.propRegex = /\\$([\\w-]+)/g;\n                            result.push(quote);\n                        }\n                    }\n                    parserInput.forget();\n                    return new tree.Expression(result, true);\n                }\n                parserInput.restore();\n            },\n\n            //\n            // An @import atrule\n            //\n            //     @import \"lib\";\n            //\n            // Depending on our environment, importing is done differently:\n            // In the browser, it's an XHR request, in Node, it would be a\n            // file-system operation. The function used for importing is\n            // stored in `import`, which we pass to the Import constructor.\n            //\n            'import': function () {\n                var path, features, index = parserInput.i;\n\n                var dir = parserInput.$re(/^@import?\\s+/);\n\n                if (dir) {\n                    var options = (dir ? this.importOptions() : null) || {};\n\n                    if ((path = this.entities.quoted() || this.entities.url())) {\n                        features = this.mediaFeatures();\n\n                        if (!parserInput.$char(';')) {\n                            parserInput.i = index;\n                            error('missing semi-colon or unrecognised media features on import');\n                        }\n                        features = features && new(tree.Value)(features);\n                        return new(tree.Import)(path, features, options, index, fileInfo);\n                    }\n                    else {\n                        parserInput.i = index;\n                        error('malformed import statement');\n                    }\n                }\n            },\n\n            importOptions: function() {\n                var o, options = {}, optionName, value;\n\n                // list of options, surrounded by parens\n                if (!parserInput.$char('(')) { return null; }\n                do {\n                    o = this.importOption();\n                    if (o) {\n                        optionName = o;\n                        value = true;\n                        switch (optionName) {\n                            case 'css':\n                                optionName = 'less';\n                                value = false;\n                                break;\n                            case 'once':\n                                optionName = 'multiple';\n                                value = false;\n                                break;\n                        }\n                        options[optionName] = value;\n                        if (!parserInput.$char(',')) { break; }\n                    }\n                } while (o);\n                expectChar(')');\n                return options;\n            },\n\n            importOption: function() {\n                var opt = parserInput.$re(/^(less|css|multiple|once|inline|reference|optional)/);\n                if (opt) {\n                    return opt[1];\n                }\n            },\n\n            mediaFeature: function () {\n                var entities = this.entities, nodes = [], e, p;\n                parserInput.save();\n                do {\n                    e = entities.keyword() || entities.variable() || entities.mixinLookup();\n                    if (e) {\n                        nodes.push(e);\n                    } else if (parserInput.$char('(')) {\n                        p = this.property();\n                        e = this.value();\n                        if (parserInput.$char(')')) {\n                            if (p && e) {\n                                nodes.push(new(tree.Paren)(new(tree.Declaration)(p, e, null, null, parserInput.i, fileInfo, true)));\n                            } else if (e) {\n                                nodes.push(new(tree.Paren)(e));\n                            } else {\n                                error('badly formed media feature definition');\n                            }\n                        } else {\n                            error('Missing closing \\')\\'', 'Parse');\n                        }\n                    }\n                } while (e);\n\n                parserInput.forget();\n                if (nodes.length > 0) {\n                    return new(tree.Expression)(nodes);\n                }\n            },\n\n            mediaFeatures: function () {\n                var entities = this.entities, features = [], e;\n                do {\n                    e = this.mediaFeature();\n                    if (e) {\n                        features.push(e);\n                        if (!parserInput.$char(',')) { break; }\n                    } else {\n                        e = entities.variable() || entities.mixinLookup();\n                        if (e) {\n                            features.push(e);\n                            if (!parserInput.$char(',')) { break; }\n                        }\n                    }\n                } while (e);\n\n                return features.length > 0 ? features : null;\n            },\n\n            media: function () {\n                var features, rules, media, debugInfo, index = parserInput.i;\n\n                if (context.dumpLineNumbers) {\n                    debugInfo = getDebugInfo(index);\n                }\n\n                parserInput.save();\n\n                if (parserInput.$str('@media')) {\n                    features = this.mediaFeatures();\n\n                    rules = this.block();\n\n                    if (!rules) {\n                        error('media definitions require block statements after any features');\n                    }\n\n                    parserInput.forget();\n\n                    media = new(tree.Media)(rules, features, index, fileInfo);\n                    if (context.dumpLineNumbers) {\n                        media.debugInfo = debugInfo;\n                    }\n\n                    return media;\n                }\n\n                parserInput.restore();\n            },\n\n            //\n\n            // A @plugin directive, used to import plugins dynamically.\n            //\n            //     @plugin (args) \"lib\";\n            //\n            plugin: function () {\n                var path, args, options,\n                    index = parserInput.i,\n                    dir   = parserInput.$re(/^@plugin?\\s+/);\n\n                if (dir) {\n                    args = this.pluginArgs();\n\n                    if (args) {\n                        options = {\n                            pluginArgs: args,\n                            isPlugin: true\n                        };\n                    }\n                    else {\n                        options = { isPlugin: true };\n                    }\n\n                    if ((path = this.entities.quoted() || this.entities.url())) {\n\n                        if (!parserInput.$char(';')) {\n                            parserInput.i = index;\n                            error('missing semi-colon on @plugin');\n                        }\n                        return new(tree.Import)(path, null, options, index, fileInfo);\n                    }\n                    else {\n                        parserInput.i = index;\n                        error('malformed @plugin statement');\n                    }\n                }\n            },\n\n            pluginArgs: function() {\n                // list of options, surrounded by parens\n                parserInput.save();\n                if (!parserInput.$char('(')) {\n                    parserInput.restore();\n                    return null;\n                }\n                var args = parserInput.$re(/^\\s*([^\\);]+)\\)\\s*/);\n                if (args[1]) {\n                    parserInput.forget();\n                    return args[1].trim();\n                }\n                else { \n                    parserInput.restore();\n                    return null;\n                }\n            },\n\n            //\n            // A CSS AtRule\n            //\n            //     @charset \"utf-8\";\n            //\n            atrule: function () {\n                var index = parserInput.i, name, value, rules, nonVendorSpecificName,\n                    hasIdentifier, hasExpression, hasUnknown, hasBlock = true, isRooted = true;\n\n                if (parserInput.currentChar() !== '@') { return; }\n\n                value = this['import']() || this.plugin() || this.media();\n                if (value) {\n                    return value;\n                }\n\n                parserInput.save();\n\n                name = parserInput.$re(/^@[a-z-]+/);\n\n                if (!name) { return; }\n\n                nonVendorSpecificName = name;\n                if (name.charAt(1) == '-' && name.indexOf('-', 2) > 0) {\n                    nonVendorSpecificName = '@' + name.slice(name.indexOf('-', 2) + 1);\n                }\n\n                switch (nonVendorSpecificName) {\n                    case '@charset':\n                        hasIdentifier = true;\n                        hasBlock = false;\n                        break;\n                    case '@namespace':\n                        hasExpression = true;\n                        hasBlock = false;\n                        break;\n                    case '@keyframes':\n                    case '@counter-style':\n                        hasIdentifier = true;\n                        break;\n                    case '@document':\n                    case '@supports':\n                        hasUnknown = true;\n                        isRooted = false;\n                        break;\n                    default:\n                        hasUnknown = true;\n                        break;\n                }\n\n                parserInput.commentStore.length = 0;\n\n                if (hasIdentifier) {\n                    value = this.entity();\n                    if (!value) {\n                        error('expected ' + name + ' identifier');\n                    }\n                } else if (hasExpression) {\n                    value = this.expression();\n                    if (!value) {\n                        error('expected ' + name + ' expression');\n                    }\n                } else if (hasUnknown) {\n                    value = this.permissiveValue(/^[{;]/);\n                    hasBlock = (parserInput.currentChar() === '{');\n                    if (!value) {\n                        if (!hasBlock && parserInput.currentChar() !== ';') {\n                            error(name + ' rule is missing block or ending semi-colon');\n                        }\n                    }\n                    else if (!value.value) {\n                        value = null;\n                    }\n                }\n\n                if (hasBlock) {\n                    rules = this.blockRuleset();\n                }\n\n                if (rules || (!hasBlock && value && parserInput.$char(';'))) {\n                    parserInput.forget();\n                    return new (tree.AtRule)(name, value, rules, index, fileInfo,\n                        context.dumpLineNumbers ? getDebugInfo(index) : null,\n                        isRooted\n                    );\n                }\n\n                parserInput.restore('at-rule options not recognised');\n            },\n\n            //\n            // A Value is a comma-delimited list of Expressions\n            //\n            //     font-family: Baskerville, Georgia, serif;\n            //\n            // In a Rule, a Value represents everything after the `:`,\n            // and before the `;`.\n            //\n            value: function () {\n                var e, expressions = [], index = parserInput.i;\n\n                do {\n                    e = this.expression();\n                    if (e) {\n                        expressions.push(e);\n                        if (!parserInput.$char(',')) { break; }\n                    }\n                } while (e);\n\n                if (expressions.length > 0) {\n                    return new(tree.Value)(expressions, index);\n                }\n            },\n            important: function () {\n                if (parserInput.currentChar() === '!') {\n                    return parserInput.$re(/^! *important/);\n                }\n            },\n            sub: function () {\n                var a, e;\n\n                parserInput.save();\n                if (parserInput.$char('(')) {\n                    a = this.addition();\n                    if (a && parserInput.$char(')')) {\n                        parserInput.forget();\n                        e = new(tree.Expression)([a]);\n                        e.parens = true;\n                        return e;\n                    }\n                    parserInput.restore('Expected \\')\\'');\n                    return;\n                }\n                parserInput.restore();\n            },\n            multiplication: function () {\n                var m, a, op, operation, isSpaced;\n                m = this.operand();\n                if (m) {\n                    isSpaced = parserInput.isWhitespace(-1);\n                    while (true) {\n                        if (parserInput.peek(/^\\/[*\\/]/)) {\n                            break;\n                        }\n\n                        parserInput.save();\n\n                        op = parserInput.$char('/') || parserInput.$char('*') || parserInput.$str('./');\n\n                        if (!op) { parserInput.forget(); break; }\n\n                        a = this.operand();\n\n                        if (!a) { parserInput.restore(); break; }\n                        parserInput.forget();\n\n                        m.parensInOp = true;\n                        a.parensInOp = true;\n                        operation = new(tree.Operation)(op, [operation || m, a], isSpaced);\n                        isSpaced = parserInput.isWhitespace(-1);\n                    }\n                    return operation || m;\n                }\n            },\n            addition: function () {\n                var m, a, op, operation, isSpaced;\n                m = this.multiplication();\n                if (m) {\n                    isSpaced = parserInput.isWhitespace(-1);\n                    while (true) {\n                        op = parserInput.$re(/^[-+]\\s+/) || (!isSpaced && (parserInput.$char('+') || parserInput.$char('-')));\n                        if (!op) {\n                            break;\n                        }\n                        a = this.multiplication();\n                        if (!a) {\n                            break;\n                        }\n\n                        m.parensInOp = true;\n                        a.parensInOp = true;\n                        operation = new(tree.Operation)(op, [operation || m, a], isSpaced);\n                        isSpaced = parserInput.isWhitespace(-1);\n                    }\n                    return operation || m;\n                }\n            },\n            conditions: function () {\n                var a, b, index = parserInput.i, condition;\n\n                a = this.condition(true);\n                if (a) {\n                    while (true) {\n                        if (!parserInput.peek(/^,\\s*(not\\s*)?\\(/) || !parserInput.$char(',')) {\n                            break;\n                        }\n                        b = this.condition(true);\n                        if (!b) {\n                            break;\n                        }\n                        condition = new(tree.Condition)('or', condition || a, b, index);\n                    }\n                    return condition || a;\n                }\n            },\n            condition: function (needsParens) {\n                var result, logical, next;\n                function or() {\n                    return parserInput.$str('or');\n                }\n\n                result = this.conditionAnd(needsParens);\n                if (!result) {\n                    return ;\n                }\n                logical = or();\n                if (logical) {\n                    next = this.condition(needsParens);\n                    if (next) {\n                        result = new(tree.Condition)(logical, result, next);\n                    } else {\n                        return ;\n                    }\n                }\n                return result;\n            },\n            conditionAnd: function (needsParens) {\n                var result, logical, next, self = this;\n                function insideCondition() {\n                    var cond = self.negatedCondition(needsParens) || self.parenthesisCondition(needsParens);\n                    if (!cond && !needsParens) {\n                        return self.atomicCondition(needsParens);\n                    }\n                    return cond;\n                }\n                function and() {\n                    return parserInput.$str('and');\n                }\n\n                result = insideCondition();\n                if (!result) {\n                    return ;\n                }\n                logical = and();\n                if (logical) {\n                    next = this.conditionAnd(needsParens);\n                    if (next) {\n                        result = new(tree.Condition)(logical, result, next);\n                    } else {\n                        return ;\n                    }\n                }\n                return result;\n            },\n            negatedCondition: function (needsParens) {\n                if (parserInput.$str('not')) {\n                    var result = this.parenthesisCondition(needsParens);\n                    if (result) {\n                        result.negate = !result.negate;\n                    }\n                    return result;\n                }\n            },\n            parenthesisCondition: function (needsParens) {\n                function tryConditionFollowedByParenthesis(me) {\n                    var body;\n                    parserInput.save();\n                    body = me.condition(needsParens);\n                    if (!body) {\n                        parserInput.restore();\n                        return ;\n                    }\n                    if (!parserInput.$char(')')) {\n                        parserInput.restore();\n                        return ;\n                    }\n                    parserInput.forget();\n                    return body;\n                }\n\n                var body;\n                parserInput.save();\n                if (!parserInput.$str('(')) {\n                    parserInput.restore();\n                    return ;\n                }\n                body = tryConditionFollowedByParenthesis(this);\n                if (body) {\n                    parserInput.forget();\n                    return body;\n                }\n\n                body = this.atomicCondition(needsParens);\n                if (!body) {\n                    parserInput.restore();\n                    return ;\n                }\n                if (!parserInput.$char(')')) {\n                    parserInput.restore('expected \\')\\' got \\'' + parserInput.currentChar() + '\\'');\n                    return ;\n                }\n                parserInput.forget();\n                return body;\n            },\n            atomicCondition: function (needsParens) {\n                var entities = this.entities, index = parserInput.i, a, b, c, op;\n\n                function cond() {\n                    return this.addition() || entities.keyword() || entities.quoted() || entities.mixinLookup();\n                }\n                cond = cond.bind(this);\n\n                a = cond();\n                if (a) {\n                    if (parserInput.$char('>')) {\n                        if (parserInput.$char('=')) {\n                            op = '>=';\n                        } else {\n                            op = '>';\n                        }\n                    } else\n                    if (parserInput.$char('<')) {\n                        if (parserInput.$char('=')) {\n                            op = '<=';\n                        } else {\n                            op = '<';\n                        }\n                    } else\n                    if (parserInput.$char('=')) {\n                        if (parserInput.$char('>')) {\n                            op = '=>';\n                        } else if (parserInput.$char('<')) {\n                            op = '=<';\n                        } else {\n                            op = '=';\n                        }\n                    }\n                    if (op) {\n                        b = cond();\n                        if (b) {\n                            c = new(tree.Condition)(op, a, b, index, false);\n                        } else {\n                            error('expected expression');\n                        }\n                    } else {\n                        c = new(tree.Condition)('=', a, new(tree.Keyword)('true'), index, false);\n                    }\n                    return c;\n                }\n            },\n\n            //\n            // An operand is anything that can be part of an operation,\n            // such as a Color, or a Variable\n            //\n            operand: function () {\n                var entities = this.entities, negate;\n\n                if (parserInput.peek(/^-[@\\$\\(]/)) {\n                    negate = parserInput.$char('-');\n                }\n\n                var o = this.sub() || entities.dimension() ||\n                        entities.color() || entities.variable() ||\n                        entities.property() || entities.call() ||\n                        entities.quoted(true) || entities.colorKeyword() ||\n                        entities.mixinLookup();\n\n                if (negate) {\n                    o.parensInOp = true;\n                    o = new(tree.Negative)(o);\n                }\n\n                return o;\n            },\n\n            //\n            // Expressions either represent mathematical operations,\n            // or white-space delimited Entities.\n            //\n            //     1px solid black\n            //     @var * 2\n            //\n            expression: function () {\n                var entities = [], e, delim, index = parserInput.i;\n\n                do {\n                    e = this.comment();\n                    if (e) {\n                        entities.push(e);\n                        continue;\n                    }\n                    e = this.addition() || this.entity();\n                    if (e) {\n                        entities.push(e);\n                        // operations do not allow keyword \"/\" dimension (e.g. small/20px) so we support that here\n                        if (!parserInput.peek(/^\\/[\\/*]/)) {\n                            delim = parserInput.$char('/');\n                            if (delim) {\n                                entities.push(new(tree.Anonymous)(delim, index));\n                            }\n                        }\n                    }\n                } while (e);\n                if (entities.length > 0) {\n                    return new(tree.Expression)(entities);\n                }\n            },\n            property: function () {\n                var name = parserInput.$re(/^(\\*?-?[_a-zA-Z0-9-]+)\\s*:/);\n                if (name) {\n                    return name[1];\n                }\n            },\n            ruleProperty: function () {\n                var name = [], index = [], s, k;\n\n                parserInput.save();\n\n                var simpleProperty = parserInput.$re(/^([_a-zA-Z0-9-]+)\\s*:/);\n                if (simpleProperty) {\n                    name = [new(tree.Keyword)(simpleProperty[1])];\n                    parserInput.forget();\n                    return name;\n                }\n\n                function match(re) {\n                    var i = parserInput.i,\n                        chunk = parserInput.$re(re);\n                    if (chunk) {\n                        index.push(i);\n                        return name.push(chunk[1]);\n                    }\n                }\n\n                match(/^(\\*?)/);\n                while (true) {\n                    if (!match(/^((?:[\\w-]+)|(?:[@\\$]\\{[\\w-]+\\}))/)) {\n                        break;\n                    }\n                }\n\n                if ((name.length > 1) && match(/^((?:\\+_|\\+)?)\\s*:/)) {\n                    parserInput.forget();\n\n                    // at last, we have the complete match now. move forward,\n                    // convert name particles to tree objects and return:\n                    if (name[0] === '') {\n                        name.shift();\n                        index.shift();\n                    }\n                    for (k = 0; k < name.length; k++) {\n                        s = name[k];\n                        name[k] = (s.charAt(0) !== '@' && s.charAt(0) !== '$') ?\n                            new(tree.Keyword)(s) :\n                            (s.charAt(0) === '@' ?\n                                new(tree.Variable)('@' + s.slice(2, -1), index[k], fileInfo) :\n                                new(tree.Property)('$' + s.slice(2, -1), index[k], fileInfo));\n                    }\n                    return name;\n                }\n                parserInput.restore();\n            }\n        }\n    };\n};\nParser.serializeVars = function(vars) {\n    var s = '';\n\n    for (var name in vars) {\n        if (Object.hasOwnProperty.call(vars, name)) {\n            var value = vars[name];\n            s += ((name[0] === '@') ? '' : '@') + name + ': ' + value +\n                ((String(value).slice(-1) === ';') ? '' : ';');\n        }\n    }\n\n    return s;\n};\n\nmodule.exports = Parser;\n\n},{\"../functions/function-registry\":27,\"../less-error\":38,\"../tree\":67,\"../utils\":89,\"../visitors\":93,\"./parser-input\":43}],45:[function(require,module,exports){\n/**\n * Plugin Manager\n */\nvar PluginManager = function(less) {\n    this.less = less;\n    this.visitors = [];\n    this.preProcessors = [];\n    this.postProcessors = [];\n    this.installedPlugins = [];\n    this.fileManagers = [];\n    this.iterator = -1;\n    this.pluginCache = {};\n    this.Loader = new less.PluginLoader(less);\n};\n\nvar pm, PluginManagerFactory = function(less, newFactory) {\n        if (newFactory || !pm) {\n            pm = new PluginManager(less);\n        }\n        return pm;\n    };\n\n/**\n * Adds all the plugins in the array\n * @param {Array} plugins\n */\nPluginManager.prototype.addPlugins = function(plugins) {\n    if (plugins) {\n        for (var i = 0; i < plugins.length; i++) {\n            this.addPlugin(plugins[i]);\n        }\n    }\n};\n/**\n *\n * @param plugin\n * @param {String} filename\n */\nPluginManager.prototype.addPlugin = function(plugin, filename, functionRegistry) {\n    this.installedPlugins.push(plugin);\n    if (filename) {\n        this.pluginCache[filename] = plugin;\n    }\n    if (plugin.install) {\n        plugin.install(this.less, this, functionRegistry || this.less.functions.functionRegistry);\n    }\n};\n/**\n *\n * @param filename\n */\nPluginManager.prototype.get = function(filename) {\n    return this.pluginCache[filename];\n};\n\n/**\n * Adds a visitor. The visitor object has options on itself to determine\n * when it should run.\n * @param visitor\n */\nPluginManager.prototype.addVisitor = function(visitor) {\n    this.visitors.push(visitor);\n};\n/**\n * Adds a pre processor object\n * @param {object} preProcessor\n * @param {number} priority - guidelines 1 = before import, 1000 = import, 2000 = after import\n */\nPluginManager.prototype.addPreProcessor = function(preProcessor, priority) {\n    var indexToInsertAt;\n    for (indexToInsertAt = 0; indexToInsertAt < this.preProcessors.length; indexToInsertAt++) {\n        if (this.preProcessors[indexToInsertAt].priority >= priority) {\n            break;\n        }\n    }\n    this.preProcessors.splice(indexToInsertAt, 0, {preProcessor: preProcessor, priority: priority});\n};\n/**\n * Adds a post processor object\n * @param {object} postProcessor\n * @param {number} priority - guidelines 1 = before compression, 1000 = compression, 2000 = after compression\n */\nPluginManager.prototype.addPostProcessor = function(postProcessor, priority) {\n    var indexToInsertAt;\n    for (indexToInsertAt = 0; indexToInsertAt < this.postProcessors.length; indexToInsertAt++) {\n        if (this.postProcessors[indexToInsertAt].priority >= priority) {\n            break;\n        }\n    }\n    this.postProcessors.splice(indexToInsertAt, 0, {postProcessor: postProcessor, priority: priority});\n};\n/**\n *\n * @param manager\n */\nPluginManager.prototype.addFileManager = function(manager) {\n    this.fileManagers.push(manager);\n};\n/**\n *\n * @returns {Array}\n * @private\n */\nPluginManager.prototype.getPreProcessors = function() {\n    var preProcessors = [];\n    for (var i = 0; i < this.preProcessors.length; i++) {\n        preProcessors.push(this.preProcessors[i].preProcessor);\n    }\n    return preProcessors;\n};\n/**\n *\n * @returns {Array}\n * @private\n */\nPluginManager.prototype.getPostProcessors = function() {\n    var postProcessors = [];\n    for (var i = 0; i < this.postProcessors.length; i++) {\n        postProcessors.push(this.postProcessors[i].postProcessor);\n    }\n    return postProcessors;\n};\n/**\n *\n * @returns {Array}\n * @private\n */\nPluginManager.prototype.getVisitors = function() {\n    return this.visitors;\n};\n\nPluginManager.prototype.visitor = function() {\n    var self = this;\n    return {\n        first: function() {\n            self.iterator = -1;\n            return self.visitors[self.iterator];\n        },\n        get: function() {\n            self.iterator += 1;\n            return self.visitors[self.iterator];\n        }\n    };\n};\n/**\n *\n * @returns {Array}\n * @private\n */\nPluginManager.prototype.getFileManagers = function() {\n    return this.fileManagers;\n};\n\n//\nmodule.exports = PluginManagerFactory;\n\n},{}],46:[function(require,module,exports){\nvar PromiseConstructor,\n    utils = require('./utils');\n\nmodule.exports = function(environment, ParseTree, ImportManager) {\n    var render = function (input, options, callback) {\n        if (typeof options === 'function') {\n            callback = options;\n            options = utils.copyOptions(this.options, {});\n        }\n        else {\n            options = utils.copyOptions(this.options, options || {});\n        }\n\n        if (!callback) {\n            if (!PromiseConstructor) {\n                PromiseConstructor = typeof Promise === 'undefined' ? require('promise') : Promise;\n            }\n            var self = this;\n            return new PromiseConstructor(function (resolve, reject) {\n                render.call(self, input, options, function(err, output) {\n                    if (err) {\n                        reject(err);\n                    } else {\n                        resolve(output);\n                    }\n                });\n            });\n        } else {\n            this.parse(input, options, function(err, root, imports, options) {\n                if (err) { return callback(err); }\n\n                var result;\n                try {\n                    var parseTree = new ParseTree(root, imports);\n                    result = parseTree.toCSS(options);\n                }\n                catch (err) { return callback(err); }\n\n                callback(null, result);\n            });\n        }\n    };\n\n    return render;\n};\n\n},{\"./utils\":89,\"promise\":undefined}],47:[function(require,module,exports){\nmodule.exports = function (SourceMapOutput, environment) {\n\n    var SourceMapBuilder = function (options) {\n        this.options = options;\n    };\n\n    SourceMapBuilder.prototype.toCSS = function(rootNode, options, imports) {\n        var sourceMapOutput = new SourceMapOutput(\n            {\n                contentsIgnoredCharsMap: imports.contentsIgnoredChars,\n                rootNode: rootNode,\n                contentsMap: imports.contents,\n                sourceMapFilename: this.options.sourceMapFilename,\n                sourceMapURL: this.options.sourceMapURL,\n                outputFilename: this.options.sourceMapOutputFilename,\n                sourceMapBasepath: this.options.sourceMapBasepath,\n                sourceMapRootpath: this.options.sourceMapRootpath,\n                outputSourceFiles: this.options.outputSourceFiles,\n                sourceMapGenerator: this.options.sourceMapGenerator,\n                sourceMapFileInline: this.options.sourceMapFileInline\n            });\n\n        var css = sourceMapOutput.toCSS(options);\n        this.sourceMap = sourceMapOutput.sourceMap;\n        this.sourceMapURL = sourceMapOutput.sourceMapURL;\n        if (this.options.sourceMapInputFilename) {\n            this.sourceMapInputFilename = sourceMapOutput.normalizeFilename(this.options.sourceMapInputFilename);\n        }\n        if (this.options.sourceMapBasepath !== undefined && this.sourceMapURL !== undefined) {\n            this.sourceMapURL = sourceMapOutput.removeBasepath(this.sourceMapURL);\n        }\n        return css + this.getCSSAppendage();\n    };\n\n    SourceMapBuilder.prototype.getCSSAppendage = function() {\n\n        var sourceMapURL = this.sourceMapURL;\n        if (this.options.sourceMapFileInline) {\n            if (this.sourceMap === undefined) {\n                return '';\n            }\n            sourceMapURL = 'data:application/json;base64,' + environment.encodeBase64(this.sourceMap);\n        }\n\n        if (sourceMapURL) {\n            return '/*# sourceMappingURL=' + sourceMapURL + ' */';\n        }\n        return '';\n    };\n\n    SourceMapBuilder.prototype.getExternalSourceMap = function() {\n        return this.sourceMap;\n    };\n    SourceMapBuilder.prototype.setExternalSourceMap = function(sourceMap) {\n        this.sourceMap = sourceMap;\n    };\n\n    SourceMapBuilder.prototype.isInline = function() {\n        return this.options.sourceMapFileInline;\n    };\n    SourceMapBuilder.prototype.getSourceMapURL = function() {\n        return this.sourceMapURL;\n    };\n    SourceMapBuilder.prototype.getOutputFilename = function() {\n        return this.options.sourceMapOutputFilename;\n    };\n    SourceMapBuilder.prototype.getInputFilename = function() {\n        return this.sourceMapInputFilename;\n    };\n\n    return SourceMapBuilder;\n};\n\n},{}],48:[function(require,module,exports){\nmodule.exports = function (environment) {\n\n    var SourceMapOutput = function (options) {\n        this._css = [];\n        this._rootNode = options.rootNode;\n        this._contentsMap = options.contentsMap;\n        this._contentsIgnoredCharsMap = options.contentsIgnoredCharsMap;\n        if (options.sourceMapFilename) {\n            this._sourceMapFilename = options.sourceMapFilename.replace(/\\\\/g, '/');\n        }\n        this._outputFilename = options.outputFilename;\n        this.sourceMapURL = options.sourceMapURL;\n        if (options.sourceMapBasepath) {\n            this._sourceMapBasepath = options.sourceMapBasepath.replace(/\\\\/g, '/');\n        }\n        if (options.sourceMapRootpath) {\n            this._sourceMapRootpath = options.sourceMapRootpath.replace(/\\\\/g, '/');\n            if (this._sourceMapRootpath.charAt(this._sourceMapRootpath.length - 1) !== '/') {\n                this._sourceMapRootpath += '/';\n            }\n        } else {\n            this._sourceMapRootpath = '';\n        }\n        this._outputSourceFiles = options.outputSourceFiles;\n        this._sourceMapGeneratorConstructor = environment.getSourceMapGenerator();\n\n        this._lineNumber = 0;\n        this._column = 0;\n    };\n\n    SourceMapOutput.prototype.removeBasepath = function(path) {\n        if (this._sourceMapBasepath && path.indexOf(this._sourceMapBasepath) === 0) {\n            path = path.substring(this._sourceMapBasepath.length);\n            if (path.charAt(0) === '\\\\' || path.charAt(0) === '/') {\n                path = path.substring(1);\n            }\n        }\n\n        return path;\n    };\n\n    SourceMapOutput.prototype.normalizeFilename = function(filename) {\n        filename = filename.replace(/\\\\/g, '/');\n        filename = this.removeBasepath(filename);\n        return (this._sourceMapRootpath || '') + filename;\n    };\n\n    SourceMapOutput.prototype.add = function(chunk, fileInfo, index, mapLines) {\n\n        // ignore adding empty strings\n        if (!chunk) {\n            return;\n        }\n\n        var lines,\n            sourceLines,\n            columns,\n            sourceColumns,\n            i;\n\n        if (fileInfo && fileInfo.filename) {\n            var inputSource = this._contentsMap[fileInfo.filename];\n\n            // remove vars/banner added to the top of the file\n            if (this._contentsIgnoredCharsMap[fileInfo.filename]) {\n                // adjust the index\n                index -= this._contentsIgnoredCharsMap[fileInfo.filename];\n                if (index < 0) { index = 0; }\n                // adjust the source\n                inputSource = inputSource.slice(this._contentsIgnoredCharsMap[fileInfo.filename]);\n            }\n            inputSource = inputSource.substring(0, index);\n            sourceLines = inputSource.split('\\n');\n            sourceColumns = sourceLines[sourceLines.length - 1];\n        }\n\n        lines = chunk.split('\\n');\n        columns = lines[lines.length - 1];\n\n        if (fileInfo && fileInfo.filename) {\n            if (!mapLines) {\n                this._sourceMapGenerator.addMapping({ generated: { line: this._lineNumber + 1, column: this._column},\n                    original: { line: sourceLines.length, column: sourceColumns.length},\n                    source: this.normalizeFilename(fileInfo.filename)});\n            } else {\n                for (i = 0; i < lines.length; i++) {\n                    this._sourceMapGenerator.addMapping({ generated: { line: this._lineNumber + i + 1, column: i === 0 ? this._column : 0},\n                        original: { line: sourceLines.length + i, column: i === 0 ? sourceColumns.length : 0},\n                        source: this.normalizeFilename(fileInfo.filename)});\n                }\n            }\n        }\n\n        if (lines.length === 1) {\n            this._column += columns.length;\n        } else {\n            this._lineNumber += lines.length - 1;\n            this._column = columns.length;\n        }\n\n        this._css.push(chunk);\n    };\n\n    SourceMapOutput.prototype.isEmpty = function() {\n        return this._css.length === 0;\n    };\n\n    SourceMapOutput.prototype.toCSS = function(context) {\n        this._sourceMapGenerator = new this._sourceMapGeneratorConstructor({ file: this._outputFilename, sourceRoot: null });\n\n        if (this._outputSourceFiles) {\n            for (var filename in this._contentsMap) {\n                if (this._contentsMap.hasOwnProperty(filename)) {\n                    var source = this._contentsMap[filename];\n                    if (this._contentsIgnoredCharsMap[filename]) {\n                        source = source.slice(this._contentsIgnoredCharsMap[filename]);\n                    }\n                    this._sourceMapGenerator.setSourceContent(this.normalizeFilename(filename), source);\n                }\n            }\n        }\n\n        this._rootNode.genCSS(context, this);\n\n        if (this._css.length > 0) {\n            var sourceMapURL,\n                sourceMapContent = JSON.stringify(this._sourceMapGenerator.toJSON());\n\n            if (this.sourceMapURL) {\n                sourceMapURL = this.sourceMapURL;\n            } else if (this._sourceMapFilename) {\n                sourceMapURL = this._sourceMapFilename;\n            }\n            this.sourceMapURL = sourceMapURL;\n\n            this.sourceMap = sourceMapContent;\n        }\n\n        return this._css.join('');\n    };\n\n    return SourceMapOutput;\n};\n\n},{}],49:[function(require,module,exports){\nvar contexts = require('./contexts'),\n    visitor = require('./visitors'),\n    tree = require('./tree');\n\nmodule.exports = function(root, options) {\n    options = options || {};\n    var evaldRoot,\n        variables = options.variables,\n        evalEnv = new contexts.Eval(options);\n\n    //\n    // Allows setting variables with a hash, so:\n    //\n    //   `{ color: new tree.Color('#f01') }` will become:\n    //\n    //   new tree.Declaration('@color',\n    //     new tree.Value([\n    //       new tree.Expression([\n    //         new tree.Color('#f01')\n    //       ])\n    //     ])\n    //   )\n    //\n    if (typeof variables === 'object' && !Array.isArray(variables)) {\n        variables = Object.keys(variables).map(function (k) {\n            var value = variables[k];\n\n            if (!(value instanceof tree.Value)) {\n                if (!(value instanceof tree.Expression)) {\n                    value = new tree.Expression([value]);\n                }\n                value = new tree.Value([value]);\n            }\n            return new tree.Declaration('@' + k, value, false, null, 0);\n        });\n        evalEnv.frames = [new tree.Ruleset(null, variables)];\n    }\n\n    var visitors = [\n            new visitor.JoinSelectorVisitor(),\n            new visitor.MarkVisibleSelectorsVisitor(true),\n            new visitor.ExtendVisitor(),\n            new visitor.ToCSSVisitor({compress: Boolean(options.compress)})\n        ], preEvalVisitors = [], v, visitorIterator;\n\n    /**\n     * first() / get() allows visitors to be added while visiting\n     * \n     * @todo Add scoping for visitors just like functions for @plugin; right now they're global\n     */\n    if (options.pluginManager) {\n        visitorIterator = options.pluginManager.visitor();\n        for (var i = 0; i < 2; i++) {\n            visitorIterator.first();\n            while ((v = visitorIterator.get())) {\n                if (v.isPreEvalVisitor) {\n                    if (i === 0 || preEvalVisitors.indexOf(v) === -1) {\n                        preEvalVisitors.push(v);\n                        v.run(root);\n                    }\n                }\n                else {\n                    if (i === 0 || visitors.indexOf(v) === -1) {\n                        if (v.isPreVisitor) {\n                            visitors.unshift(v);\n                        }\n                        else {\n                            visitors.push(v);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    evaldRoot = root.eval(evalEnv);\n\n    for (var i = 0; i < visitors.length; i++) {\n        visitors[i].run(evaldRoot);\n    }\n\n    // Run any remaining visitors added after eval pass\n    if (options.pluginManager) {\n        visitorIterator.first();\n        while ((v = visitorIterator.get())) {\n            if (visitors.indexOf(v) === -1 && preEvalVisitors.indexOf(v) === -1) {\n                v.run(evaldRoot);\n            }\n        }\n    }\n\n    return evaldRoot;\n};\n\n},{\"./contexts\":13,\"./tree\":67,\"./visitors\":93}],50:[function(require,module,exports){\nvar Node = require('./node');\n\nvar Anonymous = function (value, index, currentFileInfo, mapLines, rulesetLike, visibilityInfo) {\n    this.value = value;\n    this._index = index;\n    this._fileInfo = currentFileInfo;\n    this.mapLines = mapLines;\n    this.rulesetLike = (typeof rulesetLike === 'undefined') ? false : rulesetLike;\n    this.allowRoot = true;\n    this.copyVisibilityInfo(visibilityInfo);\n};\nAnonymous.prototype = new Node();\nAnonymous.prototype.type = 'Anonymous';\nAnonymous.prototype.eval = function () {\n    return new Anonymous(this.value, this._index, this._fileInfo, this.mapLines, this.rulesetLike, this.visibilityInfo());\n};\nAnonymous.prototype.compare = function (other) {\n    return other.toCSS && this.toCSS() === other.toCSS() ? 0 : undefined;\n};\nAnonymous.prototype.isRulesetLike = function() {\n    return this.rulesetLike;\n};\nAnonymous.prototype.genCSS = function (context, output) {\n    this.nodeVisible = Boolean(this.value);\n    if (this.nodeVisible) {\n        output.add(this.value, this._fileInfo, this._index, this.mapLines);\n    }\n};\nmodule.exports = Anonymous;\n\n},{\"./node\":76}],51:[function(require,module,exports){\nvar Node = require('./node');\n\nvar Assignment = function (key, val) {\n    this.key = key;\n    this.value = val;\n};\n\nAssignment.prototype = new Node();\nAssignment.prototype.type = 'Assignment';\nAssignment.prototype.accept = function (visitor) {\n    this.value = visitor.visit(this.value);\n};\nAssignment.prototype.eval = function (context) {\n    if (this.value.eval) {\n        return new Assignment(this.key, this.value.eval(context));\n    }\n    return this;\n};\nAssignment.prototype.genCSS = function (context, output) {\n    output.add(this.key + '=');\n    if (this.value.genCSS) {\n        this.value.genCSS(context, output);\n    } else {\n        output.add(this.value);\n    }\n};\nmodule.exports = Assignment;\n\n},{\"./node\":76}],52:[function(require,module,exports){\nvar Node = require('./node'),\n    Selector = require('./selector'),\n    Ruleset = require('./ruleset'),\n    Anonymous = require('./anonymous');\n\nvar AtRule = function (name, value, rules, index, currentFileInfo, debugInfo, isRooted, visibilityInfo) {\n    var i;\n\n    this.name  = name;\n    this.value = (value instanceof Node) ? value : (value ? new Anonymous(value) : value);\n    if (rules) {\n        if (Array.isArray(rules)) {\n            this.rules = rules;\n        } else {\n            this.rules = [rules];\n            this.rules[0].selectors = (new Selector([], null, null, index, currentFileInfo)).createEmptySelectors();\n        }\n        for (i = 0; i < this.rules.length; i++) {\n            this.rules[i].allowImports = true;\n        }\n        this.setParent(this.rules, this);\n    }\n    this._index = index;\n    this._fileInfo = currentFileInfo;\n    this.debugInfo = debugInfo;\n    this.isRooted = isRooted || false;\n    this.copyVisibilityInfo(visibilityInfo);\n    this.allowRoot = true;\n};\n\nAtRule.prototype = new Node();\nAtRule.prototype.type = 'AtRule';\nAtRule.prototype.accept = function (visitor) {\n    var value = this.value, rules = this.rules;\n    if (rules) {\n        this.rules = visitor.visitArray(rules);\n    }\n    if (value) {\n        this.value = visitor.visit(value);\n    }\n};\nAtRule.prototype.isRulesetLike = function() {\n    return this.rules || !this.isCharset();\n};\nAtRule.prototype.isCharset = function() {\n    return '@charset' === this.name;\n};\nAtRule.prototype.genCSS = function (context, output) {\n    var value = this.value, rules = this.rules;\n    output.add(this.name, this.fileInfo(), this.getIndex());\n    if (value) {\n        output.add(' ');\n        value.genCSS(context, output);\n    }\n    if (rules) {\n        this.outputRuleset(context, output, rules);\n    } else {\n        output.add(';');\n    }\n};\nAtRule.prototype.eval = function (context) {\n    var mediaPathBackup, mediaBlocksBackup, value = this.value, rules = this.rules;\n\n    // media stored inside other atrule should not bubble over it\n    // backpup media bubbling information\n    mediaPathBackup = context.mediaPath;\n    mediaBlocksBackup = context.mediaBlocks;\n    // deleted media bubbling information\n    context.mediaPath = [];\n    context.mediaBlocks = [];\n\n    if (value) {\n        value = value.eval(context);\n    }\n    if (rules) {\n        // assuming that there is only one rule at this point - that is how parser constructs the rule\n        rules = [rules[0].eval(context)];\n        rules[0].root = true;\n    }\n    // restore media bubbling information\n    context.mediaPath = mediaPathBackup;\n    context.mediaBlocks = mediaBlocksBackup;\n\n    return new AtRule(this.name, value, rules,\n        this.getIndex(), this.fileInfo(), this.debugInfo, this.isRooted, this.visibilityInfo());\n};\nAtRule.prototype.variable = function (name) {\n    if (this.rules) {\n        // assuming that there is only one rule at this point - that is how parser constructs the rule\n        return Ruleset.prototype.variable.call(this.rules[0], name);\n    }\n};\nAtRule.prototype.find = function () {\n    if (this.rules) {\n        // assuming that there is only one rule at this point - that is how parser constructs the rule\n        return Ruleset.prototype.find.apply(this.rules[0], arguments);\n    }\n};\nAtRule.prototype.rulesets = function () {\n    if (this.rules) {\n        // assuming that there is only one rule at this point - that is how parser constructs the rule\n        return Ruleset.prototype.rulesets.apply(this.rules[0]);\n    }\n};\nAtRule.prototype.outputRuleset = function (context, output, rules) {\n    var ruleCnt = rules.length, i;\n    context.tabLevel = (context.tabLevel | 0) + 1;\n\n    // Compressed\n    if (context.compress) {\n        output.add('{');\n        for (i = 0; i < ruleCnt; i++) {\n            rules[i].genCSS(context, output);\n        }\n        output.add('}');\n        context.tabLevel--;\n        return;\n    }\n\n    // Non-compressed\n    var tabSetStr = '\\n' + Array(context.tabLevel).join('  '), tabRuleStr = tabSetStr + '  ';\n    if (!ruleCnt) {\n        output.add(' {' + tabSetStr + '}');\n    } else {\n        output.add(' {' + tabRuleStr);\n        rules[0].genCSS(context, output);\n        for (i = 1; i < ruleCnt; i++) {\n            output.add(tabRuleStr);\n            rules[i].genCSS(context, output);\n        }\n        output.add(tabSetStr + '}');\n    }\n\n    context.tabLevel--;\n};\nmodule.exports = AtRule;\n\n},{\"./anonymous\":50,\"./node\":76,\"./ruleset\":81,\"./selector\":82}],53:[function(require,module,exports){\nvar Node = require('./node');\n\nvar Attribute = function (key, op, value) {\n    this.key = key;\n    this.op = op;\n    this.value = value;\n};\nAttribute.prototype = new Node();\nAttribute.prototype.type = 'Attribute';\nAttribute.prototype.eval = function (context) {\n    return new Attribute(this.key.eval ? this.key.eval(context) : this.key,\n        this.op, (this.value && this.value.eval) ? this.value.eval(context) : this.value);\n};\nAttribute.prototype.genCSS = function (context, output) {\n    output.add(this.toCSS(context));\n};\nAttribute.prototype.toCSS = function (context) {\n    var value = this.key.toCSS ? this.key.toCSS(context) : this.key;\n\n    if (this.op) {\n        value += this.op;\n        value += (this.value.toCSS ? this.value.toCSS(context) : this.value);\n    }\n\n    return '[' + value + ']';\n};\nmodule.exports = Attribute;\n\n},{\"./node\":76}],54:[function(require,module,exports){\nvar Node = require('./node'),\n    Anonymous = require('./anonymous'),\n    FunctionCaller = require('../functions/function-caller');\n//\n// A function call node.\n//\nvar Call = function (name, args, index, currentFileInfo) {\n    this.name = name;\n    this.args = args;\n    this.calc = name === 'calc';\n    this._index = index;\n    this._fileInfo = currentFileInfo;\n};\nCall.prototype = new Node();\nCall.prototype.type = 'Call';\nCall.prototype.accept = function (visitor) {\n    if (this.args) {\n        this.args = visitor.visitArray(this.args);\n    }\n};\n//\n// When evaluating a function call,\n// we either find the function in the functionRegistry,\n// in which case we call it, passing the  evaluated arguments,\n// if this returns null or we cannot find the function, we\n// simply print it out as it appeared originally [2].\n//\n// The reason why we evaluate the arguments, is in the case where\n// we try to pass a variable to a function, like: `saturate(@color)`.\n// The function should receive the value, not the variable.\n//\nCall.prototype.eval = function (context) {\n    /**\n     * Turn off math for calc(), and switch back on for evaluating nested functions\n     */\n    var currentMathContext = context.mathOn;\n    context.mathOn = !this.calc;\n    if (this.calc || context.inCalc) {\n        context.enterCalc();\n    }\n    var args = this.args.map(function (a) { return a.eval(context); });\n    if (this.calc || context.inCalc) {\n        context.exitCalc();\n    }\n    context.mathOn = currentMathContext;\n\n    var result, funcCaller = new FunctionCaller(this.name, context, this.getIndex(), this.fileInfo());\n    \n    if (funcCaller.isValid()) {\n        try {\n            result = funcCaller.call(args);\n        } catch (e) {\n            throw { \n                type: e.type || 'Runtime',\n                message: 'error evaluating function `' + this.name + '`' +\n                         (e.message ? ': ' + e.message : ''),\n                index: this.getIndex(), \n                filename: this.fileInfo().filename,\n                line: e.lineNumber,\n                column: e.columnNumber\n            };\n        }\n\n        if (result !== null && result !== undefined) {\n            // Results that that are not nodes are cast as Anonymous nodes\n            // Falsy values or booleans are returned as empty nodes\n            if (!(result instanceof Node)) {\n                if (!result || result === true) {\n                    result = new Anonymous(null); \n                }\n                else {\n                    result = new Anonymous(result.toString()); \n                }\n                \n            }\n            result._index = this._index;\n            result._fileInfo = this._fileInfo;\n            return result;\n        }\n\n    }\n\n    return new Call(this.name, args, this.getIndex(), this.fileInfo());\n};\nCall.prototype.genCSS = function (context, output) {\n    output.add(this.name + '(', this.fileInfo(), this.getIndex());\n\n    for (var i = 0; i < this.args.length; i++) {\n        this.args[i].genCSS(context, output);\n        if (i + 1 < this.args.length) {\n            output.add(', ');\n        }\n    }\n\n    output.add(')');\n};\nmodule.exports = Call;\n\n},{\"../functions/function-caller\":26,\"./anonymous\":50,\"./node\":76}],55:[function(require,module,exports){\nvar Node = require('./node'),\n    colors = require('../data/colors');\n\n//\n// RGB Colors - #ff0014, #eee\n//\nvar Color = function (rgb, a, originalForm) {\n    var self = this;\n    //\n    // The end goal here, is to parse the arguments\n    // into an integer triplet, such as `128, 255, 0`\n    //\n    // This facilitates operations and conversions.\n    //\n    if (Array.isArray(rgb)) {\n        this.rgb = rgb;\n    } else if (rgb.length >= 6) {\n        this.rgb = [];\n        rgb.match(/.{2}/g).map(function (c, i) {\n            if (i < 3) {\n                self.rgb.push(parseInt(c, 16));\n            } else {\n                self.alpha = (parseInt(c, 16)) / 255;\n            }\n        });\n    } else {\n        this.rgb = [];\n        rgb.split('').map(function (c, i) {\n            if (i < 3) {\n                self.rgb.push(parseInt(c + c, 16));\n            } else {\n                self.alpha = (parseInt(c + c, 16)) / 255;\n            }\n        });\n    }\n    this.alpha = this.alpha || (typeof a === 'number' ? a : 1);\n    if (typeof originalForm !== 'undefined') {\n        this.value = originalForm;\n    }\n};\n\nColor.prototype = new Node();\nColor.prototype.type = 'Color';\n\nfunction clamp(v, max) {\n    return Math.min(Math.max(v, 0), max);\n}\n\nfunction toHex(v) {\n    return '#' + v.map(function (c) {\n        c = clamp(Math.round(c), 255);\n        return (c < 16 ? '0' : '') + c.toString(16);\n    }).join('');\n}\n\nColor.prototype.luma = function () {\n    var r = this.rgb[0] / 255,\n        g = this.rgb[1] / 255,\n        b = this.rgb[2] / 255;\n\n    r = (r <= 0.03928) ? r / 12.92 : Math.pow(((r + 0.055) / 1.055), 2.4);\n    g = (g <= 0.03928) ? g / 12.92 : Math.pow(((g + 0.055) / 1.055), 2.4);\n    b = (b <= 0.03928) ? b / 12.92 : Math.pow(((b + 0.055) / 1.055), 2.4);\n\n    return 0.2126 * r + 0.7152 * g + 0.0722 * b;\n};\nColor.prototype.genCSS = function (context, output) {\n    output.add(this.toCSS(context));\n};\nColor.prototype.toCSS = function (context, doNotCompress) {\n    var compress = context && context.compress && !doNotCompress, color, alpha,\n        colorFunction, args = [];\n\n    // `value` is set if this color was originally\n    // converted from a named color string so we need\n    // to respect this and try to output named color too.\n    alpha = this.fround(context, this.alpha);\n\n    if (this.value) {\n        if (this.value.indexOf('rgb') === 0) {\n            if (alpha < 1) {\n                colorFunction = 'rgba';\n            }\n        } else if (this.value.indexOf('hsl') === 0) {\n            if (alpha < 1) {\n                colorFunction = 'hsla';\n            } else {\n                colorFunction = 'hsl';\n            }\n        } else {\n            return this.value;\n        }\n    } else {\n        if (alpha < 1) {\n            colorFunction = 'rgba';\n        }\n    }\n\n    switch (colorFunction) {\n        case 'rgba':\n            args = this.rgb.map(function (c) {\n                return clamp(Math.round(c), 255);\n            }).concat(clamp(alpha, 1));\n            break;\n        case 'hsla':\n            args.push(clamp(alpha, 1));\n        case 'hsl':\n            color = this.toHSL();\n            args = [\n                this.fround(context, color.h),\n                this.fround(context, color.s * 100) + '%',\n                this.fround(context, color.l * 100) + '%'\n            ].concat(args);\n    }\n\n    if (colorFunction) {\n        // Values are capped between `0` and `255`, rounded and zero-padded.\n        return colorFunction + '(' + args.join(',' + (compress ? '' : ' ')) + ')';\n    }\n\n    color = this.toRGB();\n\n    if (compress) {\n        var splitcolor = color.split('');\n\n        // Convert color to short format\n        if (splitcolor[1] === splitcolor[2] && splitcolor[3] === splitcolor[4] && splitcolor[5] === splitcolor[6]) {\n            color = '#' + splitcolor[1] + splitcolor[3] + splitcolor[5];\n        }\n    }\n\n    return color;\n};\n\n//\n// Operations have to be done per-channel, if not,\n// channels will spill onto each other. Once we have\n// our result, in the form of an integer triplet,\n// we create a new Color node to hold the result.\n//\nColor.prototype.operate = function (context, op, other) {\n    var rgb = new Array(3);\n    var alpha = this.alpha * (1 - other.alpha) + other.alpha;\n    for (var c = 0; c < 3; c++) {\n        rgb[c] = this._operate(context, op, this.rgb[c], other.rgb[c]);\n    }\n    return new Color(rgb, alpha);\n};\nColor.prototype.toRGB = function () {\n    return toHex(this.rgb);\n};\nColor.prototype.toHSL = function () {\n    var r = this.rgb[0] / 255,\n        g = this.rgb[1] / 255,\n        b = this.rgb[2] / 255,\n        a = this.alpha;\n\n    var max = Math.max(r, g, b), min = Math.min(r, g, b);\n    var h, s, l = (max + min) / 2, d = max - min;\n\n    if (max === min) {\n        h = s = 0;\n    } else {\n        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n\n        switch (max) {\n            case r: h = (g - b) / d + (g < b ? 6 : 0); break;\n            case g: h = (b - r) / d + 2;               break;\n            case b: h = (r - g) / d + 4;               break;\n        }\n        h /= 6;\n    }\n    return { h: h * 360, s: s, l: l, a: a };\n};\n// Adapted from http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript\nColor.prototype.toHSV = function () {\n    var r = this.rgb[0] / 255,\n        g = this.rgb[1] / 255,\n        b = this.rgb[2] / 255,\n        a = this.alpha;\n\n    var max = Math.max(r, g, b), min = Math.min(r, g, b);\n    var h, s, v = max;\n\n    var d = max - min;\n    if (max === 0) {\n        s = 0;\n    } else {\n        s = d / max;\n    }\n\n    if (max === min) {\n        h = 0;\n    } else {\n        switch (max) {\n            case r: h = (g - b) / d + (g < b ? 6 : 0); break;\n            case g: h = (b - r) / d + 2; break;\n            case b: h = (r - g) / d + 4; break;\n        }\n        h /= 6;\n    }\n    return { h: h * 360, s: s, v: v, a: a };\n};\nColor.prototype.toARGB = function () {\n    return toHex([this.alpha * 255].concat(this.rgb));\n};\nColor.prototype.compare = function (x) {\n    return (x.rgb &&\n        x.rgb[0] === this.rgb[0] &&\n        x.rgb[1] === this.rgb[1] &&\n        x.rgb[2] === this.rgb[2] &&\n        x.alpha  === this.alpha) ? 0 : undefined;\n};\n\nColor.fromKeyword = function(keyword) {\n    var c, key = keyword.toLowerCase();\n    if (colors.hasOwnProperty(key)) {\n        c = new Color(colors[key].slice(1));\n    }\n    else if (key === 'transparent') {\n        c = new Color([0, 0, 0], 0);\n    }\n\n    if (c) {\n        c.value = keyword;\n        return c;\n    }\n};\nmodule.exports = Color;\n\n},{\"../data/colors\":14,\"./node\":76}],56:[function(require,module,exports){\nvar Node = require('./node');\n\nvar Combinator = function (value) {\n    if (value === ' ') {\n        this.value = ' ';\n        this.emptyOrWhitespace = true;\n    } else {\n        this.value = value ? value.trim() : '';\n        this.emptyOrWhitespace = this.value === '';\n    }\n};\nCombinator.prototype = new Node();\nCombinator.prototype.type = 'Combinator';\nvar _noSpaceCombinators = {\n    '': true,\n    ' ': true,\n    '|': true\n};\nCombinator.prototype.genCSS = function (context, output) {\n    var spaceOrEmpty = (context.compress || _noSpaceCombinators[this.value]) ? '' : ' ';\n    output.add(spaceOrEmpty + this.value + spaceOrEmpty);\n};\nmodule.exports = Combinator;\n\n},{\"./node\":76}],57:[function(require,module,exports){\nvar Node = require('./node'),\n    getDebugInfo = require('./debug-info');\n\nvar Comment = function (value, isLineComment, index, currentFileInfo) {\n    this.value = value;\n    this.isLineComment = isLineComment;\n    this._index = index;\n    this._fileInfo = currentFileInfo;\n    this.allowRoot = true;\n};\nComment.prototype = new Node();\nComment.prototype.type = 'Comment';\nComment.prototype.genCSS = function (context, output) {\n    if (this.debugInfo) {\n        output.add(getDebugInfo(context, this), this.fileInfo(), this.getIndex());\n    }\n    output.add(this.value);\n};\nComment.prototype.isSilent = function(context) {\n    var isCompressed = context.compress && this.value[2] !== '!';\n    return this.isLineComment || isCompressed;\n};\nmodule.exports = Comment;\n\n},{\"./debug-info\":59,\"./node\":76}],58:[function(require,module,exports){\nvar Node = require('./node');\n\nvar Condition = function (op, l, r, i, negate) {\n    this.op = op.trim();\n    this.lvalue = l;\n    this.rvalue = r;\n    this._index = i;\n    this.negate = negate;\n};\nCondition.prototype = new Node();\nCondition.prototype.type = 'Condition';\nCondition.prototype.accept = function (visitor) {\n    this.lvalue = visitor.visit(this.lvalue);\n    this.rvalue = visitor.visit(this.rvalue);\n};\nCondition.prototype.eval = function (context) {\n    var result = (function (op, a, b) {\n        switch (op) {\n            case 'and': return a && b;\n            case 'or':  return a || b;\n            default:\n                switch (Node.compare(a, b)) {\n                    case -1:\n                        return op === '<' || op === '=<' || op === '<=';\n                    case 0:\n                        return op === '=' || op === '>=' || op === '=<' || op === '<=';\n                    case 1:\n                        return op === '>' || op === '>=';\n                    default:\n                        return false;\n                }\n        }\n    })(this.op, this.lvalue.eval(context), this.rvalue.eval(context));\n\n    return this.negate ? !result : result;\n};\nmodule.exports = Condition;\n\n},{\"./node\":76}],59:[function(require,module,exports){\nvar debugInfo = function(context, ctx, lineSeparator) {\n    var result = '';\n    if (context.dumpLineNumbers && !context.compress) {\n        switch (context.dumpLineNumbers) {\n            case 'comments':\n                result = debugInfo.asComment(ctx);\n                break;\n            case 'mediaquery':\n                result = debugInfo.asMediaQuery(ctx);\n                break;\n            case 'all':\n                result = debugInfo.asComment(ctx) + (lineSeparator || '') + debugInfo.asMediaQuery(ctx);\n                break;\n        }\n    }\n    return result;\n};\n\ndebugInfo.asComment = function(ctx) {\n    return '/* line ' + ctx.debugInfo.lineNumber + ', ' + ctx.debugInfo.fileName + ' */\\n';\n};\n\ndebugInfo.asMediaQuery = function(ctx) {\n    var filenameWithProtocol = ctx.debugInfo.fileName;\n    if (!/^[a-z]+:\\/\\//i.test(filenameWithProtocol)) {\n        filenameWithProtocol = 'file://' + filenameWithProtocol;\n    }\n    return '@media -sass-debug-info{filename{font-family:' +\n        filenameWithProtocol.replace(/([.:\\/\\\\])/g, function (a) {\n            if (a == '\\\\') {\n                a = '\\/';\n            }\n            return '\\\\' + a;\n        }) +\n        '}line{font-family:\\\\00003' + ctx.debugInfo.lineNumber + '}}\\n';\n};\n\nmodule.exports = debugInfo;\n\n},{}],60:[function(require,module,exports){\nvar Node = require('./node'),\n    Value = require('./value'),\n    Keyword = require('./keyword'),\n    Anonymous = require('./anonymous'),\n    MATH = require('../constants').Math;\n\nvar Declaration = function (name, value, important, merge, index, currentFileInfo, inline, variable) {\n    this.name = name;\n    this.value = (value instanceof Node) ? value : new Value([value ? new Anonymous(value) : null]);\n    this.important = important ? ' ' + important.trim() : '';\n    this.merge = merge;\n    this._index = index;\n    this._fileInfo = currentFileInfo;\n    this.inline = inline || false;\n    this.variable = (variable !== undefined) ? variable\n        : (name.charAt && (name.charAt(0) === '@'));\n    this.allowRoot = true;\n    this.setParent(this.value, this);\n};\n\nfunction evalName(context, name) {\n    var value = '', i, n = name.length,\n        output = {add: function (s) {value += s;}};\n    for (i = 0; i < n; i++) {\n        name[i].eval(context).genCSS(context, output);\n    }\n    return value;\n}\n\nDeclaration.prototype = new Node();\nDeclaration.prototype.type = 'Declaration';\nDeclaration.prototype.genCSS = function (context, output) {\n    output.add(this.name + (context.compress ? ':' : ': '), this.fileInfo(), this.getIndex());\n    try {\n        this.value.genCSS(context, output);\n    }\n    catch (e) {\n        e.index = this._index;\n        e.filename = this._fileInfo.filename;\n        throw e;\n    }\n    output.add(this.important + ((this.inline || (context.lastRule && context.compress)) ? '' : ';'), this._fileInfo, this._index);\n};\nDeclaration.prototype.eval = function (context) {\n    var mathBypass = false, prevMath, name = this.name, evaldValue, variable = this.variable;\n    if (typeof name !== 'string') {\n        // expand 'primitive' name directly to get\n        // things faster (~10% for benchmark.less):\n        name = (name.length === 1) && (name[0] instanceof Keyword) ?\n                name[0].value : evalName(context, name);\n        variable = false; // never treat expanded interpolation as new variable name\n    }\n\n    // @todo remove when parens-division is default\n    if (name === 'font' && context.math === MATH.ALWAYS) {\n        mathBypass = true;\n        prevMath = context.math;\n        context.math = MATH.PARENS_DIVISION;\n    }\n    try {\n        context.importantScope.push({});\n        evaldValue = this.value.eval(context);\n\n        if (!this.variable && evaldValue.type === 'DetachedRuleset') {\n            throw { message: 'Rulesets cannot be evaluated on a property.',\n                index: this.getIndex(), filename: this.fileInfo().filename };\n        }\n        var important = this.important,\n            importantResult = context.importantScope.pop();\n        if (!important && importantResult.important) {\n            important = importantResult.important;\n        }\n\n        return new Declaration(name,\n                          evaldValue,\n                          important,\n                          this.merge,\n                          this.getIndex(), this.fileInfo(), this.inline,\n                              variable);\n    }\n    catch (e) {\n        if (typeof e.index !== 'number') {\n            e.index = this.getIndex();\n            e.filename = this.fileInfo().filename;\n        }\n        throw e;\n    }\n    finally {\n        if (mathBypass) {\n            context.math = prevMath;\n        }\n    }\n};\nDeclaration.prototype.makeImportant = function () {\n    return new Declaration(this.name,\n                          this.value,\n                          '!important',\n                          this.merge,\n                          this.getIndex(), this.fileInfo(), this.inline);\n};\n\nmodule.exports = Declaration;\n},{\"../constants\":12,\"./anonymous\":50,\"./keyword\":70,\"./node\":76,\"./value\":86}],61:[function(require,module,exports){\nvar Node = require('./node'),\n    contexts = require('../contexts'),\n    utils = require('../utils');\n\nvar DetachedRuleset = function (ruleset, frames) {\n    this.ruleset = ruleset;\n    this.frames = frames;\n    this.setParent(this.ruleset, this);\n};\nDetachedRuleset.prototype = new Node();\nDetachedRuleset.prototype.type = 'DetachedRuleset';\nDetachedRuleset.prototype.evalFirst = true;\nDetachedRuleset.prototype.accept = function (visitor) {\n    this.ruleset = visitor.visit(this.ruleset);\n};\nDetachedRuleset.prototype.eval = function (context) {\n    var frames = this.frames || utils.copyArray(context.frames);\n    return new DetachedRuleset(this.ruleset, frames);\n};\nDetachedRuleset.prototype.callEval = function (context) {\n    return this.ruleset.eval(this.frames ? new contexts.Eval(context, this.frames.concat(context.frames)) : context);\n};\nmodule.exports = DetachedRuleset;\n\n},{\"../contexts\":13,\"../utils\":89,\"./node\":76}],62:[function(require,module,exports){\nvar Node = require('./node'),\n    unitConversions = require('../data/unit-conversions'),\n    Unit = require('./unit'),\n    Color = require('./color');\n\n//\n// A number with a unit\n//\nvar Dimension = function (value, unit) {\n    this.value = parseFloat(value);\n    if (isNaN(this.value)) {\n        throw new Error('Dimension is not a number.');\n    }\n    this.unit = (unit && unit instanceof Unit) ? unit :\n      new Unit(unit ? [unit] : undefined);\n    this.setParent(this.unit, this);\n};\n\nDimension.prototype = new Node();\nDimension.prototype.type = 'Dimension';\nDimension.prototype.accept = function (visitor) {\n    this.unit = visitor.visit(this.unit);\n};\nDimension.prototype.eval = function (context) {\n    return this;\n};\nDimension.prototype.toColor = function () {\n    return new Color([this.value, this.value, this.value]);\n};\nDimension.prototype.genCSS = function (context, output) {\n    if ((context && context.strictUnits) && !this.unit.isSingular()) {\n        throw new Error('Multiple units in dimension. Correct the units or use the unit function. Bad unit: ' + this.unit.toString());\n    }\n\n    var value = this.fround(context, this.value),\n        strValue = String(value);\n\n    if (value !== 0 && value < 0.000001 && value > -0.000001) {\n        // would be output 1e-6 etc.\n        strValue = value.toFixed(20).replace(/0+$/, '');\n    }\n\n    if (context && context.compress) {\n        // Zero values doesn't need a unit\n        if (value === 0 && this.unit.isLength()) {\n            output.add(strValue);\n            return;\n        }\n\n        // Float values doesn't need a leading zero\n        if (value > 0 && value < 1) {\n            strValue = (strValue).substr(1);\n        }\n    }\n\n    output.add(strValue);\n    this.unit.genCSS(context, output);\n};\n\n// In an operation between two Dimensions,\n// we default to the first Dimension's unit,\n// so `1px + 2` will yield `3px`.\nDimension.prototype.operate = function (context, op, other) {\n    /* jshint noempty:false */\n    var value = this._operate(context, op, this.value, other.value),\n        unit = this.unit.clone();\n\n    if (op === '+' || op === '-') {\n        if (unit.numerator.length === 0 && unit.denominator.length === 0) {\n            unit = other.unit.clone();\n            if (this.unit.backupUnit) {\n                unit.backupUnit = this.unit.backupUnit;\n            }\n        } else if (other.unit.numerator.length === 0 && unit.denominator.length === 0) {\n            // do nothing\n        } else {\n            other = other.convertTo(this.unit.usedUnits());\n\n            if (context.strictUnits && other.unit.toString() !== unit.toString()) {\n                throw new Error('Incompatible units. Change the units or use the unit function. Bad units: \\'' + unit.toString() +\n                    '\\' and \\'' + other.unit.toString() + '\\'.');\n            }\n\n            value = this._operate(context, op, this.value, other.value);\n        }\n    } else if (op === '*') {\n        unit.numerator = unit.numerator.concat(other.unit.numerator).sort();\n        unit.denominator = unit.denominator.concat(other.unit.denominator).sort();\n        unit.cancel();\n    } else if (op === '/') {\n        unit.numerator = unit.numerator.concat(other.unit.denominator).sort();\n        unit.denominator = unit.denominator.concat(other.unit.numerator).sort();\n        unit.cancel();\n    }\n    return new Dimension(value, unit);\n};\nDimension.prototype.compare = function (other) {\n    var a, b;\n\n    if (!(other instanceof Dimension)) {\n        return undefined;\n    }\n\n    if (this.unit.isEmpty() || other.unit.isEmpty()) {\n        a = this;\n        b = other;\n    } else {\n        a = this.unify();\n        b = other.unify();\n        if (a.unit.compare(b.unit) !== 0) {\n            return undefined;\n        }\n    }\n\n    return Node.numericCompare(a.value, b.value);\n};\nDimension.prototype.unify = function () {\n    return this.convertTo({ length: 'px', duration: 's', angle: 'rad' });\n};\nDimension.prototype.convertTo = function (conversions) {\n    var value = this.value, unit = this.unit.clone(),\n        i, groupName, group, targetUnit, derivedConversions = {}, applyUnit;\n\n    if (typeof conversions === 'string') {\n        for (i in unitConversions) {\n            if (unitConversions[i].hasOwnProperty(conversions)) {\n                derivedConversions = {};\n                derivedConversions[i] = conversions;\n            }\n        }\n        conversions = derivedConversions;\n    }\n    applyUnit = function (atomicUnit, denominator) {\n        /* jshint loopfunc:true */\n        if (group.hasOwnProperty(atomicUnit)) {\n            if (denominator) {\n                value = value / (group[atomicUnit] / group[targetUnit]);\n            } else {\n                value = value * (group[atomicUnit] / group[targetUnit]);\n            }\n\n            return targetUnit;\n        }\n\n        return atomicUnit;\n    };\n\n    for (groupName in conversions) {\n        if (conversions.hasOwnProperty(groupName)) {\n            targetUnit = conversions[groupName];\n            group = unitConversions[groupName];\n\n            unit.map(applyUnit);\n        }\n    }\n\n    unit.cancel();\n\n    return new Dimension(value, unit);\n};\nmodule.exports = Dimension;\n\n},{\"../data/unit-conversions\":16,\"./color\":55,\"./node\":76,\"./unit\":84}],63:[function(require,module,exports){\nvar Node = require('./node'),\n    Paren = require('./paren'),\n    Combinator = require('./combinator');\n\nvar Element = function (combinator, value, isVariable, index, currentFileInfo, visibilityInfo) {\n    this.combinator = combinator instanceof Combinator ?\n                      combinator : new Combinator(combinator);\n\n    if (typeof value === 'string') {\n        this.value = value.trim();\n    } else if (value) {\n        this.value = value;\n    } else {\n        this.value = '';\n    }\n    this.isVariable = isVariable;\n    this._index = index;\n    this._fileInfo = currentFileInfo;\n    this.copyVisibilityInfo(visibilityInfo);\n    this.setParent(this.combinator, this);\n};\nElement.prototype = new Node();\nElement.prototype.type = 'Element';\nElement.prototype.accept = function (visitor) {\n    var value = this.value;\n    this.combinator = visitor.visit(this.combinator);\n    if (typeof value === 'object') {\n        this.value = visitor.visit(value);\n    }\n};\nElement.prototype.eval = function (context) {\n    return new Element(this.combinator,\n                             this.value.eval ? this.value.eval(context) : this.value,\n                             this.isVariable,\n                             this.getIndex(),\n                             this.fileInfo(), this.visibilityInfo());\n};\nElement.prototype.clone = function () {\n    return new Element(this.combinator,\n        this.value,\n        this.isVariable,\n        this.getIndex(),\n        this.fileInfo(), this.visibilityInfo());\n};\nElement.prototype.genCSS = function (context, output) {\n    output.add(this.toCSS(context), this.fileInfo(), this.getIndex());\n};\nElement.prototype.toCSS = function (context) {\n    context = context || {};\n    var value = this.value, firstSelector = context.firstSelector;\n    if (value instanceof Paren) {\n        // selector in parens should not be affected by outer selector\n        // flags (breaks only interpolated selectors - see #1973)\n        context.firstSelector = true;\n    }\n    value = value.toCSS ? value.toCSS(context) : value;\n    context.firstSelector = firstSelector;\n    if (value === '' && this.combinator.value.charAt(0) === '&') {\n        return '';\n    } else {\n        return this.combinator.toCSS(context) + value;\n    }\n};\nmodule.exports = Element;\n\n},{\"./combinator\":56,\"./node\":76,\"./paren\":78}],64:[function(require,module,exports){\nvar Node = require('./node'),\n    Paren = require('./paren'),\n    Comment = require('./comment'),\n    Dimension = require('./dimension'),\n    MATH = require('../constants').Math;\n\nvar Expression = function (value, noSpacing) {\n    this.value = value;\n    this.noSpacing = noSpacing;\n    if (!value) {\n        throw new Error('Expression requires an array parameter');\n    }\n};\nExpression.prototype = new Node();\nExpression.prototype.type = 'Expression';\nExpression.prototype.accept = function (visitor) {\n    this.value = visitor.visitArray(this.value);\n};\nExpression.prototype.eval = function (context) {\n    var returnValue,\n        mathOn = context.isMathOn(),\n        inParenthesis = this.parens && \n            (context.math !== MATH.STRICT_LEGACY || !this.parensInOp),\n        doubleParen = false;\n    if (inParenthesis) {\n        context.inParenthesis();\n    }\n    if (this.value.length > 1) {\n        returnValue = new Expression(this.value.map(function (e) {\n            if (!e.eval) {\n                return e;\n            }\n            return e.eval(context);\n        }), this.noSpacing);\n    } else if (this.value.length === 1) {\n        if (this.value[0].parens && !this.value[0].parensInOp && !context.inCalc) {\n            doubleParen = true;\n        }\n        returnValue = this.value[0].eval(context);\n    } else {\n        returnValue = this;\n    }\n    if (inParenthesis) {\n        context.outOfParenthesis();\n    }\n    if (this.parens && this.parensInOp && !mathOn && !doubleParen \n        && (!(returnValue instanceof Dimension))) {\n        returnValue = new Paren(returnValue);\n    }\n    return returnValue;\n};\nExpression.prototype.genCSS = function (context, output) {\n    for (var i = 0; i < this.value.length; i++) {\n        this.value[i].genCSS(context, output);\n        if (!this.noSpacing && i + 1 < this.value.length) {\n            output.add(' ');\n        }\n    }\n};\nExpression.prototype.throwAwayComments = function () {\n    this.value = this.value.filter(function(v) {\n        return !(v instanceof Comment);\n    });\n};\nmodule.exports = Expression;\n\n},{\"../constants\":12,\"./comment\":57,\"./dimension\":62,\"./node\":76,\"./paren\":78}],65:[function(require,module,exports){\nvar Node = require('./node'),\n    Selector = require('./selector');\n\nvar Extend = function Extend(selector, option, index, currentFileInfo, visibilityInfo) {\n    this.selector = selector;\n    this.option = option;\n    this.object_id = Extend.next_id++;\n    this.parent_ids = [this.object_id];\n    this._index = index;\n    this._fileInfo = currentFileInfo;\n    this.copyVisibilityInfo(visibilityInfo);\n    this.allowRoot = true;\n\n    switch (option) {\n        case 'all':\n            this.allowBefore = true;\n            this.allowAfter = true;\n            break;\n        default:\n            this.allowBefore = false;\n            this.allowAfter = false;\n            break;\n    }\n    this.setParent(this.selector, this);\n};\nExtend.next_id = 0;\n\nExtend.prototype = new Node();\nExtend.prototype.type = 'Extend';\nExtend.prototype.accept = function (visitor) {\n    this.selector = visitor.visit(this.selector);\n};\nExtend.prototype.eval = function (context) {\n    return new Extend(this.selector.eval(context), this.option, this.getIndex(), this.fileInfo(), this.visibilityInfo());\n};\nExtend.prototype.clone = function (context) {\n    return new Extend(this.selector, this.option, this.getIndex(), this.fileInfo(), this.visibilityInfo());\n};\n// it concatenates (joins) all selectors in selector array\nExtend.prototype.findSelfSelectors = function (selectors) {\n    var selfElements = [],\n        i,\n        selectorElements;\n\n    for (i = 0; i < selectors.length; i++) {\n        selectorElements = selectors[i].elements;\n        // duplicate the logic in genCSS function inside the selector node.\n        // future TODO - move both logics into the selector joiner visitor\n        if (i > 0 && selectorElements.length && selectorElements[0].combinator.value === '') {\n            selectorElements[0].combinator.value = ' ';\n        }\n        selfElements = selfElements.concat(selectors[i].elements);\n    }\n\n    this.selfSelectors = [new Selector(selfElements)];\n    this.selfSelectors[0].copyVisibilityInfo(this.visibilityInfo());\n};\nmodule.exports = Extend;\n\n},{\"./node\":76,\"./selector\":82}],66:[function(require,module,exports){\nvar Node = require('./node'),\n    Media = require('./media'),\n    URL = require('./url'),\n    Quoted = require('./quoted'),\n    Ruleset = require('./ruleset'),\n    Anonymous = require('./anonymous'),\n    utils = require('../utils'),\n    LessError = require('../less-error');\n\n//\n// CSS @import node\n//\n// The general strategy here is that we don't want to wait\n// for the parsing to be completed, before we start importing\n// the file. That's because in the context of a browser,\n// most of the time will be spent waiting for the server to respond.\n//\n// On creation, we push the import path to our import queue, though\n// `import,push`, we also pass it a callback, which it'll call once\n// the file has been fetched, and parsed.\n//\nvar Import = function (path, features, options, index, currentFileInfo, visibilityInfo) {\n    this.options = options;\n    this._index = index;\n    this._fileInfo = currentFileInfo;\n    this.path = path;\n    this.features = features;\n    this.allowRoot = true;\n\n    if (this.options.less !== undefined || this.options.inline) {\n        this.css = !this.options.less || this.options.inline;\n    } else {\n        var pathValue = this.getPath();\n        if (pathValue && /[#\\.\\&\\?]css([\\?;].*)?$/.test(pathValue)) {\n            this.css = true;\n        }\n    }\n    this.copyVisibilityInfo(visibilityInfo);\n    this.setParent(this.features, this);\n    this.setParent(this.path, this);\n};\n\n//\n// The actual import node doesn't return anything, when converted to CSS.\n// The reason is that it's used at the evaluation stage, so that the rules\n// it imports can be treated like any other rules.\n//\n// In `eval`, we make sure all Import nodes get evaluated, recursively, so\n// we end up with a flat structure, which can easily be imported in the parent\n// ruleset.\n//\nImport.prototype = new Node();\nImport.prototype.type = 'Import';\nImport.prototype.accept = function (visitor) {\n    if (this.features) {\n        this.features = visitor.visit(this.features);\n    }\n    this.path = visitor.visit(this.path);\n    if (!this.options.isPlugin && !this.options.inline && this.root) {\n        this.root = visitor.visit(this.root);\n    }\n};\nImport.prototype.genCSS = function (context, output) {\n    if (this.css && this.path._fileInfo.reference === undefined) {\n        output.add('@import ', this._fileInfo, this._index);\n        this.path.genCSS(context, output);\n        if (this.features) {\n            output.add(' ');\n            this.features.genCSS(context, output);\n        }\n        output.add(';');\n    }\n};\nImport.prototype.getPath = function () {\n    return (this.path instanceof URL) ?\n        this.path.value.value : this.path.value;\n};\nImport.prototype.isVariableImport = function () {\n    var path = this.path;\n    if (path instanceof URL) {\n        path = path.value;\n    }\n    if (path instanceof Quoted) {\n        return path.containsVariables();\n    }\n\n    return true;\n};\nImport.prototype.evalForImport = function (context) {\n    var path = this.path;\n\n    if (path instanceof URL) {\n        path = path.value;\n    }\n\n    return new Import(path.eval(context), this.features, this.options, this._index, this._fileInfo, this.visibilityInfo());\n};\nImport.prototype.evalPath = function (context) {\n    var path = this.path.eval(context);\n    var fileInfo = this._fileInfo;\n\n    if (!(path instanceof URL)) {\n        // Add the rootpath if the URL requires a rewrite\n        var pathValue = path.value;\n        if (fileInfo &&\n            pathValue &&\n            context.pathRequiresRewrite(pathValue)) {\n            path.value = context.rewritePath(pathValue, fileInfo.rootpath);\n        } else {\n            path.value = context.normalizePath(path.value);\n        }\n    }\n\n    return path;\n};\nImport.prototype.eval = function (context) {\n    var result = this.doEval(context);\n    if (this.options.reference || this.blocksVisibility()) {\n        if (result.length || result.length === 0) {\n            result.forEach(function (node) {\n                node.addVisibilityBlock();\n            }\n            );\n        } else {\n            result.addVisibilityBlock();\n        }\n    }\n    return result;\n};\nImport.prototype.doEval = function (context) {\n    var ruleset, registry,\n        features = this.features && this.features.eval(context);\n\n    if (this.options.isPlugin) {\n        if (this.root && this.root.eval) {\n            try {\n                this.root.eval(context);\n            }\n            catch (e) {\n                e.message = 'Plugin error during evaluation';\n                throw new LessError(e, this.root.imports, this.root.filename);\n            }\n        }\n        registry = context.frames[0] && context.frames[0].functionRegistry;\n        if ( registry && this.root && this.root.functions ) {\n            registry.addMultiple( this.root.functions );\n        }\n\n        return [];\n    }\n\n    if (this.skip) {\n        if (typeof this.skip === 'function') {\n            this.skip = this.skip();\n        }\n        if (this.skip) {\n            return [];\n        }\n    }\n    if (this.options.inline) {\n        var contents = new Anonymous(this.root, 0,\n            {\n                filename: this.importedFilename,\n                reference: this.path._fileInfo && this.path._fileInfo.reference\n            }, true, true);\n\n        return this.features ? new Media([contents], this.features.value) : [contents];\n    } else if (this.css) {\n        var newImport = new Import(this.evalPath(context), features, this.options, this._index);\n        if (!newImport.css && this.error) {\n            throw this.error;\n        }\n        return newImport;\n    } else {\n        ruleset = new Ruleset(null, utils.copyArray(this.root.rules));\n        ruleset.evalImports(context);\n\n        return this.features ? new Media(ruleset.rules, this.features.value) : ruleset.rules;\n    }\n};\nmodule.exports = Import;\n\n},{\"../less-error\":38,\"../utils\":89,\"./anonymous\":50,\"./media\":71,\"./node\":76,\"./quoted\":80,\"./ruleset\":81,\"./url\":85}],67:[function(require,module,exports){\nvar tree = Object.create(null);\n\ntree.Node = require('./node');\ntree.Color = require('./color');\ntree.AtRule = require('./atrule');\ntree.DetachedRuleset = require('./detached-ruleset');\ntree.Operation = require('./operation');\ntree.Dimension = require('./dimension');\ntree.Unit = require('./unit');\ntree.Keyword = require('./keyword');\ntree.Variable = require('./variable');\ntree.Property = require('./property');\ntree.Ruleset = require('./ruleset');\ntree.Element = require('./element');\ntree.Attribute = require('./attribute');\ntree.Combinator = require('./combinator');\ntree.Selector = require('./selector');\ntree.Quoted = require('./quoted');\ntree.Expression = require('./expression');\ntree.Declaration = require('./declaration');\ntree.Call = require('./call');\ntree.URL = require('./url');\ntree.Import = require('./import');\ntree.mixin = {\n    Call: require('./mixin-call'),\n    Definition: require('./mixin-definition')\n};\ntree.Comment = require('./comment');\ntree.Anonymous = require('./anonymous');\ntree.Value = require('./value');\ntree.JavaScript = require('./javascript');\ntree.Assignment = require('./assignment');\ntree.Condition = require('./condition');\ntree.Paren = require('./paren');\ntree.Media = require('./media');\ntree.UnicodeDescriptor = require('./unicode-descriptor');\ntree.Negative = require('./negative');\ntree.Extend = require('./extend');\ntree.VariableCall = require('./variable-call');\ntree.NamespaceValue = require('./namespace-value');\n\nmodule.exports = tree;\n\n},{\"./anonymous\":50,\"./assignment\":51,\"./atrule\":52,\"./attribute\":53,\"./call\":54,\"./color\":55,\"./combinator\":56,\"./comment\":57,\"./condition\":58,\"./declaration\":60,\"./detached-ruleset\":61,\"./dimension\":62,\"./element\":63,\"./expression\":64,\"./extend\":65,\"./import\":66,\"./javascript\":68,\"./keyword\":70,\"./media\":71,\"./mixin-call\":72,\"./mixin-definition\":73,\"./namespace-value\":74,\"./negative\":75,\"./node\":76,\"./operation\":77,\"./paren\":78,\"./property\":79,\"./quoted\":80,\"./ruleset\":81,\"./selector\":82,\"./unicode-descriptor\":83,\"./unit\":84,\"./url\":85,\"./value\":86,\"./variable\":88,\"./variable-call\":87}],68:[function(require,module,exports){\nvar JsEvalNode = require('./js-eval-node'),\n    Dimension = require('./dimension'),\n    Quoted = require('./quoted'),\n    Anonymous = require('./anonymous');\n\nvar JavaScript = function (string, escaped, index, currentFileInfo) {\n    this.escaped = escaped;\n    this.expression = string;\n    this._index = index;\n    this._fileInfo = currentFileInfo;\n};\nJavaScript.prototype = new JsEvalNode();\nJavaScript.prototype.type = 'JavaScript';\nJavaScript.prototype.eval = function(context) {\n    var result = this.evaluateJavaScript(this.expression, context);\n    var type = typeof result;\n\n    if (type === 'number' && !isNaN(result)) {\n        return new Dimension(result);\n    } else if (type === 'string') {\n        return new Quoted('\"' + result + '\"', result, this.escaped, this._index);\n    } else if (Array.isArray(result)) {\n        return new Anonymous(result.join(', '));\n    } else {\n        return new Anonymous(result);\n    }\n};\n\nmodule.exports = JavaScript;\n\n},{\"./anonymous\":50,\"./dimension\":62,\"./js-eval-node\":69,\"./quoted\":80}],69:[function(require,module,exports){\nvar Node = require('./node'),\n    Variable = require('./variable');\n\nvar JsEvalNode = function() {\n};\nJsEvalNode.prototype = new Node();\n\nJsEvalNode.prototype.evaluateJavaScript = function (expression, context) {\n    var result,\n        that = this,\n        evalContext = {};\n\n    if (!context.javascriptEnabled) {\n        throw { message: 'Inline JavaScript is not enabled. Is it set in your options?',\n            filename: this.fileInfo().filename,\n            index: this.getIndex() };\n    }\n\n    expression = expression.replace(/@\\{([\\w-]+)\\}/g, function (_, name) {\n        return that.jsify(new Variable('@' + name, that.getIndex(), that.fileInfo()).eval(context));\n    });\n\n    try {\n        expression = new Function('return (' + expression + ')');\n    } catch (e) {\n        throw { message: 'JavaScript evaluation error: ' + e.message + ' from `' + expression + '`' ,\n            filename: this.fileInfo().filename,\n            index: this.getIndex() };\n    }\n\n    var variables = context.frames[0].variables();\n    for (var k in variables) {\n        if (variables.hasOwnProperty(k)) {\n            /* jshint loopfunc:true */\n            evalContext[k.slice(1)] = {\n                value: variables[k].value,\n                toJS: function () {\n                    return this.value.eval(context).toCSS();\n                }\n            };\n        }\n    }\n\n    try {\n        result = expression.call(evalContext);\n    } catch (e) {\n        throw { message: 'JavaScript evaluation error: \\'' + e.name + ': ' + e.message.replace(/[\"]/g, '\\'') + '\\'' ,\n            filename: this.fileInfo().filename,\n            index: this.getIndex() };\n    }\n    return result;\n};\nJsEvalNode.prototype.jsify = function (obj) {\n    if (Array.isArray(obj.value) && (obj.value.length > 1)) {\n        return '[' + obj.value.map(function (v) { return v.toCSS(); }).join(', ') + ']';\n    } else {\n        return obj.toCSS();\n    }\n};\n\nmodule.exports = JsEvalNode;\n\n},{\"./node\":76,\"./variable\":88}],70:[function(require,module,exports){\nvar Node = require('./node');\n\nvar Keyword = function (value) { this.value = value; };\nKeyword.prototype = new Node();\nKeyword.prototype.type = 'Keyword';\nKeyword.prototype.genCSS = function (context, output) {\n    if (this.value === '%') { throw { type: 'Syntax', message: 'Invalid % without number' }; }\n    output.add(this.value);\n};\n\nKeyword.True = new Keyword('true');\nKeyword.False = new Keyword('false');\n\nmodule.exports = Keyword;\n\n},{\"./node\":76}],71:[function(require,module,exports){\nvar Ruleset = require('./ruleset'),\n    Value = require('./value'),\n    Selector = require('./selector'),\n    Anonymous = require('./anonymous'),\n    Expression = require('./expression'),\n    AtRule = require('./atrule'),\n    utils = require('../utils');\n\nvar Media = function (value, features, index, currentFileInfo, visibilityInfo) {\n    this._index = index;\n    this._fileInfo = currentFileInfo;\n\n    var selectors = (new Selector([], null, null, this._index, this._fileInfo)).createEmptySelectors();\n\n    this.features = new Value(features);\n    this.rules = [new Ruleset(selectors, value)];\n    this.rules[0].allowImports = true;\n    this.copyVisibilityInfo(visibilityInfo);\n    this.allowRoot = true;\n    this.setParent(selectors, this);\n    this.setParent(this.features, this);\n    this.setParent(this.rules, this);\n};\nMedia.prototype = new AtRule();\nMedia.prototype.type = 'Media';\nMedia.prototype.isRulesetLike = function() { return true; };\nMedia.prototype.accept = function (visitor) {\n    if (this.features) {\n        this.features = visitor.visit(this.features);\n    }\n    if (this.rules) {\n        this.rules = visitor.visitArray(this.rules);\n    }\n};\nMedia.prototype.genCSS = function (context, output) {\n    output.add('@media ', this._fileInfo, this._index);\n    this.features.genCSS(context, output);\n    this.outputRuleset(context, output, this.rules);\n};\nMedia.prototype.eval = function (context) {\n    if (!context.mediaBlocks) {\n        context.mediaBlocks = [];\n        context.mediaPath = [];\n    }\n\n    var media = new Media(null, [], this._index, this._fileInfo, this.visibilityInfo());\n    if (this.debugInfo) {\n        this.rules[0].debugInfo = this.debugInfo;\n        media.debugInfo = this.debugInfo;\n    }\n    \n    media.features = this.features.eval(context);\n\n    context.mediaPath.push(media);\n    context.mediaBlocks.push(media);\n\n    this.rules[0].functionRegistry = context.frames[0].functionRegistry.inherit();\n    context.frames.unshift(this.rules[0]);\n    media.rules = [this.rules[0].eval(context)];\n    context.frames.shift();\n\n    context.mediaPath.pop();\n\n    return context.mediaPath.length === 0 ? media.evalTop(context) :\n                media.evalNested(context);\n};\nMedia.prototype.evalTop = function (context) {\n    var result = this;\n\n    // Render all dependent Media blocks.\n    if (context.mediaBlocks.length > 1) {\n        var selectors = (new Selector([], null, null, this.getIndex(), this.fileInfo())).createEmptySelectors();\n        result = new Ruleset(selectors, context.mediaBlocks);\n        result.multiMedia = true;\n        result.copyVisibilityInfo(this.visibilityInfo());\n        this.setParent(result, this);\n    }\n\n    delete context.mediaBlocks;\n    delete context.mediaPath;\n\n    return result;\n};\nMedia.prototype.evalNested = function (context) {\n    var i, value,\n        path = context.mediaPath.concat([this]);\n\n    // Extract the media-query conditions separated with `,` (OR).\n    for (i = 0; i < path.length; i++) {\n        value = path[i].features instanceof Value ?\n                    path[i].features.value : path[i].features;\n        path[i] = Array.isArray(value) ? value : [value];\n    }\n\n    // Trace all permutations to generate the resulting media-query.\n    //\n    // (a, b and c) with nested (d, e) ->\n    //    a and d\n    //    a and e\n    //    b and c and d\n    //    b and c and e\n    this.features = new Value(this.permute(path).map(function (path) {\n        path = path.map(function (fragment) {\n            return fragment.toCSS ? fragment : new Anonymous(fragment);\n        });\n\n        for (i = path.length - 1; i > 0; i--) {\n            path.splice(i, 0, new Anonymous('and'));\n        }\n\n        return new Expression(path);\n    }));\n    this.setParent(this.features, this);\n\n    // Fake a tree-node that doesn't output anything.\n    return new Ruleset([], []);\n};\nMedia.prototype.permute = function (arr) {\n    if (arr.length === 0) {\n        return [];\n    } else if (arr.length === 1) {\n        return arr[0];\n    } else {\n        var result = [];\n        var rest = this.permute(arr.slice(1));\n        for (var i = 0; i < rest.length; i++) {\n            for (var j = 0; j < arr[0].length; j++) {\n                result.push([arr[0][j]].concat(rest[i]));\n            }\n        }\n        return result;\n    }\n};\nMedia.prototype.bubbleSelectors = function (selectors) {\n    if (!selectors) {\n        return;\n    }\n    this.rules = [new Ruleset(utils.copyArray(selectors), [this.rules[0]])];\n    this.setParent(this.rules, this);\n};\nmodule.exports = Media;\n\n},{\"../utils\":89,\"./anonymous\":50,\"./atrule\":52,\"./expression\":64,\"./ruleset\":81,\"./selector\":82,\"./value\":86}],72:[function(require,module,exports){\nvar Node = require('./node'),\n    Selector = require('./selector'),\n    MixinDefinition = require('./mixin-definition'),\n    defaultFunc = require('../functions/default');\n\nvar MixinCall = function (elements, args, index, currentFileInfo, important) {\n    this.selector = new Selector(elements);\n    this.arguments = args || [];\n    this._index = index;\n    this._fileInfo = currentFileInfo;\n    this.important = important;\n    this.allowRoot = true;\n    this.setParent(this.selector, this);\n};\nMixinCall.prototype = new Node();\nMixinCall.prototype.type = 'MixinCall';\nMixinCall.prototype.accept = function (visitor) {\n    if (this.selector) {\n        this.selector = visitor.visit(this.selector);\n    }\n    if (this.arguments.length) {\n        this.arguments = visitor.visitArray(this.arguments);\n    }\n};\nMixinCall.prototype.eval = function (context) {\n    var mixins, mixin, mixinPath, args = [], arg, argValue,\n        rules = [], match = false, i, m, f, isRecursive, isOneFound,\n        candidates = [], candidate, conditionResult = [], defaultResult, defFalseEitherCase = -1,\n        defNone = 0, defTrue = 1, defFalse = 2, count, originalRuleset, noArgumentsFilter;\n\n    this.selector = this.selector.eval(context);\n\n    function calcDefGroup(mixin, mixinPath) {\n        var f, p, namespace;\n\n        for (f = 0; f < 2; f++) {\n            conditionResult[f] = true;\n            defaultFunc.value(f);\n            for (p = 0; p < mixinPath.length && conditionResult[f]; p++) {\n                namespace = mixinPath[p];\n                if (namespace.matchCondition) {\n                    conditionResult[f] = conditionResult[f] && namespace.matchCondition(null, context);\n                }\n            }\n            if (mixin.matchCondition) {\n                conditionResult[f] = conditionResult[f] && mixin.matchCondition(args, context);\n            }\n        }\n        if (conditionResult[0] || conditionResult[1]) {\n            if (conditionResult[0] != conditionResult[1]) {\n                return conditionResult[1] ?\n                    defTrue : defFalse;\n            }\n\n            return defNone;\n        }\n        return defFalseEitherCase;\n    }\n\n    for (i = 0; i < this.arguments.length; i++) {\n        arg = this.arguments[i];\n        argValue = arg.value.eval(context);\n        if (arg.expand && Array.isArray(argValue.value)) {\n            argValue = argValue.value;\n            for (m = 0; m < argValue.length; m++) {\n                args.push({value: argValue[m]});\n            }\n        } else {\n            args.push({name: arg.name, value: argValue});\n        }\n    }\n\n    noArgumentsFilter = function(rule) {return rule.matchArgs(null, context);};\n\n    for (i = 0; i < context.frames.length; i++) {\n        if ((mixins = context.frames[i].find(this.selector, null, noArgumentsFilter)).length > 0) {\n            isOneFound = true;\n\n            // To make `default()` function independent of definition order we have two \"subpasses\" here.\n            // At first we evaluate each guard *twice* (with `default() == true` and `default() == false`),\n            // and build candidate list with corresponding flags. Then, when we know all possible matches,\n            // we make a final decision.\n\n            for (m = 0; m < mixins.length; m++) {\n                mixin = mixins[m].rule;\n                mixinPath = mixins[m].path;\n                isRecursive = false;\n                for (f = 0; f < context.frames.length; f++) {\n                    if ((!(mixin instanceof MixinDefinition)) && mixin === (context.frames[f].originalRuleset || context.frames[f])) {\n                        isRecursive = true;\n                        break;\n                    }\n                }\n                if (isRecursive) {\n                    continue;\n                }\n\n                if (mixin.matchArgs(args, context)) {\n                    candidate = {mixin: mixin, group: calcDefGroup(mixin, mixinPath)};\n\n                    if (candidate.group !== defFalseEitherCase) {\n                        candidates.push(candidate);\n                    }\n\n                    match = true;\n                }\n            }\n\n            defaultFunc.reset();\n\n            count = [0, 0, 0];\n            for (m = 0; m < candidates.length; m++) {\n                count[candidates[m].group]++;\n            }\n\n            if (count[defNone] > 0) {\n                defaultResult = defFalse;\n            } else {\n                defaultResult = defTrue;\n                if ((count[defTrue] + count[defFalse]) > 1) {\n                    throw { type: 'Runtime',\n                        message: 'Ambiguous use of `default()` found when matching for `' + this.format(args) + '`',\n                        index: this.getIndex(), filename: this.fileInfo().filename };\n                }\n            }\n\n            for (m = 0; m < candidates.length; m++) {\n                candidate = candidates[m].group;\n                if ((candidate === defNone) || (candidate === defaultResult)) {\n                    try {\n                        mixin = candidates[m].mixin;\n                        if (!(mixin instanceof MixinDefinition)) {\n                            originalRuleset = mixin.originalRuleset || mixin;\n                            mixin = new MixinDefinition('', [], mixin.rules, null, false, null, originalRuleset.visibilityInfo());\n                            mixin.originalRuleset = originalRuleset;\n                        }\n                        var newRules = mixin.evalCall(context, args, this.important).rules;\n                        this._setVisibilityToReplacement(newRules);\n                        Array.prototype.push.apply(rules, newRules);\n                    } catch (e) {\n                        throw { message: e.message, index: this.getIndex(), filename: this.fileInfo().filename, stack: e.stack };\n                    }\n                }\n            }\n\n            if (match) {\n                return rules;\n            }\n        }\n    }\n    if (isOneFound) {\n        throw { type:    'Runtime',\n            message: 'No matching definition was found for `' + this.format(args) + '`',\n            index:   this.getIndex(), filename: this.fileInfo().filename };\n    } else {\n        throw { type:    'Name',\n            message: this.selector.toCSS().trim() + ' is undefined',\n            index:   this.getIndex(), filename: this.fileInfo().filename };\n    }\n};\n\nMixinCall.prototype._setVisibilityToReplacement = function (replacement) {\n    var i, rule;\n    if (this.blocksVisibility()) {\n        for (i = 0; i < replacement.length; i++) {\n            rule = replacement[i];\n            rule.addVisibilityBlock();\n        }\n    }\n};\nMixinCall.prototype.format = function (args) {\n    return this.selector.toCSS().trim() + '(' +\n        (args ? args.map(function (a) {\n            var argValue = '';\n            if (a.name) {\n                argValue += a.name + ':';\n            }\n            if (a.value.toCSS) {\n                argValue += a.value.toCSS();\n            } else {\n                argValue += '???';\n            }\n            return argValue;\n        }).join(', ') : '') + ')';\n};\nmodule.exports = MixinCall;\n\n},{\"../functions/default\":25,\"./mixin-definition\":73,\"./node\":76,\"./selector\":82}],73:[function(require,module,exports){\nvar Selector = require('./selector'),\n    Element = require('./element'),\n    Ruleset = require('./ruleset'),\n    Declaration = require('./declaration'),\n    DetachedRuleset = require('./detached-ruleset'),\n    Expression = require('./expression'),\n    contexts = require('../contexts'),\n    utils = require('../utils');\n\nvar Definition = function (name, params, rules, condition, variadic, frames, visibilityInfo) {\n    this.name = name || 'anonymous mixin';\n    this.selectors = [new Selector([new Element(null, name, false, this._index, this._fileInfo)])];\n    this.params = params;\n    this.condition = condition;\n    this.variadic = variadic;\n    this.arity = params.length;\n    this.rules = rules;\n    this._lookups = {};\n    var optionalParameters = [];\n    this.required = params.reduce(function (count, p) {\n        if (!p.name || (p.name && !p.value)) {\n            return count + 1;\n        }\n        else {\n            optionalParameters.push(p.name);\n            return count;\n        }\n    }, 0);\n    this.optionalParameters = optionalParameters;\n    this.frames = frames;\n    this.copyVisibilityInfo(visibilityInfo);\n    this.allowRoot = true;\n};\nDefinition.prototype = new Ruleset();\nDefinition.prototype.type = 'MixinDefinition';\nDefinition.prototype.evalFirst = true;\nDefinition.prototype.accept = function (visitor) {\n    if (this.params && this.params.length) {\n        this.params = visitor.visitArray(this.params);\n    }\n    this.rules = visitor.visitArray(this.rules);\n    if (this.condition) {\n        this.condition = visitor.visit(this.condition);\n    }\n};\nDefinition.prototype.evalParams = function (context, mixinEnv, args, evaldArguments) {\n    /* jshint boss:true */\n    var frame = new Ruleset(null, null),\n        varargs, arg,\n        params = utils.copyArray(this.params),\n        i, j, val, name, isNamedFound, argIndex, argsLength = 0;\n\n    if (mixinEnv.frames && mixinEnv.frames[0] && mixinEnv.frames[0].functionRegistry) {\n        frame.functionRegistry = mixinEnv.frames[0].functionRegistry.inherit();\n    }\n    mixinEnv = new contexts.Eval(mixinEnv, [frame].concat(mixinEnv.frames));\n\n    if (args) {\n        args = utils.copyArray(args);\n        argsLength = args.length;\n\n        for (i = 0; i < argsLength; i++) {\n            arg = args[i];\n            if (name = (arg && arg.name)) {\n                isNamedFound = false;\n                for (j = 0; j < params.length; j++) {\n                    if (!evaldArguments[j] && name === params[j].name) {\n                        evaldArguments[j] = arg.value.eval(context);\n                        frame.prependRule(new Declaration(name, arg.value.eval(context)));\n                        isNamedFound = true;\n                        break;\n                    }\n                }\n                if (isNamedFound) {\n                    args.splice(i, 1);\n                    i--;\n                    continue;\n                } else {\n                    throw { type: 'Runtime', message: 'Named argument for ' + this.name +\n                        ' ' + args[i].name + ' not found' };\n                }\n            }\n        }\n    }\n    argIndex = 0;\n    for (i = 0; i < params.length; i++) {\n        if (evaldArguments[i]) { continue; }\n\n        arg = args && args[argIndex];\n\n        if (name = params[i].name) {\n            if (params[i].variadic) {\n                varargs = [];\n                for (j = argIndex; j < argsLength; j++) {\n                    varargs.push(args[j].value.eval(context));\n                }\n                frame.prependRule(new Declaration(name, new Expression(varargs).eval(context)));\n            } else {\n                val = arg && arg.value;\n                if (val) {\n                    // This was a mixin call, pass in a detached ruleset of it's eval'd rules\n                    if (Array.isArray(val)) {\n                        val = new DetachedRuleset(new Ruleset('', val));\n                    }\n                    else {\n                        val = val.eval(context);\n                    }\n                } else if (params[i].value) {\n                    val = params[i].value.eval(mixinEnv);\n                    frame.resetCache();\n                } else {\n                    throw { type: 'Runtime', message: 'wrong number of arguments for ' + this.name +\n                        ' (' + argsLength + ' for ' + this.arity + ')' };\n                }\n\n                frame.prependRule(new Declaration(name, val));\n                evaldArguments[i] = val;\n            }\n        }\n\n        if (params[i].variadic && args) {\n            for (j = argIndex; j < argsLength; j++) {\n                evaldArguments[j] = args[j].value.eval(context);\n            }\n        }\n        argIndex++;\n    }\n\n    return frame;\n};\nDefinition.prototype.makeImportant = function() {\n    var rules = !this.rules ? this.rules : this.rules.map(function (r) {\n        if (r.makeImportant) {\n            return r.makeImportant(true);\n        } else {\n            return r;\n        }\n    });\n    var result = new Definition(this.name, this.params, rules, this.condition, this.variadic, this.frames);\n    return result;\n};\nDefinition.prototype.eval = function (context) {\n    return new Definition(this.name, this.params, this.rules, this.condition, this.variadic, this.frames || utils.copyArray(context.frames));\n};\nDefinition.prototype.evalCall = function (context, args, important) {\n    var _arguments = [],\n        mixinFrames = this.frames ? this.frames.concat(context.frames) : context.frames,\n        frame = this.evalParams(context, new contexts.Eval(context, mixinFrames), args, _arguments),\n        rules, ruleset;\n\n    frame.prependRule(new Declaration('@arguments', new Expression(_arguments).eval(context)));\n\n    rules = utils.copyArray(this.rules);\n\n    ruleset = new Ruleset(null, rules);\n    ruleset.originalRuleset = this;\n    ruleset = ruleset.eval(new contexts.Eval(context, [this, frame].concat(mixinFrames)));\n    if (important) {\n        ruleset = ruleset.makeImportant();\n    }\n    return ruleset;\n};\nDefinition.prototype.matchCondition = function (args, context) {\n    if (this.condition && !this.condition.eval(\n        new contexts.Eval(context,\n            [this.evalParams(context, /* the parameter variables */\n                new contexts.Eval(context, this.frames ? this.frames.concat(context.frames) : context.frames), args, [])]\n            .concat(this.frames || []) // the parent namespace/mixin frames\n            .concat(context.frames)))) { // the current environment frames\n        return false;\n    }\n    return true;\n};\nDefinition.prototype.matchArgs = function (args, context) {\n    var allArgsCnt = (args && args.length) || 0, len, optionalParameters = this.optionalParameters;\n    var requiredArgsCnt = !args ? 0 : args.reduce(function (count, p) {\n        if (optionalParameters.indexOf(p.name) < 0) {\n            return count + 1;\n        } else {\n            return count;\n        }\n    }, 0);\n\n    if (!this.variadic) {\n        if (requiredArgsCnt < this.required) {\n            return false;\n        }\n        if (allArgsCnt > this.params.length) {\n            return false;\n        }\n    } else {\n        if (requiredArgsCnt < (this.required - 1)) {\n            return false;\n        }\n    }\n\n    // check patterns\n    len = Math.min(requiredArgsCnt, this.arity);\n\n    for (var i = 0; i < len; i++) {\n        if (!this.params[i].name && !this.params[i].variadic) {\n            if (args[i].value.eval(context).toCSS() != this.params[i].value.eval(context).toCSS()) {\n                return false;\n            }\n        }\n    }\n    return true;\n};\nmodule.exports = Definition;\n\n},{\"../contexts\":13,\"../utils\":89,\"./declaration\":60,\"./detached-ruleset\":61,\"./element\":63,\"./expression\":64,\"./ruleset\":81,\"./selector\":82}],74:[function(require,module,exports){\nvar Node = require('./node'),\n    Variable = require('./variable'),\n    Ruleset = require('./ruleset'),\n    Selector = require('./selector');\n\nvar NamespaceValue = function (ruleCall, lookups, important, index, fileInfo) {\n    this.value = ruleCall;\n    this.lookups = lookups;\n    this.important = important;\n    this._index = index;\n    this._fileInfo = fileInfo;\n};\nNamespaceValue.prototype = new Node();\nNamespaceValue.prototype.type = 'NamespaceValue';\nNamespaceValue.prototype.eval = function (context) {\n    var i, j, name, rules = this.value.eval(context);\n    \n    for (i = 0; i < this.lookups.length; i++) {\n        name = this.lookups[i];\n\n        /**\n         * Eval'd DRs return rulesets.\n         * Eval'd mixins return rules, so let's make a ruleset if we need it.\n         * We need to do this because of late parsing of values\n         */\n        if (Array.isArray(rules)) {\n            rules = new Ruleset([new Selector()], rules);\n        }\n\n        if (name === '') {\n            rules = rules.lastDeclaration();\n        }\n        else if (name.charAt(0) === '@') {\n            if (name.charAt(1) === '@') {\n                name = '@' + new Variable(name.substr(1)).eval(context).value;\n            }\n            if (rules.variables) {\n                rules = rules.variable(name);\n            }\n            \n            if (!rules) {\n                throw { type: 'Name',\n                    message: 'variable ' + name + ' not found',\n                    filename: this.fileInfo().filename,\n                    index: this.getIndex() };\n            }\n        }\n        else {\n            if (name.substring(0, 2) === '$@') {\n                name = '$' + new Variable(name.substr(1)).eval(context).value;\n            }\n            else {\n                name = name.charAt(0) === '$' ? name : '$' + name;\n            }\n            if (rules.properties) {\n                rules = rules.property(name);\n            }\n        \n            if (!rules) {\n                throw { type: 'Name',\n                    message: 'property \"' + name.substr(1) + '\" not found',\n                    filename: this.fileInfo().filename,\n                    index: this.getIndex() };\n            }\n            // Properties are an array of values, since a ruleset can have multiple props.\n            // We pick the last one (the \"cascaded\" value)\n            rules = rules[rules.length - 1];\n        }\n\n        if (rules.value) {\n            rules = rules.eval(context).value;\n        }\n        if (rules.ruleset) {\n            rules = rules.ruleset.eval(context);\n        }\n    }\n    return rules;\n};\nmodule.exports = NamespaceValue;\n\n},{\"./node\":76,\"./ruleset\":81,\"./selector\":82,\"./variable\":88}],75:[function(require,module,exports){\nvar Node = require('./node'),\n    Operation = require('./operation'),\n    Dimension = require('./dimension');\n\nvar Negative = function (node) {\n    this.value = node;\n};\nNegative.prototype = new Node();\nNegative.prototype.type = 'Negative';\nNegative.prototype.genCSS = function (context, output) {\n    output.add('-');\n    this.value.genCSS(context, output);\n};\nNegative.prototype.eval = function (context) {\n    if (context.isMathOn()) {\n        return (new Operation('*', [new Dimension(-1), this.value])).eval(context);\n    }\n    return new Negative(this.value.eval(context));\n};\nmodule.exports = Negative;\n\n},{\"./dimension\":62,\"./node\":76,\"./operation\":77}],76:[function(require,module,exports){\nvar Node = function() {\n    this.parent = null;\n    this.visibilityBlocks = undefined;\n    this.nodeVisible = undefined;\n    this.rootNode = null;\n    this.parsed = null;\n\n    var self = this;\n    Object.defineProperty(this, 'currentFileInfo', {\n        get: function() { return self.fileInfo(); }\n    });\n    Object.defineProperty(this, 'index', {\n        get: function() { return self.getIndex(); }\n    });\n\n};\nNode.prototype.setParent = function(nodes, parent) {\n    function set(node) {\n        if (node && node instanceof Node) {\n            node.parent = parent;\n        }\n    }\n    if (Array.isArray(nodes)) {\n        nodes.forEach(set);\n    }\n    else {\n        set(nodes);\n    }\n};\nNode.prototype.getIndex = function() {\n    return this._index || (this.parent && this.parent.getIndex()) || 0;\n};\nNode.prototype.fileInfo = function() {\n    return this._fileInfo || (this.parent && this.parent.fileInfo()) || {};\n};\nNode.prototype.isRulesetLike = function() { return false; };\nNode.prototype.toCSS = function (context) {\n    var strs = [];\n    this.genCSS(context, {\n        add: function(chunk, fileInfo, index) {\n            strs.push(chunk);\n        },\n        isEmpty: function () {\n            return strs.length === 0;\n        }\n    });\n    return strs.join('');\n};\nNode.prototype.genCSS = function (context, output) {\n    output.add(this.value);\n};\nNode.prototype.accept = function (visitor) {\n    this.value = visitor.visit(this.value);\n};\nNode.prototype.eval = function () { return this; };\nNode.prototype._operate = function (context, op, a, b) {\n    switch (op) {\n        case '+': return a + b;\n        case '-': return a - b;\n        case '*': return a * b;\n        case '/': return a / b;\n    }\n};\nNode.prototype.fround = function(context, value) {\n    var precision = context && context.numPrecision;\n    // add \"epsilon\" to ensure numbers like 1.000000005 (represented as 1.000000004999...) are properly rounded:\n    return (precision) ? Number((value + 2e-16).toFixed(precision)) : value;\n};\nNode.compare = function (a, b) {\n    /* returns:\n     -1: a < b\n     0: a = b\n     1: a > b\n     and *any* other value for a != b (e.g. undefined, NaN, -2 etc.) */\n\n    if ((a.compare) &&\n        // for \"symmetric results\" force toCSS-based comparison\n        // of Quoted or Anonymous if either value is one of those\n        !(b.type === 'Quoted' || b.type === 'Anonymous')) {\n        return a.compare(b);\n    } else if (b.compare) {\n        return -b.compare(a);\n    } else if (a.type !== b.type) {\n        return undefined;\n    }\n\n    a = a.value;\n    b = b.value;\n    if (!Array.isArray(a)) {\n        return a === b ? 0 : undefined;\n    }\n    if (a.length !== b.length) {\n        return undefined;\n    }\n    for (var i = 0; i < a.length; i++) {\n        if (Node.compare(a[i], b[i]) !== 0) {\n            return undefined;\n        }\n    }\n    return 0;\n};\n\nNode.numericCompare = function (a, b) {\n    return a  <  b ? -1\n        : a === b ?  0\n        : a  >  b ?  1 : undefined;\n};\n// Returns true if this node represents root of ast imported by reference\nNode.prototype.blocksVisibility = function () {\n    if (this.visibilityBlocks == null) {\n        this.visibilityBlocks = 0;\n    }\n    return this.visibilityBlocks !== 0;\n};\nNode.prototype.addVisibilityBlock = function () {\n    if (this.visibilityBlocks == null) {\n        this.visibilityBlocks = 0;\n    }\n    this.visibilityBlocks = this.visibilityBlocks + 1;\n};\nNode.prototype.removeVisibilityBlock = function () {\n    if (this.visibilityBlocks == null) {\n        this.visibilityBlocks = 0;\n    }\n    this.visibilityBlocks = this.visibilityBlocks - 1;\n};\n// Turns on node visibility - if called node will be shown in output regardless\n// of whether it comes from import by reference or not\nNode.prototype.ensureVisibility = function () {\n    this.nodeVisible = true;\n};\n// Turns off node visibility - if called node will NOT be shown in output regardless\n// of whether it comes from import by reference or not\nNode.prototype.ensureInvisibility = function () {\n    this.nodeVisible = false;\n};\n// return values:\n// false - the node must not be visible\n// true - the node must be visible\n// undefined or null - the node has the same visibility as its parent\nNode.prototype.isVisible = function () {\n    return this.nodeVisible;\n};\nNode.prototype.visibilityInfo = function() {\n    return {\n        visibilityBlocks: this.visibilityBlocks,\n        nodeVisible: this.nodeVisible\n    };\n};\nNode.prototype.copyVisibilityInfo = function(info) {\n    if (!info) {\n        return;\n    }\n    this.visibilityBlocks = info.visibilityBlocks;\n    this.nodeVisible = info.nodeVisible;\n};\nmodule.exports = Node;\n\n},{}],77:[function(require,module,exports){\nvar Node = require('./node'),\n    Color = require('./color'),\n    Dimension = require('./dimension'),\n    MATH = require('../constants').Math;\n\nvar Operation = function (op, operands, isSpaced) {\n    this.op = op.trim();\n    this.operands = operands;\n    this.isSpaced = isSpaced;\n};\nOperation.prototype = new Node();\nOperation.prototype.type = 'Operation';\nOperation.prototype.accept = function (visitor) {\n    this.operands = visitor.visit(this.operands);\n};\nOperation.prototype.eval = function (context) {\n    var a = this.operands[0].eval(context),\n        b = this.operands[1].eval(context),\n        op;\n\n    if (context.isMathOn(this.op)) {\n        op = this.op === './' ? '/' : this.op;\n        if (a instanceof Dimension && b instanceof Color) {\n            a = a.toColor();\n        }\n        if (b instanceof Dimension && a instanceof Color) {\n            b = b.toColor();\n        }\n        if (!a.operate) {\n            if (a instanceof Operation && a.op === '/' && context.math === MATH.PARENS_DIVISION) {\n                return new Operation(this.op, [a, b], this.isSpaced);\n            }\n            throw { type: 'Operation',\n                message: 'Operation on an invalid type' };\n        }\n\n        return a.operate(context, op, b);\n    } else {\n        return new Operation(this.op, [a, b], this.isSpaced);\n    }\n};\nOperation.prototype.genCSS = function (context, output) {\n    this.operands[0].genCSS(context, output);\n    if (this.isSpaced) {\n        output.add(' ');\n    }\n    output.add(this.op);\n    if (this.isSpaced) {\n        output.add(' ');\n    }\n    this.operands[1].genCSS(context, output);\n};\n\nmodule.exports = Operation;\n\n},{\"../constants\":12,\"./color\":55,\"./dimension\":62,\"./node\":76}],78:[function(require,module,exports){\nvar Node = require('./node');\n\nvar Paren = function (node) {\n    this.value = node;\n};\nParen.prototype = new Node();\nParen.prototype.type = 'Paren';\nParen.prototype.genCSS = function (context, output) {\n    output.add('(');\n    this.value.genCSS(context, output);\n    output.add(')');\n};\nParen.prototype.eval = function (context) {\n    return new Paren(this.value.eval(context));\n};\nmodule.exports = Paren;\n\n},{\"./node\":76}],79:[function(require,module,exports){\nvar Node = require('./node'),\n    Declaration = require('./declaration');\n\nvar Property = function (name, index, currentFileInfo) {\n    this.name = name;\n    this._index = index;\n    this._fileInfo = currentFileInfo;\n};\nProperty.prototype = new Node();\nProperty.prototype.type = 'Property';\nProperty.prototype.eval = function (context) {\n    var property, name = this.name;\n    // TODO: shorten this reference\n    var mergeRules = context.pluginManager.less.visitors.ToCSSVisitor.prototype._mergeRules;\n\n    if (this.evaluating) {\n        throw { type: 'Name',\n            message: 'Recursive property reference for ' + name,\n            filename: this.fileInfo().filename,\n            index: this.getIndex() };\n    }\n\n    this.evaluating = true;\n\n    property = this.find(context.frames, function (frame) {\n\n        var v, vArr = frame.property(name);\n        if (vArr) {\n            for (var i = 0; i < vArr.length; i++) {\n                v = vArr[i];\n\n                vArr[i] = new Declaration(v.name,\n                    v.value,\n                    v.important,\n                    v.merge,\n                    v.index,\n                    v.currentFileInfo,\n                    v.inline,\n                    v.variable\n                );\n            }\n            mergeRules(vArr);\n\n            v = vArr[vArr.length - 1];\n            if (v.important) {\n                var importantScope = context.importantScope[context.importantScope.length - 1];\n                importantScope.important = v.important;\n            }\n            v = v.value.eval(context);\n            return v;\n        }\n    });\n    if (property) {\n        this.evaluating = false;\n        return property;\n    } else {\n        throw { type: 'Name',\n            message: 'Property \\'' + name + '\\' is undefined',\n            filename: this.currentFileInfo.filename,\n            index: this.index };\n    }\n};\nProperty.prototype.find = function (obj, fun) {\n    for (var i = 0, r; i < obj.length; i++) {\n        r = fun.call(obj, obj[i]);\n        if (r) { return r; }\n    }\n    return null;\n};\nmodule.exports = Property;\n\n},{\"./declaration\":60,\"./node\":76}],80:[function(require,module,exports){\nvar Node = require('./node'),\n    Variable = require('./variable'),\n    Property = require('./property');\n\nvar Quoted = function (str, content, escaped, index, currentFileInfo) {\n    this.escaped = (escaped == null) ? true : escaped;\n    this.value = content || '';\n    this.quote = str.charAt(0);\n    this._index = index;\n    this._fileInfo = currentFileInfo;\n    this.variableRegex = /@\\{([\\w-]+)\\}/g;\n    this.propRegex = /\\$\\{([\\w-]+)\\}/g;\n};\nQuoted.prototype = new Node();\nQuoted.prototype.type = 'Quoted';\nQuoted.prototype.genCSS = function (context, output) {\n    if (!this.escaped) {\n        output.add(this.quote, this.fileInfo(), this.getIndex());\n    }\n    output.add(this.value);\n    if (!this.escaped) {\n        output.add(this.quote);\n    }\n};\nQuoted.prototype.containsVariables = function() {\n    return this.value.match(this.variableRegex);\n};\nQuoted.prototype.eval = function (context) {\n    var that = this, value = this.value;\n    var variableReplacement = function (_, name) {\n        var v = new Variable('@' + name, that.getIndex(), that.fileInfo()).eval(context, true);\n        return (v instanceof Quoted) ? v.value : v.toCSS();\n    };\n    var propertyReplacement = function (_, name) {\n        var v = new Property('$' + name, that.getIndex(), that.fileInfo()).eval(context, true);\n        return (v instanceof Quoted) ? v.value : v.toCSS();\n    };\n    function iterativeReplace(value, regexp, replacementFnc) {\n        var evaluatedValue = value;\n        do {\n            value = evaluatedValue;\n            evaluatedValue = value.replace(regexp, replacementFnc);\n        } while (value !== evaluatedValue);\n        return evaluatedValue;\n    }\n    value = iterativeReplace(value, this.variableRegex, variableReplacement);\n    value = iterativeReplace(value, this.propRegex, propertyReplacement);\n    return new Quoted(this.quote + value + this.quote, value, this.escaped, this.getIndex(), this.fileInfo());\n};\nQuoted.prototype.compare = function (other) {\n    // when comparing quoted strings allow the quote to differ\n    if (other.type === 'Quoted' && !this.escaped && !other.escaped) {\n        return Node.numericCompare(this.value, other.value);\n    } else {\n        return other.toCSS && this.toCSS() === other.toCSS() ? 0 : undefined;\n    }\n};\nmodule.exports = Quoted;\n\n},{\"./node\":76,\"./property\":79,\"./variable\":88}],81:[function(require,module,exports){\nvar Node = require('./node'),\n    Declaration = require('./declaration'),\n    Keyword = require('./keyword'),\n    Comment = require('./comment'),\n    Paren = require('./paren'),\n    Selector = require('./selector'),\n    Element = require('./element'),\n    Anonymous = require('./anonymous'),\n    contexts = require('../contexts'),\n    globalFunctionRegistry = require('../functions/function-registry'),\n    defaultFunc = require('../functions/default'),\n    getDebugInfo = require('./debug-info'),\n    utils = require('../utils');\n\nvar Ruleset = function (selectors, rules, strictImports, visibilityInfo) {\n    this.selectors = selectors;\n    this.rules = rules;\n    this._lookups = {};\n    this._variables = null;\n    this._properties = null;\n    this.strictImports = strictImports;\n    this.copyVisibilityInfo(visibilityInfo);\n    this.allowRoot = true;\n\n    this.setParent(this.selectors, this);\n    this.setParent(this.rules, this);\n\n};\nRuleset.prototype = new Node();\nRuleset.prototype.type = 'Ruleset';\nRuleset.prototype.isRuleset = true;\nRuleset.prototype.isRulesetLike = function() { return true; };\nRuleset.prototype.accept = function (visitor) {\n    if (this.paths) {\n        this.paths = visitor.visitArray(this.paths, true);\n    } else if (this.selectors) {\n        this.selectors = visitor.visitArray(this.selectors);\n    }\n    if (this.rules && this.rules.length) {\n        this.rules = visitor.visitArray(this.rules);\n    }\n};\nRuleset.prototype.eval = function (context) {\n    var that = this, selectors, selCnt, selector, i, hasVariable, hasOnePassingSelector = false;\n\n    if (this.selectors && (selCnt = this.selectors.length)) {\n        selectors = new Array(selCnt);\n        defaultFunc.error({\n            type: 'Syntax',\n            message: 'it is currently only allowed in parametric mixin guards,'\n        });\n\n        for (i = 0; i < selCnt; i++) {\n            selector = this.selectors[i].eval(context);\n            for (var j = 0; j < selector.elements.length; j++) {\n                if (selector.elements[j].isVariable) {\n                    hasVariable = true;\n                    break;\n                }\n            }\n            selectors[i] = selector;\n            if (selector.evaldCondition) {\n                hasOnePassingSelector = true;\n            }\n        }\n\n        if (hasVariable) {\n            var toParseSelectors = new Array(selCnt);\n            for (i = 0; i < selCnt; i++) {\n                selector = selectors[i];\n                toParseSelectors[i] = selector.toCSS(context);\n            }\n            this.parse.parseNode(\n                toParseSelectors.join(','),\n                [\"selectors\"], \n                selectors[0].getIndex(), \n                selectors[0].fileInfo(), \n                function(err, result) {\n                    if (result) {\n                        selectors = utils.flattenArray(result);\n                    }\n                });\n        }\n\n        defaultFunc.reset();\n    } else {\n        hasOnePassingSelector = true;\n    }\n\n    var rules = this.rules ? utils.copyArray(this.rules) : null,\n        ruleset = new Ruleset(selectors, rules, this.strictImports, this.visibilityInfo()),\n        rule, subRule;\n\n    ruleset.originalRuleset = this;\n    ruleset.root = this.root;\n    ruleset.firstRoot = this.firstRoot;\n    ruleset.allowImports = this.allowImports;\n\n    if (this.debugInfo) {\n        ruleset.debugInfo = this.debugInfo;\n    }\n\n    if (!hasOnePassingSelector) {\n        rules.length = 0;\n    }\n\n    // inherit a function registry from the frames stack when possible;\n    // otherwise from the global registry\n    ruleset.functionRegistry = (function (frames) {\n        var i = 0,\n            n = frames.length,\n            found;\n        for ( ; i !== n ; ++i ) {\n            found = frames[ i ].functionRegistry;\n            if ( found ) { return found; }\n        }\n        return globalFunctionRegistry;\n    }(context.frames)).inherit();\n\n    // push the current ruleset to the frames stack\n    var ctxFrames = context.frames;\n    ctxFrames.unshift(ruleset);\n\n    // currrent selectors\n    var ctxSelectors = context.selectors;\n    if (!ctxSelectors) {\n        context.selectors = ctxSelectors = [];\n    }\n    ctxSelectors.unshift(this.selectors);\n\n    // Evaluate imports\n    if (ruleset.root || ruleset.allowImports || !ruleset.strictImports) {\n        ruleset.evalImports(context);\n    }\n\n    // Store the frames around mixin definitions,\n    // so they can be evaluated like closures when the time comes.\n    var rsRules = ruleset.rules;\n    for (i = 0; (rule = rsRules[i]); i++) {\n        if (rule.evalFirst) {\n            rsRules[i] = rule.eval(context);\n        }\n    }\n\n    var mediaBlockCount = (context.mediaBlocks && context.mediaBlocks.length) || 0;\n\n    // Evaluate mixin calls.\n    for (i = 0; (rule = rsRules[i]); i++) {\n        if (rule.type === 'MixinCall') {\n            /* jshint loopfunc:true */\n            rules = rule.eval(context).filter(function(r) {\n                if ((r instanceof Declaration) && r.variable) {\n                    // do not pollute the scope if the variable is\n                    // already there. consider returning false here\n                    // but we need a way to \"return\" variable from mixins\n                    return !(ruleset.variable(r.name));\n                }\n                return true;\n            });\n            rsRules.splice.apply(rsRules, [i, 1].concat(rules));\n            i += rules.length - 1;\n            ruleset.resetCache();\n        } else if (rule.type ===  'VariableCall') {\n            /* jshint loopfunc:true */\n            rules = rule.eval(context).rules.filter(function(r) {\n                if ((r instanceof Declaration) && r.variable) {\n                    // do not pollute the scope at all\n                    return false;\n                }\n                return true;\n            });\n            rsRules.splice.apply(rsRules, [i, 1].concat(rules));\n            i += rules.length - 1;\n            ruleset.resetCache();\n        }\n    }\n\n    // Evaluate everything else\n    for (i = 0; (rule = rsRules[i]); i++) {\n        if (!rule.evalFirst) {\n            rsRules[i] = rule = rule.eval ? rule.eval(context) : rule;\n        }\n    }\n\n    // Evaluate everything else\n    for (i = 0; (rule = rsRules[i]); i++) {\n        // for rulesets, check if it is a css guard and can be removed\n        if (rule instanceof Ruleset && rule.selectors && rule.selectors.length === 1) {\n            // check if it can be folded in (e.g. & where)\n            if (rule.selectors[0] && rule.selectors[0].isJustParentSelector()) {\n                rsRules.splice(i--, 1);\n\n                for (var j = 0; (subRule = rule.rules[j]); j++) {\n                    if (subRule instanceof Node) {\n                        subRule.copyVisibilityInfo(rule.visibilityInfo());\n                        if (!(subRule instanceof Declaration) || !subRule.variable) {\n                            rsRules.splice(++i, 0, subRule);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    // Pop the stack\n    ctxFrames.shift();\n    ctxSelectors.shift();\n\n    if (context.mediaBlocks) {\n        for (i = mediaBlockCount; i < context.mediaBlocks.length; i++) {\n            context.mediaBlocks[i].bubbleSelectors(selectors);\n        }\n    }\n\n    return ruleset;\n};\nRuleset.prototype.evalImports = function(context) {\n    var rules = this.rules, i, importRules;\n    if (!rules) { return; }\n\n    for (i = 0; i < rules.length; i++) {\n        if (rules[i].type === 'Import') {\n            importRules = rules[i].eval(context);\n            if (importRules && (importRules.length || importRules.length === 0)) {\n                rules.splice.apply(rules, [i, 1].concat(importRules));\n                i += importRules.length - 1;\n            } else {\n                rules.splice(i, 1, importRules);\n            }\n            this.resetCache();\n        }\n    }\n};\nRuleset.prototype.makeImportant = function() {\n    var result = new Ruleset(this.selectors, this.rules.map(function (r) {\n        if (r.makeImportant) {\n            return r.makeImportant();\n        } else {\n            return r;\n        }\n    }), this.strictImports, this.visibilityInfo());\n\n    return result;\n};\nRuleset.prototype.matchArgs = function (args) {\n    return !args || args.length === 0;\n};\n// lets you call a css selector with a guard\nRuleset.prototype.matchCondition = function (args, context) {\n    var lastSelector = this.selectors[this.selectors.length - 1];\n    if (!lastSelector.evaldCondition) {\n        return false;\n    }\n    if (lastSelector.condition &&\n        !lastSelector.condition.eval(\n            new contexts.Eval(context,\n                context.frames))) {\n        return false;\n    }\n    return true;\n};\nRuleset.prototype.resetCache = function () {\n    this._rulesets = null;\n    this._variables = null;\n    this._properties = null;\n    this._lookups = {};\n};\nRuleset.prototype.variables = function () {\n    if (!this._variables) {\n        this._variables = !this.rules ? {} : this.rules.reduce(function (hash, r) {\n            if (r instanceof Declaration && r.variable === true) {\n                hash[r.name] = r;\n            }\n            // when evaluating variables in an import statement, imports have not been eval'd\n            // so we need to go inside import statements.\n            // guard against root being a string (in the case of inlined less)\n            if (r.type === 'Import' && r.root && r.root.variables) {\n                var vars = r.root.variables();\n                for (var name in vars) {\n                    if (vars.hasOwnProperty(name)) {\n                        hash[name] = r.root.variable(name);\n                    }\n                }\n            }\n            return hash;\n        }, {});\n    }\n    return this._variables;\n};\nRuleset.prototype.properties = function () {\n    if (!this._properties) {\n        this._properties = !this.rules ? {} : this.rules.reduce(function (hash, r) {\n            if (r instanceof Declaration && r.variable !== true) {\n                var name = (r.name.length === 1) && (r.name[0] instanceof Keyword) ?\n                    r.name[0].value : r.name;\n                // Properties don't overwrite as they can merge\n                if (!hash['$' + name]) {\n                    hash['$' + name] = [ r ];\n                }\n                else {\n                    hash['$' + name].push(r);\n                }\n            }\n            return hash;\n        }, {});\n    }\n    return this._properties;\n};\nRuleset.prototype.variable = function (name) {\n    var decl = this.variables()[name];\n    if (decl) {\n        return this.parseValue(decl);\n    }\n};\nRuleset.prototype.property = function (name) {\n    var decl = this.properties()[name];\n    if (decl) {\n        return this.parseValue(decl);\n    }\n};\nRuleset.prototype.lastDeclaration = function () {\n    for (var i = this.rules.length; i > 0; i--) {\n        var decl = this.rules[i - 1];\n        if (decl instanceof Declaration) {\n            return this.parseValue(decl);\n        }\n    }\n};\nRuleset.prototype.parseValue = function(toParse) {\n    var self = this;\n    function transformDeclaration(decl) {\n        if (decl.value instanceof Anonymous && !decl.parsed) {\n            if (typeof decl.value.value === 'string') {\n                this.parse.parseNode(\n                    decl.value.value,\n                    ['value', 'important'], \n                    decl.value.getIndex(), \n                    decl.fileInfo(), \n                    function(err, result) {\n                        if (err) {\n                            decl.parsed = true;\n                        }\n                        if (result) {\n                            decl.value = result[0];\n                            decl.important = result[1] || '';\n                            decl.parsed = true;\n                        }\n                    });\n            } else {\n                decl.parsed = true;\n            }\n\n            return decl;\n        }\n        else {\n            return decl;\n        }\n    }\n    if (!Array.isArray(toParse)) {\n        return transformDeclaration.call(self, toParse);\n    }\n    else {\n        var nodes = [];\n        toParse.forEach(function(n) {\n            nodes.push(transformDeclaration.call(self, n));\n        });\n        return nodes;\n    }\n};\nRuleset.prototype.rulesets = function () {\n    if (!this.rules) { return []; }\n\n    var filtRules = [], rules = this.rules,\n        i, rule;\n\n    for (i = 0; (rule = rules[i]); i++) {\n        if (rule.isRuleset) {\n            filtRules.push(rule);\n        }\n    }\n\n    return filtRules;\n};\nRuleset.prototype.prependRule = function (rule) {\n    var rules = this.rules;\n    if (rules) {\n        rules.unshift(rule);\n    } else {\n        this.rules = [ rule ];\n    }\n    this.setParent(rule, this);\n};\nRuleset.prototype.find = function (selector, self, filter) {\n    self = self || this;\n    var rules = [], match, foundMixins,\n        key = selector.toCSS();\n\n    if (key in this._lookups) { return this._lookups[key]; }\n\n    this.rulesets().forEach(function (rule) {\n        if (rule !== self) {\n            for (var j = 0; j < rule.selectors.length; j++) {\n                match = selector.match(rule.selectors[j]);\n                if (match) {\n                    if (selector.elements.length > match) {\n                        if (!filter || filter(rule)) {\n                            foundMixins = rule.find(new Selector(selector.elements.slice(match)), self, filter);\n                            for (var i = 0; i < foundMixins.length; ++i) {\n                                foundMixins[i].path.push(rule);\n                            }\n                            Array.prototype.push.apply(rules, foundMixins);\n                        }\n                    } else {\n                        rules.push({ rule: rule, path: []});\n                    }\n                    break;\n                }\n            }\n        }\n    });\n    this._lookups[key] = rules;\n    return rules;\n};\nRuleset.prototype.genCSS = function (context, output) {\n    var i, j,\n        charsetRuleNodes = [],\n        ruleNodes = [],\n        debugInfo,     // Line number debugging\n        rule,\n        path;\n\n    context.tabLevel = (context.tabLevel || 0);\n\n    if (!this.root) {\n        context.tabLevel++;\n    }\n\n    var tabRuleStr = context.compress ? '' : Array(context.tabLevel + 1).join('  '),\n        tabSetStr = context.compress ? '' : Array(context.tabLevel).join('  '),\n        sep;\n\n    var charsetNodeIndex = 0;\n    var importNodeIndex = 0;\n    for (i = 0; (rule = this.rules[i]); i++) {\n        if (rule instanceof Comment) {\n            if (importNodeIndex === i) {\n                importNodeIndex++;\n            }\n            ruleNodes.push(rule);\n        } else if (rule.isCharset && rule.isCharset()) {\n            ruleNodes.splice(charsetNodeIndex, 0, rule);\n            charsetNodeIndex++;\n            importNodeIndex++;\n        } else if (rule.type === 'Import') {\n            ruleNodes.splice(importNodeIndex, 0, rule);\n            importNodeIndex++;\n        } else {\n            ruleNodes.push(rule);\n        }\n    }\n    ruleNodes = charsetRuleNodes.concat(ruleNodes);\n\n    // If this is the root node, we don't render\n    // a selector, or {}.\n    if (!this.root) {\n        debugInfo = getDebugInfo(context, this, tabSetStr);\n\n        if (debugInfo) {\n            output.add(debugInfo);\n            output.add(tabSetStr);\n        }\n\n        var paths = this.paths, pathCnt = paths.length,\n            pathSubCnt;\n\n        sep = context.compress ? ',' : (',\\n' + tabSetStr);\n\n        for (i = 0; i < pathCnt; i++) {\n            path = paths[i];\n            if (!(pathSubCnt = path.length)) { continue; }\n            if (i > 0) { output.add(sep); }\n\n            context.firstSelector = true;\n            path[0].genCSS(context, output);\n\n            context.firstSelector = false;\n            for (j = 1; j < pathSubCnt; j++) {\n                path[j].genCSS(context, output);\n            }\n        }\n\n        output.add((context.compress ? '{' : ' {\\n') + tabRuleStr);\n    }\n\n    // Compile rules and rulesets\n    for (i = 0; (rule = ruleNodes[i]); i++) {\n\n        if (i + 1 === ruleNodes.length) {\n            context.lastRule = true;\n        }\n\n        var currentLastRule = context.lastRule;\n        if (rule.isRulesetLike(rule)) {\n            context.lastRule = false;\n        }\n\n        if (rule.genCSS) {\n            rule.genCSS(context, output);\n        } else if (rule.value) {\n            output.add(rule.value.toString());\n        }\n\n        context.lastRule = currentLastRule;\n\n        if (!context.lastRule && rule.isVisible()) {\n            output.add(context.compress ? '' : ('\\n' + tabRuleStr));\n        } else {\n            context.lastRule = false;\n        }\n    }\n\n    if (!this.root) {\n        output.add((context.compress ? '}' : '\\n' + tabSetStr + '}'));\n        context.tabLevel--;\n    }\n\n    if (!output.isEmpty() && !context.compress && this.firstRoot) {\n        output.add('\\n');\n    }\n};\n\nRuleset.prototype.joinSelectors = function (paths, context, selectors) {\n    for (var s = 0; s < selectors.length; s++) {\n        this.joinSelector(paths, context, selectors[s]);\n    }\n};\n\nRuleset.prototype.joinSelector = function (paths, context, selector) {\n\n    function createParenthesis(elementsToPak, originalElement) {\n        var replacementParen, j;\n        if (elementsToPak.length === 0) {\n            replacementParen = new Paren(elementsToPak[0]);\n        } else {\n            var insideParent = new Array(elementsToPak.length);\n            for (j = 0; j < elementsToPak.length; j++) {\n                insideParent[j] = new Element(\n                    null,\n                    elementsToPak[j],\n                    originalElement.isVariable,\n                    originalElement._index,\n                    originalElement._fileInfo\n                );\n            }\n            replacementParen = new Paren(new Selector(insideParent));\n        }\n        return replacementParen;\n    }\n\n    function createSelector(containedElement, originalElement) {\n        var element, selector;\n        element = new Element(null, containedElement, originalElement.isVariable, originalElement._index, originalElement._fileInfo);\n        selector = new Selector([element]);\n        return selector;\n    }\n\n    // joins selector path from `beginningPath` with selector path in `addPath`\n    // `replacedElement` contains element that is being replaced by `addPath`\n    // returns concatenated path\n    function addReplacementIntoPath(beginningPath, addPath, replacedElement, originalSelector) {\n        var newSelectorPath, lastSelector, newJoinedSelector;\n        // our new selector path\n        newSelectorPath = [];\n\n        // construct the joined selector - if & is the first thing this will be empty,\n        // if not newJoinedSelector will be the last set of elements in the selector\n        if (beginningPath.length > 0) {\n            newSelectorPath = utils.copyArray(beginningPath);\n            lastSelector = newSelectorPath.pop();\n            newJoinedSelector = originalSelector.createDerived(utils.copyArray(lastSelector.elements));\n        }\n        else {\n            newJoinedSelector = originalSelector.createDerived([]);\n        }\n\n        if (addPath.length > 0) {\n            // /deep/ is a CSS4 selector - (removed, so should deprecate)\n            // that is valid without anything in front of it\n            // so if the & does not have a combinator that is \"\" or \" \" then\n            // and there is a combinator on the parent, then grab that.\n            // this also allows + a { & .b { .a & { ... though not sure why you would want to do that\n            var combinator = replacedElement.combinator, parentEl = addPath[0].elements[0];\n            if (combinator.emptyOrWhitespace && !parentEl.combinator.emptyOrWhitespace) {\n                combinator = parentEl.combinator;\n            }\n            // join the elements so far with the first part of the parent\n            newJoinedSelector.elements.push(new Element(\n                combinator,\n                parentEl.value,\n                replacedElement.isVariable,\n                replacedElement._index,\n                replacedElement._fileInfo\n            ));\n            newJoinedSelector.elements = newJoinedSelector.elements.concat(addPath[0].elements.slice(1));\n        }\n\n        // now add the joined selector - but only if it is not empty\n        if (newJoinedSelector.elements.length !== 0) {\n            newSelectorPath.push(newJoinedSelector);\n        }\n\n        // put together the parent selectors after the join (e.g. the rest of the parent)\n        if (addPath.length > 1) {\n            var restOfPath = addPath.slice(1);\n            restOfPath = restOfPath.map(function (selector) {\n                return selector.createDerived(selector.elements, []);\n            });\n            newSelectorPath = newSelectorPath.concat(restOfPath);\n        }\n        return newSelectorPath;\n    }\n\n    // joins selector path from `beginningPath` with every selector path in `addPaths` array\n    // `replacedElement` contains element that is being replaced by `addPath`\n    // returns array with all concatenated paths\n    function addAllReplacementsIntoPath( beginningPath, addPaths, replacedElement, originalSelector, result) {\n        var j;\n        for (j = 0; j < beginningPath.length; j++) {\n            var newSelectorPath = addReplacementIntoPath(beginningPath[j], addPaths, replacedElement, originalSelector);\n            result.push(newSelectorPath);\n        }\n        return result;\n    }\n\n    function mergeElementsOnToSelectors(elements, selectors) {\n        var i, sel;\n\n        if (elements.length === 0) {\n            return ;\n        }\n        if (selectors.length === 0) {\n            selectors.push([ new Selector(elements) ]);\n            return;\n        }\n\n        for (i = 0; (sel = selectors[i]); i++) {\n            // if the previous thing in sel is a parent this needs to join on to it\n            if (sel.length > 0) {\n                sel[sel.length - 1] = sel[sel.length - 1].createDerived(sel[sel.length - 1].elements.concat(elements));\n            }\n            else {\n                sel.push(new Selector(elements));\n            }\n        }\n    }\n\n    // replace all parent selectors inside `inSelector` by content of `context` array\n    // resulting selectors are returned inside `paths` array\n    // returns true if `inSelector` contained at least one parent selector\n    function replaceParentSelector(paths, context, inSelector) {\n        // The paths are [[Selector]]\n        // The first list is a list of comma separated selectors\n        // The inner list is a list of inheritance separated selectors\n        // e.g.\n        // .a, .b {\n        //   .c {\n        //   }\n        // }\n        // == [[.a] [.c]] [[.b] [.c]]\n        //\n        var i, j, k, currentElements, newSelectors, selectorsMultiplied, sel, el, hadParentSelector = false, length, lastSelector;\n        function findNestedSelector(element) {\n            var maybeSelector;\n            if (!(element.value instanceof Paren)) {\n                return null;\n            }\n\n            maybeSelector = element.value.value;\n            if (!(maybeSelector instanceof Selector)) {\n                return null;\n            }\n\n            return maybeSelector;\n        }\n\n        // the elements from the current selector so far\n        currentElements = [];\n        // the current list of new selectors to add to the path.\n        // We will build it up. We initiate it with one empty selector as we \"multiply\" the new selectors\n        // by the parents\n        newSelectors = [\n            []\n        ];\n\n        for (i = 0; (el = inSelector.elements[i]); i++) {\n            // non parent reference elements just get added\n            if (el.value !== '&') {\n                var nestedSelector = findNestedSelector(el);\n                if (nestedSelector != null) {\n                    // merge the current list of non parent selector elements\n                    // on to the current list of selectors to add\n                    mergeElementsOnToSelectors(currentElements, newSelectors);\n\n                    var nestedPaths = [], replaced, replacedNewSelectors = [];\n                    replaced = replaceParentSelector(nestedPaths, context, nestedSelector);\n                    hadParentSelector = hadParentSelector || replaced;\n                    // the nestedPaths array should have only one member - replaceParentSelector does not multiply selectors\n                    for (k = 0; k < nestedPaths.length; k++) {\n                        var replacementSelector = createSelector(createParenthesis(nestedPaths[k], el), el);\n                        addAllReplacementsIntoPath(newSelectors, [replacementSelector], el, inSelector, replacedNewSelectors);\n                    }\n                    newSelectors = replacedNewSelectors;\n                    currentElements = [];\n\n                } else {\n                    currentElements.push(el);\n                }\n\n            } else {\n                hadParentSelector = true;\n                // the new list of selectors to add\n                selectorsMultiplied = [];\n\n                // merge the current list of non parent selector elements\n                // on to the current list of selectors to add\n                mergeElementsOnToSelectors(currentElements, newSelectors);\n\n                // loop through our current selectors\n                for (j = 0; j < newSelectors.length; j++) {\n                    sel = newSelectors[j];\n                    // if we don't have any parent paths, the & might be in a mixin so that it can be used\n                    // whether there are parents or not\n                    if (context.length === 0) {\n                        // the combinator used on el should now be applied to the next element instead so that\n                        // it is not lost\n                        if (sel.length > 0) {\n                            sel[0].elements.push(new Element(el.combinator, '', el.isVariable, el._index, el._fileInfo));\n                        }\n                        selectorsMultiplied.push(sel);\n                    }\n                    else {\n                        // and the parent selectors\n                        for (k = 0; k < context.length; k++) {\n                            // We need to put the current selectors\n                            // then join the last selector's elements on to the parents selectors\n                            var newSelectorPath = addReplacementIntoPath(sel, context[k], el, inSelector);\n                            // add that to our new set of selectors\n                            selectorsMultiplied.push(newSelectorPath);\n                        }\n                    }\n                }\n\n                // our new selectors has been multiplied, so reset the state\n                newSelectors = selectorsMultiplied;\n                currentElements = [];\n            }\n        }\n\n        // if we have any elements left over (e.g. .a& .b == .b)\n        // add them on to all the current selectors\n        mergeElementsOnToSelectors(currentElements, newSelectors);\n\n        for (i = 0; i < newSelectors.length; i++) {\n            length = newSelectors[i].length;\n            if (length > 0) {\n                paths.push(newSelectors[i]);\n                lastSelector = newSelectors[i][length - 1];\n                newSelectors[i][length - 1] = lastSelector.createDerived(lastSelector.elements, inSelector.extendList);\n            }\n        }\n\n        return hadParentSelector;\n    }\n\n    function deriveSelector(visibilityInfo, deriveFrom) {\n        var newSelector = deriveFrom.createDerived(deriveFrom.elements, deriveFrom.extendList, deriveFrom.evaldCondition);\n        newSelector.copyVisibilityInfo(visibilityInfo);\n        return newSelector;\n    }\n\n    // joinSelector code follows\n    var i, newPaths, hadParentSelector;\n\n    newPaths = [];\n    hadParentSelector = replaceParentSelector(newPaths, context, selector);\n\n    if (!hadParentSelector) {\n        if (context.length > 0) {\n            newPaths = [];\n            for (i = 0; i < context.length; i++) {\n\n                var concatenated = context[i].map(deriveSelector.bind(this, selector.visibilityInfo()));\n\n                concatenated.push(selector);\n                newPaths.push(concatenated);\n            }\n        }\n        else {\n            newPaths = [[selector]];\n        }\n    }\n\n    for (i = 0; i < newPaths.length; i++) {\n        paths.push(newPaths[i]);\n    }\n\n};\nmodule.exports = Ruleset;\n\n},{\"../contexts\":13,\"../functions/default\":25,\"../functions/function-registry\":27,\"../utils\":89,\"./anonymous\":50,\"./comment\":57,\"./debug-info\":59,\"./declaration\":60,\"./element\":63,\"./keyword\":70,\"./node\":76,\"./paren\":78,\"./selector\":82}],82:[function(require,module,exports){\nvar Node = require('./node'),\n    Element = require('./element'),\n    LessError = require('../less-error');\n\nvar Selector = function (elements, extendList, condition, index, currentFileInfo, visibilityInfo) {\n    this.extendList = extendList;\n    this.condition = condition;\n    this.evaldCondition = !condition;\n    this._index = index;\n    this._fileInfo = currentFileInfo;\n    this.elements = this.getElements(elements);\n    this.mixinElements_ = undefined;\n    this.copyVisibilityInfo(visibilityInfo);\n    this.setParent(this.elements, this);\n};\nSelector.prototype = new Node();\nSelector.prototype.type = 'Selector';\nSelector.prototype.accept = function (visitor) {\n    if (this.elements) {\n        this.elements = visitor.visitArray(this.elements);\n    }\n    if (this.extendList) {\n        this.extendList = visitor.visitArray(this.extendList);\n    }\n    if (this.condition) {\n        this.condition = visitor.visit(this.condition);\n    }\n};\nSelector.prototype.createDerived = function(elements, extendList, evaldCondition) {\n    elements = this.getElements(elements);\n    var newSelector = new Selector(elements, extendList || this.extendList,\n        null, this.getIndex(), this.fileInfo(), this.visibilityInfo());\n    newSelector.evaldCondition = (evaldCondition != null) ? evaldCondition : this.evaldCondition;\n    newSelector.mediaEmpty = this.mediaEmpty;\n    return newSelector;\n};\nSelector.prototype.getElements = function(els) {\n    if (!els) {\n        return [new Element('', '&', false, this._index, this._fileInfo)];\n    }\n    if (typeof els === 'string') {\n        this.parse.parseNode(\n            els, \n            ['selector'],\n            this._index, \n            this._fileInfo, \n            function(err, result) {\n                if (err) {\n                    throw new LessError({\n                        index: err.index,\n                        message: err.message\n                    }, this.parse.imports, this._fileInfo.filename);\n                }\n                els = result[0].elements;\n            });\n    }\n    return els;\n};\nSelector.prototype.createEmptySelectors = function() {\n    var el = new Element('', '&', false, this._index, this._fileInfo),\n        sels = [new Selector([el], null, null, this._index, this._fileInfo)];\n    sels[0].mediaEmpty = true;\n    return sels;\n};\nSelector.prototype.match = function (other) {\n    var elements = this.elements,\n        len = elements.length,\n        olen, i;\n\n    other = other.mixinElements();\n    olen = other.length;\n    if (olen === 0 || len < olen) {\n        return 0;\n    } else {\n        for (i = 0; i < olen; i++) {\n            if (elements[i].value !== other[i]) {\n                return 0;\n            }\n        }\n    }\n\n    return olen; // return number of matched elements\n};\nSelector.prototype.mixinElements = function() {\n    if (this.mixinElements_) {\n        return this.mixinElements_;\n    }\n\n    var elements = this.elements.map( function(v) {\n        return v.combinator.value + (v.value.value || v.value);\n    }).join('').match(/[,&#\\*\\.\\w-]([\\w-]|(\\\\.))*/g);\n\n    if (elements) {\n        if (elements[0] === '&') {\n            elements.shift();\n        }\n    } else {\n        elements = [];\n    }\n\n    return (this.mixinElements_ = elements);\n};\nSelector.prototype.isJustParentSelector = function() {\n    return !this.mediaEmpty &&\n        this.elements.length === 1 &&\n        this.elements[0].value === '&' &&\n        (this.elements[0].combinator.value === ' ' || this.elements[0].combinator.value === '');\n};\nSelector.prototype.eval = function (context) {\n    var evaldCondition = this.condition && this.condition.eval(context),\n        elements = this.elements, extendList = this.extendList;\n\n    elements = elements && elements.map(function (e) { return e.eval(context); });\n    extendList = extendList && extendList.map(function(extend) { return extend.eval(context); });\n\n    return this.createDerived(elements, extendList, evaldCondition);\n};\nSelector.prototype.genCSS = function (context, output) {\n    var i, element;\n    if ((!context || !context.firstSelector) && this.elements[0].combinator.value === '') {\n        output.add(' ', this.fileInfo(), this.getIndex());\n    }\n    for (i = 0; i < this.elements.length; i++) {\n        element = this.elements[i];\n        element.genCSS(context, output);\n    }\n};\nSelector.prototype.getIsOutput = function() {\n    return this.evaldCondition;\n};\nmodule.exports = Selector;\n\n},{\"../less-error\":38,\"./element\":63,\"./node\":76}],83:[function(require,module,exports){\nvar Node = require('./node');\n\nvar UnicodeDescriptor = function (value) {\n    this.value = value;\n};\nUnicodeDescriptor.prototype = new Node();\nUnicodeDescriptor.prototype.type = 'UnicodeDescriptor';\n\nmodule.exports = UnicodeDescriptor;\n\n},{\"./node\":76}],84:[function(require,module,exports){\nvar Node = require('./node'),\n    unitConversions = require('../data/unit-conversions'),\n    utils = require('../utils');\n\nvar Unit = function (numerator, denominator, backupUnit) {\n    this.numerator = numerator ? utils.copyArray(numerator).sort() : [];\n    this.denominator = denominator ? utils.copyArray(denominator).sort() : [];\n    if (backupUnit) {\n        this.backupUnit = backupUnit;\n    } else if (numerator && numerator.length) {\n        this.backupUnit = numerator[0];\n    }\n};\n\nUnit.prototype = new Node();\nUnit.prototype.type = 'Unit';\nUnit.prototype.clone = function () {\n    return new Unit(utils.copyArray(this.numerator), utils.copyArray(this.denominator), this.backupUnit);\n};\nUnit.prototype.genCSS = function (context, output) {\n    // Dimension checks the unit is singular and throws an error if in strict math mode.\n    var strictUnits = context && context.strictUnits;\n    if (this.numerator.length === 1) {\n        output.add(this.numerator[0]); // the ideal situation\n    } else if (!strictUnits && this.backupUnit) {\n        output.add(this.backupUnit);\n    } else if (!strictUnits && this.denominator.length) {\n        output.add(this.denominator[0]);\n    }\n};\nUnit.prototype.toString = function () {\n    var i, returnStr = this.numerator.join('*');\n    for (i = 0; i < this.denominator.length; i++) {\n        returnStr += '/' + this.denominator[i];\n    }\n    return returnStr;\n};\nUnit.prototype.compare = function (other) {\n    return this.is(other.toString()) ? 0 : undefined;\n};\nUnit.prototype.is = function (unitString) {\n    return this.toString().toUpperCase() === unitString.toUpperCase();\n};\nUnit.prototype.isLength = function () {\n    return RegExp('^(px|em|ex|ch|rem|in|cm|mm|pc|pt|ex|vw|vh|vmin|vmax)$', 'gi').test(this.toCSS());\n};\nUnit.prototype.isEmpty = function () {\n    return this.numerator.length === 0 && this.denominator.length === 0;\n};\nUnit.prototype.isSingular = function() {\n    return this.numerator.length <= 1 && this.denominator.length === 0;\n};\nUnit.prototype.map = function(callback) {\n    var i;\n\n    for (i = 0; i < this.numerator.length; i++) {\n        this.numerator[i] = callback(this.numerator[i], false);\n    }\n\n    for (i = 0; i < this.denominator.length; i++) {\n        this.denominator[i] = callback(this.denominator[i], true);\n    }\n};\nUnit.prototype.usedUnits = function() {\n    var group, result = {}, mapUnit, groupName;\n\n    mapUnit = function (atomicUnit) {\n        /* jshint loopfunc:true */\n        if (group.hasOwnProperty(atomicUnit) && !result[groupName]) {\n            result[groupName] = atomicUnit;\n        }\n\n        return atomicUnit;\n    };\n\n    for (groupName in unitConversions) {\n        if (unitConversions.hasOwnProperty(groupName)) {\n            group = unitConversions[groupName];\n\n            this.map(mapUnit);\n        }\n    }\n\n    return result;\n};\nUnit.prototype.cancel = function () {\n    var counter = {}, atomicUnit, i;\n\n    for (i = 0; i < this.numerator.length; i++) {\n        atomicUnit = this.numerator[i];\n        counter[atomicUnit] = (counter[atomicUnit] || 0) + 1;\n    }\n\n    for (i = 0; i < this.denominator.length; i++) {\n        atomicUnit = this.denominator[i];\n        counter[atomicUnit] = (counter[atomicUnit] || 0) - 1;\n    }\n\n    this.numerator = [];\n    this.denominator = [];\n\n    for (atomicUnit in counter) {\n        if (counter.hasOwnProperty(atomicUnit)) {\n            var count = counter[atomicUnit];\n\n            if (count > 0) {\n                for (i = 0; i < count; i++) {\n                    this.numerator.push(atomicUnit);\n                }\n            } else if (count < 0) {\n                for (i = 0; i < -count; i++) {\n                    this.denominator.push(atomicUnit);\n                }\n            }\n        }\n    }\n\n    this.numerator.sort();\n    this.denominator.sort();\n};\nmodule.exports = Unit;\n\n},{\"../data/unit-conversions\":16,\"../utils\":89,\"./node\":76}],85:[function(require,module,exports){\nvar Node = require('./node');\n\nvar URL = function (val, index, currentFileInfo, isEvald) {\n    this.value = val;\n    this._index = index;\n    this._fileInfo = currentFileInfo;\n    this.isEvald = isEvald;\n};\nURL.prototype = new Node();\nURL.prototype.type = 'Url';\nURL.prototype.accept = function (visitor) {\n    this.value = visitor.visit(this.value);\n};\nURL.prototype.genCSS = function (context, output) {\n    output.add('url(');\n    this.value.genCSS(context, output);\n    output.add(')');\n};\nURL.prototype.eval = function (context) {\n    var val = this.value.eval(context),\n        rootpath;\n\n    if (!this.isEvald) {\n        // Add the rootpath if the URL requires a rewrite\n        rootpath = this.fileInfo() && this.fileInfo().rootpath;\n        if (typeof rootpath === 'string' &&\n            typeof val.value === 'string' &&\n            context.pathRequiresRewrite(val.value)){\n            if (!val.quote) {\n                rootpath = escapePath(rootpath);\n            }\n            val.value = context.rewritePath(val.value, rootpath);\n        } else {\n            val.value = context.normalizePath(val.value);\n        }\n\n        // Add url args if enabled\n        if (context.urlArgs) {\n            if (!val.value.match(/^\\s*data:/)) {\n                var delimiter = val.value.indexOf('?') === -1 ? '?' : '&';\n                var urlArgs = delimiter + context.urlArgs;\n                if (val.value.indexOf('#') !== -1) {\n                    val.value = val.value.replace('#', urlArgs + '#');\n                } else {\n                    val.value += urlArgs;\n                }\n            }\n        }\n    }\n\n    return new URL(val, this.getIndex(), this.fileInfo(), true);\n};\n\nfunction escapePath(path) {\n    return path.replace(/[\\(\\)'\"\\s]/g, function(match) { return '\\\\' + match; });\n}\n\nmodule.exports = URL;\n\n},{\"./node\":76}],86:[function(require,module,exports){\nvar Node = require('./node');\n\nvar Value = function (value) {\n    if (!value) {\n        throw new Error('Value requires an array argument');\n    }\n    if (!Array.isArray(value)) {\n        this.value = [ value ];\n    }\n    else {\n        this.value = value;\n    }\n};\nValue.prototype = new Node();\nValue.prototype.type = 'Value';\nValue.prototype.accept = function (visitor) {\n    if (this.value) {\n        this.value = visitor.visitArray(this.value);\n    }\n};\nValue.prototype.eval = function (context) {\n    if (this.value.length === 1) {\n        return this.value[0].eval(context);\n    } else {\n        return new Value(this.value.map(function (v) {\n            return v.eval(context);\n        }));\n    }\n};\nValue.prototype.genCSS = function (context, output) {\n    var i;\n    for (i = 0; i < this.value.length; i++) {\n        this.value[i].genCSS(context, output);\n        if (i + 1 < this.value.length) {\n            output.add((context && context.compress) ? ',' : ', ');\n        }\n    }\n};\nmodule.exports = Value;\n\n},{\"./node\":76}],87:[function(require,module,exports){\nvar Node = require('./node'),\n    Variable = require('./variable'),\n    Ruleset = require('./ruleset'),\n    DetachedRuleset = require('./detached-ruleset'),\n    LessError = require('../less-error');\n\nvar VariableCall = function (variable, index, currentFileInfo) {\n    this.variable = variable;\n    this._index = index;\n    this._fileInfo = currentFileInfo;\n    this.allowRoot = true;\n};\nVariableCall.prototype = new Node();\nVariableCall.prototype.type = 'VariableCall';\nVariableCall.prototype.eval = function (context) {\n    var rules, detachedRuleset = new Variable(this.variable, this.getIndex(), this.fileInfo()).eval(context),\n        error = new LessError({message: 'Could not evaluate variable call ' + this.variable});\n\n    if (!detachedRuleset.ruleset) {\n        if (detachedRuleset.rules) {\n            rules = detachedRuleset;\n        }\n        else if (Array.isArray(detachedRuleset)) {\n            rules = new Ruleset('', detachedRuleset);\n        }\n        else if (Array.isArray(detachedRuleset.value)) {\n            rules = new Ruleset('', detachedRuleset.value);\n        }\n        else {\n            throw error;\n        }\n        detachedRuleset = new DetachedRuleset(rules);\n    }\n    if (detachedRuleset.ruleset) {\n        return detachedRuleset.callEval(context);\n    }\n    throw error;\n};\nmodule.exports = VariableCall;\n\n},{\"../less-error\":38,\"./detached-ruleset\":61,\"./node\":76,\"./ruleset\":81,\"./variable\":88}],88:[function(require,module,exports){\nvar Node = require('./node'),\n    Call = require('./call');\n\nvar Variable = function (name, index, currentFileInfo) {\n    this.name = name;\n    this._index = index;\n    this._fileInfo = currentFileInfo;\n};\nVariable.prototype = new Node();\nVariable.prototype.type = 'Variable';\nVariable.prototype.eval = function (context) {\n    var variable, name = this.name;\n\n    if (name.indexOf('@@') === 0) {\n        name = '@' + new Variable(name.slice(1), this.getIndex(), this.fileInfo()).eval(context).value;\n    }\n\n    if (this.evaluating) {\n        throw { type: 'Name',\n            message: 'Recursive variable definition for ' + name,\n            filename: this.fileInfo().filename,\n            index: this.getIndex() };\n    }\n\n    this.evaluating = true;\n\n    variable = this.find(context.frames, function (frame) {\n        var v = frame.variable(name);\n        if (v) {\n            if (v.important) {\n                var importantScope = context.importantScope[context.importantScope.length - 1];\n                importantScope.important = v.important;\n            }\n            // If in calc, wrap vars in a function call to cascade evaluate args first\n            if (context.inCalc) {\n                return (new Call('_SELF', [v.value])).eval(context);\n            }\n            else {\n                return v.value.eval(context);\n            }\n        }\n    });\n    if (variable) {\n        this.evaluating = false;\n        return variable;\n    } else {\n        throw { type: 'Name',\n            message: 'variable ' + name + ' is undefined',\n            filename: this.fileInfo().filename,\n            index: this.getIndex() };\n    }\n};\nVariable.prototype.find = function (obj, fun) {\n    for (var i = 0, r; i < obj.length; i++) {\n        r = fun.call(obj, obj[i]);\n        if (r) { return r; }\n    }\n    return null;\n};\nmodule.exports = Variable;\n\n},{\"./call\":54,\"./node\":76}],89:[function(require,module,exports){\n/* jshint proto: true */\nvar Constants = require('./constants');\nvar clone = require('clone');\n\nvar utils = {\n    getLocation: function(index, inputStream) {\n        var n = index + 1,\n            line = null,\n            column = -1;\n\n        while (--n >= 0 && inputStream.charAt(n) !== '\\n') {\n            column++;\n        }\n\n        if (typeof index === 'number') {\n            line = (inputStream.slice(0, index).match(/\\n/g) || '').length;\n        }\n\n        return {\n            line: line,\n            column: column\n        };\n    },\n    copyArray: function(arr) {\n        var i, length = arr.length,\n            copy = new Array(length);\n        \n        for (i = 0; i < length; i++) {\n            copy[i] = arr[i];\n        }\n        return copy;\n    },\n    clone: function (obj) {\n        var cloned = {};\n        for (var prop in obj) {\n            if (obj.hasOwnProperty(prop)) {\n                cloned[prop] = obj[prop];\n            }\n        }\n        return cloned;\n    },\n    copyOptions: function(obj1, obj2) {\n        if (obj2 && obj2._defaults) {\n            return obj2;\n        }\n        var opts = utils.defaults(obj1, obj2);\n        if (opts.strictMath) {\n            opts.math = Constants.Math.STRICT_LEGACY;\n        }\n        // Back compat with changed relativeUrls option\n        if (opts.relativeUrls) {\n            opts.rewriteUrls = Constants.RewriteUrls.ALL;\n        }\n        if (typeof opts.math === 'string') {\n            switch (opts.math.toLowerCase()) {\n                case 'always':\n                    opts.math = Constants.Math.ALWAYS;\n                    break;\n                case 'parens-division':\n                    opts.math = Constants.Math.PARENS_DIVISION;\n                    break;\n                case 'strict':\n                case 'parens':\n                    opts.math = Constants.Math.PARENS;\n                    break;\n                case 'strict-legacy':\n                    opts.math = Constants.Math.STRICT_LEGACY;\n            }\n        }\n        if (typeof opts.rewriteUrls === 'string') {\n            switch (opts.rewriteUrls.toLowerCase()) {\n                case 'off':\n                    opts.rewriteUrls = Constants.RewriteUrls.OFF;\n                    break;\n                case 'local':\n                    opts.rewriteUrls = Constants.RewriteUrls.LOCAL;\n                    break;\n                case 'all':\n                    opts.rewriteUrls = Constants.RewriteUrls.ALL;\n                    break;\n            }\n        }\n        return opts;\n    },\n    defaults: function(obj1, obj2) {\n        var newObj = obj2 || {};\n        if (!obj2._defaults) {\n            newObj = {};\n            var defaults = clone(obj1);\n            newObj._defaults = defaults;\n            var cloned = obj2 ? clone(obj2) : {};\n            Object.assign(newObj, defaults, cloned);\n        }\n        return newObj;\n    },\n    merge: function(obj1, obj2) {\n        for (var prop in obj2) {\n            if (obj2.hasOwnProperty(prop)) {\n                obj1[prop] = obj2[prop];\n            }\n        }\n        return obj1;\n    },\n    flattenArray: function(arr, result) {\n        result = result || [];\n        for (var i = 0, length = arr.length; i < length; i++) {\n            var value = arr[i];\n            if (Array.isArray(value)) {\n                utils.flattenArray(value, result);\n            } else {\n                if (value !== undefined) {\n                    result.push(value);\n                }\n            }\n        }\n        return result;\n    }\n};\n\nmodule.exports = utils;\n},{\"./constants\":12,\"clone\":100}],90:[function(require,module,exports){\nvar tree = require('../tree'),\n    Visitor = require('./visitor'),\n    logger = require('../logger'),\n    utils = require('../utils');\n\n/* jshint loopfunc:true */\n\nvar ExtendFinderVisitor = function() {\n    this._visitor = new Visitor(this);\n    this.contexts = [];\n    this.allExtendsStack = [[]];\n};\n\nExtendFinderVisitor.prototype = {\n    run: function (root) {\n        root = this._visitor.visit(root);\n        root.allExtends = this.allExtendsStack[0];\n        return root;\n    },\n    visitDeclaration: function (declNode, visitArgs) {\n        visitArgs.visitDeeper = false;\n    },\n    visitMixinDefinition: function (mixinDefinitionNode, visitArgs) {\n        visitArgs.visitDeeper = false;\n    },\n    visitRuleset: function (rulesetNode, visitArgs) {\n        if (rulesetNode.root) {\n            return;\n        }\n\n        var i, j, extend, allSelectorsExtendList = [], extendList;\n\n        // get &:extend(.a); rules which apply to all selectors in this ruleset\n        var rules = rulesetNode.rules, ruleCnt = rules ? rules.length : 0;\n        for (i = 0; i < ruleCnt; i++) {\n            if (rulesetNode.rules[i] instanceof tree.Extend) {\n                allSelectorsExtendList.push(rules[i]);\n                rulesetNode.extendOnEveryPath = true;\n            }\n        }\n\n        // now find every selector and apply the extends that apply to all extends\n        // and the ones which apply to an individual extend\n        var paths = rulesetNode.paths;\n        for (i = 0; i < paths.length; i++) {\n            var selectorPath = paths[i],\n                selector = selectorPath[selectorPath.length - 1],\n                selExtendList = selector.extendList;\n\n            extendList = selExtendList ? utils.copyArray(selExtendList).concat(allSelectorsExtendList)\n                                       : allSelectorsExtendList;\n\n            if (extendList) {\n                extendList = extendList.map(function(allSelectorsExtend) {\n                    return allSelectorsExtend.clone();\n                });\n            }\n\n            for (j = 0; j < extendList.length; j++) {\n                this.foundExtends = true;\n                extend = extendList[j];\n                extend.findSelfSelectors(selectorPath);\n                extend.ruleset = rulesetNode;\n                if (j === 0) { extend.firstExtendOnThisSelectorPath = true; }\n                this.allExtendsStack[this.allExtendsStack.length - 1].push(extend);\n            }\n        }\n\n        this.contexts.push(rulesetNode.selectors);\n    },\n    visitRulesetOut: function (rulesetNode) {\n        if (!rulesetNode.root) {\n            this.contexts.length = this.contexts.length - 1;\n        }\n    },\n    visitMedia: function (mediaNode, visitArgs) {\n        mediaNode.allExtends = [];\n        this.allExtendsStack.push(mediaNode.allExtends);\n    },\n    visitMediaOut: function (mediaNode) {\n        this.allExtendsStack.length = this.allExtendsStack.length - 1;\n    },\n    visitAtRule: function (atRuleNode, visitArgs) {\n        atRuleNode.allExtends = [];\n        this.allExtendsStack.push(atRuleNode.allExtends);\n    },\n    visitAtRuleOut: function (atRuleNode) {\n        this.allExtendsStack.length = this.allExtendsStack.length - 1;\n    }\n};\n\nvar ProcessExtendsVisitor = function() {\n    this._visitor = new Visitor(this);\n};\n\nProcessExtendsVisitor.prototype = {\n    run: function(root) {\n        var extendFinder = new ExtendFinderVisitor();\n        this.extendIndices = {};\n        extendFinder.run(root);\n        if (!extendFinder.foundExtends) { return root; }\n        root.allExtends = root.allExtends.concat(this.doExtendChaining(root.allExtends, root.allExtends));\n        this.allExtendsStack = [root.allExtends];\n        var newRoot = this._visitor.visit(root);\n        this.checkExtendsForNonMatched(root.allExtends);\n        return newRoot;\n    },\n    checkExtendsForNonMatched: function(extendList) {\n        var indices = this.extendIndices;\n        extendList.filter(function(extend) {\n            return !extend.hasFoundMatches && extend.parent_ids.length == 1;\n        }).forEach(function(extend) {\n            var selector = '_unknown_';\n            try {\n                selector = extend.selector.toCSS({});\n            }\n            catch (_) {}\n\n            if (!indices[extend.index + ' ' + selector]) {\n                indices[extend.index + ' ' + selector] = true;\n                logger.warn('extend \\'' + selector + '\\' has no matches');\n            }\n        });\n    },\n    doExtendChaining: function (extendsList, extendsListTarget, iterationCount) {\n        //\n        // chaining is different from normal extension.. if we extend an extend then we are not just copying, altering\n        // and pasting the selector we would do normally, but we are also adding an extend with the same target selector\n        // this means this new extend can then go and alter other extends\n        //\n        // this method deals with all the chaining work - without it, extend is flat and doesn't work on other extend selectors\n        // this is also the most expensive.. and a match on one selector can cause an extension of a selector we had already\n        // processed if we look at each selector at a time, as is done in visitRuleset\n\n        var extendIndex, targetExtendIndex, matches, extendsToAdd = [], newSelector, extendVisitor = this, selectorPath,\n            extend, targetExtend, newExtend;\n\n        iterationCount = iterationCount || 0;\n\n        // loop through comparing every extend with every target extend.\n        // a target extend is the one on the ruleset we are looking at copy/edit/pasting in place\n        // e.g.  .a:extend(.b) {}  and .b:extend(.c) {} then the first extend extends the second one\n        // and the second is the target.\n        // the separation into two lists allows us to process a subset of chains with a bigger set, as is the\n        // case when processing media queries\n        for (extendIndex = 0; extendIndex < extendsList.length; extendIndex++) {\n            for (targetExtendIndex = 0; targetExtendIndex < extendsListTarget.length; targetExtendIndex++) {\n\n                extend = extendsList[extendIndex];\n                targetExtend = extendsListTarget[targetExtendIndex];\n\n                // look for circular references\n                if ( extend.parent_ids.indexOf( targetExtend.object_id ) >= 0 ) { continue; }\n\n                // find a match in the target extends self selector (the bit before :extend)\n                selectorPath = [targetExtend.selfSelectors[0]];\n                matches = extendVisitor.findMatch(extend, selectorPath);\n\n                if (matches.length) {\n                    extend.hasFoundMatches = true;\n\n                    // we found a match, so for each self selector..\n                    extend.selfSelectors.forEach(function(selfSelector) {\n                        var info = targetExtend.visibilityInfo();\n\n                        // process the extend as usual\n                        newSelector = extendVisitor.extendSelector(matches, selectorPath, selfSelector, extend.isVisible());\n\n                        // but now we create a new extend from it\n                        newExtend = new(tree.Extend)(targetExtend.selector, targetExtend.option, 0, targetExtend.fileInfo(), info);\n                        newExtend.selfSelectors = newSelector;\n\n                        // add the extend onto the list of extends for that selector\n                        newSelector[newSelector.length - 1].extendList = [newExtend];\n\n                        // record that we need to add it.\n                        extendsToAdd.push(newExtend);\n                        newExtend.ruleset = targetExtend.ruleset;\n\n                        // remember its parents for circular references\n                        newExtend.parent_ids = newExtend.parent_ids.concat(targetExtend.parent_ids, extend.parent_ids);\n\n                        // only process the selector once.. if we have :extend(.a,.b) then multiple\n                        // extends will look at the same selector path, so when extending\n                        // we know that any others will be duplicates in terms of what is added to the css\n                        if (targetExtend.firstExtendOnThisSelectorPath) {\n                            newExtend.firstExtendOnThisSelectorPath = true;\n                            targetExtend.ruleset.paths.push(newSelector);\n                        }\n                    });\n                }\n            }\n        }\n\n        if (extendsToAdd.length) {\n            // try to detect circular references to stop a stack overflow.\n            // may no longer be needed.\n            this.extendChainCount++;\n            if (iterationCount > 100) {\n                var selectorOne = '{unable to calculate}';\n                var selectorTwo = '{unable to calculate}';\n                try {\n                    selectorOne = extendsToAdd[0].selfSelectors[0].toCSS();\n                    selectorTwo = extendsToAdd[0].selector.toCSS();\n                }\n                catch (e) {}\n                throw { message: 'extend circular reference detected. One of the circular extends is currently:' +\n                    selectorOne + ':extend(' + selectorTwo + ')'};\n            }\n\n            // now process the new extends on the existing rules so that we can handle a extending b extending c extending\n            // d extending e...\n            return extendsToAdd.concat(extendVisitor.doExtendChaining(extendsToAdd, extendsListTarget, iterationCount + 1));\n        } else {\n            return extendsToAdd;\n        }\n    },\n    visitDeclaration: function (ruleNode, visitArgs) {\n        visitArgs.visitDeeper = false;\n    },\n    visitMixinDefinition: function (mixinDefinitionNode, visitArgs) {\n        visitArgs.visitDeeper = false;\n    },\n    visitSelector: function (selectorNode, visitArgs) {\n        visitArgs.visitDeeper = false;\n    },\n    visitRuleset: function (rulesetNode, visitArgs) {\n        if (rulesetNode.root) {\n            return;\n        }\n        var matches, pathIndex, extendIndex, allExtends = this.allExtendsStack[this.allExtendsStack.length - 1],\n            selectorsToAdd = [], extendVisitor = this, selectorPath;\n\n        // look at each selector path in the ruleset, find any extend matches and then copy, find and replace\n\n        for (extendIndex = 0; extendIndex < allExtends.length; extendIndex++) {\n            for (pathIndex = 0; pathIndex < rulesetNode.paths.length; pathIndex++) {\n                selectorPath = rulesetNode.paths[pathIndex];\n\n                // extending extends happens initially, before the main pass\n                if (rulesetNode.extendOnEveryPath) { continue; }\n                var extendList = selectorPath[selectorPath.length - 1].extendList;\n                if (extendList && extendList.length) { continue; }\n\n                matches = this.findMatch(allExtends[extendIndex], selectorPath);\n\n                if (matches.length) {\n                    allExtends[extendIndex].hasFoundMatches = true;\n\n                    allExtends[extendIndex].selfSelectors.forEach(function(selfSelector) {\n                        var extendedSelectors;\n                        extendedSelectors = extendVisitor.extendSelector(matches, selectorPath, selfSelector, allExtends[extendIndex].isVisible());\n                        selectorsToAdd.push(extendedSelectors);\n                    });\n                }\n            }\n        }\n        rulesetNode.paths = rulesetNode.paths.concat(selectorsToAdd);\n    },\n    findMatch: function (extend, haystackSelectorPath) {\n        //\n        // look through the haystack selector path to try and find the needle - extend.selector\n        // returns an array of selector matches that can then be replaced\n        //\n        var haystackSelectorIndex, hackstackSelector, hackstackElementIndex, haystackElement,\n            targetCombinator, i,\n            extendVisitor = this,\n            needleElements = extend.selector.elements,\n            potentialMatches = [], potentialMatch, matches = [];\n\n        // loop through the haystack elements\n        for (haystackSelectorIndex = 0; haystackSelectorIndex < haystackSelectorPath.length; haystackSelectorIndex++) {\n            hackstackSelector = haystackSelectorPath[haystackSelectorIndex];\n\n            for (hackstackElementIndex = 0; hackstackElementIndex < hackstackSelector.elements.length; hackstackElementIndex++) {\n\n                haystackElement = hackstackSelector.elements[hackstackElementIndex];\n\n                // if we allow elements before our match we can add a potential match every time. otherwise only at the first element.\n                if (extend.allowBefore || (haystackSelectorIndex === 0 && hackstackElementIndex === 0)) {\n                    potentialMatches.push({pathIndex: haystackSelectorIndex, index: hackstackElementIndex, matched: 0,\n                        initialCombinator: haystackElement.combinator});\n                }\n\n                for (i = 0; i < potentialMatches.length; i++) {\n                    potentialMatch = potentialMatches[i];\n\n                    // selectors add \" \" onto the first element. When we use & it joins the selectors together, but if we don't\n                    // then each selector in haystackSelectorPath has a space before it added in the toCSS phase. so we need to\n                    // work out what the resulting combinator will be\n                    targetCombinator = haystackElement.combinator.value;\n                    if (targetCombinator === '' && hackstackElementIndex === 0) {\n                        targetCombinator = ' ';\n                    }\n\n                    // if we don't match, null our match to indicate failure\n                    if (!extendVisitor.isElementValuesEqual(needleElements[potentialMatch.matched].value, haystackElement.value) ||\n                        (potentialMatch.matched > 0 && needleElements[potentialMatch.matched].combinator.value !== targetCombinator)) {\n                        potentialMatch = null;\n                    } else {\n                        potentialMatch.matched++;\n                    }\n\n                    // if we are still valid and have finished, test whether we have elements after and whether these are allowed\n                    if (potentialMatch) {\n                        potentialMatch.finished = potentialMatch.matched === needleElements.length;\n                        if (potentialMatch.finished &&\n                            (!extend.allowAfter &&\n                                (hackstackElementIndex + 1 < hackstackSelector.elements.length || haystackSelectorIndex + 1 < haystackSelectorPath.length))) {\n                            potentialMatch = null;\n                        }\n                    }\n                    // if null we remove, if not, we are still valid, so either push as a valid match or continue\n                    if (potentialMatch) {\n                        if (potentialMatch.finished) {\n                            potentialMatch.length = needleElements.length;\n                            potentialMatch.endPathIndex = haystackSelectorIndex;\n                            potentialMatch.endPathElementIndex = hackstackElementIndex + 1; // index after end of match\n                            potentialMatches.length = 0; // we don't allow matches to overlap, so start matching again\n                            matches.push(potentialMatch);\n                        }\n                    } else {\n                        potentialMatches.splice(i, 1);\n                        i--;\n                    }\n                }\n            }\n        }\n        return matches;\n    },\n    isElementValuesEqual: function(elementValue1, elementValue2) {\n        if (typeof elementValue1 === 'string' || typeof elementValue2 === 'string') {\n            return elementValue1 === elementValue2;\n        }\n        if (elementValue1 instanceof tree.Attribute) {\n            if (elementValue1.op !== elementValue2.op || elementValue1.key !== elementValue2.key) {\n                return false;\n            }\n            if (!elementValue1.value || !elementValue2.value) {\n                if (elementValue1.value || elementValue2.value) {\n                    return false;\n                }\n                return true;\n            }\n            elementValue1 = elementValue1.value.value || elementValue1.value;\n            elementValue2 = elementValue2.value.value || elementValue2.value;\n            return elementValue1 === elementValue2;\n        }\n        elementValue1 = elementValue1.value;\n        elementValue2 = elementValue2.value;\n        if (elementValue1 instanceof tree.Selector) {\n            if (!(elementValue2 instanceof tree.Selector) || elementValue1.elements.length !== elementValue2.elements.length) {\n                return false;\n            }\n            for (var i = 0; i  < elementValue1.elements.length; i++) {\n                if (elementValue1.elements[i].combinator.value !== elementValue2.elements[i].combinator.value) {\n                    if (i !== 0 || (elementValue1.elements[i].combinator.value || ' ') !== (elementValue2.elements[i].combinator.value || ' ')) {\n                        return false;\n                    }\n                }\n                if (!this.isElementValuesEqual(elementValue1.elements[i].value, elementValue2.elements[i].value)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    },\n    extendSelector:function (matches, selectorPath, replacementSelector, isVisible) {\n\n        // for a set of matches, replace each match with the replacement selector\n\n        var currentSelectorPathIndex = 0,\n            currentSelectorPathElementIndex = 0,\n            path = [],\n            matchIndex,\n            selector,\n            firstElement,\n            match,\n            newElements;\n\n        for (matchIndex = 0; matchIndex < matches.length; matchIndex++) {\n            match = matches[matchIndex];\n            selector = selectorPath[match.pathIndex];\n            firstElement = new tree.Element(\n                match.initialCombinator,\n                replacementSelector.elements[0].value,\n                replacementSelector.elements[0].isVariable,\n                replacementSelector.elements[0].getIndex(),\n                replacementSelector.elements[0].fileInfo()\n            );\n\n            if (match.pathIndex > currentSelectorPathIndex && currentSelectorPathElementIndex > 0) {\n                path[path.length - 1].elements = path[path.length - 1]\n                    .elements.concat(selectorPath[currentSelectorPathIndex].elements.slice(currentSelectorPathElementIndex));\n                currentSelectorPathElementIndex = 0;\n                currentSelectorPathIndex++;\n            }\n\n            newElements = selector.elements\n                .slice(currentSelectorPathElementIndex, match.index)\n                .concat([firstElement])\n                .concat(replacementSelector.elements.slice(1));\n\n            if (currentSelectorPathIndex === match.pathIndex && matchIndex > 0) {\n                path[path.length - 1].elements =\n                    path[path.length - 1].elements.concat(newElements);\n            } else {\n                path = path.concat(selectorPath.slice(currentSelectorPathIndex, match.pathIndex));\n\n                path.push(new tree.Selector(\n                    newElements\n                ));\n            }\n            currentSelectorPathIndex = match.endPathIndex;\n            currentSelectorPathElementIndex = match.endPathElementIndex;\n            if (currentSelectorPathElementIndex >= selectorPath[currentSelectorPathIndex].elements.length) {\n                currentSelectorPathElementIndex = 0;\n                currentSelectorPathIndex++;\n            }\n        }\n\n        if (currentSelectorPathIndex < selectorPath.length && currentSelectorPathElementIndex > 0) {\n            path[path.length - 1].elements = path[path.length - 1]\n                .elements.concat(selectorPath[currentSelectorPathIndex].elements.slice(currentSelectorPathElementIndex));\n            currentSelectorPathIndex++;\n        }\n\n        path = path.concat(selectorPath.slice(currentSelectorPathIndex, selectorPath.length));\n        path = path.map(function (currentValue) {\n            // we can re-use elements here, because the visibility property matters only for selectors\n            var derived = currentValue.createDerived(currentValue.elements);\n            if (isVisible) {\n                derived.ensureVisibility();\n            } else {\n                derived.ensureInvisibility();\n            }\n            return derived;\n        });\n        return path;\n    },\n    visitMedia: function (mediaNode, visitArgs) {\n        var newAllExtends = mediaNode.allExtends.concat(this.allExtendsStack[this.allExtendsStack.length - 1]);\n        newAllExtends = newAllExtends.concat(this.doExtendChaining(newAllExtends, mediaNode.allExtends));\n        this.allExtendsStack.push(newAllExtends);\n    },\n    visitMediaOut: function (mediaNode) {\n        var lastIndex = this.allExtendsStack.length - 1;\n        this.allExtendsStack.length = lastIndex;\n    },\n    visitAtRule: function (atRuleNode, visitArgs) {\n        var newAllExtends = atRuleNode.allExtends.concat(this.allExtendsStack[this.allExtendsStack.length - 1]);\n        newAllExtends = newAllExtends.concat(this.doExtendChaining(newAllExtends, atRuleNode.allExtends));\n        this.allExtendsStack.push(newAllExtends);\n    },\n    visitAtRuleOut: function (atRuleNode) {\n        var lastIndex = this.allExtendsStack.length - 1;\n        this.allExtendsStack.length = lastIndex;\n    }\n};\n\nmodule.exports = ProcessExtendsVisitor;\n\n},{\"../logger\":39,\"../tree\":67,\"../utils\":89,\"./visitor\":97}],91:[function(require,module,exports){\nfunction ImportSequencer(onSequencerEmpty) {\n    this.imports = [];\n    this.variableImports = [];\n    this._onSequencerEmpty = onSequencerEmpty;\n    this._currentDepth = 0;\n}\n\nImportSequencer.prototype.addImport = function(callback) {\n    var importSequencer = this,\n        importItem = {\n            callback: callback,\n            args: null,\n            isReady: false\n        };\n    this.imports.push(importItem);\n    return function() {\n        importItem.args = Array.prototype.slice.call(arguments, 0);\n        importItem.isReady = true;\n        importSequencer.tryRun();\n    };\n};\n\nImportSequencer.prototype.addVariableImport = function(callback) {\n    this.variableImports.push(callback);\n};\n\nImportSequencer.prototype.tryRun = function() {\n    this._currentDepth++;\n    try {\n        while (true) {\n            while (this.imports.length > 0) {\n                var importItem = this.imports[0];\n                if (!importItem.isReady) {\n                    return;\n                }\n                this.imports = this.imports.slice(1);\n                importItem.callback.apply(null, importItem.args);\n            }\n            if (this.variableImports.length === 0) {\n                break;\n            }\n            var variableImport = this.variableImports[0];\n            this.variableImports = this.variableImports.slice(1);\n            variableImport();\n        }\n    } finally {\n        this._currentDepth--;\n    }\n    if (this._currentDepth === 0 && this._onSequencerEmpty) {\n        this._onSequencerEmpty();\n    }\n};\n\nmodule.exports = ImportSequencer;\n\n},{}],92:[function(require,module,exports){\nvar contexts = require('../contexts'),\n    Visitor = require('./visitor'),\n    ImportSequencer = require('./import-sequencer'),\n    utils = require('../utils');\n\nvar ImportVisitor = function(importer, finish) {\n\n    this._visitor = new Visitor(this);\n    this._importer = importer;\n    this._finish = finish;\n    this.context = new contexts.Eval();\n    this.importCount = 0;\n    this.onceFileDetectionMap = {};\n    this.recursionDetector = {};\n    this._sequencer = new ImportSequencer(this._onSequencerEmpty.bind(this));\n};\n\nImportVisitor.prototype = {\n    isReplacing: false,\n    run: function (root) {\n        try {\n            // process the contents\n            this._visitor.visit(root);\n        }\n        catch (e) {\n            this.error = e;\n        }\n\n        this.isFinished = true;\n        this._sequencer.tryRun();\n    },\n    _onSequencerEmpty: function() {\n        if (!this.isFinished) {\n            return;\n        }\n        this._finish(this.error);\n    },\n    visitImport: function (importNode, visitArgs) {\n        var inlineCSS = importNode.options.inline;\n\n        if (!importNode.css || inlineCSS) {\n\n            var context = new contexts.Eval(this.context, utils.copyArray(this.context.frames));\n            var importParent = context.frames[0];\n\n            this.importCount++;\n            if (importNode.isVariableImport()) {\n                this._sequencer.addVariableImport(this.processImportNode.bind(this, importNode, context, importParent));\n            } else {\n                this.processImportNode(importNode, context, importParent);\n            }\n        }\n        visitArgs.visitDeeper = false;\n    },\n    processImportNode: function(importNode, context, importParent) {\n        var evaldImportNode,\n            inlineCSS = importNode.options.inline;\n\n        try {\n            evaldImportNode = importNode.evalForImport(context);\n        } catch (e) {\n            if (!e.filename) { e.index = importNode.getIndex(); e.filename = importNode.fileInfo().filename; }\n            // attempt to eval properly and treat as css\n            importNode.css = true;\n            // if that fails, this error will be thrown\n            importNode.error = e;\n        }\n\n        if (evaldImportNode && (!evaldImportNode.css || inlineCSS)) {\n\n            if (evaldImportNode.options.multiple) {\n                context.importMultiple = true;\n            }\n\n            // try appending if we haven't determined if it is css or not\n            var tryAppendLessExtension = evaldImportNode.css === undefined;\n\n            for (var i = 0; i < importParent.rules.length; i++) {\n                if (importParent.rules[i] === importNode) {\n                    importParent.rules[i] = evaldImportNode;\n                    break;\n                }\n            }\n\n            var onImported = this.onImported.bind(this, evaldImportNode, context),\n                sequencedOnImported = this._sequencer.addImport(onImported);\n\n            this._importer.push(evaldImportNode.getPath(), tryAppendLessExtension, evaldImportNode.fileInfo(),\n                evaldImportNode.options, sequencedOnImported);\n        } else {\n            this.importCount--;\n            if (this.isFinished) {\n                this._sequencer.tryRun();\n            }\n        }\n    },\n    onImported: function (importNode, context, e, root, importedAtRoot, fullPath) {\n        if (e) {\n            if (!e.filename) {\n                e.index = importNode.getIndex(); e.filename = importNode.fileInfo().filename;\n            }\n            this.error = e;\n        }\n\n        var importVisitor = this,\n            inlineCSS = importNode.options.inline,\n            isPlugin = importNode.options.isPlugin,\n            isOptional = importNode.options.optional,\n            duplicateImport = importedAtRoot || fullPath in importVisitor.recursionDetector;\n\n        if (!context.importMultiple) {\n            if (duplicateImport) {\n                importNode.skip = true;\n            } else {\n                importNode.skip = function() {\n                    if (fullPath in importVisitor.onceFileDetectionMap) {\n                        return true;\n                    }\n                    importVisitor.onceFileDetectionMap[fullPath] = true;\n                    return false;\n                };\n            }\n        }\n\n        if (!fullPath && isOptional) {\n            importNode.skip = true;\n        }\n\n        if (root) {\n            importNode.root = root;\n            importNode.importedFilename = fullPath;\n\n            if (!inlineCSS && !isPlugin && (context.importMultiple || !duplicateImport)) {\n                importVisitor.recursionDetector[fullPath] = true;\n\n                var oldContext = this.context;\n                this.context = context;\n                try {\n                    this._visitor.visit(root);\n                } catch (e) {\n                    this.error = e;\n                }\n                this.context = oldContext;\n            }\n        }\n\n        importVisitor.importCount--;\n\n        if (importVisitor.isFinished) {\n            importVisitor._sequencer.tryRun();\n        }\n    },\n    visitDeclaration: function (declNode, visitArgs) {\n        if (declNode.value.type === 'DetachedRuleset') {\n            this.context.frames.unshift(declNode);\n        } else {\n            visitArgs.visitDeeper = false;\n        }\n    },\n    visitDeclarationOut: function(declNode) {\n        if (declNode.value.type === 'DetachedRuleset') {\n            this.context.frames.shift();\n        }\n    },\n    visitAtRule: function (atRuleNode, visitArgs) {\n        this.context.frames.unshift(atRuleNode);\n    },\n    visitAtRuleOut: function (atRuleNode) {\n        this.context.frames.shift();\n    },\n    visitMixinDefinition: function (mixinDefinitionNode, visitArgs) {\n        this.context.frames.unshift(mixinDefinitionNode);\n    },\n    visitMixinDefinitionOut: function (mixinDefinitionNode) {\n        this.context.frames.shift();\n    },\n    visitRuleset: function (rulesetNode, visitArgs) {\n        this.context.frames.unshift(rulesetNode);\n    },\n    visitRulesetOut: function (rulesetNode) {\n        this.context.frames.shift();\n    },\n    visitMedia: function (mediaNode, visitArgs) {\n        this.context.frames.unshift(mediaNode.rules[0]);\n    },\n    visitMediaOut: function (mediaNode) {\n        this.context.frames.shift();\n    }\n};\nmodule.exports = ImportVisitor;\n\n},{\"../contexts\":13,\"../utils\":89,\"./import-sequencer\":91,\"./visitor\":97}],93:[function(require,module,exports){\nvar visitors = {\n    Visitor: require('./visitor'),\n    ImportVisitor: require('./import-visitor'),\n    MarkVisibleSelectorsVisitor: require('./set-tree-visibility-visitor'),\n    ExtendVisitor: require('./extend-visitor'),\n    JoinSelectorVisitor: require('./join-selector-visitor'),\n    ToCSSVisitor: require('./to-css-visitor')\n};\n\nmodule.exports = visitors;\n\n},{\"./extend-visitor\":90,\"./import-visitor\":92,\"./join-selector-visitor\":94,\"./set-tree-visibility-visitor\":95,\"./to-css-visitor\":96,\"./visitor\":97}],94:[function(require,module,exports){\nvar Visitor = require('./visitor');\n\nvar JoinSelectorVisitor = function() {\n    this.contexts = [[]];\n    this._visitor = new Visitor(this);\n};\n\nJoinSelectorVisitor.prototype = {\n    run: function (root) {\n        return this._visitor.visit(root);\n    },\n    visitDeclaration: function (declNode, visitArgs) {\n        visitArgs.visitDeeper = false;\n    },\n    visitMixinDefinition: function (mixinDefinitionNode, visitArgs) {\n        visitArgs.visitDeeper = false;\n    },\n\n    visitRuleset: function (rulesetNode, visitArgs) {\n        var context = this.contexts[this.contexts.length - 1],\n            paths = [], selectors;\n\n        this.contexts.push(paths);\n\n        if (!rulesetNode.root) {\n            selectors = rulesetNode.selectors;\n            if (selectors) {\n                selectors = selectors.filter(function(selector) { return selector.getIsOutput(); });\n                rulesetNode.selectors = selectors.length ? selectors : (selectors = null);\n                if (selectors) { rulesetNode.joinSelectors(paths, context, selectors); }\n            }\n            if (!selectors) { rulesetNode.rules = null; }\n            rulesetNode.paths = paths;\n        }\n    },\n    visitRulesetOut: function (rulesetNode) {\n        this.contexts.length = this.contexts.length - 1;\n    },\n    visitMedia: function (mediaNode, visitArgs) {\n        var context = this.contexts[this.contexts.length - 1];\n        mediaNode.rules[0].root = (context.length === 0 || context[0].multiMedia);\n    },\n    visitAtRule: function (atRuleNode, visitArgs) {\n        var context = this.contexts[this.contexts.length - 1];\n        if (atRuleNode.rules && atRuleNode.rules.length) {\n            atRuleNode.rules[0].root = (atRuleNode.isRooted || context.length === 0 || null);\n        }\n    }\n};\n\nmodule.exports = JoinSelectorVisitor;\n\n},{\"./visitor\":97}],95:[function(require,module,exports){\nvar SetTreeVisibilityVisitor = function(visible) {\n    this.visible = visible;\n};\nSetTreeVisibilityVisitor.prototype.run = function(root) {\n    this.visit(root);\n};\nSetTreeVisibilityVisitor.prototype.visitArray = function(nodes) {\n    if (!nodes) {\n        return nodes;\n    }\n\n    var cnt = nodes.length, i;\n    for (i = 0; i < cnt; i++) {\n        this.visit(nodes[i]);\n    }\n    return nodes;\n};\nSetTreeVisibilityVisitor.prototype.visit = function(node) {\n    if (!node) {\n        return node;\n    }\n    if (node.constructor === Array) {\n        return this.visitArray(node);\n    }\n\n    if (!node.blocksVisibility || node.blocksVisibility()) {\n        return node;\n    }\n    if (this.visible) {\n        node.ensureVisibility();\n    } else {\n        node.ensureInvisibility();\n    }\n\n    node.accept(this);\n    return node;\n};\nmodule.exports = SetTreeVisibilityVisitor;\n},{}],96:[function(require,module,exports){\nvar tree = require('../tree'),\n    Visitor = require('./visitor');\n\nvar CSSVisitorUtils = function(context) {\n    this._visitor = new Visitor(this);\n    this._context = context;\n};\n\nCSSVisitorUtils.prototype = {\n    containsSilentNonBlockedChild: function(bodyRules) {\n        var rule;\n        if (!bodyRules) {\n            return false;\n        }\n        for (var r = 0; r < bodyRules.length; r++) {\n            rule = bodyRules[r];\n            if (rule.isSilent && rule.isSilent(this._context) && !rule.blocksVisibility()) {\n                // the atrule contains something that was referenced (likely by extend)\n                // therefore it needs to be shown in output too\n                return true;\n            }\n        }\n        return false;\n    },\n\n    keepOnlyVisibleChilds: function(owner) {\n        if (owner && owner.rules) {\n            owner.rules = owner.rules.filter(function(thing) {\n                return thing.isVisible();\n            });\n        }\n    },\n\n    isEmpty: function(owner) {\n        return (owner && owner.rules) \n            ? (owner.rules.length === 0) : true;\n    },\n\n    hasVisibleSelector: function(rulesetNode) {\n        return (rulesetNode && rulesetNode.paths)\n            ? (rulesetNode.paths.length > 0) : false;\n    },\n\n    resolveVisibility: function (node, originalRules) {\n        if (!node.blocksVisibility()) {\n            if (this.isEmpty(node) && !this.containsSilentNonBlockedChild(originalRules)) {\n                return ;\n            }\n\n            return node;\n        }\n\n        var compiledRulesBody = node.rules[0];\n        this.keepOnlyVisibleChilds(compiledRulesBody);\n\n        if (this.isEmpty(compiledRulesBody)) {\n            return ;\n        }\n\n        node.ensureVisibility();\n        node.removeVisibilityBlock();\n\n        return node;\n    },\n\n    isVisibleRuleset: function(rulesetNode) {\n        if (rulesetNode.firstRoot) {\n            return true;\n        }\n\n        if (this.isEmpty(rulesetNode)) {\n            return false;\n        }\n\n        if (!rulesetNode.root && !this.hasVisibleSelector(rulesetNode)) {\n            return false;\n        }\n\n        return true;\n    }\n\n};\n\nvar ToCSSVisitor = function(context) {\n    this._visitor = new Visitor(this);\n    this._context = context;\n    this.utils = new CSSVisitorUtils(context);\n};\n\nToCSSVisitor.prototype = {\n    isReplacing: true,\n    run: function (root) {\n        return this._visitor.visit(root);\n    },\n\n    visitDeclaration: function (declNode, visitArgs) {\n        if (declNode.blocksVisibility() || declNode.variable) {\n            return;\n        }\n        return declNode;\n    },\n\n    visitMixinDefinition: function (mixinNode, visitArgs) {\n        // mixin definitions do not get eval'd - this means they keep state\n        // so we have to clear that state here so it isn't used if toCSS is called twice\n        mixinNode.frames = [];\n    },\n\n    visitExtend: function (extendNode, visitArgs) {\n    },\n\n    visitComment: function (commentNode, visitArgs) {\n        if (commentNode.blocksVisibility() || commentNode.isSilent(this._context)) {\n            return;\n        }\n        return commentNode;\n    },\n\n    visitMedia: function(mediaNode, visitArgs) {\n        var originalRules = mediaNode.rules[0].rules;\n        mediaNode.accept(this._visitor);\n        visitArgs.visitDeeper = false;\n\n        return this.utils.resolveVisibility(mediaNode, originalRules);\n    },\n\n    visitImport: function (importNode, visitArgs) {\n        if (importNode.blocksVisibility()) {\n            return ;\n        }\n        return importNode;\n    },\n\n    visitAtRule: function(atRuleNode, visitArgs) {\n        if (atRuleNode.rules && atRuleNode.rules.length) {\n            return this.visitAtRuleWithBody(atRuleNode, visitArgs);\n        } else {\n            return this.visitAtRuleWithoutBody(atRuleNode, visitArgs);\n        }\n    },\n\n    visitAnonymous: function(anonymousNode, visitArgs) {\n        if (!anonymousNode.blocksVisibility()) {\n            anonymousNode.accept(this._visitor);\n            return anonymousNode;\n        }\n    },\n\n    visitAtRuleWithBody: function(atRuleNode, visitArgs) {\n        // if there is only one nested ruleset and that one has no path, then it is\n        // just fake ruleset\n        function hasFakeRuleset(atRuleNode) {\n            var bodyRules = atRuleNode.rules;\n            return bodyRules.length === 1 && (!bodyRules[0].paths || bodyRules[0].paths.length === 0);\n        }\n        function getBodyRules(atRuleNode) {\n            var nodeRules = atRuleNode.rules;\n            if (hasFakeRuleset(atRuleNode)) {\n                return nodeRules[0].rules;\n            }\n\n            return nodeRules;\n        }\n        // it is still true that it is only one ruleset in array\n        // this is last such moment\n        // process childs\n        var originalRules = getBodyRules(atRuleNode);\n        atRuleNode.accept(this._visitor);\n        visitArgs.visitDeeper = false;\n\n        if (!this.utils.isEmpty(atRuleNode)) {\n            this._mergeRules(atRuleNode.rules[0].rules);\n        }\n\n        return this.utils.resolveVisibility(atRuleNode, originalRules);\n    },\n\n    visitAtRuleWithoutBody: function(atRuleNode, visitArgs) {\n        if (atRuleNode.blocksVisibility()) {\n            return;\n        }\n\n        if (atRuleNode.name === '@charset') {\n            // Only output the debug info together with subsequent @charset definitions\n            // a comment (or @media statement) before the actual @charset atrule would\n            // be considered illegal css as it has to be on the first line\n            if (this.charset) {\n                if (atRuleNode.debugInfo) {\n                    var comment = new tree.Comment('/* ' + atRuleNode.toCSS(this._context).replace(/\\n/g, '') + ' */\\n');\n                    comment.debugInfo = atRuleNode.debugInfo;\n                    return this._visitor.visit(comment);\n                }\n                return;\n            }\n            this.charset = true;\n        }\n\n        return atRuleNode;\n    },\n\n    checkValidNodes: function(rules, isRoot) {\n        if (!rules) {\n            return;\n        }\n\n        for (var i = 0; i < rules.length; i++) {\n            var ruleNode = rules[i];\n            if (isRoot && ruleNode instanceof tree.Declaration && !ruleNode.variable) {\n                throw { message: 'Properties must be inside selector blocks. They cannot be in the root',\n                    index: ruleNode.getIndex(), filename: ruleNode.fileInfo() && ruleNode.fileInfo().filename};\n            }\n            if (ruleNode instanceof tree.Call) {\n                throw { message: 'Function \\'' + ruleNode.name + '\\' is undefined',\n                    index: ruleNode.getIndex(), filename: ruleNode.fileInfo() && ruleNode.fileInfo().filename};\n            }\n            if (ruleNode.type && !ruleNode.allowRoot) {\n                throw { message: ruleNode.type + ' node returned by a function is not valid here',\n                    index: ruleNode.getIndex(), filename: ruleNode.fileInfo() && ruleNode.fileInfo().filename};\n            }\n        }\n    },\n\n    visitRuleset: function (rulesetNode, visitArgs) {\n        // at this point rulesets are nested into each other\n        var rule, rulesets = [];\n\n        this.checkValidNodes(rulesetNode.rules, rulesetNode.firstRoot);\n\n        if (!rulesetNode.root) {\n            // remove invisible paths\n            this._compileRulesetPaths(rulesetNode);\n\n            // remove rulesets from this ruleset body and compile them separately\n            var nodeRules = rulesetNode.rules, nodeRuleCnt = nodeRules ? nodeRules.length : 0;\n            for (var i = 0; i < nodeRuleCnt; ) {\n                rule = nodeRules[i];\n                if (rule && rule.rules) {\n                    // visit because we are moving them out from being a child\n                    rulesets.push(this._visitor.visit(rule));\n                    nodeRules.splice(i, 1);\n                    nodeRuleCnt--;\n                    continue;\n                }\n                i++;\n            }\n            // accept the visitor to remove rules and refactor itself\n            // then we can decide nogw whether we want it or not\n            // compile body\n            if (nodeRuleCnt > 0) {\n                rulesetNode.accept(this._visitor);\n            } else {\n                rulesetNode.rules = null;\n            }\n            visitArgs.visitDeeper = false;\n\n        } else { // if (! rulesetNode.root) {\n            rulesetNode.accept(this._visitor);\n            visitArgs.visitDeeper = false;\n        }\n\n        if (rulesetNode.rules) {\n            this._mergeRules(rulesetNode.rules);\n            this._removeDuplicateRules(rulesetNode.rules);\n        }\n\n        // now decide whether we keep the ruleset\n        if (this.utils.isVisibleRuleset(rulesetNode)) {\n            rulesetNode.ensureVisibility();\n            rulesets.splice(0, 0, rulesetNode);\n        }\n\n        if (rulesets.length === 1) {\n            return rulesets[0];\n        }\n        return rulesets;\n    },\n\n    _compileRulesetPaths: function(rulesetNode) {\n        if (rulesetNode.paths) {\n            rulesetNode.paths = rulesetNode.paths\n                .filter(function(p) {\n                    var i;\n                    if (p[0].elements[0].combinator.value === ' ') {\n                        p[0].elements[0].combinator = new(tree.Combinator)('');\n                    }\n                    for (i = 0; i < p.length; i++) {\n                        if (p[i].isVisible() && p[i].getIsOutput()) {\n                            return true;\n                        }\n                    }\n                    return false;\n                });\n        }\n    },\n\n    _removeDuplicateRules: function(rules) {\n        if (!rules) { return; }\n\n        // remove duplicates\n        var ruleCache = {},\n            ruleList, rule, i;\n\n        for (i = rules.length - 1; i >= 0 ; i--) {\n            rule = rules[i];\n            if (rule instanceof tree.Declaration) {\n                if (!ruleCache[rule.name]) {\n                    ruleCache[rule.name] = rule;\n                } else {\n                    ruleList = ruleCache[rule.name];\n                    if (ruleList instanceof tree.Declaration) {\n                        ruleList = ruleCache[rule.name] = [ruleCache[rule.name].toCSS(this._context)];\n                    }\n                    var ruleCSS = rule.toCSS(this._context);\n                    if (ruleList.indexOf(ruleCSS) !== -1) {\n                        rules.splice(i, 1);\n                    } else {\n                        ruleList.push(ruleCSS);\n                    }\n                }\n            }\n        }\n    },\n\n    _mergeRules: function(rules) {\n        if (!rules) {\n            return; \n        }\n\n        var groups    = {},\n            groupsArr = [];\n        \n        for (var i = 0; i < rules.length; i++) {\n            var rule = rules[i];\n            if (rule.merge) {\n                var key = rule.name;\n                groups[key] ? rules.splice(i--, 1) : \n                    groupsArr.push(groups[key] = []);\n                groups[key].push(rule);\n            }\n        }\n\n        groupsArr.forEach(function(group) {\n            if (group.length > 0) {\n                var result = group[0],\n                    space  = [],\n                    comma  = [new tree.Expression(space)];\n                group.forEach(function(rule) {\n                    if ((rule.merge === '+') && (space.length > 0)) {\n                        comma.push(new tree.Expression(space = []));\n                    }\n                    space.push(rule.value);\n                    result.important = result.important || rule.important;\n                });\n                result.value = new tree.Value(comma);\n            }\n        });\n    }\n};\n\nmodule.exports = ToCSSVisitor;\n\n},{\"../tree\":67,\"./visitor\":97}],97:[function(require,module,exports){\nvar tree = require('../tree');\n\nvar _visitArgs = { visitDeeper: true },\n    _hasIndexed = false;\n\nfunction _noop(node) {\n    return node;\n}\n\nfunction indexNodeTypes(parent, ticker) {\n    // add .typeIndex to tree node types for lookup table\n    var key, child;\n    for (key in parent) { \n        /* eslint guard-for-in: 0 */\n        child = parent[key];\n        switch (typeof child) {\n            case 'function':\n                // ignore bound functions directly on tree which do not have a prototype\n                // or aren't nodes\n                if (child.prototype && child.prototype.type) {\n                    child.prototype.typeIndex = ticker++;\n                }\n                break;\n            case 'object':\n                ticker = indexNodeTypes(child, ticker);\n                break;\n        \n        }\n    }\n    return ticker;\n}\n\nvar Visitor = function(implementation) {\n    this._implementation = implementation;\n    this._visitInCache = {};\n    this._visitOutCache = {};\n\n    if (!_hasIndexed) {\n        indexNodeTypes(tree, 1);\n        _hasIndexed = true;\n    }\n};\n\nVisitor.prototype = {\n    visit: function(node) {\n        if (!node) {\n            return node;\n        }\n\n        var nodeTypeIndex = node.typeIndex;\n        if (!nodeTypeIndex) {\n            // MixinCall args aren't a node type?\n            if (node.value && node.value.typeIndex) {\n                this.visit(node.value);\n            }\n            return node;\n        }\n\n        var impl = this._implementation,\n            func = this._visitInCache[nodeTypeIndex],\n            funcOut = this._visitOutCache[nodeTypeIndex],\n            visitArgs = _visitArgs,\n            fnName;\n\n        visitArgs.visitDeeper = true;\n\n        if (!func) {\n            fnName = 'visit' + node.type;\n            func = impl[fnName] || _noop;\n            funcOut = impl[fnName + 'Out'] || _noop;\n            this._visitInCache[nodeTypeIndex] = func;\n            this._visitOutCache[nodeTypeIndex] = funcOut;\n        }\n\n        if (func !== _noop) {\n            var newNode = func.call(impl, node, visitArgs);\n            if (node && impl.isReplacing) {\n                node = newNode;\n            }\n        }\n\n        if (visitArgs.visitDeeper && node && node.accept) {\n            node.accept(this);\n        }\n\n        if (funcOut != _noop) {\n            funcOut.call(impl, node);\n        }\n\n        return node;\n    },\n    visitArray: function(nodes, nonReplacing) {\n        if (!nodes) {\n            return nodes;\n        }\n\n        var cnt = nodes.length, i;\n\n        // Non-replacing\n        if (nonReplacing || !this._implementation.isReplacing) {\n            for (i = 0; i < cnt; i++) {\n                this.visit(nodes[i]);\n            }\n            return nodes;\n        }\n\n        // Replacing\n        var out = [];\n        for (i = 0; i < cnt; i++) {\n            var evald = this.visit(nodes[i]);\n            if (evald === undefined) { continue; }\n            if (!evald.splice) {\n                out.push(evald);\n            } else if (evald.length) {\n                this.flatten(evald, out);\n            }\n        }\n        return out;\n    },\n    flatten: function(arr, out) {\n        if (!out) {\n            out = [];\n        }\n\n        var cnt, i, item,\n            nestedCnt, j, nestedItem;\n\n        for (i = 0, cnt = arr.length; i < cnt; i++) {\n            item = arr[i];\n            if (item === undefined) {\n                continue;\n            }\n            if (!item.splice) {\n                out.push(item);\n                continue;\n            }\n\n            for (j = 0, nestedCnt = item.length; j < nestedCnt; j++) {\n                nestedItem = item[j];\n                if (nestedItem === undefined) {\n                    continue;\n                }\n                if (!nestedItem.splice) {\n                    out.push(nestedItem);\n                } else if (nestedItem.length) {\n                    this.flatten(nestedItem, out);\n                }\n            }\n        }\n\n        return out;\n    }\n};\nmodule.exports = Visitor;\n\n},{\"../tree\":67}],98:[function(require,module,exports){\n\"use strict\";\n\n// rawAsap provides everything we need except exception management.\nvar rawAsap = require(\"./raw\");\n// RawTasks are recycled to reduce GC churn.\nvar freeTasks = [];\n// We queue errors to ensure they are thrown in right order (FIFO).\n// Array-as-queue is good enough here, since we are just dealing with exceptions.\nvar pendingErrors = [];\nvar requestErrorThrow = rawAsap.makeRequestCallFromTimer(throwFirstError);\n\nfunction throwFirstError() {\n    if (pendingErrors.length) {\n        throw pendingErrors.shift();\n    }\n}\n\n/**\n * Calls a task as soon as possible after returning, in its own event, with priority\n * over other events like animation, reflow, and repaint. An error thrown from an\n * event will not interrupt, nor even substantially slow down the processing of\n * other events, but will be rather postponed to a lower priority event.\n * @param {{call}} task A callable object, typically a function that takes no\n * arguments.\n */\nmodule.exports = asap;\nfunction asap(task) {\n    var rawTask;\n    if (freeTasks.length) {\n        rawTask = freeTasks.pop();\n    } else {\n        rawTask = new RawTask();\n    }\n    rawTask.task = task;\n    rawAsap(rawTask);\n}\n\n// We wrap tasks with recyclable task objects.  A task object implements\n// `call`, just like a function.\nfunction RawTask() {\n    this.task = null;\n}\n\n// The sole purpose of wrapping the task is to catch the exception and recycle\n// the task object after its single use.\nRawTask.prototype.call = function () {\n    try {\n        this.task.call();\n    } catch (error) {\n        if (asap.onerror) {\n            // This hook exists purely for testing purposes.\n            // Its name will be periodically randomized to break any code that\n            // depends on its existence.\n            asap.onerror(error);\n        } else {\n            // In a web browser, exceptions are not fatal. However, to avoid\n            // slowing down the queue of pending tasks, we rethrow the error in a\n            // lower priority turn.\n            pendingErrors.push(error);\n            requestErrorThrow();\n        }\n    } finally {\n        this.task = null;\n        freeTasks[freeTasks.length] = this;\n    }\n};\n\n},{\"./raw\":99}],99:[function(require,module,exports){\n(function (global){\n\"use strict\";\n\n// Use the fastest means possible to execute a task in its own turn, with\n// priority over other events including IO, animation, reflow, and redraw\n// events in browsers.\n//\n// An exception thrown by a task will permanently interrupt the processing of\n// subsequent tasks. The higher level `asap` function ensures that if an\n// exception is thrown by a task, that the task queue will continue flushing as\n// soon as possible, but if you use `rawAsap` directly, you are responsible to\n// either ensure that no exceptions are thrown from your task, or to manually\n// call `rawAsap.requestFlush` if an exception is thrown.\nmodule.exports = rawAsap;\nfunction rawAsap(task) {\n    if (!queue.length) {\n        requestFlush();\n        flushing = true;\n    }\n    // Equivalent to push, but avoids a function call.\n    queue[queue.length] = task;\n}\n\nvar queue = [];\n// Once a flush has been requested, no further calls to `requestFlush` are\n// necessary until the next `flush` completes.\nvar flushing = false;\n// `requestFlush` is an implementation-specific method that attempts to kick\n// off a `flush` event as quickly as possible. `flush` will attempt to exhaust\n// the event queue before yielding to the browser's own event loop.\nvar requestFlush;\n// The position of the next task to execute in the task queue. This is\n// preserved between calls to `flush` so that it can be resumed if\n// a task throws an exception.\nvar index = 0;\n// If a task schedules additional tasks recursively, the task queue can grow\n// unbounded. To prevent memory exhaustion, the task queue will periodically\n// truncate already-completed tasks.\nvar capacity = 1024;\n\n// The flush function processes all tasks that have been scheduled with\n// `rawAsap` unless and until one of those tasks throws an exception.\n// If a task throws an exception, `flush` ensures that its state will remain\n// consistent and will resume where it left off when called again.\n// However, `flush` does not make any arrangements to be called again if an\n// exception is thrown.\nfunction flush() {\n    while (index < queue.length) {\n        var currentIndex = index;\n        // Advance the index before calling the task. This ensures that we will\n        // begin flushing on the next task the task throws an error.\n        index = index + 1;\n        queue[currentIndex].call();\n        // Prevent leaking memory for long chains of recursive calls to `asap`.\n        // If we call `asap` within tasks scheduled by `asap`, the queue will\n        // grow, but to avoid an O(n) walk for every task we execute, we don't\n        // shift tasks off the queue after they have been executed.\n        // Instead, we periodically shift 1024 tasks off the queue.\n        if (index > capacity) {\n            // Manually shift all values starting at the index back to the\n            // beginning of the queue.\n            for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {\n                queue[scan] = queue[scan + index];\n            }\n            queue.length -= index;\n            index = 0;\n        }\n    }\n    queue.length = 0;\n    index = 0;\n    flushing = false;\n}\n\n// `requestFlush` is implemented using a strategy based on data collected from\n// every available SauceLabs Selenium web driver worker at time of writing.\n// https://docs.google.com/spreadsheets/d/1mG-5UYGup5qxGdEMWkhP6BWCz053NUb2E1QoUTU16uA/edit#gid=783724593\n\n// Safari 6 and 6.1 for desktop, iPad, and iPhone are the only browsers that\n// have WebKitMutationObserver but not un-prefixed MutationObserver.\n// Must use `global` or `self` instead of `window` to work in both frames and web\n// workers. `global` is a provision of Browserify, Mr, Mrs, or Mop.\n\n/* globals self */\nvar scope = typeof global !== \"undefined\" ? global : self;\nvar BrowserMutationObserver = scope.MutationObserver || scope.WebKitMutationObserver;\n\n// MutationObservers are desirable because they have high priority and work\n// reliably everywhere they are implemented.\n// They are implemented in all modern browsers.\n//\n// - Android 4-4.3\n// - Chrome 26-34\n// - Firefox 14-29\n// - Internet Explorer 11\n// - iPad Safari 6-7.1\n// - iPhone Safari 7-7.1\n// - Safari 6-7\nif (typeof BrowserMutationObserver === \"function\") {\n    requestFlush = makeRequestCallFromMutationObserver(flush);\n\n// MessageChannels are desirable because they give direct access to the HTML\n// task queue, are implemented in Internet Explorer 10, Safari 5.0-1, and Opera\n// 11-12, and in web workers in many engines.\n// Although message channels yield to any queued rendering and IO tasks, they\n// would be better than imposing the 4ms delay of timers.\n// However, they do not work reliably in Internet Explorer or Safari.\n\n// Internet Explorer 10 is the only browser that has setImmediate but does\n// not have MutationObservers.\n// Although setImmediate yields to the browser's renderer, it would be\n// preferrable to falling back to setTimeout since it does not have\n// the minimum 4ms penalty.\n// Unfortunately there appears to be a bug in Internet Explorer 10 Mobile (and\n// Desktop to a lesser extent) that renders both setImmediate and\n// MessageChannel useless for the purposes of ASAP.\n// https://github.com/kriskowal/q/issues/396\n\n// Timers are implemented universally.\n// We fall back to timers in workers in most engines, and in foreground\n// contexts in the following browsers.\n// However, note that even this simple case requires nuances to operate in a\n// broad spectrum of browsers.\n//\n// - Firefox 3-13\n// - Internet Explorer 6-9\n// - iPad Safari 4.3\n// - Lynx 2.8.7\n} else {\n    requestFlush = makeRequestCallFromTimer(flush);\n}\n\n// `requestFlush` requests that the high priority event queue be flushed as\n// soon as possible.\n// This is useful to prevent an error thrown in a task from stalling the event\n// queue if the exception handled by Node.jss\n// `process.on(\"uncaughtException\")` or by a domain.\nrawAsap.requestFlush = requestFlush;\n\n// To request a high priority event, we induce a mutation observer by toggling\n// the text of a text node between \"1\" and \"-1\".\nfunction makeRequestCallFromMutationObserver(callback) {\n    var toggle = 1;\n    var observer = new BrowserMutationObserver(callback);\n    var node = document.createTextNode(\"\");\n    observer.observe(node, {characterData: true});\n    return function requestCall() {\n        toggle = -toggle;\n        node.data = toggle;\n    };\n}\n\n// The message channel technique was discovered by Malte Ubl and was the\n// original foundation for this library.\n// http://www.nonblocking.io/2011/06/windownexttick.html\n\n// Safari 6.0.5 (at least) intermittently fails to create message ports on a\n// page's first load. Thankfully, this version of Safari supports\n// MutationObservers, so we don't need to fall back in that case.\n\n// function makeRequestCallFromMessageChannel(callback) {\n//     var channel = new MessageChannel();\n//     channel.port1.onmessage = callback;\n//     return function requestCall() {\n//         channel.port2.postMessage(0);\n//     };\n// }\n\n// For reasons explained above, we are also unable to use `setImmediate`\n// under any circumstances.\n// Even if we were, there is another bug in Internet Explorer 10.\n// It is not sufficient to assign `setImmediate` to `requestFlush` because\n// `setImmediate` must be called *by name* and therefore must be wrapped in a\n// closure.\n// Never forget.\n\n// function makeRequestCallFromSetImmediate(callback) {\n//     return function requestCall() {\n//         setImmediate(callback);\n//     };\n// }\n\n// Safari 6.0 has a problem where timers will get lost while the user is\n// scrolling. This problem does not impact ASAP because Safari 6.0 supports\n// mutation observers, so that implementation is used instead.\n// However, if we ever elect to use timers in Safari, the prevalent work-around\n// is to add a scroll event listener that calls for a flush.\n\n// `setTimeout` does not call the passed callback if the delay is less than\n// approximately 7 in web workers in Firefox 8 through 18, and sometimes not\n// even then.\n\nfunction makeRequestCallFromTimer(callback) {\n    return function requestCall() {\n        // We dispatch a timeout with a specified delay of 0 for engines that\n        // can reliably accommodate that request. This will usually be snapped\n        // to a 4 milisecond delay, but once we're flushing, there's no delay\n        // between events.\n        var timeoutHandle = setTimeout(handleTimer, 0);\n        // However, since this timer gets frequently dropped in Firefox\n        // workers, we enlist an interval handle that will try to fire\n        // an event 20 times per second until it succeeds.\n        var intervalHandle = setInterval(handleTimer, 50);\n\n        function handleTimer() {\n            // Whichever timer succeeds will cancel both timers and\n            // execute the callback.\n            clearTimeout(timeoutHandle);\n            clearInterval(intervalHandle);\n            callback();\n        }\n    };\n}\n\n// This is for `asap.js` only.\n// Its name will be periodically randomized to break any code that depends on\n// its existence.\nrawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer;\n\n// ASAP was originally a nextTick shim included in Q. This was factored out\n// into this ASAP package. It was later adapted to RSVP which made further\n// amendments. These decisions, particularly to marginalize MessageChannel and\n// to capture the MutationObserver implementation in a closure, were integrated\n// back into ASAP proper.\n// https://github.com/tildeio/rsvp.js/blob/cddf7232546a9cf858524b75cde6f9edf72620a7/lib/rsvp/asap.js\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],100:[function(require,module,exports){\nvar clone = (function() {\n'use strict';\n\nfunction _instanceof(obj, type) {\n  return type != null && obj instanceof type;\n}\n\nvar nativeMap;\ntry {\n  nativeMap = Map;\n} catch(_) {\n  // maybe a reference error because no `Map`. Give it a dummy value that no\n  // value will ever be an instanceof.\n  nativeMap = function() {};\n}\n\nvar nativeSet;\ntry {\n  nativeSet = Set;\n} catch(_) {\n  nativeSet = function() {};\n}\n\nvar nativePromise;\ntry {\n  nativePromise = Promise;\n} catch(_) {\n  nativePromise = function() {};\n}\n\n/**\n * Clones (copies) an Object using deep copying.\n *\n * This function supports circular references by default, but if you are certain\n * there are no circular references in your object, you can save some CPU time\n * by calling clone(obj, false).\n *\n * Caution: if `circular` is false and `parent` contains circular references,\n * your program may enter an infinite loop and crash.\n *\n * @param `parent` - the object to be cloned\n * @param `circular` - set to true if the object to be cloned may contain\n *    circular references. (optional - true by default)\n * @param `depth` - set to a number if the object is only to be cloned to\n *    a particular depth. (optional - defaults to Infinity)\n * @param `prototype` - sets the prototype to be used when cloning an object.\n *    (optional - defaults to parent prototype).\n * @param `includeNonEnumerable` - set to true if the non-enumerable properties\n *    should be cloned as well. Non-enumerable properties on the prototype\n *    chain will be ignored. (optional - false by default)\n*/\nfunction clone(parent, circular, depth, prototype, includeNonEnumerable) {\n  if (typeof circular === 'object') {\n    depth = circular.depth;\n    prototype = circular.prototype;\n    includeNonEnumerable = circular.includeNonEnumerable;\n    circular = circular.circular;\n  }\n  // maintain two arrays for circular references, where corresponding parents\n  // and children have the same index\n  var allParents = [];\n  var allChildren = [];\n\n  var useBuffer = typeof Buffer != 'undefined';\n\n  if (typeof circular == 'undefined')\n    circular = true;\n\n  if (typeof depth == 'undefined')\n    depth = Infinity;\n\n  // recurse this function so we don't reset allParents and allChildren\n  function _clone(parent, depth) {\n    // cloning null always returns null\n    if (parent === null)\n      return null;\n\n    if (depth === 0)\n      return parent;\n\n    var child;\n    var proto;\n    if (typeof parent != 'object') {\n      return parent;\n    }\n\n    if (_instanceof(parent, nativeMap)) {\n      child = new nativeMap();\n    } else if (_instanceof(parent, nativeSet)) {\n      child = new nativeSet();\n    } else if (_instanceof(parent, nativePromise)) {\n      child = new nativePromise(function (resolve, reject) {\n        parent.then(function(value) {\n          resolve(_clone(value, depth - 1));\n        }, function(err) {\n          reject(_clone(err, depth - 1));\n        });\n      });\n    } else if (clone.__isArray(parent)) {\n      child = [];\n    } else if (clone.__isRegExp(parent)) {\n      child = new RegExp(parent.source, __getRegExpFlags(parent));\n      if (parent.lastIndex) child.lastIndex = parent.lastIndex;\n    } else if (clone.__isDate(parent)) {\n      child = new Date(parent.getTime());\n    } else if (useBuffer && Buffer.isBuffer(parent)) {\n      if (Buffer.allocUnsafe) {\n        // Node.js >= 4.5.0\n        child = Buffer.allocUnsafe(parent.length);\n      } else {\n        // Older Node.js versions\n        child = new Buffer(parent.length);\n      }\n      parent.copy(child);\n      return child;\n    } else if (_instanceof(parent, Error)) {\n      child = Object.create(parent);\n    } else {\n      if (typeof prototype == 'undefined') {\n        proto = Object.getPrototypeOf(parent);\n        child = Object.create(proto);\n      }\n      else {\n        child = Object.create(prototype);\n        proto = prototype;\n      }\n    }\n\n    if (circular) {\n      var index = allParents.indexOf(parent);\n\n      if (index != -1) {\n        return allChildren[index];\n      }\n      allParents.push(parent);\n      allChildren.push(child);\n    }\n\n    if (_instanceof(parent, nativeMap)) {\n      parent.forEach(function(value, key) {\n        var keyChild = _clone(key, depth - 1);\n        var valueChild = _clone(value, depth - 1);\n        child.set(keyChild, valueChild);\n      });\n    }\n    if (_instanceof(parent, nativeSet)) {\n      parent.forEach(function(value) {\n        var entryChild = _clone(value, depth - 1);\n        child.add(entryChild);\n      });\n    }\n\n    for (var i in parent) {\n      var attrs;\n      if (proto) {\n        attrs = Object.getOwnPropertyDescriptor(proto, i);\n      }\n\n      if (attrs && attrs.set == null) {\n        continue;\n      }\n      child[i] = _clone(parent[i], depth - 1);\n    }\n\n    if (Object.getOwnPropertySymbols) {\n      var symbols = Object.getOwnPropertySymbols(parent);\n      for (var i = 0; i < symbols.length; i++) {\n        // Don't need to worry about cloning a symbol because it is a primitive,\n        // like a number or string.\n        var symbol = symbols[i];\n        var descriptor = Object.getOwnPropertyDescriptor(parent, symbol);\n        if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {\n          continue;\n        }\n        child[symbol] = _clone(parent[symbol], depth - 1);\n        if (!descriptor.enumerable) {\n          Object.defineProperty(child, symbol, {\n            enumerable: false\n          });\n        }\n      }\n    }\n\n    if (includeNonEnumerable) {\n      var allPropertyNames = Object.getOwnPropertyNames(parent);\n      for (var i = 0; i < allPropertyNames.length; i++) {\n        var propertyName = allPropertyNames[i];\n        var descriptor = Object.getOwnPropertyDescriptor(parent, propertyName);\n        if (descriptor && descriptor.enumerable) {\n          continue;\n        }\n        child[propertyName] = _clone(parent[propertyName], depth - 1);\n        Object.defineProperty(child, propertyName, {\n          enumerable: false\n        });\n      }\n    }\n\n    return child;\n  }\n\n  return _clone(parent, depth);\n}\n\n/**\n * Simple flat clone using prototype, accepts only objects, usefull for property\n * override on FLAT configuration object (no nested props).\n *\n * USE WITH CAUTION! This may not behave as you wish if you do not know how this\n * works.\n */\nclone.clonePrototype = function clonePrototype(parent) {\n  if (parent === null)\n    return null;\n\n  var c = function () {};\n  c.prototype = parent;\n  return new c();\n};\n\n// private utility functions\n\nfunction __objToStr(o) {\n  return Object.prototype.toString.call(o);\n}\nclone.__objToStr = __objToStr;\n\nfunction __isDate(o) {\n  return typeof o === 'object' && __objToStr(o) === '[object Date]';\n}\nclone.__isDate = __isDate;\n\nfunction __isArray(o) {\n  return typeof o === 'object' && __objToStr(o) === '[object Array]';\n}\nclone.__isArray = __isArray;\n\nfunction __isRegExp(o) {\n  return typeof o === 'object' && __objToStr(o) === '[object RegExp]';\n}\nclone.__isRegExp = __isRegExp;\n\nfunction __getRegExpFlags(re) {\n  var flags = '';\n  if (re.global) flags += 'g';\n  if (re.ignoreCase) flags += 'i';\n  if (re.multiline) flags += 'm';\n  return flags;\n}\nclone.__getRegExpFlags = __getRegExpFlags;\n\nreturn clone;\n})();\n\nif (typeof module === 'object' && module.exports) {\n  module.exports = clone;\n}\n\n},{}],101:[function(require,module,exports){\n'use strict';\n\nvar asap = require('asap/raw');\n\nfunction noop() {}\n\n// States:\n//\n// 0 - pending\n// 1 - fulfilled with _value\n// 2 - rejected with _value\n// 3 - adopted the state of another promise, _value\n//\n// once the state is no longer pending (0) it is immutable\n\n// All `_` prefixed properties will be reduced to `_{random number}`\n// at build time to obfuscate them and discourage their use.\n// We don't use symbols or Object.defineProperty to fully hide them\n// because the performance isn't good enough.\n\n\n// to avoid using try/catch inside critical functions, we\n// extract them to here.\nvar LAST_ERROR = null;\nvar IS_ERROR = {};\nfunction getThen(obj) {\n  try {\n    return obj.then;\n  } catch (ex) {\n    LAST_ERROR = ex;\n    return IS_ERROR;\n  }\n}\n\nfunction tryCallOne(fn, a) {\n  try {\n    return fn(a);\n  } catch (ex) {\n    LAST_ERROR = ex;\n    return IS_ERROR;\n  }\n}\nfunction tryCallTwo(fn, a, b) {\n  try {\n    fn(a, b);\n  } catch (ex) {\n    LAST_ERROR = ex;\n    return IS_ERROR;\n  }\n}\n\nmodule.exports = Promise;\n\nfunction Promise(fn) {\n  if (typeof this !== 'object') {\n    throw new TypeError('Promises must be constructed via new');\n  }\n  if (typeof fn !== 'function') {\n    throw new TypeError('Promise constructor\\'s argument is not a function');\n  }\n  this._40 = 0;\n  this._65 = 0;\n  this._55 = null;\n  this._72 = null;\n  if (fn === noop) return;\n  doResolve(fn, this);\n}\nPromise._37 = null;\nPromise._87 = null;\nPromise._61 = noop;\n\nPromise.prototype.then = function(onFulfilled, onRejected) {\n  if (this.constructor !== Promise) {\n    return safeThen(this, onFulfilled, onRejected);\n  }\n  var res = new Promise(noop);\n  handle(this, new Handler(onFulfilled, onRejected, res));\n  return res;\n};\n\nfunction safeThen(self, onFulfilled, onRejected) {\n  return new self.constructor(function (resolve, reject) {\n    var res = new Promise(noop);\n    res.then(resolve, reject);\n    handle(self, new Handler(onFulfilled, onRejected, res));\n  });\n}\nfunction handle(self, deferred) {\n  while (self._65 === 3) {\n    self = self._55;\n  }\n  if (Promise._37) {\n    Promise._37(self);\n  }\n  if (self._65 === 0) {\n    if (self._40 === 0) {\n      self._40 = 1;\n      self._72 = deferred;\n      return;\n    }\n    if (self._40 === 1) {\n      self._40 = 2;\n      self._72 = [self._72, deferred];\n      return;\n    }\n    self._72.push(deferred);\n    return;\n  }\n  handleResolved(self, deferred);\n}\n\nfunction handleResolved(self, deferred) {\n  asap(function() {\n    var cb = self._65 === 1 ? deferred.onFulfilled : deferred.onRejected;\n    if (cb === null) {\n      if (self._65 === 1) {\n        resolve(deferred.promise, self._55);\n      } else {\n        reject(deferred.promise, self._55);\n      }\n      return;\n    }\n    var ret = tryCallOne(cb, self._55);\n    if (ret === IS_ERROR) {\n      reject(deferred.promise, LAST_ERROR);\n    } else {\n      resolve(deferred.promise, ret);\n    }\n  });\n}\nfunction resolve(self, newValue) {\n  // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure\n  if (newValue === self) {\n    return reject(\n      self,\n      new TypeError('A promise cannot be resolved with itself.')\n    );\n  }\n  if (\n    newValue &&\n    (typeof newValue === 'object' || typeof newValue === 'function')\n  ) {\n    var then = getThen(newValue);\n    if (then === IS_ERROR) {\n      return reject(self, LAST_ERROR);\n    }\n    if (\n      then === self.then &&\n      newValue instanceof Promise\n    ) {\n      self._65 = 3;\n      self._55 = newValue;\n      finale(self);\n      return;\n    } else if (typeof then === 'function') {\n      doResolve(then.bind(newValue), self);\n      return;\n    }\n  }\n  self._65 = 1;\n  self._55 = newValue;\n  finale(self);\n}\n\nfunction reject(self, newValue) {\n  self._65 = 2;\n  self._55 = newValue;\n  if (Promise._87) {\n    Promise._87(self, newValue);\n  }\n  finale(self);\n}\nfunction finale(self) {\n  if (self._40 === 1) {\n    handle(self, self._72);\n    self._72 = null;\n  }\n  if (self._40 === 2) {\n    for (var i = 0; i < self._72.length; i++) {\n      handle(self, self._72[i]);\n    }\n    self._72 = null;\n  }\n}\n\nfunction Handler(onFulfilled, onRejected, promise){\n  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n  this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n  this.promise = promise;\n}\n\n/**\n * Take a potentially misbehaving resolver function and make sure\n * onFulfilled and onRejected are only called once.\n *\n * Makes no guarantees about asynchrony.\n */\nfunction doResolve(fn, promise) {\n  var done = false;\n  var res = tryCallTwo(fn, function (value) {\n    if (done) return;\n    done = true;\n    resolve(promise, value);\n  }, function (reason) {\n    if (done) return;\n    done = true;\n    reject(promise, reason);\n  });\n  if (!done && res === IS_ERROR) {\n    done = true;\n    reject(promise, LAST_ERROR);\n  }\n}\n\n},{\"asap/raw\":99}],102:[function(require,module,exports){\n'use strict';\n\n//This file contains the ES6 extensions to the core Promises/A+ API\n\nvar Promise = require('./core.js');\n\nmodule.exports = Promise;\n\n/* Static Functions */\n\nvar TRUE = valuePromise(true);\nvar FALSE = valuePromise(false);\nvar NULL = valuePromise(null);\nvar UNDEFINED = valuePromise(undefined);\nvar ZERO = valuePromise(0);\nvar EMPTYSTRING = valuePromise('');\n\nfunction valuePromise(value) {\n  var p = new Promise(Promise._61);\n  p._65 = 1;\n  p._55 = value;\n  return p;\n}\nPromise.resolve = function (value) {\n  if (value instanceof Promise) return value;\n\n  if (value === null) return NULL;\n  if (value === undefined) return UNDEFINED;\n  if (value === true) return TRUE;\n  if (value === false) return FALSE;\n  if (value === 0) return ZERO;\n  if (value === '') return EMPTYSTRING;\n\n  if (typeof value === 'object' || typeof value === 'function') {\n    try {\n      var then = value.then;\n      if (typeof then === 'function') {\n        return new Promise(then.bind(value));\n      }\n    } catch (ex) {\n      return new Promise(function (resolve, reject) {\n        reject(ex);\n      });\n    }\n  }\n  return valuePromise(value);\n};\n\nPromise.all = function (arr) {\n  var args = Array.prototype.slice.call(arr);\n\n  return new Promise(function (resolve, reject) {\n    if (args.length === 0) return resolve([]);\n    var remaining = args.length;\n    function res(i, val) {\n      if (val && (typeof val === 'object' || typeof val === 'function')) {\n        if (val instanceof Promise && val.then === Promise.prototype.then) {\n          while (val._65 === 3) {\n            val = val._55;\n          }\n          if (val._65 === 1) return res(i, val._55);\n          if (val._65 === 2) reject(val._55);\n          val.then(function (val) {\n            res(i, val);\n          }, reject);\n          return;\n        } else {\n          var then = val.then;\n          if (typeof then === 'function') {\n            var p = new Promise(then.bind(val));\n            p.then(function (val) {\n              res(i, val);\n            }, reject);\n            return;\n          }\n        }\n      }\n      args[i] = val;\n      if (--remaining === 0) {\n        resolve(args);\n      }\n    }\n    for (var i = 0; i < args.length; i++) {\n      res(i, args[i]);\n    }\n  });\n};\n\nPromise.reject = function (value) {\n  return new Promise(function (resolve, reject) {\n    reject(value);\n  });\n};\n\nPromise.race = function (values) {\n  return new Promise(function (resolve, reject) {\n    values.forEach(function(value){\n      Promise.resolve(value).then(resolve, reject);\n    });\n  });\n};\n\n/* Prototype Methods */\n\nPromise.prototype['catch'] = function (onRejected) {\n  return this.then(null, onRejected);\n};\n\n},{\"./core.js\":101}],103:[function(require,module,exports){\n// should work in any browser without browserify\n\nif (typeof Promise.prototype.done !== 'function') {\n  Promise.prototype.done = function (onFulfilled, onRejected) {\n    var self = arguments.length ? this.then.apply(this, arguments) : this\n    self.then(null, function (err) {\n      setTimeout(function () {\n        throw err\n      }, 0)\n    })\n  }\n}\n},{}],104:[function(require,module,exports){\n// not \"use strict\" so we can declare global \"Promise\"\n\nvar asap = require('asap');\n\nif (typeof Promise === 'undefined') {\n  Promise = require('./lib/core.js')\n  require('./lib/es6-extensions.js')\n}\n\nrequire('./polyfill-done.js');\n\n},{\"./lib/core.js\":101,\"./lib/es6-extensions.js\":102,\"./polyfill-done.js\":103,\"asap\":98}]},{},[2])(2)\n});\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./../../webpack/buildin/global.js */ 1), __webpack_require__(/*! ./../../buffer/index.js */ 6).Buffer))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbGVzcy9kaXN0L2xlc3MuanM/OWViMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIExlc3MgLSBMZWFuZXIgQ1NTIHYzLjkuMFxuICogaHR0cDovL2xlc3Njc3Mub3JnXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDA5LTIwMTgsIEFsZXhpcyBTZWxsaWVyIDxzZWxmQGNsb3VkaGVhZC5uZXQ+XG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlLTIuMCBMaWNlbnNlLlxuICpcbiAqL1xuXG4gLyoqICogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuICovXG5cbihmdW5jdGlvbihmKXtpZih0eXBlb2YgZXhwb3J0cz09PVwib2JqZWN0XCImJnR5cGVvZiBtb2R1bGUhPT1cInVuZGVmaW5lZFwiKXttb2R1bGUuZXhwb3J0cz1mKCl9ZWxzZSBpZih0eXBlb2YgZGVmaW5lPT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kKXtkZWZpbmUoW10sZil9ZWxzZXt2YXIgZztpZih0eXBlb2Ygd2luZG93IT09XCJ1bmRlZmluZWRcIil7Zz13aW5kb3d9ZWxzZSBpZih0eXBlb2YgZ2xvYmFsIT09XCJ1bmRlZmluZWRcIil7Zz1nbG9iYWx9ZWxzZSBpZih0eXBlb2Ygc2VsZiE9PVwidW5kZWZpbmVkXCIpe2c9c2VsZn1lbHNle2c9dGhpc31nLmxlc3MgPSBmKCl9fSkoZnVuY3Rpb24oKXt2YXIgZGVmaW5lLG1vZHVsZSxleHBvcnRzO3JldHVybiAoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSh7MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgYWRkRGF0YUF0dHIgPSByZXF1aXJlKCcuL3V0aWxzJykuYWRkRGF0YUF0dHIsXG4gICAgYnJvd3NlciA9IHJlcXVpcmUoJy4vYnJvd3NlcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHdpbmRvdywgb3B0aW9ucykge1xuXG4gICAgLy8gdXNlIG9wdGlvbnMgZnJvbSB0aGUgY3VycmVudCBzY3JpcHQgdGFnIGRhdGEgYXR0cmlidWVzXG4gICAgYWRkRGF0YUF0dHIob3B0aW9ucywgYnJvd3Nlci5jdXJyZW50U2NyaXB0KHdpbmRvdykpO1xuXG4gICAgaWYgKG9wdGlvbnMuaXNGaWxlUHJvdG9jb2wgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvcHRpb25zLmlzRmlsZVByb3RvY29sID0gL14oZmlsZXwoY2hyb21lfHNhZmFyaSkoLWV4dGVuc2lvbik/fHJlc291cmNlfHFyY3xhcHApOi8udGVzdCh3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wpO1xuICAgIH1cblxuICAgIC8vIExvYWQgc3R5bGVzIGFzeW5jaHJvbm91c2x5IChkZWZhdWx0OiBmYWxzZSlcbiAgICAvL1xuICAgIC8vIFRoaXMgaXMgc2V0IHRvIGBmYWxzZWAgYnkgZGVmYXVsdCwgc28gdGhhdCB0aGUgYm9keVxuICAgIC8vIGRvZXNuJ3Qgc3RhcnQgbG9hZGluZyBiZWZvcmUgdGhlIHN0eWxlc2hlZXRzIGFyZSBwYXJzZWQuXG4gICAgLy8gU2V0dGluZyB0aGlzIHRvIGB0cnVlYCBjYW4gcmVzdWx0IGluIGZsaWNrZXJpbmcuXG4gICAgLy9cbiAgICBvcHRpb25zLmFzeW5jID0gb3B0aW9ucy5hc3luYyB8fCBmYWxzZTtcbiAgICBvcHRpb25zLmZpbGVBc3luYyA9IG9wdGlvbnMuZmlsZUFzeW5jIHx8IGZhbHNlO1xuXG4gICAgLy8gSW50ZXJ2YWwgYmV0d2VlbiB3YXRjaCBwb2xsc1xuICAgIG9wdGlvbnMucG9sbCA9IG9wdGlvbnMucG9sbCB8fCAob3B0aW9ucy5pc0ZpbGVQcm90b2NvbCA/IDEwMDAgOiAxNTAwKTtcblxuICAgIG9wdGlvbnMuZW52ID0gb3B0aW9ucy5lbnYgfHwgKHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZSA9PSAnMTI3LjAuMC4xJyB8fFxuICAgICAgICB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUgPT0gJzAuMC4wLjAnICAgfHxcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lID09ICdsb2NhbGhvc3QnIHx8XG4gICAgICAgICh3aW5kb3cubG9jYXRpb24ucG9ydCAmJlxuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLnBvcnQubGVuZ3RoID4gMCkgICAgICB8fFxuICAgICAgICBvcHRpb25zLmlzRmlsZVByb3RvY29sICAgICAgICAgICAgICAgICAgID8gJ2RldmVsb3BtZW50J1xuICAgICAgICA6ICdwcm9kdWN0aW9uJyk7XG5cbiAgICB2YXIgZHVtcExpbmVOdW1iZXJzID0gLyFkdW1wTGluZU51bWJlcnM6KGNvbW1lbnRzfG1lZGlhcXVlcnl8YWxsKS8uZXhlYyh3aW5kb3cubG9jYXRpb24uaGFzaCk7XG4gICAgaWYgKGR1bXBMaW5lTnVtYmVycykge1xuICAgICAgICBvcHRpb25zLmR1bXBMaW5lTnVtYmVycyA9IGR1bXBMaW5lTnVtYmVyc1sxXTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy51c2VGaWxlQ2FjaGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvcHRpb25zLnVzZUZpbGVDYWNoZSA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMub25SZWFkeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9wdGlvbnMub25SZWFkeSA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMucmVsYXRpdmVVcmxzKSB7XG4gICAgICAgIG9wdGlvbnMucmV3cml0ZVVybHMgPSAnYWxsJztcbiAgICB9XG59O1xuXG59LHtcIi4vYnJvd3NlclwiOjMsXCIuL3V0aWxzXCI6MTF9XSwyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogS2lja3Mgb2ZmIGxlc3MgYW5kIGNvbXBpbGVzIGFueSBzdHlsZXNoZWV0c1xuICogdXNlZCBpbiB0aGUgYnJvd3NlciBkaXN0cmlidXRlZCB2ZXJzaW9uIG9mIGxlc3NcbiAqIHRvIGtpY2stc3RhcnQgbGVzcyB1c2luZyB0aGUgYnJvd3NlciBhcGlcbiAqL1xuLyogZ2xvYmFsIHdpbmRvdywgZG9jdW1lbnQgKi9cblxuLy8gVE9ETyAtIGNvbnNpZGVyIHN3aXRjaGluZyB0aGlzIG91dCBmb3IgYSByZWNvbW1lbmRhdGlvbiBmb3IgdGhpcyBwb2x5ZmlsbD9cbi8vIDxzY3JpcHQgc3JjPVwiaHR0cHM6Ly9jZG4ucG9seWZpbGwuaW8vdjIvcG9seWZpbGwubWluLmpzXCI+PC9zY3JpcHQ+XG4vLyBCcm93c2VycyBoYXZlIGdvb2QgUHJvbWlzZSBzdXBwb3J0XG5yZXF1aXJlKCdwcm9taXNlL3BvbHlmaWxsJyk7XG5cbnZhciBvcHRpb25zID0gcmVxdWlyZSgnLi4vbGVzcy9kZWZhdWx0LW9wdGlvbnMnKSgpO1xuXG5pZiAod2luZG93Lmxlc3MpIHtcbiAgICBmb3IgKGtleSBpbiB3aW5kb3cubGVzcykge1xuICAgICAgICBpZiAod2luZG93Lmxlc3MuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgb3B0aW9uc1trZXldID0gd2luZG93Lmxlc3Nba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbn1cbnJlcXVpcmUoJy4vYWRkLWRlZmF1bHQtb3B0aW9ucycpKHdpbmRvdywgb3B0aW9ucyk7XG5cbm9wdGlvbnMucGx1Z2lucyA9IG9wdGlvbnMucGx1Z2lucyB8fCBbXTtcblxuaWYgKHdpbmRvdy5MRVNTX1BMVUdJTlMpIHtcbiAgICBvcHRpb25zLnBsdWdpbnMgPSBvcHRpb25zLnBsdWdpbnMuY29uY2F0KHdpbmRvdy5MRVNTX1BMVUdJTlMpO1xufVxuXG52YXIgbGVzcyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9pbmRleCcpKHdpbmRvdywgb3B0aW9ucyk7XG5cbndpbmRvdy5sZXNzID0gbGVzcztcblxudmFyIGNzcywgaGVhZCwgc3R5bGU7XG5cbi8vIEFsd2F5cyByZXN0b3JlIHBhZ2UgdmlzaWJpbGl0eVxuZnVuY3Rpb24gcmVzb2x2ZU9yUmVqZWN0KGRhdGEpIHtcbiAgICBpZiAoZGF0YS5maWxlbmFtZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oZGF0YSk7XG4gICAgfVxuICAgIGlmICghb3B0aW9ucy5hc3luYykge1xuICAgICAgICBoZWFkLnJlbW92ZUNoaWxkKHN0eWxlKTtcbiAgICB9XG59XG5cbmlmIChvcHRpb25zLm9uUmVhZHkpIHtcbiAgICBpZiAoLyF3YXRjaC8udGVzdCh3aW5kb3cubG9jYXRpb24uaGFzaCkpIHtcbiAgICAgICAgbGVzcy53YXRjaCgpO1xuICAgIH1cbiAgICAvLyBTaW11bGF0ZSBzeW5jaHJvbm91cyBzdHlsZXNoZWV0IGxvYWRpbmcgYnkgaGlkaW5nIHBhZ2UgcmVuZGVyaW5nXG4gICAgaWYgKCFvcHRpb25zLmFzeW5jKSB7XG4gICAgICAgIGNzcyA9ICdib2R5IHsgZGlzcGxheTogbm9uZSAhaW1wb3J0YW50IH0nO1xuICAgICAgICBoZWFkID0gZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdO1xuICAgICAgICBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG5cbiAgICAgICAgc3R5bGUudHlwZSA9ICd0ZXh0L2Nzcyc7XG4gICAgICAgIGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG4gICAgICAgICAgICBzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICAgIH1cbiAgICBsZXNzLnJlZ2lzdGVyU3R5bGVzaGVldHNJbW1lZGlhdGVseSgpO1xuICAgIGxlc3MucGFnZUxvYWRGaW5pc2hlZCA9IGxlc3MucmVmcmVzaChsZXNzLmVudiA9PT0gJ2RldmVsb3BtZW50JykudGhlbihyZXNvbHZlT3JSZWplY3QsIHJlc29sdmVPclJlamVjdCk7XG59XG5cbn0se1wiLi4vbGVzcy9kZWZhdWx0LW9wdGlvbnNcIjoxNyxcIi4vYWRkLWRlZmF1bHQtb3B0aW9uc1wiOjEsXCIuL2luZGV4XCI6OCxcInByb21pc2UvcG9seWZpbGxcIjoxMDR9XSwzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGNyZWF0ZUNTUzogZnVuY3Rpb24gKGRvY3VtZW50LCBzdHlsZXMsIHNoZWV0KSB7XG4gICAgICAgIC8vIFN0cmlwIHRoZSBxdWVyeS1zdHJpbmdcbiAgICAgICAgdmFyIGhyZWYgPSBzaGVldC5ocmVmIHx8ICcnO1xuXG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIHRpdGxlIHNldCwgdXNlIHRoZSBmaWxlbmFtZSwgbWludXMgdGhlIGV4dGVuc2lvblxuICAgICAgICB2YXIgaWQgPSAnbGVzczonICsgKHNoZWV0LnRpdGxlIHx8IHV0aWxzLmV4dHJhY3RJZChocmVmKSk7XG5cbiAgICAgICAgLy8gSWYgdGhpcyBoYXMgYWxyZWFkeSBiZWVuIGluc2VydGVkIGludG8gdGhlIERPTSwgd2UgbWF5IG5lZWQgdG8gcmVwbGFjZSBpdFxuICAgICAgICB2YXIgb2xkU3R5bGVOb2RlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuICAgICAgICB2YXIga2VlcE9sZFN0eWxlTm9kZSA9IGZhbHNlO1xuXG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBzdHlsZXNoZWV0IG5vZGUgZm9yIGluc2VydGlvbiBvciAoaWYgbmVjZXNzYXJ5KSByZXBsYWNlbWVudFxuICAgICAgICB2YXIgc3R5bGVOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICAgICAgc3R5bGVOb2RlLnNldEF0dHJpYnV0ZSgndHlwZScsICd0ZXh0L2NzcycpO1xuICAgICAgICBpZiAoc2hlZXQubWVkaWEpIHtcbiAgICAgICAgICAgIHN0eWxlTm9kZS5zZXRBdHRyaWJ1dGUoJ21lZGlhJywgc2hlZXQubWVkaWEpO1xuICAgICAgICB9XG4gICAgICAgIHN0eWxlTm9kZS5pZCA9IGlkO1xuXG4gICAgICAgIGlmICghc3R5bGVOb2RlLnN0eWxlU2hlZXQpIHtcbiAgICAgICAgICAgIHN0eWxlTm9kZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShzdHlsZXMpKTtcblxuICAgICAgICAgICAgLy8gSWYgbmV3IGNvbnRlbnRzIG1hdGNoIGNvbnRlbnRzIG9mIG9sZFN0eWxlTm9kZSwgZG9uJ3QgcmVwbGFjZSBvbGRTdHlsZU5vZGVcbiAgICAgICAgICAgIGtlZXBPbGRTdHlsZU5vZGUgPSAob2xkU3R5bGVOb2RlICE9PSBudWxsICYmIG9sZFN0eWxlTm9kZS5jaGlsZE5vZGVzLmxlbmd0aCA+IDAgJiYgc3R5bGVOb2RlLmNoaWxkTm9kZXMubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgICAgIG9sZFN0eWxlTm9kZS5maXJzdENoaWxkLm5vZGVWYWx1ZSA9PT0gc3R5bGVOb2RlLmZpcnN0Q2hpbGQubm9kZVZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBoZWFkID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcblxuICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyBvbGRTdHlsZU5vZGUsIGp1c3QgYXBwZW5kOyBvdGhlcndpc2UsIG9ubHkgYXBwZW5kIGlmIHdlIG5lZWRcbiAgICAgICAgLy8gdG8gcmVwbGFjZSBvbGRTdHlsZU5vZGUgd2l0aCBhbiB1cGRhdGVkIHN0eWxlc2hlZXRcbiAgICAgICAgaWYgKG9sZFN0eWxlTm9kZSA9PT0gbnVsbCB8fCBrZWVwT2xkU3R5bGVOb2RlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdmFyIG5leHRFbCA9IHNoZWV0ICYmIHNoZWV0Lm5leHRTaWJsaW5nIHx8IG51bGw7XG4gICAgICAgICAgICBpZiAobmV4dEVsKSB7XG4gICAgICAgICAgICAgICAgbmV4dEVsLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHN0eWxlTm9kZSwgbmV4dEVsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaGVhZC5hcHBlbmRDaGlsZChzdHlsZU5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvbGRTdHlsZU5vZGUgJiYga2VlcE9sZFN0eWxlTm9kZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIG9sZFN0eWxlTm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG9sZFN0eWxlTm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGb3IgSUUuXG4gICAgICAgIC8vIFRoaXMgbmVlZHMgdG8gaGFwcGVuICphZnRlciogdGhlIHN0eWxlIGVsZW1lbnQgaXMgYWRkZWQgdG8gdGhlIERPTSwgb3RoZXJ3aXNlIElFIDcgYW5kIDggbWF5IGNyYXNoLlxuICAgICAgICAvLyBTZWUgaHR0cDovL3NvY2lhbC5tc2RuLm1pY3Jvc29mdC5jb20vRm9ydW1zL2VuLVVTLzdlMDgxYjY1LTg3OGEtNGMyMi04ZTY4LWMxMGQzOWMyZWQzMi9pbnRlcm5ldC1leHBsb3Jlci1jcmFzaGVzLWFwcGVuZGluZy1zdHlsZS1lbGVtZW50LXRvLWhlYWRcbiAgICAgICAgaWYgKHN0eWxlTm9kZS5zdHlsZVNoZWV0KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHN0eWxlTm9kZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBzdHlsZXM7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZG5cXCd0IHJlYXNzaWduIHN0eWxlU2hlZXQuY3NzVGV4dC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgY3VycmVudFNjcmlwdDogZnVuY3Rpb24od2luZG93KSB7XG4gICAgICAgIHZhciBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudDtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmN1cnJlbnRTY3JpcHQgfHwgKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHNjcmlwdHMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc2NyaXB0Jyk7XG4gICAgICAgICAgICByZXR1cm4gc2NyaXB0c1tzY3JpcHRzLmxlbmd0aCAtIDFdO1xuICAgICAgICB9KSgpO1xuICAgIH1cbn07XG5cbn0se1wiLi91dGlsc1wiOjExfV0sNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vLyBDYWNoZSBzeXN0ZW0gaXMgYSBiaXQgb3V0ZGF0ZWQgYW5kIGNvdWxkIGRvIHdpdGggd29ya1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHdpbmRvdywgb3B0aW9ucywgbG9nZ2VyKSB7XG4gICAgdmFyIGNhY2hlID0gbnVsbDtcbiAgICBpZiAob3B0aW9ucy5lbnYgIT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNhY2hlID0gKHR5cGVvZiB3aW5kb3cubG9jYWxTdG9yYWdlID09PSAndW5kZWZpbmVkJykgPyBudWxsIDogd2luZG93LmxvY2FsU3RvcmFnZTtcbiAgICAgICAgfSBjYXRjaCAoXykge31cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2V0Q1NTOiBmdW5jdGlvbihwYXRoLCBsYXN0TW9kaWZpZWQsIG1vZGlmeVZhcnMsIHN0eWxlcykge1xuICAgICAgICAgICAgaWYgKGNhY2hlKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmluZm8oJ3NhdmluZyAnICsgcGF0aCArICcgdG8gY2FjaGUuJyk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGUuc2V0SXRlbShwYXRoLCBzdHlsZXMpO1xuICAgICAgICAgICAgICAgICAgICBjYWNoZS5zZXRJdGVtKHBhdGggKyAnOnRpbWVzdGFtcCcsIGxhc3RNb2RpZmllZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2RpZnlWYXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZS5zZXRJdGVtKHBhdGggKyAnOnZhcnMnLCBKU09OLnN0cmluZ2lmeShtb2RpZnlWYXJzKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gLSBjb3VsZCBkbyB3aXRoIGFkZGluZyBtb3JlIHJvYnVzdCBlcnJvciBoYW5kbGluZ1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoJ2ZhaWxlZCB0byBzYXZlIFwiJyArIHBhdGggKyAnXCIgdG8gbG9jYWwgc3RvcmFnZSBmb3IgY2FjaGluZy4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGdldENTUzogZnVuY3Rpb24ocGF0aCwgd2ViSW5mbywgbW9kaWZ5VmFycykge1xuICAgICAgICAgICAgdmFyIGNzcyAgICAgICA9IGNhY2hlICYmIGNhY2hlLmdldEl0ZW0ocGF0aCksXG4gICAgICAgICAgICAgICAgdGltZXN0YW1wID0gY2FjaGUgJiYgY2FjaGUuZ2V0SXRlbShwYXRoICsgJzp0aW1lc3RhbXAnKSxcbiAgICAgICAgICAgICAgICB2YXJzICAgICAgPSBjYWNoZSAmJiBjYWNoZS5nZXRJdGVtKHBhdGggKyAnOnZhcnMnKTtcblxuICAgICAgICAgICAgbW9kaWZ5VmFycyA9IG1vZGlmeVZhcnMgfHwge307XG4gICAgICAgICAgICB2YXJzID0gdmFycyB8fCBcInt9XCI7IC8vIGlmIG5vdCBzZXQsIHRyZWF0IGFzIHRoZSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIGFuIGVtcHR5IG9iamVjdFxuXG4gICAgICAgICAgICBpZiAodGltZXN0YW1wICYmIHdlYkluZm8ubGFzdE1vZGlmaWVkICYmXG4gICAgICAgICAgICAgICAgKG5ldyBEYXRlKHdlYkluZm8ubGFzdE1vZGlmaWVkKS52YWx1ZU9mKCkgPT09XG4gICAgICAgICAgICAgICAgICAgIG5ldyBEYXRlKHRpbWVzdGFtcCkudmFsdWVPZigpKSAmJlxuICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KG1vZGlmeVZhcnMpID09PSB2YXJzKSB7XG4gICAgICAgICAgICAgICAgLy8gVXNlIGxvY2FsIGNvcHlcbiAgICAgICAgICAgICAgICByZXR1cm4gY3NzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn07XG5cbn0se31dLDU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpLFxuICAgIGJyb3dzZXIgPSByZXF1aXJlKCcuL2Jyb3dzZXInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih3aW5kb3csIGxlc3MsIG9wdGlvbnMpIHtcblxuICAgIGZ1bmN0aW9uIGVycm9ySFRNTChlLCByb290SHJlZikge1xuICAgICAgICB2YXIgaWQgPSAnbGVzcy1lcnJvci1tZXNzYWdlOicgKyB1dGlscy5leHRyYWN0SWQocm9vdEhyZWYgfHwgJycpO1xuICAgICAgICB2YXIgdGVtcGxhdGUgPSAnPGxpPjxsYWJlbD57bGluZX08L2xhYmVsPjxwcmUgY2xhc3M9XCJ7Y2xhc3N9XCI+e2NvbnRlbnR9PC9wcmU+PC9saT4nO1xuICAgICAgICB2YXIgZWxlbSA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSwgdGltZXIsIGNvbnRlbnQsIGVycm9ycyA9IFtdO1xuICAgICAgICB2YXIgZmlsZW5hbWUgPSBlLmZpbGVuYW1lIHx8IHJvb3RIcmVmO1xuICAgICAgICB2YXIgZmlsZW5hbWVOb1BhdGggPSBmaWxlbmFtZS5tYXRjaCgvKFteXFwvXSsoXFw/LiopPykkLylbMV07XG5cbiAgICAgICAgZWxlbS5pZCAgICAgICAgPSBpZDtcbiAgICAgICAgZWxlbS5jbGFzc05hbWUgPSAnbGVzcy1lcnJvci1tZXNzYWdlJztcblxuICAgICAgICBjb250ZW50ID0gJzxoMz4nICArIChlLnR5cGUgfHwgJ1N5bnRheCcpICsgJ0Vycm9yOiAnICsgKGUubWVzc2FnZSB8fCAnVGhlcmUgaXMgYW4gZXJyb3IgaW4geW91ciAubGVzcyBmaWxlJykgK1xuICAgICAgICAgICAgJzwvaDM+JyArICc8cD5pbiA8YSBocmVmPVwiJyArIGZpbGVuYW1lICAgKyAnXCI+JyArIGZpbGVuYW1lTm9QYXRoICsgJzwvYT4gJztcblxuICAgICAgICB2YXIgZXJyb3JsaW5lID0gZnVuY3Rpb24gKGUsIGksIGNsYXNzbmFtZSkge1xuICAgICAgICAgICAgaWYgKGUuZXh0cmFjdFtpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2godGVtcGxhdGUucmVwbGFjZSgvXFx7bGluZVxcfS8sIChwYXJzZUludChlLmxpbmUsIDEwKSB8fCAwKSArIChpIC0gMSkpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXHtjbGFzc1xcfS8sIGNsYXNzbmFtZSlcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xce2NvbnRlbnRcXH0vLCBlLmV4dHJhY3RbaV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZS5saW5lKSB7XG4gICAgICAgICAgICBlcnJvcmxpbmUoZSwgMCwgJycpO1xuICAgICAgICAgICAgZXJyb3JsaW5lKGUsIDEsICdsaW5lJyk7XG4gICAgICAgICAgICBlcnJvcmxpbmUoZSwgMiwgJycpO1xuICAgICAgICAgICAgY29udGVudCArPSAnb24gbGluZSAnICsgZS5saW5lICsgJywgY29sdW1uICcgKyAoZS5jb2x1bW4gKyAxKSArICc6PC9wPicgK1xuICAgICAgICAgICAgICAgICc8dWw+JyArIGVycm9ycy5qb2luKCcnKSArICc8L3VsPic7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGUuc3RhY2sgJiYgKGUuZXh0cmFjdCB8fCBvcHRpb25zLmxvZ0xldmVsID49IDQpKSB7XG4gICAgICAgICAgICBjb250ZW50ICs9ICc8YnIvPlN0YWNrIFRyYWNlPC9iciAvPicgKyBlLnN0YWNrLnNwbGl0KCdcXG4nKS5zbGljZSgxKS5qb2luKCc8YnIvPicpO1xuICAgICAgICB9XG4gICAgICAgIGVsZW0uaW5uZXJIVE1MID0gY29udGVudDtcblxuICAgICAgICAvLyBDU1MgZm9yIGVycm9yIG1lc3NhZ2VzXG4gICAgICAgIGJyb3dzZXIuY3JlYXRlQ1NTKHdpbmRvdy5kb2N1bWVudCwgW1xuICAgICAgICAgICAgJy5sZXNzLWVycm9yLW1lc3NhZ2UgdWwsIC5sZXNzLWVycm9yLW1lc3NhZ2UgbGkgeycsXG4gICAgICAgICAgICAnbGlzdC1zdHlsZS10eXBlOiBub25lOycsXG4gICAgICAgICAgICAnbWFyZ2luLXJpZ2h0OiAxNXB4OycsXG4gICAgICAgICAgICAncGFkZGluZzogNHB4IDA7JyxcbiAgICAgICAgICAgICdtYXJnaW46IDA7JyxcbiAgICAgICAgICAgICd9JyxcbiAgICAgICAgICAgICcubGVzcy1lcnJvci1tZXNzYWdlIGxhYmVsIHsnLFxuICAgICAgICAgICAgJ2ZvbnQtc2l6ZTogMTJweDsnLFxuICAgICAgICAgICAgJ21hcmdpbi1yaWdodDogMTVweDsnLFxuICAgICAgICAgICAgJ3BhZGRpbmc6IDRweCAwOycsXG4gICAgICAgICAgICAnY29sb3I6ICNjYzc3Nzc7JyxcbiAgICAgICAgICAgICd9JyxcbiAgICAgICAgICAgICcubGVzcy1lcnJvci1tZXNzYWdlIHByZSB7JyxcbiAgICAgICAgICAgICdjb2xvcjogI2RkNjY2NjsnLFxuICAgICAgICAgICAgJ3BhZGRpbmc6IDRweCAwOycsXG4gICAgICAgICAgICAnbWFyZ2luOiAwOycsXG4gICAgICAgICAgICAnZGlzcGxheTogaW5saW5lLWJsb2NrOycsXG4gICAgICAgICAgICAnfScsXG4gICAgICAgICAgICAnLmxlc3MtZXJyb3ItbWVzc2FnZSBwcmUubGluZSB7JyxcbiAgICAgICAgICAgICdjb2xvcjogI2ZmMDAwMDsnLFxuICAgICAgICAgICAgJ30nLFxuICAgICAgICAgICAgJy5sZXNzLWVycm9yLW1lc3NhZ2UgaDMgeycsXG4gICAgICAgICAgICAnZm9udC1zaXplOiAyMHB4OycsXG4gICAgICAgICAgICAnZm9udC13ZWlnaHQ6IGJvbGQ7JyxcbiAgICAgICAgICAgICdwYWRkaW5nOiAxNXB4IDAgNXB4IDA7JyxcbiAgICAgICAgICAgICdtYXJnaW46IDA7JyxcbiAgICAgICAgICAgICd9JyxcbiAgICAgICAgICAgICcubGVzcy1lcnJvci1tZXNzYWdlIGEgeycsXG4gICAgICAgICAgICAnY29sb3I6ICMxMGEnLFxuICAgICAgICAgICAgJ30nLFxuICAgICAgICAgICAgJy5sZXNzLWVycm9yLW1lc3NhZ2UgLmVycm9yIHsnLFxuICAgICAgICAgICAgJ2NvbG9yOiByZWQ7JyxcbiAgICAgICAgICAgICdmb250LXdlaWdodDogYm9sZDsnLFxuICAgICAgICAgICAgJ3BhZGRpbmctYm90dG9tOiAycHg7JyxcbiAgICAgICAgICAgICdib3JkZXItYm90dG9tOiAxcHggZGFzaGVkIHJlZDsnLFxuICAgICAgICAgICAgJ30nXG4gICAgICAgIF0uam9pbignXFxuJyksIHsgdGl0bGU6ICdlcnJvci1tZXNzYWdlJyB9KTtcblxuICAgICAgICBlbGVtLnN0eWxlLmNzc1RleHQgPSBbXG4gICAgICAgICAgICAnZm9udC1mYW1pbHk6IEFyaWFsLCBzYW5zLXNlcmlmJyxcbiAgICAgICAgICAgICdib3JkZXI6IDFweCBzb2xpZCAjZTAwJyxcbiAgICAgICAgICAgICdiYWNrZ3JvdW5kLWNvbG9yOiAjZWVlJyxcbiAgICAgICAgICAgICdib3JkZXItcmFkaXVzOiA1cHgnLFxuICAgICAgICAgICAgJy13ZWJraXQtYm9yZGVyLXJhZGl1czogNXB4JyxcbiAgICAgICAgICAgICctbW96LWJvcmRlci1yYWRpdXM6IDVweCcsXG4gICAgICAgICAgICAnY29sb3I6ICNlMDAnLFxuICAgICAgICAgICAgJ3BhZGRpbmc6IDE1cHgnLFxuICAgICAgICAgICAgJ21hcmdpbi1ib3R0b206IDE1cHgnXG4gICAgICAgIF0uam9pbignOycpO1xuXG4gICAgICAgIGlmIChvcHRpb25zLmVudiA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgICAgdGltZXIgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50LFxuICAgICAgICAgICAgICAgICAgICBib2R5ID0gZG9jdW1lbnQuYm9keTtcbiAgICAgICAgICAgICAgICBpZiAoYm9keSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5LnJlcGxhY2VDaGlsZChlbGVtLCBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keS5pbnNlcnRCZWZvcmUoZWxlbSwgYm9keS5maXJzdENoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKHRpbWVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCAxMCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1vdmVFcnJvckhUTUwocGF0aCkge1xuICAgICAgICB2YXIgbm9kZSA9IHdpbmRvdy5kb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbGVzcy1lcnJvci1tZXNzYWdlOicgKyB1dGlscy5leHRyYWN0SWQocGF0aCkpO1xuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgbm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlRXJyb3JDb25zb2xlKHBhdGgpIHtcbiAgICAgICAgLy8gbm8gYWN0aW9uXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlRXJyb3IocGF0aCkge1xuICAgICAgICBpZiAoIW9wdGlvbnMuZXJyb3JSZXBvcnRpbmcgfHwgb3B0aW9ucy5lcnJvclJlcG9ydGluZyA9PT0gJ2h0bWwnKSB7XG4gICAgICAgICAgICByZW1vdmVFcnJvckhUTUwocGF0aCk7XG4gICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5lcnJvclJlcG9ydGluZyA9PT0gJ2NvbnNvbGUnKSB7XG4gICAgICAgICAgICByZW1vdmVFcnJvckNvbnNvbGUocGF0aCk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMuZXJyb3JSZXBvcnRpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuZXJyb3JSZXBvcnRpbmcoJ3JlbW92ZScsIHBhdGgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXJyb3JDb25zb2xlKGUsIHJvb3RIcmVmKSB7XG4gICAgICAgIHZhciB0ZW1wbGF0ZSA9ICd7bGluZX0ge2NvbnRlbnR9JztcbiAgICAgICAgdmFyIGZpbGVuYW1lID0gZS5maWxlbmFtZSB8fCByb290SHJlZjtcbiAgICAgICAgdmFyIGVycm9ycyA9IFtdO1xuICAgICAgICB2YXIgY29udGVudCA9IChlLnR5cGUgfHwgJ1N5bnRheCcpICsgJ0Vycm9yOiAnICsgKGUubWVzc2FnZSB8fCAnVGhlcmUgaXMgYW4gZXJyb3IgaW4geW91ciAubGVzcyBmaWxlJykgK1xuICAgICAgICAgICAgJyBpbiAnICsgZmlsZW5hbWU7XG5cbiAgICAgICAgdmFyIGVycm9ybGluZSA9IGZ1bmN0aW9uIChlLCBpLCBjbGFzc25hbWUpIHtcbiAgICAgICAgICAgIGlmIChlLmV4dHJhY3RbaV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHRlbXBsYXRlLnJlcGxhY2UoL1xce2xpbmVcXH0vLCAocGFyc2VJbnQoZS5saW5lLCAxMCkgfHwgMCkgKyAoaSAtIDEpKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFx7Y2xhc3NcXH0vLCBjbGFzc25hbWUpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXHtjb250ZW50XFx9LywgZS5leHRyYWN0W2ldKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGUubGluZSkge1xuICAgICAgICAgICAgZXJyb3JsaW5lKGUsIDAsICcnKTtcbiAgICAgICAgICAgIGVycm9ybGluZShlLCAxLCAnbGluZScpO1xuICAgICAgICAgICAgZXJyb3JsaW5lKGUsIDIsICcnKTtcbiAgICAgICAgICAgIGNvbnRlbnQgKz0gJyBvbiBsaW5lICcgKyBlLmxpbmUgKyAnLCBjb2x1bW4gJyArIChlLmNvbHVtbiArIDEpICsgJzpcXG4nICtcbiAgICAgICAgICAgICAgICBlcnJvcnMuam9pbignXFxuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGUuc3RhY2sgJiYgKGUuZXh0cmFjdCB8fCBvcHRpb25zLmxvZ0xldmVsID49IDQpKSB7XG4gICAgICAgICAgICBjb250ZW50ICs9ICdcXG5TdGFjayBUcmFjZVxcbicgKyBlLnN0YWNrO1xuICAgICAgICB9XG4gICAgICAgIGxlc3MubG9nZ2VyLmVycm9yKGNvbnRlbnQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVycm9yKGUsIHJvb3RIcmVmKSB7XG4gICAgICAgIGlmICghb3B0aW9ucy5lcnJvclJlcG9ydGluZyB8fCBvcHRpb25zLmVycm9yUmVwb3J0aW5nID09PSAnaHRtbCcpIHtcbiAgICAgICAgICAgIGVycm9ySFRNTChlLCByb290SHJlZik7XG4gICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5lcnJvclJlcG9ydGluZyA9PT0gJ2NvbnNvbGUnKSB7XG4gICAgICAgICAgICBlcnJvckNvbnNvbGUoZSwgcm9vdEhyZWYpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLmVycm9yUmVwb3J0aW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBvcHRpb25zLmVycm9yUmVwb3J0aW5nKCdhZGQnLCBlLCByb290SHJlZik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBhZGQ6IGVycm9yLFxuICAgICAgICByZW1vdmU6IHJlbW92ZUVycm9yXG4gICAgfTtcbn07XG5cbn0se1wiLi9icm93c2VyXCI6MyxcIi4vdXRpbHNcIjoxMX1dLDY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyogZ2xvYmFsIHdpbmRvdywgWE1MSHR0cFJlcXVlc3QgKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvcHRpb25zLCBsb2dnZXIpIHtcblxuICAgIHZhciBBYnN0cmFjdEZpbGVNYW5hZ2VyID0gcmVxdWlyZSgnLi4vbGVzcy9lbnZpcm9ubWVudC9hYnN0cmFjdC1maWxlLW1hbmFnZXIuanMnKTtcblxuICAgIHZhciBmaWxlQ2FjaGUgPSB7fTtcblxuICAgIC8vIFRPRE9TIC0gbW92ZSBsb2cgc29tZXdoZXJlLiBwYXRoRGlmZiBhbmQgZG9pbmcgc29tZXRoaW5nIHNpbWlsYXIgaW4gbm9kZS4gdXNlIHBhdGhEaWZmIGluIHRoZSBvdGhlciBicm93c2VyIGZpbGUgZm9yIHRoZSBpbml0aWFsIGxvYWRcbiAgICB2YXIgRmlsZU1hbmFnZXIgPSBmdW5jdGlvbigpIHtcbiAgICB9O1xuXG4gICAgRmlsZU1hbmFnZXIucHJvdG90eXBlID0gbmV3IEFic3RyYWN0RmlsZU1hbmFnZXIoKTtcblxuICAgIEZpbGVNYW5hZ2VyLnByb3RvdHlwZS5hbHdheXNNYWtlUGF0aHNBYnNvbHV0ZSA9IGZ1bmN0aW9uIGFsd2F5c01ha2VQYXRoc0Fic29sdXRlKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIEZpbGVNYW5hZ2VyLnByb3RvdHlwZS5qb2luID0gZnVuY3Rpb24gam9pbihiYXNlUGF0aCwgbGF0ZXJQYXRoKSB7XG4gICAgICAgIGlmICghYmFzZVBhdGgpIHtcbiAgICAgICAgICAgIHJldHVybiBsYXRlclBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZXh0cmFjdFVybFBhcnRzKGxhdGVyUGF0aCwgYmFzZVBhdGgpLnBhdGg7XG4gICAgfTtcbiAgICBGaWxlTWFuYWdlci5wcm90b3R5cGUuZG9YSFIgPSBmdW5jdGlvbiBkb1hIUih1cmwsIHR5cGUsIGNhbGxiYWNrLCBlcnJiYWNrKSB7XG5cbiAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICB2YXIgYXN5bmMgPSBvcHRpb25zLmlzRmlsZVByb3RvY29sID8gb3B0aW9ucy5maWxlQXN5bmMgOiB0cnVlO1xuXG4gICAgICAgIGlmICh0eXBlb2YgeGhyLm92ZXJyaWRlTWltZVR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHhoci5vdmVycmlkZU1pbWVUeXBlKCd0ZXh0L2NzcycpO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnWEhSOiBHZXR0aW5nIFxcJycgKyB1cmwgKyAnXFwnJyk7XG4gICAgICAgIHhoci5vcGVuKCdHRVQnLCB1cmwsIGFzeW5jKTtcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0FjY2VwdCcsIHR5cGUgfHwgJ3RleHQveC1sZXNzLCB0ZXh0L2NzczsgcT0wLjksICovKjsgcT0wLjUnKTtcbiAgICAgICAgeGhyLnNlbmQobnVsbCk7XG5cbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlUmVzcG9uc2UoeGhyLCBjYWxsYmFjaywgZXJyYmFjaykge1xuICAgICAgICAgICAgaWYgKHhoci5zdGF0dXMgPj0gMjAwICYmIHhoci5zdGF0dXMgPCAzMDApIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayh4aHIucmVzcG9uc2VUZXh0LFxuICAgICAgICAgICAgICAgICAgICB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ0xhc3QtTW9kaWZpZWQnKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBlcnJiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZXJyYmFjayh4aHIuc3RhdHVzLCB1cmwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuaXNGaWxlUHJvdG9jb2wgJiYgIW9wdGlvbnMuZmlsZUFzeW5jKSB7XG4gICAgICAgICAgICBpZiAoeGhyLnN0YXR1cyA9PT0gMCB8fCAoeGhyLnN0YXR1cyA+PSAyMDAgJiYgeGhyLnN0YXR1cyA8IDMwMCkpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayh4aHIucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXJyYmFjayh4aHIuc3RhdHVzLCB1cmwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGFzeW5jKSB7XG4gICAgICAgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZVJlc3BvbnNlKHhociwgY2FsbGJhY2ssIGVycmJhY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoYW5kbGVSZXNwb25zZSh4aHIsIGNhbGxiYWNrLCBlcnJiYWNrKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRmlsZU1hbmFnZXIucHJvdG90eXBlLnN1cHBvcnRzID0gZnVuY3Rpb24oZmlsZW5hbWUsIGN1cnJlbnREaXJlY3RvcnksIG9wdGlvbnMsIGVudmlyb25tZW50KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICBGaWxlTWFuYWdlci5wcm90b3R5cGUuY2xlYXJGaWxlQ2FjaGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZmlsZUNhY2hlID0ge307XG4gICAgfTtcblxuICAgIEZpbGVNYW5hZ2VyLnByb3RvdHlwZS5sb2FkRmlsZSA9IGZ1bmN0aW9uIGxvYWRGaWxlKGZpbGVuYW1lLCBjdXJyZW50RGlyZWN0b3J5LCBvcHRpb25zLCBlbnZpcm9ubWVudCkge1xuICAgICAgICAvLyBUT0RPOiBBZGQgcHJlZml4IHN1cHBvcnQgbGlrZSBsZXNzLW5vZGU/XG4gICAgICAgIC8vIFdoYXQgYWJvdXQgbXVsdGlwbGUgcGF0aHM/XG5cbiAgICAgICAgaWYgKGN1cnJlbnREaXJlY3RvcnkgJiYgIXRoaXMuaXNQYXRoQWJzb2x1dGUoZmlsZW5hbWUpKSB7XG4gICAgICAgICAgICBmaWxlbmFtZSA9IGN1cnJlbnREaXJlY3RvcnkgKyBmaWxlbmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZpbGVuYW1lID0gb3B0aW9ucy5leHQgPyB0aGlzLnRyeUFwcGVuZEV4dGVuc2lvbihmaWxlbmFtZSwgb3B0aW9ucy5leHQpIDogZmlsZW5hbWU7XG5cbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgLy8gc2hlZXQgbWF5IGJlIHNldCB0byB0aGUgc3R5bGVzaGVldCBmb3IgdGhlIGluaXRpYWwgbG9hZCBvciBhIGNvbGxlY3Rpb24gb2YgcHJvcGVydGllcyBpbmNsdWRpbmdcbiAgICAgICAgLy8gc29tZSBjb250ZXh0IHZhcmlhYmxlcyBmb3IgaW1wb3J0c1xuICAgICAgICB2YXIgaHJlZlBhcnRzID0gdGhpcy5leHRyYWN0VXJsUGFydHMoZmlsZW5hbWUsIHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcbiAgICAgICAgdmFyIGhyZWYgICAgICA9IGhyZWZQYXJ0cy51cmw7XG4gICAgICAgIHZhciBzZWxmICAgICAgPSB0aGlzO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMudXNlRmlsZUNhY2hlICYmIGZpbGVDYWNoZVtocmVmXSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsZXNzVGV4dCA9IGZpbGVDYWNoZVtocmVmXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoeyBjb250ZW50czogbGVzc1RleHQsIGZpbGVuYW1lOiBocmVmLCB3ZWJJbmZvOiB7IGxhc3RNb2RpZmllZDogbmV3IERhdGUoKSB9fSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KHsgZmlsZW5hbWU6IGhyZWYsIG1lc3NhZ2U6ICdFcnJvciBsb2FkaW5nIGZpbGUgJyArIGhyZWYgKyAnIGVycm9yIHdhcyAnICsgZS5tZXNzYWdlIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZi5kb1hIUihocmVmLCBvcHRpb25zLm1pbWUsIGZ1bmN0aW9uIGRvWEhSQ2FsbGJhY2soZGF0YSwgbGFzdE1vZGlmaWVkKSB7XG4gICAgICAgICAgICAgICAgLy8gcGVyIGZpbGUgY2FjaGVcbiAgICAgICAgICAgICAgICBmaWxlQ2FjaGVbaHJlZl0gPSBkYXRhO1xuXG4gICAgICAgICAgICAgICAgLy8gVXNlIHJlbW90ZSBjb3B5IChyZS1wYXJzZSlcbiAgICAgICAgICAgICAgICByZXNvbHZlKHsgY29udGVudHM6IGRhdGEsIGZpbGVuYW1lOiBocmVmLCB3ZWJJbmZvOiB7IGxhc3RNb2RpZmllZDogbGFzdE1vZGlmaWVkIH19KTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIGRvWEhSRXJyb3Ioc3RhdHVzLCB1cmwpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoeyB0eXBlOiAnRmlsZScsIG1lc3NhZ2U6ICdcXCcnICsgdXJsICsgJ1xcJyB3YXNuXFwndCBmb3VuZCAoJyArIHN0YXR1cyArICcpJywgaHJlZjogaHJlZiB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEZpbGVNYW5hZ2VyO1xufTtcblxufSx7XCIuLi9sZXNzL2Vudmlyb25tZW50L2Fic3RyYWN0LWZpbGUtbWFuYWdlci5qc1wiOjE4fV0sNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIGZ1bmN0aW9uUmVnaXN0cnkgPSByZXF1aXJlKCcuLy4uL2xlc3MvZnVuY3Rpb25zL2Z1bmN0aW9uLXJlZ2lzdHJ5Jyk7XG5cbiAgICBmdW5jdGlvbiBpbWFnZVNpemUoKSB7XG4gICAgICAgIHRocm93IHtcbiAgICAgICAgICAgIHR5cGU6ICdSdW50aW1lJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdJbWFnZSBzaXplIGZ1bmN0aW9ucyBhcmUgbm90IHN1cHBvcnRlZCBpbiBicm93c2VyIHZlcnNpb24gb2YgbGVzcydcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgaW1hZ2VGdW5jdGlvbnMgPSB7XG4gICAgICAgICdpbWFnZS1zaXplJzogZnVuY3Rpb24oZmlsZVBhdGhOb2RlKSB7XG4gICAgICAgICAgICBpbWFnZVNpemUodGhpcywgZmlsZVBhdGhOb2RlKTtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfSxcbiAgICAgICAgJ2ltYWdlLXdpZHRoJzogZnVuY3Rpb24oZmlsZVBhdGhOb2RlKSB7XG4gICAgICAgICAgICBpbWFnZVNpemUodGhpcywgZmlsZVBhdGhOb2RlKTtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfSxcbiAgICAgICAgJ2ltYWdlLWhlaWdodCc6IGZ1bmN0aW9uKGZpbGVQYXRoTm9kZSkge1xuICAgICAgICAgICAgaW1hZ2VTaXplKHRoaXMsIGZpbGVQYXRoTm9kZSk7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb25SZWdpc3RyeS5hZGRNdWx0aXBsZShpbWFnZUZ1bmN0aW9ucyk7XG59O1xuXG59LHtcIi4vLi4vbGVzcy9mdW5jdGlvbnMvZnVuY3Rpb24tcmVnaXN0cnlcIjoyN31dLDg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLy9cbi8vIGluZGV4LmpzXG4vLyBTaG91bGQgZXhwb3NlIHRoZSBhZGRpdGlvbmFsIGJyb3dzZXIgZnVuY3Rpb25zIG9uIHRvIHRoZSBsZXNzIG9iamVjdFxuLy9cbnZhciBhZGREYXRhQXR0ciA9IHJlcXVpcmUoJy4vdXRpbHMnKS5hZGREYXRhQXR0cixcbiAgICBicm93c2VyID0gcmVxdWlyZSgnLi9icm93c2VyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24od2luZG93LCBvcHRpb25zKSB7XG4gICAgdmFyIGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50O1xuICAgIHZhciBsZXNzID0gcmVxdWlyZSgnLi4vbGVzcycpKCk7XG4gICAgXG4gICAgbGVzcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB2YXIgZW52aXJvbm1lbnQgPSBsZXNzLmVudmlyb25tZW50LFxuICAgICAgICBGaWxlTWFuYWdlciA9IHJlcXVpcmUoJy4vZmlsZS1tYW5hZ2VyJykob3B0aW9ucywgbGVzcy5sb2dnZXIpLFxuICAgICAgICBmaWxlTWFuYWdlciA9IG5ldyBGaWxlTWFuYWdlcigpO1xuICAgIGVudmlyb25tZW50LmFkZEZpbGVNYW5hZ2VyKGZpbGVNYW5hZ2VyKTtcbiAgICBsZXNzLkZpbGVNYW5hZ2VyID0gRmlsZU1hbmFnZXI7XG4gICAgbGVzcy5QbHVnaW5Mb2FkZXIgPSByZXF1aXJlKCcuL3BsdWdpbi1sb2FkZXInKTtcblxuICAgIHJlcXVpcmUoJy4vbG9nLWxpc3RlbmVyJykobGVzcywgb3B0aW9ucyk7XG4gICAgdmFyIGVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3ItcmVwb3J0aW5nJykod2luZG93LCBsZXNzLCBvcHRpb25zKTtcbiAgICB2YXIgY2FjaGUgPSBsZXNzLmNhY2hlID0gb3B0aW9ucy5jYWNoZSB8fCByZXF1aXJlKCcuL2NhY2hlJykod2luZG93LCBvcHRpb25zLCBsZXNzLmxvZ2dlcik7XG4gICAgcmVxdWlyZSgnLi9pbWFnZS1zaXplJykobGVzcy5lbnZpcm9ubWVudCk7XG5cbiAgICAvLyBTZXR1cCB1c2VyIGZ1bmN0aW9ucyAtIERlcHJlY2F0ZT9cbiAgICBpZiAob3B0aW9ucy5mdW5jdGlvbnMpIHtcbiAgICAgICAgbGVzcy5mdW5jdGlvbnMuZnVuY3Rpb25SZWdpc3RyeS5hZGRNdWx0aXBsZShvcHRpb25zLmZ1bmN0aW9ucyk7XG4gICAgfVxuXG4gICAgdmFyIHR5cGVQYXR0ZXJuID0gL150ZXh0XFwvKHgtKT9sZXNzJC87XG5cbiAgICBmdW5jdGlvbiBjbG9uZShvYmopIHtcbiAgICAgICAgdmFyIGNsb25lZCA9IHt9O1xuICAgICAgICBmb3IgKHZhciBwcm9wIGluIG9iaikge1xuICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAgICAgICAgIGNsb25lZFtwcm9wXSA9IG9ialtwcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2xvbmVkO1xuICAgIH1cblxuICAgIC8vIG9ubHkgcmVhbGx5IG5lZWRlZCBmb3IgcGhhbnRvbVxuICAgIGZ1bmN0aW9uIGJpbmQoZnVuYywgdGhpc0FyZykge1xuICAgICAgICB2YXIgY3VycnlBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBjdXJyeUFyZ3MuY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkpO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9hZFN0eWxlcyhtb2RpZnlWYXJzKSB7XG4gICAgICAgIHZhciBzdHlsZXMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc3R5bGUnKSxcbiAgICAgICAgICAgIHN0eWxlO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzdHlsZSA9IHN0eWxlc1tpXTtcbiAgICAgICAgICAgIGlmIChzdHlsZS50eXBlLm1hdGNoKHR5cGVQYXR0ZXJuKSkge1xuICAgICAgICAgICAgICAgIHZhciBpbnN0YW5jZU9wdGlvbnMgPSBjbG9uZShvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZU9wdGlvbnMubW9kaWZ5VmFycyA9IG1vZGlmeVZhcnM7XG4gICAgICAgICAgICAgICAgdmFyIGxlc3NUZXh0ID0gc3R5bGUuaW5uZXJIVE1MIHx8ICcnO1xuICAgICAgICAgICAgICAgIGluc3RhbmNlT3B0aW9ucy5maWxlbmFtZSA9IGRvY3VtZW50LmxvY2F0aW9uLmhyZWYucmVwbGFjZSgvIy4qJC8sICcnKTtcblxuICAgICAgICAgICAgICAgIC8qIGpzaGludCBsb29wZnVuYzp0cnVlICovXG4gICAgICAgICAgICAgICAgLy8gdXNlIGNsb3N1cmUgdG8gc3RvcmUgY3VycmVudCBzdHlsZVxuICAgICAgICAgICAgICAgIGxlc3MucmVuZGVyKGxlc3NUZXh0LCBpbnN0YW5jZU9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBiaW5kKGZ1bmN0aW9uKHN0eWxlLCBlLCByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMuYWRkKGUsICdpbmxpbmUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZS50eXBlID0gJ3RleHQvY3NzJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlc3VsdC5jc3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZS5pbm5lckhUTUwgPSByZXN1bHQuY3NzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgbnVsbCwgc3R5bGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvYWRTdHlsZVNoZWV0KHNoZWV0LCBjYWxsYmFjaywgcmVsb2FkLCByZW1haW5pbmcsIG1vZGlmeVZhcnMpIHtcblxuICAgICAgICB2YXIgaW5zdGFuY2VPcHRpb25zID0gY2xvbmUob3B0aW9ucyk7XG4gICAgICAgIGFkZERhdGFBdHRyKGluc3RhbmNlT3B0aW9ucywgc2hlZXQpO1xuICAgICAgICBpbnN0YW5jZU9wdGlvbnMubWltZSA9IHNoZWV0LnR5cGU7XG5cbiAgICAgICAgaWYgKG1vZGlmeVZhcnMpIHtcbiAgICAgICAgICAgIGluc3RhbmNlT3B0aW9ucy5tb2RpZnlWYXJzID0gbW9kaWZ5VmFycztcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGxvYWRJbml0aWFsRmlsZUNhbGxiYWNrKGxvYWRlZEZpbGUpIHtcblxuICAgICAgICAgICAgdmFyIGRhdGEgPSBsb2FkZWRGaWxlLmNvbnRlbnRzLFxuICAgICAgICAgICAgICAgIHBhdGggPSBsb2FkZWRGaWxlLmZpbGVuYW1lLFxuICAgICAgICAgICAgICAgIHdlYkluZm8gPSBsb2FkZWRGaWxlLndlYkluZm87XG5cbiAgICAgICAgICAgIHZhciBuZXdGaWxlSW5mbyA9IHtcbiAgICAgICAgICAgICAgICBjdXJyZW50RGlyZWN0b3J5OiBmaWxlTWFuYWdlci5nZXRQYXRoKHBhdGgpLFxuICAgICAgICAgICAgICAgIGZpbGVuYW1lOiBwYXRoLFxuICAgICAgICAgICAgICAgIHJvb3RGaWxlbmFtZTogcGF0aCxcbiAgICAgICAgICAgICAgICByZXdyaXRlVXJsczogaW5zdGFuY2VPcHRpb25zLnJld3JpdGVVcmxzXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBuZXdGaWxlSW5mby5lbnRyeVBhdGggPSBuZXdGaWxlSW5mby5jdXJyZW50RGlyZWN0b3J5O1xuICAgICAgICAgICAgbmV3RmlsZUluZm8ucm9vdHBhdGggPSBpbnN0YW5jZU9wdGlvbnMucm9vdHBhdGggfHwgbmV3RmlsZUluZm8uY3VycmVudERpcmVjdG9yeTtcblxuICAgICAgICAgICAgaWYgKHdlYkluZm8pIHtcbiAgICAgICAgICAgICAgICB3ZWJJbmZvLnJlbWFpbmluZyA9IHJlbWFpbmluZztcblxuICAgICAgICAgICAgICAgIHZhciBjc3MgPSBjYWNoZS5nZXRDU1MocGF0aCwgd2ViSW5mbywgaW5zdGFuY2VPcHRpb25zLm1vZGlmeVZhcnMpO1xuICAgICAgICAgICAgICAgIGlmICghcmVsb2FkICYmIGNzcykge1xuICAgICAgICAgICAgICAgICAgICB3ZWJJbmZvLmxvY2FsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgY3NzLCBkYXRhLCBzaGVldCwgd2ViSW5mbywgcGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVE9ETyBhZGQgdGVzdHMgYXJvdW5kIGhvdyB0aGlzIGJlaGF2ZXMgd2hlbiByZWxvYWRpbmdcbiAgICAgICAgICAgIGVycm9ycy5yZW1vdmUocGF0aCk7XG5cbiAgICAgICAgICAgIGluc3RhbmNlT3B0aW9ucy5yb290RmlsZUluZm8gPSBuZXdGaWxlSW5mbztcbiAgICAgICAgICAgIGxlc3MucmVuZGVyKGRhdGEsIGluc3RhbmNlT3B0aW9ucywgZnVuY3Rpb24oZSwgcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5ocmVmID0gcGF0aDtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGUuc2V0Q1NTKHNoZWV0LmhyZWYsIHdlYkluZm8ubGFzdE1vZGlmaWVkLCBpbnN0YW5jZU9wdGlvbnMubW9kaWZ5VmFycywgcmVzdWx0LmNzcyk7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHJlc3VsdC5jc3MsIGRhdGEsIHNoZWV0LCB3ZWJJbmZvLCBwYXRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZpbGVNYW5hZ2VyLmxvYWRGaWxlKHNoZWV0LmhyZWYsIG51bGwsIGluc3RhbmNlT3B0aW9ucywgZW52aXJvbm1lbnQpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbihsb2FkZWRGaWxlKSB7XG4gICAgICAgICAgICAgICAgbG9hZEluaXRpYWxGaWxlQ2FsbGJhY2sobG9hZGVkRmlsZSk7XG4gICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9KTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvYWRTdHlsZVNoZWV0cyhjYWxsYmFjaywgcmVsb2FkLCBtb2RpZnlWYXJzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVzcy5zaGVldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxvYWRTdHlsZVNoZWV0KGxlc3Muc2hlZXRzW2ldLCBjYWxsYmFjaywgcmVsb2FkLCBsZXNzLnNoZWV0cy5sZW5ndGggLSAoaSArIDEpLCBtb2RpZnlWYXJzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluaXRSdW5uaW5nTW9kZSgpIHtcbiAgICAgICAgaWYgKGxlc3MuZW52ID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgICAgICBsZXNzLndhdGNoVGltZXIgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxlc3Mud2F0Y2hNb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGVNYW5hZ2VyLmNsZWFyRmlsZUNhY2hlKCk7XG4gICAgICAgICAgICAgICAgICAgIGxvYWRTdHlsZVNoZWV0cyhmdW5jdGlvbiAoZSwgY3NzLCBfLCBzaGVldCwgd2ViSW5mbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMuYWRkKGUsIGUuaHJlZiB8fCBzaGVldC5ocmVmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY3NzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJvd3Nlci5jcmVhdGVDU1Mod2luZG93LmRvY3VtZW50LCBjc3MsIHNoZWV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgb3B0aW9ucy5wb2xsKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vXG4gICAgLy8gV2F0Y2ggbW9kZVxuICAgIC8vXG4gICAgbGVzcy53YXRjaCAgID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWxlc3Mud2F0Y2hNb2RlICkge1xuICAgICAgICAgICAgbGVzcy5lbnYgPSAnZGV2ZWxvcG1lbnQnO1xuICAgICAgICAgICAgaW5pdFJ1bm5pbmdNb2RlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53YXRjaE1vZGUgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgbGVzcy51bndhdGNoID0gZnVuY3Rpb24gKCkge2NsZWFySW50ZXJ2YWwobGVzcy53YXRjaFRpbWVyKTsgdGhpcy53YXRjaE1vZGUgPSBmYWxzZTsgcmV0dXJuIGZhbHNlOyB9O1xuXG4gICAgLy9cbiAgICAvLyBTeW5jaHJvbm91c2x5IGdldCBhbGwgPGxpbms+IHRhZ3Mgd2l0aCB0aGUgJ3JlbCcgYXR0cmlidXRlIHNldCB0b1xuICAgIC8vIFwic3R5bGVzaGVldC9sZXNzXCIuXG4gICAgLy9cbiAgICBsZXNzLnJlZ2lzdGVyU3R5bGVzaGVldHNJbW1lZGlhdGVseSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbGlua3MgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnbGluaycpO1xuICAgICAgICBsZXNzLnNoZWV0cyA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlua3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChsaW5rc1tpXS5yZWwgPT09ICdzdHlsZXNoZWV0L2xlc3MnIHx8IChsaW5rc1tpXS5yZWwubWF0Y2goL3N0eWxlc2hlZXQvKSAmJlxuICAgICAgICAgICAgICAgIChsaW5rc1tpXS50eXBlLm1hdGNoKHR5cGVQYXR0ZXJuKSkpKSB7XG4gICAgICAgICAgICAgICAgbGVzcy5zaGVldHMucHVzaChsaW5rc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy9cbiAgICAvLyBBc3luY2hyb25vdXNseSBnZXQgYWxsIDxsaW5rPiB0YWdzIHdpdGggdGhlICdyZWwnIGF0dHJpYnV0ZSBzZXQgdG9cbiAgICAvLyBcInN0eWxlc2hlZXQvbGVzc1wiLCByZXR1cm5pbmcgYSBQcm9taXNlLlxuICAgIC8vXG4gICAgbGVzcy5yZWdpc3RlclN0eWxlc2hlZXRzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIGxlc3MucmVnaXN0ZXJTdHlsZXNoZWV0c0ltbWVkaWF0ZWx5KCk7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvL1xuICAgIC8vIFdpdGggdGhpcyBmdW5jdGlvbiwgaXQncyBwb3NzaWJsZSB0byBhbHRlciB2YXJpYWJsZXMgYW5kIHJlLXJlbmRlclxuICAgIC8vIENTUyB3aXRob3V0IHJlbG9hZGluZyBsZXNzLWZpbGVzXG4gICAgLy9cbiAgICBsZXNzLm1vZGlmeVZhcnMgPSBmdW5jdGlvbihyZWNvcmQpIHtcbiAgICAgICAgcmV0dXJuIGxlc3MucmVmcmVzaCh0cnVlLCByZWNvcmQsIGZhbHNlKTtcbiAgICB9O1xuXG4gICAgbGVzcy5yZWZyZXNoID0gZnVuY3Rpb24gKHJlbG9hZCwgbW9kaWZ5VmFycywgY2xlYXJGaWxlQ2FjaGUpIHtcbiAgICAgICAgaWYgKChyZWxvYWQgfHwgY2xlYXJGaWxlQ2FjaGUpICYmIGNsZWFyRmlsZUNhY2hlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgZmlsZU1hbmFnZXIuY2xlYXJGaWxlQ2FjaGUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgdmFyIHN0YXJ0VGltZSwgZW5kVGltZSwgdG90YWxNaWxsaXNlY29uZHMsIHJlbWFpbmluZ1NoZWV0cztcbiAgICAgICAgICAgIHN0YXJ0VGltZSA9IGVuZFRpbWUgPSBuZXcgRGF0ZSgpO1xuXG4gICAgICAgICAgICAvLyBTZXQgY291bnRlciBmb3IgcmVtYWluaW5nIHVucHJvY2Vzc2VkIHNoZWV0c1xuICAgICAgICAgICAgcmVtYWluaW5nU2hlZXRzID0gbGVzcy5zaGVldHMubGVuZ3RoO1xuXG4gICAgICAgICAgICBpZiAocmVtYWluaW5nU2hlZXRzID09PSAwKSB7XG5cbiAgICAgICAgICAgICAgICBlbmRUaW1lID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgICAgICB0b3RhbE1pbGxpc2Vjb25kcyA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XG4gICAgICAgICAgICAgICAgbGVzcy5sb2dnZXIuaW5mbygnTGVzcyBoYXMgZmluaXNoZWQgYW5kIG5vIHNoZWV0cyB3ZXJlIGxvYWRlZC4nKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRUaW1lOiBzdGFydFRpbWUsXG4gICAgICAgICAgICAgICAgICAgIGVuZFRpbWU6IGVuZFRpbWUsXG4gICAgICAgICAgICAgICAgICAgIHRvdGFsTWlsbGlzZWNvbmRzOiB0b3RhbE1pbGxpc2Vjb25kcyxcbiAgICAgICAgICAgICAgICAgICAgc2hlZXRzOiBsZXNzLnNoZWV0cy5sZW5ndGhcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBSZWxpZXMgb24gbGVzcy5zaGVldHMgYXJyYXksIGNhbGxiYWNrIHNlZW1zIHRvIGJlIGd1YXJhbnRlZWQgdG8gYmUgY2FsbGVkIGZvciBldmVyeSBlbGVtZW50IG9mIHRoZSBhcnJheVxuICAgICAgICAgICAgICAgIGxvYWRTdHlsZVNoZWV0cyhmdW5jdGlvbiAoZSwgY3NzLCBfLCBzaGVldCwgd2ViSW5mbykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLmFkZChlLCBlLmhyZWYgfHwgc2hlZXQuaHJlZik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHdlYkluZm8ubG9jYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlc3MubG9nZ2VyLmluZm8oJ0xvYWRpbmcgJyArIHNoZWV0LmhyZWYgKyAnIGZyb20gY2FjaGUuJyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXNzLmxvZ2dlci5pbmZvKCdSZW5kZXJlZCAnICsgc2hlZXQuaHJlZiArICcgc3VjY2Vzc2Z1bGx5LicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyb3dzZXIuY3JlYXRlQ1NTKHdpbmRvdy5kb2N1bWVudCwgY3NzLCBzaGVldCk7XG4gICAgICAgICAgICAgICAgICAgIGxlc3MubG9nZ2VyLmluZm8oJ0NTUyBmb3IgJyArIHNoZWV0LmhyZWYgKyAnIGdlbmVyYXRlZCBpbiAnICsgKG5ldyBEYXRlKCkgLSBlbmRUaW1lKSArICdtcycpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIENvdW50IGNvbXBsZXRlZCBzaGVldFxuICAgICAgICAgICAgICAgICAgICByZW1haW5pbmdTaGVldHMtLTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgbGFzdCByZW1haW5pbmcgc2hlZXQgd2FzIHByb2Nlc3NlZCBhbmQgdGhlbiBjYWxsIHRoZSBwcm9taXNlXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZW1haW5pbmdTaGVldHMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsTWlsbGlzZWNvbmRzID0gbmV3IERhdGUoKSAtIHN0YXJ0VGltZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlc3MubG9nZ2VyLmluZm8oJ0xlc3MgaGFzIGZpbmlzaGVkLiBDU1MgZ2VuZXJhdGVkIGluICcgKyB0b3RhbE1pbGxpc2Vjb25kcyArICdtcycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRUaW1lOiBzdGFydFRpbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kVGltZTogZW5kVGltZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3RhbE1pbGxpc2Vjb25kczogdG90YWxNaWxsaXNlY29uZHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hlZXRzOiBsZXNzLnNoZWV0cy5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVuZFRpbWUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgICAgIH0sIHJlbG9hZCwgbW9kaWZ5VmFycyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxvYWRTdHlsZXMobW9kaWZ5VmFycyk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBsZXNzLnJlZnJlc2hTdHlsZXMgPSBsb2FkU3R5bGVzO1xuICAgIHJldHVybiBsZXNzO1xufTtcblxufSx7XCIuLi9sZXNzXCI6MzcsXCIuL2Jyb3dzZXJcIjozLFwiLi9jYWNoZVwiOjQsXCIuL2Vycm9yLXJlcG9ydGluZ1wiOjUsXCIuL2ZpbGUtbWFuYWdlclwiOjYsXCIuL2ltYWdlLXNpemVcIjo3LFwiLi9sb2ctbGlzdGVuZXJcIjo5LFwiLi9wbHVnaW4tbG9hZGVyXCI6MTAsXCIuL3V0aWxzXCI6MTF9XSw5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obGVzcywgb3B0aW9ucykge1xuXG4gICAgdmFyIGxvZ0xldmVsX2RlYnVnID0gNCxcbiAgICAgICAgbG9nTGV2ZWxfaW5mbyA9IDMsXG4gICAgICAgIGxvZ0xldmVsX3dhcm4gPSAyLFxuICAgICAgICBsb2dMZXZlbF9lcnJvciA9IDE7XG5cbiAgICAvLyBUaGUgYW1vdW50IG9mIGxvZ2dpbmcgaW4gdGhlIGphdmFzY3JpcHQgY29uc29sZS5cbiAgICAvLyAzIC0gRGVidWcsIGluZm9ybWF0aW9uIGFuZCBlcnJvcnNcbiAgICAvLyAyIC0gSW5mb3JtYXRpb24gYW5kIGVycm9yc1xuICAgIC8vIDEgLSBFcnJvcnNcbiAgICAvLyAwIC0gTm9uZVxuICAgIC8vIERlZmF1bHRzIHRvIDJcbiAgICBvcHRpb25zLmxvZ0xldmVsID0gdHlwZW9mIG9wdGlvbnMubG9nTGV2ZWwgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5sb2dMZXZlbCA6IChvcHRpb25zLmVudiA9PT0gJ2RldmVsb3BtZW50JyA/ICBsb2dMZXZlbF9pbmZvIDogbG9nTGV2ZWxfZXJyb3IpO1xuXG4gICAgaWYgKCFvcHRpb25zLmxvZ2dlcnMpIHtcbiAgICAgICAgb3B0aW9ucy5sb2dnZXJzID0gW3tcbiAgICAgICAgICAgIGRlYnVnOiBmdW5jdGlvbihtc2cpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5sb2dMZXZlbCA+PSBsb2dMZXZlbF9kZWJ1Zykge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhtc2cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpbmZvOiBmdW5jdGlvbihtc2cpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5sb2dMZXZlbCA+PSBsb2dMZXZlbF9pbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKG1zZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHdhcm46IGZ1bmN0aW9uKG1zZykge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmxvZ0xldmVsID49IGxvZ0xldmVsX3dhcm4pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKG1zZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbihtc2cpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5sb2dMZXZlbCA+PSBsb2dMZXZlbF9lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcHRpb25zLmxvZ2dlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGVzcy5sb2dnZXIuYWRkTGlzdGVuZXIob3B0aW9ucy5sb2dnZXJzW2ldKTtcbiAgICB9XG59O1xuXG59LHt9XSwxMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vLyBUT0RPOiBBZGQgdGVzdHMgZm9yIGJyb3dzZXIgQHBsdWdpblxuLyogZ2xvYmFsIHdpbmRvdyAqL1xuXG52YXIgQWJzdHJhY3RQbHVnaW5Mb2FkZXIgPSByZXF1aXJlKCcuLi9sZXNzL2Vudmlyb25tZW50L2Fic3RyYWN0LXBsdWdpbi1sb2FkZXIuanMnKTtcblxuLyoqXG4gKiBCcm93c2VyIFBsdWdpbiBMb2FkZXJcbiAqL1xudmFyIFBsdWdpbkxvYWRlciA9IGZ1bmN0aW9uKGxlc3MpIHtcbiAgICB0aGlzLmxlc3MgPSBsZXNzO1xuICAgIC8vIFNob3VsZCB3ZSBzaGltIHRoaXMucmVxdWlyZSBmb3IgYnJvd3Nlcj8gUHJvYmFibHkgbm90P1xufTtcblxuUGx1Z2luTG9hZGVyLnByb3RvdHlwZSA9IG5ldyBBYnN0cmFjdFBsdWdpbkxvYWRlcigpO1xuXG5QbHVnaW5Mb2FkZXIucHJvdG90eXBlLmxvYWRQbHVnaW4gPSBmdW5jdGlvbihmaWxlbmFtZSwgYmFzZVBhdGgsIGNvbnRleHQsIGVudmlyb25tZW50LCBmaWxlTWFuYWdlcikge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihmdWxmaWxsLCByZWplY3QpIHtcbiAgICAgICAgZmlsZU1hbmFnZXIubG9hZEZpbGUoZmlsZW5hbWUsIGJhc2VQYXRoLCBjb250ZXh0LCBlbnZpcm9ubWVudClcbiAgICAgICAgICAgIC50aGVuKGZ1bGZpbGwpLmNhdGNoKHJlamVjdCk7XG4gICAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBsdWdpbkxvYWRlcjtcblxuXG59LHtcIi4uL2xlc3MvZW52aXJvbm1lbnQvYWJzdHJhY3QtcGx1Z2luLWxvYWRlci5qc1wiOjE5fV0sMTE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZXh0cmFjdElkOiBmdW5jdGlvbihocmVmKSB7XG4gICAgICAgIHJldHVybiBocmVmLnJlcGxhY2UoL15bYS16LV0rOlxcLys/W15cXC9dKy8sICcnKSAgLy8gUmVtb3ZlIHByb3RvY29sICYgZG9tYWluXG4gICAgICAgICAgICAucmVwbGFjZSgvW1xcP1xcJl1saXZlcmVsb2FkPVxcdysvLCAnJykgICAgICAgIC8vIFJlbW92ZSBMaXZlUmVsb2FkIGNhY2hlYnVzdGVyXG4gICAgICAgICAgICAucmVwbGFjZSgvXlxcLy8sICcnKSAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgcm9vdCAvXG4gICAgICAgICAgICAucmVwbGFjZSgvXFwuW2EtekEtWl0rJC8sICcnKSAgICAgICAgICAgICAgICAvLyBSZW1vdmUgc2ltcGxlIGV4dGVuc2lvblxuICAgICAgICAgICAgLnJlcGxhY2UoL1teXFwuXFx3LV0rL2csICctJykgICAgICAgICAgICAgICAgIC8vIFJlcGxhY2UgaWxsZWdhbCBjaGFyYWN0ZXJzXG4gICAgICAgICAgICAucmVwbGFjZSgvXFwuL2csICc6Jyk7ICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXBsYWNlIGRvdHMgd2l0aCBjb2xvbnMoZm9yIHZhbGlkIGlkKVxuICAgIH0sXG4gICAgYWRkRGF0YUF0dHI6IGZ1bmN0aW9uKG9wdGlvbnMsIHRhZykge1xuICAgICAgICBmb3IgKHZhciBvcHQgaW4gdGFnLmRhdGFzZXQpIHtcbiAgICAgICAgICAgIGlmICh0YWcuZGF0YXNldC5oYXNPd25Qcm9wZXJ0eShvcHQpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdCA9PT0gJ2VudicgfHwgb3B0ID09PSAnZHVtcExpbmVOdW1iZXJzJyB8fCBvcHQgPT09ICdyb290cGF0aCcgfHwgb3B0ID09PSAnZXJyb3JSZXBvcnRpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnNbb3B0XSA9IHRhZy5kYXRhc2V0W29wdF07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnNbb3B0XSA9IEpTT04ucGFyc2UodGFnLmRhdGFzZXRbb3B0XSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKF8pIHt9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxufSx7fV0sMTI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgTWF0aDoge1xuICAgICAgICBBTFdBWVM6IDAsXG4gICAgICAgIFBBUkVOU19ESVZJU0lPTjogMSxcbiAgICAgICAgUEFSRU5TOiAyLFxuICAgICAgICBTVFJJQ1RfTEVHQUNZOiAzXG4gICAgfSxcbiAgICBSZXdyaXRlVXJsczoge1xuICAgICAgICBPRkY6IDAsXG4gICAgICAgIExPQ0FMOiAxLFxuICAgICAgICBBTEw6IDJcbiAgICB9XG59O1xufSx7fV0sMTM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIGNvbnRleHRzID0ge307XG5tb2R1bGUuZXhwb3J0cyA9IGNvbnRleHRzO1xudmFyIENvbnN0YW50cyA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5cbnZhciBjb3B5RnJvbU9yaWdpbmFsID0gZnVuY3Rpb24gY29weUZyb21PcmlnaW5hbChvcmlnaW5hbCwgZGVzdGluYXRpb24sIHByb3BlcnRpZXNUb0NvcHkpIHtcbiAgICBpZiAoIW9yaWdpbmFsKSB7IHJldHVybjsgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wZXJ0aWVzVG9Db3B5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChvcmlnaW5hbC5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0aWVzVG9Db3B5W2ldKSkge1xuICAgICAgICAgICAgZGVzdGluYXRpb25bcHJvcGVydGllc1RvQ29weVtpXV0gPSBvcmlnaW5hbFtwcm9wZXJ0aWVzVG9Db3B5W2ldXTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qXG4gcGFyc2UgaXMgdXNlZCB3aGlsc3QgcGFyc2luZ1xuICovXG52YXIgcGFyc2VDb3B5UHJvcGVydGllcyA9IFtcbiAgICAvLyBvcHRpb25zXG4gICAgJ3BhdGhzJywgICAgICAgICAgICAvLyBvcHRpb24gLSB1bm1vZGlmaWVkIC0gcGF0aHMgdG8gc2VhcmNoIGZvciBpbXBvcnRzIG9uXG4gICAgJ3Jld3JpdGVVcmxzJywgICAgICAvLyBvcHRpb24gLSB3aGV0aGVyIHRvIGFkanVzdCBVUkwncyB0byBiZSByZWxhdGl2ZVxuICAgICdyb290cGF0aCcsICAgICAgICAgLy8gb3B0aW9uIC0gcm9vdHBhdGggdG8gYXBwZW5kIHRvIFVSTCdzXG4gICAgJ3N0cmljdEltcG9ydHMnLCAgICAvLyBvcHRpb24gLVxuICAgICdpbnNlY3VyZScsICAgICAgICAgLy8gb3B0aW9uIC0gd2hldGhlciB0byBhbGxvdyBpbXBvcnRzIGZyb20gaW5zZWN1cmUgc3NsIGhvc3RzXG4gICAgJ2R1bXBMaW5lTnVtYmVycycsICAvLyBvcHRpb24gLSB3aGV0aGVyIHRvIGR1bXAgbGluZSBudW1iZXJzXG4gICAgJ2NvbXByZXNzJywgICAgICAgICAvLyBvcHRpb24gLSB3aGV0aGVyIHRvIGNvbXByZXNzXG4gICAgJ3N5bmNJbXBvcnQnLCAgICAgICAvLyBvcHRpb24gLSB3aGV0aGVyIHRvIGltcG9ydCBzeW5jaHJvbm91c2x5XG4gICAgJ2NodW5rSW5wdXQnLCAgICAgICAvLyBvcHRpb24gLSB3aGV0aGVyIHRvIGNodW5rIGlucHV0LiBtb3JlIHBlcmZvcm1hbnQgYnV0IGNhdXNlcyBwYXJzZSBpc3N1ZXMuXG4gICAgJ21pbWUnLCAgICAgICAgICAgICAvLyBicm93c2VyIG9ubHkgLSBtaW1lIHR5cGUgZm9yIHNoZWV0IGltcG9ydFxuICAgICd1c2VGaWxlQ2FjaGUnLCAgICAgLy8gYnJvd3NlciBvbmx5IC0gd2hldGhlciB0byB1c2UgdGhlIHBlciBmaWxlIHNlc3Npb24gY2FjaGVcbiAgICAvLyBjb250ZXh0XG4gICAgJ3Byb2Nlc3NJbXBvcnRzJywgICAvLyBvcHRpb24gJiBjb250ZXh0IC0gd2hldGhlciB0byBwcm9jZXNzIGltcG9ydHMuIGlmIGZhbHNlIHRoZW4gaW1wb3J0cyB3aWxsIG5vdCBiZSBpbXBvcnRlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZWQgYnkgdGhlIGltcG9ydCBtYW5hZ2VyIHRvIHN0b3AgbXVsdGlwbGUgaW1wb3J0IHZpc2l0b3JzIGJlaW5nIGNyZWF0ZWQuXG4gICAgJ3BsdWdpbk1hbmFnZXInICAgICAvLyBVc2VkIGFzIHRoZSBwbHVnaW4gbWFuYWdlciBmb3IgdGhlIHNlc3Npb25cbl07XG5cbmNvbnRleHRzLlBhcnNlID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIGNvcHlGcm9tT3JpZ2luYWwob3B0aW9ucywgdGhpcywgcGFyc2VDb3B5UHJvcGVydGllcyk7XG5cbiAgICBpZiAodHlwZW9mIHRoaXMucGF0aHMgPT09ICdzdHJpbmcnKSB7IHRoaXMucGF0aHMgPSBbdGhpcy5wYXRoc107IH1cbn07XG5cbnZhciBldmFsQ29weVByb3BlcnRpZXMgPSBbXG4gICAgJ3BhdGhzJywgICAgICAgICAgICAgLy8gYWRkaXRpb25hbCBpbmNsdWRlIHBhdGhzXG4gICAgJ2NvbXByZXNzJywgICAgICAgICAgLy8gd2hldGhlciB0byBjb21wcmVzc1xuICAgICdpZUNvbXBhdCcsICAgICAgICAgIC8vIHdoZXRoZXIgdG8gZW5mb3JjZSBJRSBjb21wYXRpYmlsaXR5IChJRTggZGF0YS11cmkpXG4gICAgJ21hdGgnLCAgICAgICAgICAgICAgLy8gd2hldGhlciBtYXRoIGhhcyB0byBiZSB3aXRoaW4gcGFyZW50aGVzaXNcbiAgICAnc3RyaWN0VW5pdHMnLCAgICAgICAvLyB3aGV0aGVyIHVuaXRzIG5lZWQgdG8gZXZhbHVhdGUgY29ycmVjdGx5XG4gICAgJ3NvdXJjZU1hcCcsICAgICAgICAgLy8gd2hldGhlciB0byBvdXRwdXQgYSBzb3VyY2UgbWFwXG4gICAgJ2ltcG9ydE11bHRpcGxlJywgICAgLy8gd2hldGhlciB3ZSBhcmUgY3VycmVudGx5IGltcG9ydGluZyBtdWx0aXBsZSBjb3BpZXNcbiAgICAndXJsQXJncycsICAgICAgICAgICAvLyB3aGV0aGVyIHRvIGFkZCBhcmdzIGludG8gdXJsIHRva2Vuc1xuICAgICdqYXZhc2NyaXB0RW5hYmxlZCcsIC8vIG9wdGlvbiAtIHdoZXRoZXIgSW5saW5lIEphdmFTY3JpcHQgaXMgZW5hYmxlZC4gaWYgdW5kZWZpbmVkLCBkZWZhdWx0cyB0byBmYWxzZVxuICAgICdwbHVnaW5NYW5hZ2VyJywgICAgIC8vIFVzZWQgYXMgdGhlIHBsdWdpbiBtYW5hZ2VyIGZvciB0aGUgc2Vzc2lvblxuICAgICdpbXBvcnRhbnRTY29wZScsICAgIC8vIHVzZWQgdG8gYnViYmxlIHVwICFpbXBvcnRhbnQgc3RhdGVtZW50c1xuICAgICdyZXdyaXRlVXJscycgICAgICAgIC8vIG9wdGlvbiAtIHdoZXRoZXIgdG8gYWRqdXN0IFVSTCdzIHRvIGJlIHJlbGF0aXZlXG5dO1xuXG5jb250ZXh0cy5FdmFsID0gZnVuY3Rpb24ob3B0aW9ucywgZnJhbWVzKSB7XG4gICAgY29weUZyb21PcmlnaW5hbChvcHRpb25zLCB0aGlzLCBldmFsQ29weVByb3BlcnRpZXMpO1xuXG4gICAgaWYgKHR5cGVvZiB0aGlzLnBhdGhzID09PSAnc3RyaW5nJykgeyB0aGlzLnBhdGhzID0gW3RoaXMucGF0aHNdOyB9XG5cbiAgICB0aGlzLmZyYW1lcyA9IGZyYW1lcyB8fCBbXTtcbiAgICB0aGlzLmltcG9ydGFudFNjb3BlID0gdGhpcy5pbXBvcnRhbnRTY29wZSB8fCBbXTtcbn07XG5cbmNvbnRleHRzLkV2YWwucHJvdG90eXBlLmVudGVyQ2FsYyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuY2FsY1N0YWNrKSB7XG4gICAgICAgIHRoaXMuY2FsY1N0YWNrID0gW107XG4gICAgfVxuICAgIHRoaXMuY2FsY1N0YWNrLnB1c2godHJ1ZSk7XG4gICAgdGhpcy5pbkNhbGMgPSB0cnVlO1xufTtcblxuY29udGV4dHMuRXZhbC5wcm90b3R5cGUuZXhpdENhbGMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jYWxjU3RhY2sucG9wKCk7XG4gICAgaWYgKCF0aGlzLmNhbGNTdGFjaykge1xuICAgICAgICB0aGlzLmluQ2FsYyA9IGZhbHNlO1xuICAgIH1cbn07XG5cbmNvbnRleHRzLkV2YWwucHJvdG90eXBlLmluUGFyZW50aGVzaXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLnBhcmVuc1N0YWNrKSB7XG4gICAgICAgIHRoaXMucGFyZW5zU3RhY2sgPSBbXTtcbiAgICB9XG4gICAgdGhpcy5wYXJlbnNTdGFjay5wdXNoKHRydWUpO1xufTtcblxuY29udGV4dHMuRXZhbC5wcm90b3R5cGUub3V0T2ZQYXJlbnRoZXNpcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnBhcmVuc1N0YWNrLnBvcCgpO1xufTtcblxuY29udGV4dHMuRXZhbC5wcm90b3R5cGUuaW5DYWxjID0gZmFsc2U7XG5jb250ZXh0cy5FdmFsLnByb3RvdHlwZS5tYXRoT24gPSB0cnVlO1xuY29udGV4dHMuRXZhbC5wcm90b3R5cGUuaXNNYXRoT24gPSBmdW5jdGlvbiAob3ApIHtcbiAgICBpZiAoIXRoaXMubWF0aE9uKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKG9wID09PSAnLycgJiYgdGhpcy5tYXRoICE9PSBDb25zdGFudHMuTWF0aC5BTFdBWVMgJiYgKCF0aGlzLnBhcmVuc1N0YWNrIHx8ICF0aGlzLnBhcmVuc1N0YWNrLmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodGhpcy5tYXRoID4gQ29uc3RhbnRzLk1hdGguUEFSRU5TX0RJVklTSU9OKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVuc1N0YWNrICYmIHRoaXMucGFyZW5zU3RhY2subGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbmNvbnRleHRzLkV2YWwucHJvdG90eXBlLnBhdGhSZXF1aXJlc1Jld3JpdGUgPSBmdW5jdGlvbiAocGF0aCkge1xuICAgIHZhciBpc1JlbGF0aXZlID0gdGhpcy5yZXdyaXRlVXJscyA9PT0gQ29uc3RhbnRzLlJld3JpdGVVcmxzLkxPQ0FMID8gaXNQYXRoTG9jYWxSZWxhdGl2ZSA6IGlzUGF0aFJlbGF0aXZlO1xuXG4gICAgcmV0dXJuIGlzUmVsYXRpdmUocGF0aCk7XG59O1xuXG5jb250ZXh0cy5FdmFsLnByb3RvdHlwZS5yZXdyaXRlUGF0aCA9IGZ1bmN0aW9uIChwYXRoLCByb290cGF0aCkge1xuICAgIHZhciBuZXdQYXRoO1xuXG4gICAgcm9vdHBhdGggPSByb290cGF0aCB8fMKgJyc7XG4gICAgbmV3UGF0aCA9IHRoaXMubm9ybWFsaXplUGF0aChyb290cGF0aCArIHBhdGgpO1xuXG4gICAgLy8gSWYgYSBwYXRoIHdhcyBleHBsaWNpdCByZWxhdGl2ZSBhbmQgdGhlIHJvb3RwYXRoIHdhcyBub3QgYW4gYWJzb2x1dGUgcGF0aFxuICAgIC8vIHdlIG11c3QgZW5zdXJlIHRoYXQgdGhlIG5ldyBwYXRoIGlzIGFsc28gZXhwbGljaXQgcmVsYXRpdmUuXG4gICAgaWYgKGlzUGF0aExvY2FsUmVsYXRpdmUocGF0aCkgJiZcbiAgICAgICAgaXNQYXRoUmVsYXRpdmUocm9vdHBhdGgpICYmXG4gICAgICAgIGlzUGF0aExvY2FsUmVsYXRpdmUobmV3UGF0aCkgPT09IGZhbHNlKSB7XG4gICAgICAgIG5ld1BhdGggPSAnLi8nICsgbmV3UGF0aDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3UGF0aDtcbn07XG5cbmNvbnRleHRzLkV2YWwucHJvdG90eXBlLm5vcm1hbGl6ZVBhdGggPSBmdW5jdGlvbiAocGF0aCkge1xuICAgIHZhclxuICAgICAgICBzZWdtZW50cyA9IHBhdGguc3BsaXQoJy8nKS5yZXZlcnNlKCksXG4gICAgICAgIHNlZ21lbnQ7XG5cbiAgICBwYXRoID0gW107XG4gICAgd2hpbGUgKHNlZ21lbnRzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICBzZWdtZW50ID0gc2VnbWVudHMucG9wKCk7XG4gICAgICAgIHN3aXRjaCAoIHNlZ21lbnQgKSB7XG4gICAgICAgICAgICBjYXNlICcuJzpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJy4uJzpcbiAgICAgICAgICAgICAgICBpZiAoKHBhdGgubGVuZ3RoID09PSAwKSB8fCAocGF0aFtwYXRoLmxlbmd0aCAtIDFdID09PSAnLi4nKSkge1xuICAgICAgICAgICAgICAgICAgICBwYXRoLnB1c2goIHNlZ21lbnQgKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYXRoLnBvcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcGF0aC5wdXNoKHNlZ21lbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdGguam9pbignLycpO1xufTtcblxuZnVuY3Rpb24gaXNQYXRoUmVsYXRpdmUocGF0aCkge1xuICAgIHJldHVybiAhL14oPzpbYS16LV0rOnxcXC98IykvaS50ZXN0KHBhdGgpO1xufVxuXG5mdW5jdGlvbiBpc1BhdGhMb2NhbFJlbGF0aXZlKHBhdGgpIHtcbiAgICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcuJztcbn1cblxuLy8gdG9kbyAtIGRvIHRoZSBzYW1lIGZvciB0aGUgdG9DU1MgP1xuXG59LHtcIi4vY29uc3RhbnRzXCI6MTJ9XSwxNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAnYWxpY2VibHVlJzonI2YwZjhmZicsXG4gICAgJ2FudGlxdWV3aGl0ZSc6JyNmYWViZDcnLFxuICAgICdhcXVhJzonIzAwZmZmZicsXG4gICAgJ2FxdWFtYXJpbmUnOicjN2ZmZmQ0JyxcbiAgICAnYXp1cmUnOicjZjBmZmZmJyxcbiAgICAnYmVpZ2UnOicjZjVmNWRjJyxcbiAgICAnYmlzcXVlJzonI2ZmZTRjNCcsXG4gICAgJ2JsYWNrJzonIzAwMDAwMCcsXG4gICAgJ2JsYW5jaGVkYWxtb25kJzonI2ZmZWJjZCcsXG4gICAgJ2JsdWUnOicjMDAwMGZmJyxcbiAgICAnYmx1ZXZpb2xldCc6JyM4YTJiZTInLFxuICAgICdicm93bic6JyNhNTJhMmEnLFxuICAgICdidXJseXdvb2QnOicjZGViODg3JyxcbiAgICAnY2FkZXRibHVlJzonIzVmOWVhMCcsXG4gICAgJ2NoYXJ0cmV1c2UnOicjN2ZmZjAwJyxcbiAgICAnY2hvY29sYXRlJzonI2QyNjkxZScsXG4gICAgJ2NvcmFsJzonI2ZmN2Y1MCcsXG4gICAgJ2Nvcm5mbG93ZXJibHVlJzonIzY0OTVlZCcsXG4gICAgJ2Nvcm5zaWxrJzonI2ZmZjhkYycsXG4gICAgJ2NyaW1zb24nOicjZGMxNDNjJyxcbiAgICAnY3lhbic6JyMwMGZmZmYnLFxuICAgICdkYXJrYmx1ZSc6JyMwMDAwOGInLFxuICAgICdkYXJrY3lhbic6JyMwMDhiOGInLFxuICAgICdkYXJrZ29sZGVucm9kJzonI2I4ODYwYicsXG4gICAgJ2RhcmtncmF5JzonI2E5YTlhOScsXG4gICAgJ2RhcmtncmV5JzonI2E5YTlhOScsXG4gICAgJ2RhcmtncmVlbic6JyMwMDY0MDAnLFxuICAgICdkYXJra2hha2knOicjYmRiNzZiJyxcbiAgICAnZGFya21hZ2VudGEnOicjOGIwMDhiJyxcbiAgICAnZGFya29saXZlZ3JlZW4nOicjNTU2YjJmJyxcbiAgICAnZGFya29yYW5nZSc6JyNmZjhjMDAnLFxuICAgICdkYXJrb3JjaGlkJzonIzk5MzJjYycsXG4gICAgJ2RhcmtyZWQnOicjOGIwMDAwJyxcbiAgICAnZGFya3NhbG1vbic6JyNlOTk2N2EnLFxuICAgICdkYXJrc2VhZ3JlZW4nOicjOGZiYzhmJyxcbiAgICAnZGFya3NsYXRlYmx1ZSc6JyM0ODNkOGInLFxuICAgICdkYXJrc2xhdGVncmF5JzonIzJmNGY0ZicsXG4gICAgJ2RhcmtzbGF0ZWdyZXknOicjMmY0ZjRmJyxcbiAgICAnZGFya3R1cnF1b2lzZSc6JyMwMGNlZDEnLFxuICAgICdkYXJrdmlvbGV0JzonIzk0MDBkMycsXG4gICAgJ2RlZXBwaW5rJzonI2ZmMTQ5MycsXG4gICAgJ2RlZXBza3libHVlJzonIzAwYmZmZicsXG4gICAgJ2RpbWdyYXknOicjNjk2OTY5JyxcbiAgICAnZGltZ3JleSc6JyM2OTY5NjknLFxuICAgICdkb2RnZXJibHVlJzonIzFlOTBmZicsXG4gICAgJ2ZpcmVicmljayc6JyNiMjIyMjInLFxuICAgICdmbG9yYWx3aGl0ZSc6JyNmZmZhZjAnLFxuICAgICdmb3Jlc3RncmVlbic6JyMyMjhiMjInLFxuICAgICdmdWNoc2lhJzonI2ZmMDBmZicsXG4gICAgJ2dhaW5zYm9ybyc6JyNkY2RjZGMnLFxuICAgICdnaG9zdHdoaXRlJzonI2Y4ZjhmZicsXG4gICAgJ2dvbGQnOicjZmZkNzAwJyxcbiAgICAnZ29sZGVucm9kJzonI2RhYTUyMCcsXG4gICAgJ2dyYXknOicjODA4MDgwJyxcbiAgICAnZ3JleSc6JyM4MDgwODAnLFxuICAgICdncmVlbic6JyMwMDgwMDAnLFxuICAgICdncmVlbnllbGxvdyc6JyNhZGZmMmYnLFxuICAgICdob25leWRldyc6JyNmMGZmZjAnLFxuICAgICdob3RwaW5rJzonI2ZmNjliNCcsXG4gICAgJ2luZGlhbnJlZCc6JyNjZDVjNWMnLFxuICAgICdpbmRpZ28nOicjNGIwMDgyJyxcbiAgICAnaXZvcnknOicjZmZmZmYwJyxcbiAgICAna2hha2knOicjZjBlNjhjJyxcbiAgICAnbGF2ZW5kZXInOicjZTZlNmZhJyxcbiAgICAnbGF2ZW5kZXJibHVzaCc6JyNmZmYwZjUnLFxuICAgICdsYXduZ3JlZW4nOicjN2NmYzAwJyxcbiAgICAnbGVtb25jaGlmZm9uJzonI2ZmZmFjZCcsXG4gICAgJ2xpZ2h0Ymx1ZSc6JyNhZGQ4ZTYnLFxuICAgICdsaWdodGNvcmFsJzonI2YwODA4MCcsXG4gICAgJ2xpZ2h0Y3lhbic6JyNlMGZmZmYnLFxuICAgICdsaWdodGdvbGRlbnJvZHllbGxvdyc6JyNmYWZhZDInLFxuICAgICdsaWdodGdyYXknOicjZDNkM2QzJyxcbiAgICAnbGlnaHRncmV5JzonI2QzZDNkMycsXG4gICAgJ2xpZ2h0Z3JlZW4nOicjOTBlZTkwJyxcbiAgICAnbGlnaHRwaW5rJzonI2ZmYjZjMScsXG4gICAgJ2xpZ2h0c2FsbW9uJzonI2ZmYTA3YScsXG4gICAgJ2xpZ2h0c2VhZ3JlZW4nOicjMjBiMmFhJyxcbiAgICAnbGlnaHRza3libHVlJzonIzg3Y2VmYScsXG4gICAgJ2xpZ2h0c2xhdGVncmF5JzonIzc3ODg5OScsXG4gICAgJ2xpZ2h0c2xhdGVncmV5JzonIzc3ODg5OScsXG4gICAgJ2xpZ2h0c3RlZWxibHVlJzonI2IwYzRkZScsXG4gICAgJ2xpZ2h0eWVsbG93JzonI2ZmZmZlMCcsXG4gICAgJ2xpbWUnOicjMDBmZjAwJyxcbiAgICAnbGltZWdyZWVuJzonIzMyY2QzMicsXG4gICAgJ2xpbmVuJzonI2ZhZjBlNicsXG4gICAgJ21hZ2VudGEnOicjZmYwMGZmJyxcbiAgICAnbWFyb29uJzonIzgwMDAwMCcsXG4gICAgJ21lZGl1bWFxdWFtYXJpbmUnOicjNjZjZGFhJyxcbiAgICAnbWVkaXVtYmx1ZSc6JyMwMDAwY2QnLFxuICAgICdtZWRpdW1vcmNoaWQnOicjYmE1NWQzJyxcbiAgICAnbWVkaXVtcHVycGxlJzonIzkzNzBkOCcsXG4gICAgJ21lZGl1bXNlYWdyZWVuJzonIzNjYjM3MScsXG4gICAgJ21lZGl1bXNsYXRlYmx1ZSc6JyM3YjY4ZWUnLFxuICAgICdtZWRpdW1zcHJpbmdncmVlbic6JyMwMGZhOWEnLFxuICAgICdtZWRpdW10dXJxdW9pc2UnOicjNDhkMWNjJyxcbiAgICAnbWVkaXVtdmlvbGV0cmVkJzonI2M3MTU4NScsXG4gICAgJ21pZG5pZ2h0Ymx1ZSc6JyMxOTE5NzAnLFxuICAgICdtaW50Y3JlYW0nOicjZjVmZmZhJyxcbiAgICAnbWlzdHlyb3NlJzonI2ZmZTRlMScsXG4gICAgJ21vY2Nhc2luJzonI2ZmZTRiNScsXG4gICAgJ25hdmFqb3doaXRlJzonI2ZmZGVhZCcsXG4gICAgJ25hdnknOicjMDAwMDgwJyxcbiAgICAnb2xkbGFjZSc6JyNmZGY1ZTYnLFxuICAgICdvbGl2ZSc6JyM4MDgwMDAnLFxuICAgICdvbGl2ZWRyYWInOicjNmI4ZTIzJyxcbiAgICAnb3JhbmdlJzonI2ZmYTUwMCcsXG4gICAgJ29yYW5nZXJlZCc6JyNmZjQ1MDAnLFxuICAgICdvcmNoaWQnOicjZGE3MGQ2JyxcbiAgICAncGFsZWdvbGRlbnJvZCc6JyNlZWU4YWEnLFxuICAgICdwYWxlZ3JlZW4nOicjOThmYjk4JyxcbiAgICAncGFsZXR1cnF1b2lzZSc6JyNhZmVlZWUnLFxuICAgICdwYWxldmlvbGV0cmVkJzonI2Q4NzA5MycsXG4gICAgJ3BhcGF5YXdoaXAnOicjZmZlZmQ1JyxcbiAgICAncGVhY2hwdWZmJzonI2ZmZGFiOScsXG4gICAgJ3BlcnUnOicjY2Q4NTNmJyxcbiAgICAncGluayc6JyNmZmMwY2InLFxuICAgICdwbHVtJzonI2RkYTBkZCcsXG4gICAgJ3Bvd2RlcmJsdWUnOicjYjBlMGU2JyxcbiAgICAncHVycGxlJzonIzgwMDA4MCcsXG4gICAgJ3JlYmVjY2FwdXJwbGUnOicjNjYzMzk5JyxcbiAgICAncmVkJzonI2ZmMDAwMCcsXG4gICAgJ3Jvc3licm93bic6JyNiYzhmOGYnLFxuICAgICdyb3lhbGJsdWUnOicjNDE2OWUxJyxcbiAgICAnc2FkZGxlYnJvd24nOicjOGI0NTEzJyxcbiAgICAnc2FsbW9uJzonI2ZhODA3MicsXG4gICAgJ3NhbmR5YnJvd24nOicjZjRhNDYwJyxcbiAgICAnc2VhZ3JlZW4nOicjMmU4YjU3JyxcbiAgICAnc2Vhc2hlbGwnOicjZmZmNWVlJyxcbiAgICAnc2llbm5hJzonI2EwNTIyZCcsXG4gICAgJ3NpbHZlcic6JyNjMGMwYzAnLFxuICAgICdza3libHVlJzonIzg3Y2VlYicsXG4gICAgJ3NsYXRlYmx1ZSc6JyM2YTVhY2QnLFxuICAgICdzbGF0ZWdyYXknOicjNzA4MDkwJyxcbiAgICAnc2xhdGVncmV5JzonIzcwODA5MCcsXG4gICAgJ3Nub3cnOicjZmZmYWZhJyxcbiAgICAnc3ByaW5nZ3JlZW4nOicjMDBmZjdmJyxcbiAgICAnc3RlZWxibHVlJzonIzQ2ODJiNCcsXG4gICAgJ3Rhbic6JyNkMmI0OGMnLFxuICAgICd0ZWFsJzonIzAwODA4MCcsXG4gICAgJ3RoaXN0bGUnOicjZDhiZmQ4JyxcbiAgICAndG9tYXRvJzonI2ZmNjM0NycsXG4gICAgJ3R1cnF1b2lzZSc6JyM0MGUwZDAnLFxuICAgICd2aW9sZXQnOicjZWU4MmVlJyxcbiAgICAnd2hlYXQnOicjZjVkZWIzJyxcbiAgICAnd2hpdGUnOicjZmZmZmZmJyxcbiAgICAnd2hpdGVzbW9rZSc6JyNmNWY1ZjUnLFxuICAgICd5ZWxsb3cnOicjZmZmZjAwJyxcbiAgICAneWVsbG93Z3JlZW4nOicjOWFjZDMyJ1xufTtcbn0se31dLDE1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGNvbG9yczogcmVxdWlyZSgnLi9jb2xvcnMnKSxcbiAgICB1bml0Q29udmVyc2lvbnM6IHJlcXVpcmUoJy4vdW5pdC1jb252ZXJzaW9ucycpXG59O1xuXG59LHtcIi4vY29sb3JzXCI6MTQsXCIuL3VuaXQtY29udmVyc2lvbnNcIjoxNn1dLDE2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGxlbmd0aDoge1xuICAgICAgICAnbSc6IDEsXG4gICAgICAgICdjbSc6IDAuMDEsXG4gICAgICAgICdtbSc6IDAuMDAxLFxuICAgICAgICAnaW4nOiAwLjAyNTQsXG4gICAgICAgICdweCc6IDAuMDI1NCAvIDk2LFxuICAgICAgICAncHQnOiAwLjAyNTQgLyA3MixcbiAgICAgICAgJ3BjJzogMC4wMjU0IC8gNzIgKiAxMlxuICAgIH0sXG4gICAgZHVyYXRpb246IHtcbiAgICAgICAgJ3MnOiAxLFxuICAgICAgICAnbXMnOiAwLjAwMVxuICAgIH0sXG4gICAgYW5nbGU6IHtcbiAgICAgICAgJ3JhZCc6IDEgLyAoMiAqIE1hdGguUEkpLFxuICAgICAgICAnZGVnJzogMSAvIDM2MCxcbiAgICAgICAgJ2dyYWQnOiAxIC8gNDAwLFxuICAgICAgICAndHVybic6IDFcbiAgICB9XG59O1xufSx7fV0sMTc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLy8gRXhwb3J0IGEgbmV3IGRlZmF1bHQgZWFjaCB0aW1lXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qIElubGluZSBKYXZhc2NyaXB0IC0gQHBsdWdpbiBzdGlsbCBhbGxvd2VkICovXG4gICAgICAgIGphdmFzY3JpcHRFbmFibGVkOiBmYWxzZSxcblxuICAgICAgICAvKiBPdXRwdXRzIGEgbWFrZWZpbGUgaW1wb3J0IGRlcGVuZGVuY3kgbGlzdCB0byBzdGRvdXQuICovXG4gICAgICAgIGRlcGVuZHM6IGZhbHNlLFxuXG4gICAgICAgIC8qIChERVBSRUNBVEVEKSBDb21wcmVzcyB1c2luZyBsZXNzIGJ1aWx0LWluIGNvbXByZXNzaW9uLiBcbiAgICAgICAgICogVGhpcyBkb2VzIGFuIG9rYXkgam9iIGJ1dCBkb2VzIG5vdCB1dGlsaXNlIGFsbCB0aGUgdHJpY2tzIG9mIFxuICAgICAgICAgKiBkZWRpY2F0ZWQgY3NzIGNvbXByZXNzaW9uLiAqL1xuICAgICAgICBjb21wcmVzczogZmFsc2UsXG5cbiAgICAgICAgLyogUnVucyB0aGUgbGVzcyBwYXJzZXIgYW5kIGp1c3QgcmVwb3J0cyBlcnJvcnMgd2l0aG91dCBhbnkgb3V0cHV0LiAqL1xuICAgICAgICBsaW50OiBmYWxzZSxcblxuICAgICAgICAvKiBTZXRzIGF2YWlsYWJsZSBpbmNsdWRlIHBhdGhzLlxuICAgICAgICAgKiBJZiB0aGUgZmlsZSBpbiBhbiBAaW1wb3J0IHJ1bGUgZG9lcyBub3QgZXhpc3QgYXQgdGhhdCBleGFjdCBsb2NhdGlvbiwgXG4gICAgICAgICAqIGxlc3Mgd2lsbCBsb29rIGZvciBpdCBhdCB0aGUgbG9jYXRpb24ocykgcGFzc2VkIHRvIHRoaXMgb3B0aW9uLiBcbiAgICAgICAgICogWW91IG1pZ2h0IHVzZSB0aGlzIGZvciBpbnN0YW5jZSB0byBzcGVjaWZ5IGEgcGF0aCB0byBhIGxpYnJhcnkgd2hpY2ggXG4gICAgICAgICAqIHlvdSB3YW50IHRvIGJlIHJlZmVyZW5jZWQgc2ltcGx5IGFuZCByZWxhdGl2ZWx5IGluIHRoZSBsZXNzIGZpbGVzLiAqL1xuICAgICAgICBwYXRoczogW10sXG5cbiAgICAgICAgLyogY29sb3Igb3V0cHV0IGluIHRoZSB0ZXJtaW5hbCAqL1xuICAgICAgICBjb2xvcjogdHJ1ZSxcblxuICAgICAgICAvKiBUaGUgc3RyaWN0SW1wb3J0cyBjb250cm9scyB3aGV0aGVyIHRoZSBjb21waWxlciB3aWxsIGFsbG93IGFuIEBpbXBvcnQgaW5zaWRlIG9mIGVpdGhlciBcbiAgICAgICAgICogQG1lZGlhIGJsb2NrcyBvciAoYSBsYXRlciBhZGRpdGlvbikgb3RoZXIgc2VsZWN0b3IgYmxvY2tzLlxuICAgICAgICAgKiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9sZXNzL2xlc3MuanMvaXNzdWVzLzY1NiAqL1xuICAgICAgICBzdHJpY3RJbXBvcnRzOiBmYWxzZSxcblxuICAgICAgICAvKiBBbGxvdyBJbXBvcnRzIGZyb20gSW5zZWN1cmUgSFRUUFMgSG9zdHMgKi9cbiAgICAgICAgaW5zZWN1cmU6IGZhbHNlLFxuXG4gICAgICAgIC8qIEFsbG93cyB5b3UgdG8gYWRkIGEgcGF0aCB0byBldmVyeSBnZW5lcmF0ZWQgaW1wb3J0IGFuZCB1cmwgaW4geW91ciBjc3MuIFxuICAgICAgICAgKiBUaGlzIGRvZXMgbm90IGFmZmVjdCBsZXNzIGltcG9ydCBzdGF0ZW1lbnRzIHRoYXQgYXJlIHByb2Nlc3NlZCwganVzdCBvbmVzIFxuICAgICAgICAgKiB0aGF0IGFyZSBsZWZ0IGluIHRoZSBvdXRwdXQgY3NzLiAqL1xuICAgICAgICByb290cGF0aDogJycsXG5cbiAgICAgICAgLyogQnkgZGVmYXVsdCBVUkxzIGFyZSBrZXB0IGFzLWlzLCBzbyBpZiB5b3UgaW1wb3J0IGEgZmlsZSBpbiBhIHN1Yi1kaXJlY3RvcnkgXG4gICAgICAgICAqIHRoYXQgcmVmZXJlbmNlcyBhbiBpbWFnZSwgZXhhY3RseSB0aGUgc2FtZSBVUkwgd2lsbCBiZSBvdXRwdXQgaW4gdGhlIGNzcy4gXG4gICAgICAgICAqIFRoaXMgb3B0aW9uIGFsbG93cyB5b3UgdG8gcmUtd3JpdGUgVVJMJ3MgaW4gaW1wb3J0ZWQgZmlsZXMgc28gdGhhdCB0aGUgXG4gICAgICAgICAqIFVSTCBpcyBhbHdheXMgcmVsYXRpdmUgdG8gdGhlIGJhc2UgaW1wb3J0ZWQgZmlsZSAqL1xuICAgICAgICByZXdyaXRlVXJsczogZmFsc2UsXG5cbiAgICAgICAgLyogQ29tcGF0aWJpbGl0eSB3aXRoIElFOC4gVXNlZCBmb3IgbGltaXRpbmcgZGF0YS11cmkgbGVuZ3RoICovXG4gICAgICAgIGllQ29tcGF0OiBmYWxzZSwgIC8vIHRydWUgdW50aWwgMy4wXG5cbiAgICAgICAgLyogSG93IHRvIHByb2Nlc3MgbWF0aCBcbiAgICAgICAgICogICAwIGFsd2F5cyAgICAgICAgICAgLSBlYWdlcmx5IHRyeSB0byBzb2x2ZSBhbGwgb3BlcmF0aW9uc1xuICAgICAgICAgKiAgIDEgcGFyZW5zLWRpdmlzaW9uICAtIHJlcXVpcmUgcGFyZW5zIGZvciBkaXZpc2lvbiBcIi9cIlxuICAgICAgICAgKiAgIDIgcGFyZW5zIHwgc3RyaWN0ICAtIHJlcXVpcmUgcGFyZW5zIGZvciBhbGwgb3BlcmF0aW9uc1xuICAgICAgICAgKiAgIDMgc3RyaWN0LWxlZ2FjeSAgICAtIGxlZ2FjeSBzdHJpY3QgYmVoYXZpb3IgKHN1cGVyLXN0cmljdClcbiAgICAgICAgICovXG4gICAgICAgIG1hdGg6IDAsXG5cbiAgICAgICAgLyogV2l0aG91dCB0aGlzIG9wdGlvbiwgbGVzcyBhdHRlbXB0cyB0byBndWVzcyBhdCB0aGUgb3V0cHV0IHVuaXQgd2hlbiBpdCBkb2VzIG1hdGhzLiAqL1xuICAgICAgICBzdHJpY3RVbml0czogZmFsc2UsXG5cbiAgICAgICAgLyogRWZmZWN0aXZlbHkgdGhlIGRlY2xhcmF0aW9uIGlzIHB1dCBhdCB0aGUgdG9wIG9mIHlvdXIgYmFzZSBMZXNzIGZpbGUsIFxuICAgICAgICAgKiBtZWFuaW5nIGl0IGNhbiBiZSB1c2VkIGJ1dCBpdCBhbHNvIGNhbiBiZSBvdmVycmlkZGVuIGlmIHRoaXMgdmFyaWFibGUgXG4gICAgICAgICAqIGlzIGRlZmluZWQgaW4gdGhlIGZpbGUuICovXG4gICAgICAgIGdsb2JhbFZhcnM6IG51bGwsXG5cbiAgICAgICAgLyogQXMgb3Bwb3NlZCB0byB0aGUgZ2xvYmFsIHZhcmlhYmxlIG9wdGlvbiwgdGhpcyBwdXRzIHRoZSBkZWNsYXJhdGlvbiBhdCB0aGVcbiAgICAgICAgICogZW5kIG9mIHlvdXIgYmFzZSBmaWxlLCBtZWFuaW5nIGl0IHdpbGwgb3ZlcnJpZGUgYW55dGhpbmcgZGVmaW5lZCBpbiB5b3VyIExlc3MgZmlsZS4gKi9cbiAgICAgICAgbW9kaWZ5VmFyczogbnVsbCxcblxuICAgICAgICAvKiBUaGlzIG9wdGlvbiBhbGxvd3MgeW91IHRvIHNwZWNpZnkgYSBhcmd1bWVudCB0byBnbyBvbiB0byBldmVyeSBVUkwuICAqL1xuICAgICAgICB1cmxBcmdzOiAnJ1xuICAgIH1cbn1cbn0se31dLDE4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBhYnN0cmFjdEZpbGVNYW5hZ2VyID0gZnVuY3Rpb24oKSB7XG59O1xuXG5hYnN0cmFjdEZpbGVNYW5hZ2VyLnByb3RvdHlwZS5nZXRQYXRoID0gZnVuY3Rpb24gKGZpbGVuYW1lKSB7XG4gICAgdmFyIGogPSBmaWxlbmFtZS5sYXN0SW5kZXhPZignPycpO1xuICAgIGlmIChqID4gMCkge1xuICAgICAgICBmaWxlbmFtZSA9IGZpbGVuYW1lLnNsaWNlKDAsIGopO1xuICAgIH1cbiAgICBqID0gZmlsZW5hbWUubGFzdEluZGV4T2YoJy8nKTtcbiAgICBpZiAoaiA8IDApIHtcbiAgICAgICAgaiA9IGZpbGVuYW1lLmxhc3RJbmRleE9mKCdcXFxcJyk7XG4gICAgfVxuICAgIGlmIChqIDwgMCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHJldHVybiBmaWxlbmFtZS5zbGljZSgwLCBqICsgMSk7XG59O1xuXG5hYnN0cmFjdEZpbGVNYW5hZ2VyLnByb3RvdHlwZS50cnlBcHBlbmRFeHRlbnNpb24gPSBmdW5jdGlvbihwYXRoLCBleHQpIHtcbiAgICByZXR1cm4gLyhcXC5bYS16XSokKXwoW1xcPztdLiopJC8udGVzdChwYXRoKSA/IHBhdGggOiBwYXRoICsgZXh0O1xufTtcblxuYWJzdHJhY3RGaWxlTWFuYWdlci5wcm90b3R5cGUudHJ5QXBwZW5kTGVzc0V4dGVuc2lvbiA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICByZXR1cm4gdGhpcy50cnlBcHBlbmRFeHRlbnNpb24ocGF0aCwgJy5sZXNzJyk7XG59O1xuXG5hYnN0cmFjdEZpbGVNYW5hZ2VyLnByb3RvdHlwZS5zdXBwb3J0c1N5bmMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5hYnN0cmFjdEZpbGVNYW5hZ2VyLnByb3RvdHlwZS5hbHdheXNNYWtlUGF0aHNBYnNvbHV0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbmFic3RyYWN0RmlsZU1hbmFnZXIucHJvdG90eXBlLmlzUGF0aEFic29sdXRlID0gZnVuY3Rpb24oZmlsZW5hbWUpIHtcbiAgICByZXR1cm4gKC9eKD86W2Etei1dKzp8XFwvfFxcXFx8IykvaSkudGVzdChmaWxlbmFtZSk7XG59O1xuLy8gVE9ETzogcHVsbCBvdXQgLyByZXBsYWNlP1xuYWJzdHJhY3RGaWxlTWFuYWdlci5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uKGJhc2VQYXRoLCBsYXRlclBhdGgpIHtcbiAgICBpZiAoIWJhc2VQYXRoKSB7XG4gICAgICAgIHJldHVybiBsYXRlclBhdGg7XG4gICAgfVxuICAgIHJldHVybiBiYXNlUGF0aCArIGxhdGVyUGF0aDtcbn07XG5cbmFic3RyYWN0RmlsZU1hbmFnZXIucHJvdG90eXBlLnBhdGhEaWZmID0gZnVuY3Rpb24gcGF0aERpZmYodXJsLCBiYXNlVXJsKSB7XG4gICAgLy8gZGlmZiBiZXR3ZWVuIHR3byBwYXRocyB0byBjcmVhdGUgYSByZWxhdGl2ZSBwYXRoXG5cbiAgICB2YXIgdXJsUGFydHMgPSB0aGlzLmV4dHJhY3RVcmxQYXJ0cyh1cmwpLFxuICAgICAgICBiYXNlVXJsUGFydHMgPSB0aGlzLmV4dHJhY3RVcmxQYXJ0cyhiYXNlVXJsKSxcbiAgICAgICAgaSwgbWF4LCB1cmxEaXJlY3RvcmllcywgYmFzZVVybERpcmVjdG9yaWVzLCBkaWZmID0gJyc7XG4gICAgaWYgKHVybFBhcnRzLmhvc3RQYXJ0ICE9PSBiYXNlVXJsUGFydHMuaG9zdFBhcnQpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBtYXggPSBNYXRoLm1heChiYXNlVXJsUGFydHMuZGlyZWN0b3JpZXMubGVuZ3RoLCB1cmxQYXJ0cy5kaXJlY3Rvcmllcy5sZW5ndGgpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBtYXg7IGkrKykge1xuICAgICAgICBpZiAoYmFzZVVybFBhcnRzLmRpcmVjdG9yaWVzW2ldICE9PSB1cmxQYXJ0cy5kaXJlY3Rvcmllc1tpXSkgeyBicmVhazsgfVxuICAgIH1cbiAgICBiYXNlVXJsRGlyZWN0b3JpZXMgPSBiYXNlVXJsUGFydHMuZGlyZWN0b3JpZXMuc2xpY2UoaSk7XG4gICAgdXJsRGlyZWN0b3JpZXMgPSB1cmxQYXJ0cy5kaXJlY3Rvcmllcy5zbGljZShpKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgYmFzZVVybERpcmVjdG9yaWVzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICBkaWZmICs9ICcuLi8nO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgdXJsRGlyZWN0b3JpZXMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIGRpZmYgKz0gdXJsRGlyZWN0b3JpZXNbaV0gKyAnLyc7XG4gICAgfVxuICAgIHJldHVybiBkaWZmO1xufTtcbi8vIGhlbHBlciBmdW5jdGlvbiwgbm90IHBhcnQgb2YgQVBJXG5hYnN0cmFjdEZpbGVNYW5hZ2VyLnByb3RvdHlwZS5leHRyYWN0VXJsUGFydHMgPSBmdW5jdGlvbiBleHRyYWN0VXJsUGFydHModXJsLCBiYXNlVXJsKSB7XG4gICAgLy8gdXJsUGFydHNbMV0gPSBwcm90b2NvbDovL2hvc3RuYW1lLyBPUiAvXG4gICAgLy8gdXJsUGFydHNbMl0gPSAvIGlmIHBhdGggcmVsYXRpdmUgdG8gaG9zdCBiYXNlXG4gICAgLy8gdXJsUGFydHNbM10gPSBkaXJlY3Rvcmllc1xuICAgIC8vIHVybFBhcnRzWzRdID0gZmlsZW5hbWVcbiAgICAvLyB1cmxQYXJ0c1s1XSA9IHBhcmFtZXRlcnNcblxuICAgIHZhciB1cmxQYXJ0c1JlZ2V4ID0gL14oKD86W2Etei1dKzopP1xcL3syfSg/OlteXFwvXFw/I10qXFwvKXwoW1xcL1xcXFxdKSk/KCg/OlteXFwvXFxcXFxcPyNdKltcXC9cXFxcXSkqKShbXlxcL1xcXFxcXD8jXSopKFsjXFw/XS4qKT8kL2ksXG4gICAgICAgIHVybFBhcnRzID0gdXJsLm1hdGNoKHVybFBhcnRzUmVnZXgpLFxuICAgICAgICByZXR1cm5lciA9IHt9LCByYXdEaXJlY3RvcmllcyA9IFtdLCBkaXJlY3RvcmllcyA9IFtdLCBpLCBiYXNlVXJsUGFydHM7XG5cbiAgICBpZiAoIXVybFBhcnRzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IHBhcnNlIHNoZWV0IGhyZWYgLSBcXCcnICsgdXJsICsgJ1xcJycpO1xuICAgIH1cblxuICAgIC8vIFN0eWxlc2hlZXRzIGluIElFIGRvbid0IGFsd2F5cyByZXR1cm4gdGhlIGZ1bGwgcGF0aFxuICAgIGlmIChiYXNlVXJsICYmICghdXJsUGFydHNbMV0gfHwgdXJsUGFydHNbMl0pKSB7XG4gICAgICAgIGJhc2VVcmxQYXJ0cyA9IGJhc2VVcmwubWF0Y2godXJsUGFydHNSZWdleCk7XG4gICAgICAgIGlmICghYmFzZVVybFBhcnRzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBwYXJzZSBwYWdlIHVybCAtIFxcJycgKyBiYXNlVXJsICsgJ1xcJycpO1xuICAgICAgICB9XG4gICAgICAgIHVybFBhcnRzWzFdID0gdXJsUGFydHNbMV0gfHwgYmFzZVVybFBhcnRzWzFdIHx8ICcnO1xuICAgICAgICBpZiAoIXVybFBhcnRzWzJdKSB7XG4gICAgICAgICAgICB1cmxQYXJ0c1szXSA9IGJhc2VVcmxQYXJ0c1szXSArIHVybFBhcnRzWzNdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHVybFBhcnRzWzNdKSB7XG4gICAgICAgIHJhd0RpcmVjdG9yaWVzID0gdXJsUGFydHNbM10ucmVwbGFjZSgvXFxcXC9nLCAnLycpLnNwbGl0KCcvJyk7XG5cbiAgICAgICAgLy8gY29sbGFwc2UgJy4uJyBhbmQgc2tpcCAnLidcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHJhd0RpcmVjdG9yaWVzLmxlbmd0aDsgaSsrKSB7XG5cbiAgICAgICAgICAgIGlmIChyYXdEaXJlY3Rvcmllc1tpXSA9PT0gJy4uJykge1xuICAgICAgICAgICAgICAgIGRpcmVjdG9yaWVzLnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmF3RGlyZWN0b3JpZXNbaV0gIT09ICcuJykge1xuICAgICAgICAgICAgICAgIGRpcmVjdG9yaWVzLnB1c2gocmF3RGlyZWN0b3JpZXNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybmVyLmhvc3RQYXJ0ID0gdXJsUGFydHNbMV07XG4gICAgcmV0dXJuZXIuZGlyZWN0b3JpZXMgPSBkaXJlY3RvcmllcztcbiAgICByZXR1cm5lci5yYXdQYXRoID0gKHVybFBhcnRzWzFdIHx8ICcnKSArIHJhd0RpcmVjdG9yaWVzLmpvaW4oJy8nKTtcbiAgICByZXR1cm5lci5wYXRoID0gKHVybFBhcnRzWzFdIHx8ICcnKSArIGRpcmVjdG9yaWVzLmpvaW4oJy8nKTtcbiAgICByZXR1cm5lci5maWxlbmFtZSA9IHVybFBhcnRzWzRdO1xuICAgIHJldHVybmVyLmZpbGVVcmwgPSByZXR1cm5lci5wYXRoICsgKHVybFBhcnRzWzRdIHx8ICcnKTtcbiAgICByZXR1cm5lci51cmwgPSByZXR1cm5lci5maWxlVXJsICsgKHVybFBhcnRzWzVdIHx8ICcnKTtcbiAgICByZXR1cm4gcmV0dXJuZXI7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGFic3RyYWN0RmlsZU1hbmFnZXI7XG5cbn0se31dLDE5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBmdW5jdGlvblJlZ2lzdHJ5ID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL2Z1bmN0aW9uLXJlZ2lzdHJ5JyksXG4gICAgTGVzc0Vycm9yID0gcmVxdWlyZSgnLi4vbGVzcy1lcnJvcicpO1xuXG52YXIgQWJzdHJhY3RQbHVnaW5Mb2FkZXIgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBJbXBsZW1lbnRlZCBieSBOb2RlLmpzIHBsdWdpbiBsb2FkZXJcbiAgICB0aGlzLnJlcXVpcmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufTtcblxuQWJzdHJhY3RQbHVnaW5Mb2FkZXIucHJvdG90eXBlLmV2YWxQbHVnaW4gPSBmdW5jdGlvbihjb250ZW50cywgY29udGV4dCwgaW1wb3J0cywgcGx1Z2luT3B0aW9ucywgZmlsZUluZm8pIHtcblxuICAgIHZhciBsb2FkZXIsXG4gICAgICAgIHJlZ2lzdHJ5LFxuICAgICAgICBwbHVnaW5PYmosXG4gICAgICAgIGxvY2FsTW9kdWxlLFxuICAgICAgICBwbHVnaW5NYW5hZ2VyLFxuICAgICAgICBmaWxlbmFtZSxcbiAgICAgICAgcmVzdWx0O1xuXG4gICAgcGx1Z2luTWFuYWdlciA9IGNvbnRleHQucGx1Z2luTWFuYWdlcjtcblxuICAgIGlmIChmaWxlSW5mbykge1xuICAgICAgICBpZiAodHlwZW9mIGZpbGVJbmZvID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZmlsZW5hbWUgPSBmaWxlSW5mbztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZpbGVuYW1lID0gZmlsZUluZm8uZmlsZW5hbWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIHNob3J0bmFtZSA9IChuZXcgdGhpcy5sZXNzLkZpbGVNYW5hZ2VyKCkpLmV4dHJhY3RVcmxQYXJ0cyhmaWxlbmFtZSkuZmlsZW5hbWU7XG5cbiAgICBpZiAoZmlsZW5hbWUpIHtcbiAgICAgICAgcGx1Z2luT2JqID0gcGx1Z2luTWFuYWdlci5nZXQoZmlsZW5hbWUpO1xuXG4gICAgICAgIGlmIChwbHVnaW5PYmopIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMudHJ5U2V0T3B0aW9ucyhwbHVnaW5PYmosIGZpbGVuYW1lLCBzaG9ydG5hbWUsIHBsdWdpbk9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChwbHVnaW5PYmoudXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHBsdWdpbk9iai51c2UuY2FsbCh0aGlzLmNvbnRleHQsIHBsdWdpbk9iaik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBlLm1lc3NhZ2UgPSBlLm1lc3NhZ2UgfHwgJ0Vycm9yIGR1cmluZyBAcGx1Z2luIGNhbGwnO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTGVzc0Vycm9yKGUsIGltcG9ydHMsIGZpbGVuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwbHVnaW5PYmo7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbG9jYWxNb2R1bGUgPSB7XG4gICAgICAgIGV4cG9ydHM6IHt9LFxuICAgICAgICBwbHVnaW5NYW5hZ2VyOiBwbHVnaW5NYW5hZ2VyLFxuICAgICAgICBmaWxlSW5mbzogZmlsZUluZm9cbiAgICB9O1xuICAgIHJlZ2lzdHJ5ID0gZnVuY3Rpb25SZWdpc3RyeS5jcmVhdGUoKTtcblxuICAgIHZhciByZWdpc3RlclBsdWdpbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICBwbHVnaW5PYmogPSBvYmo7XG4gICAgfTtcblxuICAgIHRyeSB7XG4gICAgICAgIGxvYWRlciA9IG5ldyBGdW5jdGlvbignbW9kdWxlJywgJ3JlcXVpcmUnLCAncmVnaXN0ZXJQbHVnaW4nLCAnZnVuY3Rpb25zJywgJ3RyZWUnLCAnbGVzcycsICdmaWxlSW5mbycsIGNvbnRlbnRzKTtcbiAgICAgICAgbG9hZGVyKGxvY2FsTW9kdWxlLCB0aGlzLnJlcXVpcmUoZmlsZW5hbWUpLCByZWdpc3RlclBsdWdpbiwgcmVnaXN0cnksIHRoaXMubGVzcy50cmVlLCB0aGlzLmxlc3MsIGZpbGVJbmZvKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMZXNzRXJyb3IoZSwgaW1wb3J0cywgZmlsZW5hbWUpO1xuICAgIH1cblxuICAgIGlmICghcGx1Z2luT2JqKSB7XG4gICAgICAgIHBsdWdpbk9iaiA9IGxvY2FsTW9kdWxlLmV4cG9ydHM7XG4gICAgfVxuICAgIHBsdWdpbk9iaiA9IHRoaXMudmFsaWRhdGVQbHVnaW4ocGx1Z2luT2JqLCBmaWxlbmFtZSwgc2hvcnRuYW1lKTtcblxuICAgIGlmIChwbHVnaW5PYmogaW5zdGFuY2VvZiBMZXNzRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHBsdWdpbk9iajtcbiAgICB9XG5cbiAgICBpZiAocGx1Z2luT2JqKSB7XG4gICAgICAgIHBsdWdpbk9iai5pbXBvcnRzID0gaW1wb3J0cztcbiAgICAgICAgcGx1Z2luT2JqLmZpbGVuYW1lID0gZmlsZW5hbWU7XG5cbiAgICAgICAgLy8gRm9yIDwgMy54IChvciB1bnNwZWNpZmllZCBtaW5WZXJzaW9uKSAtIHNldE9wdGlvbnMoKSBiZWZvcmUgaW5zdGFsbCgpXG4gICAgICAgIGlmICghcGx1Z2luT2JqLm1pblZlcnNpb24gfHwgdGhpcy5jb21wYXJlVmVyc2lvbignMy4wLjAnLCBwbHVnaW5PYmoubWluVmVyc2lvbikgPCAwKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLnRyeVNldE9wdGlvbnMocGx1Z2luT2JqLCBmaWxlbmFtZSwgc2hvcnRuYW1lLCBwbHVnaW5PcHRpb25zKTtcblxuICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSdW4gb24gZmlyc3QgbG9hZFxuICAgICAgICBwbHVnaW5NYW5hZ2VyLmFkZFBsdWdpbihwbHVnaW5PYmosIGZpbGVJbmZvLmZpbGVuYW1lLCByZWdpc3RyeSk7XG4gICAgICAgIHBsdWdpbk9iai5mdW5jdGlvbnMgPSByZWdpc3RyeS5nZXRMb2NhbEZ1bmN0aW9ucygpO1xuXG4gICAgICAgIC8vIE5lZWQgdG8gY2FsbCBzZXRPcHRpb25zIGFnYWluIGJlY2F1c2UgdGhlIHBsdWdpbk9iaiBtaWdodCBoYXZlIGZ1bmN0aW9uc1xuICAgICAgICByZXN1bHQgPSB0aGlzLnRyeVNldE9wdGlvbnMocGx1Z2luT2JqLCBmaWxlbmFtZSwgc2hvcnRuYW1lLCBwbHVnaW5PcHRpb25zKTtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJ1biBldmVyeSBAcGx1Z2luIGNhbGxcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChwbHVnaW5PYmoudXNlKSB7XG4gICAgICAgICAgICAgICAgcGx1Z2luT2JqLnVzZS5jYWxsKHRoaXMuY29udGV4dCwgcGx1Z2luT2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZS5tZXNzYWdlID0gZS5tZXNzYWdlIHx8ICdFcnJvciBkdXJpbmcgQHBsdWdpbiBjYWxsJztcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGVzc0Vycm9yKGUsIGltcG9ydHMsIGZpbGVuYW1lKTtcbiAgICAgICAgfVxuXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IExlc3NFcnJvcih7IG1lc3NhZ2U6ICdOb3QgYSB2YWxpZCBwbHVnaW4nIH0sIGltcG9ydHMsIGZpbGVuYW1lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGx1Z2luT2JqO1xuXG59O1xuXG5BYnN0cmFjdFBsdWdpbkxvYWRlci5wcm90b3R5cGUudHJ5U2V0T3B0aW9ucyA9IGZ1bmN0aW9uKHBsdWdpbiwgZmlsZW5hbWUsIG5hbWUsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyAmJiAhcGx1Z2luLnNldE9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMZXNzRXJyb3Ioe1xuICAgICAgICAgICAgbWVzc2FnZTogJ09wdGlvbnMgaGF2ZSBiZWVuIHByb3ZpZGVkIGJ1dCB0aGUgcGx1Z2luICcgK1xuICAgICAgICAgICAgICAgIG5hbWUgKyAnIGRvZXMgbm90IHN1cHBvcnQgYW55IG9wdGlvbnMuJ1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgcGx1Z2luLnNldE9wdGlvbnMgJiYgcGx1Z2luLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBuZXcgTGVzc0Vycm9yKGUpO1xuICAgIH1cbn07XG5cbkFic3RyYWN0UGx1Z2luTG9hZGVyLnByb3RvdHlwZS52YWxpZGF0ZVBsdWdpbiA9IGZ1bmN0aW9uKHBsdWdpbiwgZmlsZW5hbWUsIG5hbWUpIHtcbiAgICBpZiAocGx1Z2luKSB7XG4gICAgICAgIC8vIHN1cHBvcnQgcGx1Z2lucyBiZWluZyBhIGZ1bmN0aW9uXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlIHBsdWdpbiBjYW4gYmUgbW9yZSB1c2FibGUgcHJvZ3JhbW1hdGljYWxseVxuICAgICAgICBpZiAodHlwZW9mIHBsdWdpbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcGx1Z2luID0gbmV3IHBsdWdpbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBsdWdpbi5taW5WZXJzaW9uKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb21wYXJlVmVyc2lvbihwbHVnaW4ubWluVmVyc2lvbiwgdGhpcy5sZXNzLnZlcnNpb24pIDwgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTGVzc0Vycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ1BsdWdpbiAnICsgbmFtZSArICcgcmVxdWlyZXMgdmVyc2lvbiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmVyc2lvblRvU3RyaW5nKHBsdWdpbi5taW5WZXJzaW9uKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwbHVnaW47XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufTtcblxuQWJzdHJhY3RQbHVnaW5Mb2FkZXIucHJvdG90eXBlLmNvbXBhcmVWZXJzaW9uID0gZnVuY3Rpb24oYVZlcnNpb24sIGJWZXJzaW9uKSB7XG4gICAgaWYgKHR5cGVvZiBhVmVyc2lvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgYVZlcnNpb24gPSBhVmVyc2lvbi5tYXRjaCgvXihcXGQrKVxcLj8oXFxkKyk/XFwuPyhcXGQrKT8vKTtcbiAgICAgICAgYVZlcnNpb24uc2hpZnQoKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhVmVyc2lvbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYVZlcnNpb25baV0gIT09IGJWZXJzaW9uW2ldKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQoYVZlcnNpb25baV0pID4gcGFyc2VJbnQoYlZlcnNpb25baV0pID8gLTEgOiAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAwO1xufTtcbkFic3RyYWN0UGx1Z2luTG9hZGVyLnByb3RvdHlwZS52ZXJzaW9uVG9TdHJpbmcgPSBmdW5jdGlvbih2ZXJzaW9uKSB7XG4gICAgdmFyIHZlcnNpb25TdHJpbmcgPSAnJztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZlcnNpb24ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmVyc2lvblN0cmluZyArPSAodmVyc2lvblN0cmluZyA/ICcuJyA6ICcnKSArIHZlcnNpb25baV07XG4gICAgfVxuICAgIHJldHVybiB2ZXJzaW9uU3RyaW5nO1xufTtcbkFic3RyYWN0UGx1Z2luTG9hZGVyLnByb3RvdHlwZS5wcmludFVzYWdlID0gZnVuY3Rpb24ocGx1Z2lucykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGx1Z2lucy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcGx1Z2luID0gcGx1Z2luc1tpXTtcbiAgICAgICAgaWYgKHBsdWdpbi5wcmludFVzYWdlKSB7XG4gICAgICAgICAgICBwbHVnaW4ucHJpbnRVc2FnZSgpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBYnN0cmFjdFBsdWdpbkxvYWRlcjtcblxuXG59LHtcIi4uL2Z1bmN0aW9ucy9mdW5jdGlvbi1yZWdpc3RyeVwiOjI3LFwiLi4vbGVzcy1lcnJvclwiOjM4fV0sMjA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBAdG9kbyBEb2N1bWVudCB3aHkgdGhpcyBhYnN0cmFjdGlvbiBleGlzdHMsIGFuZCB0aGUgcmVsYXRpb25zaGlwIGJldHdlZW5cbiAqICAgICAgIGVudmlyb25tZW50LCBmaWxlIG1hbmFnZXJzLCBhbmQgcGx1Z2luIG1hbmFnZXJcbiAqL1xuXG52YXIgbG9nZ2VyID0gcmVxdWlyZSgnLi4vbG9nZ2VyJyk7XG52YXIgZW52aXJvbm1lbnQgPSBmdW5jdGlvbihleHRlcm5hbEVudmlyb25tZW50LCBmaWxlTWFuYWdlcnMpIHtcbiAgICB0aGlzLmZpbGVNYW5hZ2VycyA9IGZpbGVNYW5hZ2VycyB8fCBbXTtcbiAgICBleHRlcm5hbEVudmlyb25tZW50ID0gZXh0ZXJuYWxFbnZpcm9ubWVudCB8fCB7fTtcblxuICAgIHZhciBvcHRpb25hbEZ1bmN0aW9ucyA9IFsnZW5jb2RlQmFzZTY0JywgJ21pbWVMb29rdXAnLCAnY2hhcnNldExvb2t1cCcsICdnZXRTb3VyY2VNYXBHZW5lcmF0b3InXSxcbiAgICAgICAgcmVxdWlyZWRGdW5jdGlvbnMgPSBbXSxcbiAgICAgICAgZnVuY3Rpb25zID0gcmVxdWlyZWRGdW5jdGlvbnMuY29uY2F0KG9wdGlvbmFsRnVuY3Rpb25zKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnVuY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwcm9wTmFtZSA9IGZ1bmN0aW9uc1tpXSxcbiAgICAgICAgICAgIGVudmlyb25tZW50RnVuYyA9IGV4dGVybmFsRW52aXJvbm1lbnRbcHJvcE5hbWVdO1xuICAgICAgICBpZiAoZW52aXJvbm1lbnRGdW5jKSB7XG4gICAgICAgICAgICB0aGlzW3Byb3BOYW1lXSA9IGVudmlyb25tZW50RnVuYy5iaW5kKGV4dGVybmFsRW52aXJvbm1lbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKGkgPCByZXF1aXJlZEZ1bmN0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMud2FybignbWlzc2luZyByZXF1aXJlZCBmdW5jdGlvbiBpbiBlbnZpcm9ubWVudCAtICcgKyBwcm9wTmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5lbnZpcm9ubWVudC5wcm90b3R5cGUuZ2V0RmlsZU1hbmFnZXIgPSBmdW5jdGlvbiAoZmlsZW5hbWUsIGN1cnJlbnREaXJlY3RvcnksIG9wdGlvbnMsIGVudmlyb25tZW50LCBpc1N5bmMpIHtcblxuICAgIGlmICghZmlsZW5hbWUpIHtcbiAgICAgICAgbG9nZ2VyLndhcm4oJ2dldEZpbGVNYW5hZ2VyIGNhbGxlZCB3aXRoIG5vIGZpbGVuYW1lLi4gUGxlYXNlIHJlcG9ydCB0aGlzIGlzc3VlLiBjb250aW51aW5nLicpO1xuICAgIH1cbiAgICBpZiAoY3VycmVudERpcmVjdG9yeSA9PSBudWxsKSB7XG4gICAgICAgIGxvZ2dlci53YXJuKCdnZXRGaWxlTWFuYWdlciBjYWxsZWQgd2l0aCBudWxsIGRpcmVjdG9yeS4uIFBsZWFzZSByZXBvcnQgdGhpcyBpc3N1ZS4gY29udGludWluZy4nKTtcbiAgICB9XG5cbiAgICB2YXIgZmlsZU1hbmFnZXJzID0gdGhpcy5maWxlTWFuYWdlcnM7XG4gICAgaWYgKG9wdGlvbnMucGx1Z2luTWFuYWdlcikge1xuICAgICAgICBmaWxlTWFuYWdlcnMgPSBbXS5jb25jYXQoZmlsZU1hbmFnZXJzKS5jb25jYXQob3B0aW9ucy5wbHVnaW5NYW5hZ2VyLmdldEZpbGVNYW5hZ2VycygpKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IGZpbGVNYW5hZ2Vycy5sZW5ndGggLSAxOyBpID49IDAgOyBpLS0pIHtcbiAgICAgICAgdmFyIGZpbGVNYW5hZ2VyID0gZmlsZU1hbmFnZXJzW2ldO1xuICAgICAgICBpZiAoZmlsZU1hbmFnZXJbaXNTeW5jID8gJ3N1cHBvcnRzU3luYycgOiAnc3VwcG9ydHMnXShmaWxlbmFtZSwgY3VycmVudERpcmVjdG9yeSwgb3B0aW9ucywgZW52aXJvbm1lbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmlsZU1hbmFnZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG5lbnZpcm9ubWVudC5wcm90b3R5cGUuYWRkRmlsZU1hbmFnZXIgPSBmdW5jdGlvbiAoZmlsZU1hbmFnZXIpIHtcbiAgICB0aGlzLmZpbGVNYW5hZ2Vycy5wdXNoKGZpbGVNYW5hZ2VyKTtcbn07XG5cbmVudmlyb25tZW50LnByb3RvdHlwZS5jbGVhckZpbGVNYW5hZ2VycyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZpbGVNYW5hZ2VycyA9IFtdO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBlbnZpcm9ubWVudDtcblxufSx7XCIuLi9sb2dnZXJcIjozOX1dLDIxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblxudmFyIGZ1bmN0aW9uUmVnaXN0cnkgPSByZXF1aXJlKCcuL2Z1bmN0aW9uLXJlZ2lzdHJ5JyksXG4gICAgQW5vbnltb3VzID0gcmVxdWlyZSgnLi4vdHJlZS9hbm9ueW1vdXMnKSxcbiAgICBLZXl3b3JkID0gcmVxdWlyZSgnLi4vdHJlZS9rZXl3b3JkJyk7XG5cbmZ1bmN0aW9uUmVnaXN0cnkuYWRkTXVsdGlwbGUoe1xuICAgIGJvb2xlYW46IGZ1bmN0aW9uKGNvbmRpdGlvbikge1xuICAgICAgICByZXR1cm4gY29uZGl0aW9uID8gS2V5d29yZC5UcnVlIDogS2V5d29yZC5GYWxzZTtcbiAgICB9LFxuXG4gICAgJ2lmJzogZnVuY3Rpb24oY29uZGl0aW9uLCB0cnVlVmFsdWUsIGZhbHNlVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGNvbmRpdGlvbiA/IHRydWVWYWx1ZVxuICAgICAgICAgICAgOiAoZmFsc2VWYWx1ZSB8fCBuZXcgQW5vbnltb3VzKTtcbiAgICB9XG59KTtcblxufSx7XCIuLi90cmVlL2Fub255bW91c1wiOjUwLFwiLi4vdHJlZS9rZXl3b3JkXCI6NzAsXCIuL2Z1bmN0aW9uLXJlZ2lzdHJ5XCI6Mjd9XSwyMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgQ29sb3IgPSByZXF1aXJlKCcuLi90cmVlL2NvbG9yJyksXG4gICAgZnVuY3Rpb25SZWdpc3RyeSA9IHJlcXVpcmUoJy4vZnVuY3Rpb24tcmVnaXN0cnknKTtcblxuLy8gQ29sb3IgQmxlbmRpbmdcbi8vIHJlZjogaHR0cDovL3d3dy53My5vcmcvVFIvY29tcG9zaXRpbmctMVxuXG5mdW5jdGlvbiBjb2xvckJsZW5kKG1vZGUsIGNvbG9yMSwgY29sb3IyKSB7XG4gICAgdmFyIGFiID0gY29sb3IxLmFscGhhLCBjYiwgLy8gYmFja2Ryb3BcbiAgICAgICAgYXMgPSBjb2xvcjIuYWxwaGEsIGNzLCAvLyBzb3VyY2VcbiAgICAgICAgYXIsIGNyLCByID0gW107ICAgICAgICAvLyByZXN1bHRcblxuICAgIGFyID0gYXMgKyBhYiAqICgxIC0gYXMpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgIGNiID0gY29sb3IxLnJnYltpXSAvIDI1NTtcbiAgICAgICAgY3MgPSBjb2xvcjIucmdiW2ldIC8gMjU1O1xuICAgICAgICBjciA9IG1vZGUoY2IsIGNzKTtcbiAgICAgICAgaWYgKGFyKSB7XG4gICAgICAgICAgICBjciA9IChhcyAqIGNzICsgYWIgKiAoY2IgLVxuICAgICAgICAgICAgICAgICAgYXMgKiAoY2IgKyBjcyAtIGNyKSkpIC8gYXI7XG4gICAgICAgIH1cbiAgICAgICAgcltpXSA9IGNyICogMjU1O1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgQ29sb3IociwgYXIpO1xufVxuXG52YXIgY29sb3JCbGVuZE1vZGVGdW5jdGlvbnMgPSB7XG4gICAgbXVsdGlwbHk6IGZ1bmN0aW9uKGNiLCBjcykge1xuICAgICAgICByZXR1cm4gY2IgKiBjcztcbiAgICB9LFxuICAgIHNjcmVlbjogZnVuY3Rpb24oY2IsIGNzKSB7XG4gICAgICAgIHJldHVybiBjYiArIGNzIC0gY2IgKiBjcztcbiAgICB9LFxuICAgIG92ZXJsYXk6IGZ1bmN0aW9uKGNiLCBjcykge1xuICAgICAgICBjYiAqPSAyO1xuICAgICAgICByZXR1cm4gKGNiIDw9IDEpID9cbiAgICAgICAgICAgIGNvbG9yQmxlbmRNb2RlRnVuY3Rpb25zLm11bHRpcGx5KGNiLCBjcykgOlxuICAgICAgICAgICAgY29sb3JCbGVuZE1vZGVGdW5jdGlvbnMuc2NyZWVuKGNiIC0gMSwgY3MpO1xuICAgIH0sXG4gICAgc29mdGxpZ2h0OiBmdW5jdGlvbihjYiwgY3MpIHtcbiAgICAgICAgdmFyIGQgPSAxLCBlID0gY2I7XG4gICAgICAgIGlmIChjcyA+IDAuNSkge1xuICAgICAgICAgICAgZSA9IDE7XG4gICAgICAgICAgICBkID0gKGNiID4gMC4yNSkgPyBNYXRoLnNxcnQoY2IpXG4gICAgICAgICAgICAgICAgOiAoKDE2ICogY2IgLSAxMikgKiBjYiArIDQpICogY2I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNiIC0gKDEgLSAyICogY3MpICogZSAqIChkIC0gY2IpO1xuICAgIH0sXG4gICAgaGFyZGxpZ2h0OiBmdW5jdGlvbihjYiwgY3MpIHtcbiAgICAgICAgcmV0dXJuIGNvbG9yQmxlbmRNb2RlRnVuY3Rpb25zLm92ZXJsYXkoY3MsIGNiKTtcbiAgICB9LFxuICAgIGRpZmZlcmVuY2U6IGZ1bmN0aW9uKGNiLCBjcykge1xuICAgICAgICByZXR1cm4gTWF0aC5hYnMoY2IgLSBjcyk7XG4gICAgfSxcbiAgICBleGNsdXNpb246IGZ1bmN0aW9uKGNiLCBjcykge1xuICAgICAgICByZXR1cm4gY2IgKyBjcyAtIDIgKiBjYiAqIGNzO1xuICAgIH0sXG5cbiAgICAvLyBub24tdzNjIGZ1bmN0aW9uczpcbiAgICBhdmVyYWdlOiBmdW5jdGlvbihjYiwgY3MpIHtcbiAgICAgICAgcmV0dXJuIChjYiArIGNzKSAvIDI7XG4gICAgfSxcbiAgICBuZWdhdGlvbjogZnVuY3Rpb24oY2IsIGNzKSB7XG4gICAgICAgIHJldHVybiAxIC0gTWF0aC5hYnMoY2IgKyBjcyAtIDEpO1xuICAgIH1cbn07XG5cbmZvciAodmFyIGYgaW4gY29sb3JCbGVuZE1vZGVGdW5jdGlvbnMpIHtcbiAgICBpZiAoY29sb3JCbGVuZE1vZGVGdW5jdGlvbnMuaGFzT3duUHJvcGVydHkoZikpIHtcbiAgICAgICAgY29sb3JCbGVuZFtmXSA9IGNvbG9yQmxlbmQuYmluZChudWxsLCBjb2xvckJsZW5kTW9kZUZ1bmN0aW9uc1tmXSk7XG4gICAgfVxufVxuXG5mdW5jdGlvblJlZ2lzdHJ5LmFkZE11bHRpcGxlKGNvbG9yQmxlbmQpO1xuXG59LHtcIi4uL3RyZWUvY29sb3JcIjo1NSxcIi4vZnVuY3Rpb24tcmVnaXN0cnlcIjoyN31dLDIzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBEaW1lbnNpb24gPSByZXF1aXJlKCcuLi90cmVlL2RpbWVuc2lvbicpLFxuICAgIENvbG9yID0gcmVxdWlyZSgnLi4vdHJlZS9jb2xvcicpLFxuICAgIFF1b3RlZCA9IHJlcXVpcmUoJy4uL3RyZWUvcXVvdGVkJyksXG4gICAgQW5vbnltb3VzID0gcmVxdWlyZSgnLi4vdHJlZS9hbm9ueW1vdXMnKSxcbiAgICBmdW5jdGlvblJlZ2lzdHJ5ID0gcmVxdWlyZSgnLi9mdW5jdGlvbi1yZWdpc3RyeScpLFxuICAgIGNvbG9yRnVuY3Rpb25zO1xuXG5mdW5jdGlvbiBjbGFtcCh2YWwpIHtcbiAgICByZXR1cm4gTWF0aC5taW4oMSwgTWF0aC5tYXgoMCwgdmFsKSk7XG59XG5mdW5jdGlvbiBoc2xhKG9yaWdDb2xvciwgaHNsKSB7XG4gICAgdmFyIGNvbG9yID0gY29sb3JGdW5jdGlvbnMuaHNsYShoc2wuaCwgaHNsLnMsIGhzbC5sLCBoc2wuYSk7XG4gICAgaWYgKGNvbG9yKSB7XG4gICAgICAgIGlmIChvcmlnQ29sb3IudmFsdWUgJiYgXG4gICAgICAgICAgICAvXihyZ2J8aHNsKS8udGVzdChvcmlnQ29sb3IudmFsdWUpKSB7XG4gICAgICAgICAgICBjb2xvci52YWx1ZSA9IG9yaWdDb2xvci52YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbG9yLnZhbHVlID0gJ3JnYic7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbG9yO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG51bWJlcihuKSB7XG4gICAgaWYgKG4gaW5zdGFuY2VvZiBEaW1lbnNpb24pIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQobi51bml0LmlzKCclJykgPyBuLnZhbHVlIC8gMTAwIDogbi52YWx1ZSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIG47XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgdHlwZTogJ0FyZ3VtZW50JyxcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdjb2xvciBmdW5jdGlvbnMgdGFrZSBudW1iZXJzIGFzIHBhcmFtZXRlcnMnXG4gICAgICAgIH07XG4gICAgfVxufVxuZnVuY3Rpb24gc2NhbGVkKG4sIHNpemUpIHtcbiAgICBpZiAobiBpbnN0YW5jZW9mIERpbWVuc2lvbiAmJiBuLnVuaXQuaXMoJyUnKSkge1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChuLnZhbHVlICogc2l6ZSAvIDEwMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bWJlcihuKTtcbiAgICB9XG59XG5jb2xvckZ1bmN0aW9ucyA9IHtcbiAgICByZ2I6IGZ1bmN0aW9uIChyLCBnLCBiKSB7XG4gICAgICAgIHZhciBjb2xvciA9IGNvbG9yRnVuY3Rpb25zLnJnYmEociwgZywgYiwgMS4wKTtcbiAgICAgICAgaWYgKGNvbG9yKSB7XG4gICAgICAgICAgICBjb2xvci52YWx1ZSA9ICdyZ2InO1xuICAgICAgICAgICAgcmV0dXJuIGNvbG9yO1xuICAgICAgICB9XG4gICAgfSxcbiAgICByZ2JhOiBmdW5jdGlvbiAociwgZywgYiwgYSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgaW5zdGFuY2VvZiBDb2xvcikge1xuICAgICAgICAgICAgICAgIGlmIChnKSB7XG4gICAgICAgICAgICAgICAgICAgIGEgPSBudW1iZXIoZyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYSA9IHIuYWxwaGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29sb3Ioci5yZ2IsIGEsICdyZ2JhJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmdiID0gW3IsIGcsIGJdLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gc2NhbGVkKGMsIDI1NSk7IH0pO1xuICAgICAgICAgICAgYSA9IG51bWJlcihhKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29sb3IocmdiLCBhLCAncmdiYScpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7fVxuICAgIH0sXG4gICAgaHNsOiBmdW5jdGlvbiAoaCwgcywgbCkge1xuICAgICAgICB2YXIgY29sb3IgPSBjb2xvckZ1bmN0aW9ucy5oc2xhKGgsIHMsIGwsIDEuMCk7XG4gICAgICAgIGlmIChjb2xvcikge1xuICAgICAgICAgICAgY29sb3IudmFsdWUgPSAnaHNsJztcbiAgICAgICAgICAgIHJldHVybiBjb2xvcjtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgaHNsYTogZnVuY3Rpb24gKGgsIHMsIGwsIGEpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChoIGluc3RhbmNlb2YgQ29sb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAocykge1xuICAgICAgICAgICAgICAgICAgICBhID0gbnVtYmVyKHMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGEgPSBoLmFscGhhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbG9yKGgucmdiLCBhLCAnaHNsYScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbTEsIG0yO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBodWUoaCkge1xuICAgICAgICAgICAgICAgIGggPSBoIDwgMCA/IGggKyAxIDogKGggPiAxID8gaCAtIDEgOiBoKTtcbiAgICAgICAgICAgICAgICBpZiAoaCAqIDYgPCAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtMSArIChtMiAtIG0xKSAqIGggKiA2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChoICogMiA8IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG0yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChoICogMyA8IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG0xICsgKG0yIC0gbTEpICogKDIgLyAzIC0gaCkgKiA2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG0xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaCA9IChudW1iZXIoaCkgJSAzNjApIC8gMzYwO1xuICAgICAgICAgICAgcyA9IGNsYW1wKG51bWJlcihzKSk7IGwgPSBjbGFtcChudW1iZXIobCkpOyBhID0gY2xhbXAobnVtYmVyKGEpKTtcblxuICAgICAgICAgICAgbTIgPSBsIDw9IDAuNSA/IGwgKiAocyArIDEpIDogbCArIHMgLSBsICogcztcbiAgICAgICAgICAgIG0xID0gbCAqIDIgLSBtMjtcblxuICAgICAgICAgICAgdmFyIHJnYiA9IFtcbiAgICAgICAgICAgICAgICBodWUoaCArIDEgLyAzKSAqIDI1NSxcbiAgICAgICAgICAgICAgICBodWUoaCkgICAgICAgKiAyNTUsXG4gICAgICAgICAgICAgICAgaHVlKGggLSAxIC8gMykgKiAyNTVcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBhID0gbnVtYmVyKGEpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xvcihyZ2IsIGEsICdoc2xhJyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHt9XG4gICAgfSxcblxuICAgIGhzdjogZnVuY3Rpb24oaCwgcywgdikge1xuICAgICAgICByZXR1cm4gY29sb3JGdW5jdGlvbnMuaHN2YShoLCBzLCB2LCAxLjApO1xuICAgIH0sXG5cbiAgICBoc3ZhOiBmdW5jdGlvbihoLCBzLCB2LCBhKSB7XG4gICAgICAgIGggPSAoKG51bWJlcihoKSAlIDM2MCkgLyAzNjApICogMzYwO1xuICAgICAgICBzID0gbnVtYmVyKHMpOyB2ID0gbnVtYmVyKHYpOyBhID0gbnVtYmVyKGEpO1xuXG4gICAgICAgIHZhciBpLCBmO1xuICAgICAgICBpID0gTWF0aC5mbG9vcigoaCAvIDYwKSAlIDYpO1xuICAgICAgICBmID0gKGggLyA2MCkgLSBpO1xuXG4gICAgICAgIHZhciB2cyA9IFt2LFxuICAgICAgICAgICAgdiAqICgxIC0gcyksXG4gICAgICAgICAgICB2ICogKDEgLSBmICogcyksXG4gICAgICAgICAgICB2ICogKDEgLSAoMSAtIGYpICogcyldO1xuICAgICAgICB2YXIgcGVybSA9IFtbMCwgMywgMV0sXG4gICAgICAgICAgICBbMiwgMCwgMV0sXG4gICAgICAgICAgICBbMSwgMCwgM10sXG4gICAgICAgICAgICBbMSwgMiwgMF0sXG4gICAgICAgICAgICBbMywgMSwgMF0sXG4gICAgICAgICAgICBbMCwgMSwgMl1dO1xuXG4gICAgICAgIHJldHVybiBjb2xvckZ1bmN0aW9ucy5yZ2JhKHZzW3Blcm1baV1bMF1dICogMjU1LFxuICAgICAgICAgICAgdnNbcGVybVtpXVsxXV0gKiAyNTUsXG4gICAgICAgICAgICB2c1twZXJtW2ldWzJdXSAqIDI1NSxcbiAgICAgICAgICAgIGEpO1xuICAgIH0sXG5cbiAgICBodWU6IGZ1bmN0aW9uIChjb2xvcikge1xuICAgICAgICByZXR1cm4gbmV3IERpbWVuc2lvbihjb2xvci50b0hTTCgpLmgpO1xuICAgIH0sXG4gICAgc2F0dXJhdGlvbjogZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGltZW5zaW9uKGNvbG9yLnRvSFNMKCkucyAqIDEwMCwgJyUnKTtcbiAgICB9LFxuICAgIGxpZ2h0bmVzczogZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGltZW5zaW9uKGNvbG9yLnRvSFNMKCkubCAqIDEwMCwgJyUnKTtcbiAgICB9LFxuICAgIGhzdmh1ZTogZnVuY3Rpb24oY29sb3IpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEaW1lbnNpb24oY29sb3IudG9IU1YoKS5oKTtcbiAgICB9LFxuICAgIGhzdnNhdHVyYXRpb246IGZ1bmN0aW9uIChjb2xvcikge1xuICAgICAgICByZXR1cm4gbmV3IERpbWVuc2lvbihjb2xvci50b0hTVigpLnMgKiAxMDAsICclJyk7XG4gICAgfSxcbiAgICBoc3Z2YWx1ZTogZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGltZW5zaW9uKGNvbG9yLnRvSFNWKCkudiAqIDEwMCwgJyUnKTtcbiAgICB9LFxuICAgIHJlZDogZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGltZW5zaW9uKGNvbG9yLnJnYlswXSk7XG4gICAgfSxcbiAgICBncmVlbjogZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGltZW5zaW9uKGNvbG9yLnJnYlsxXSk7XG4gICAgfSxcbiAgICBibHVlOiBmdW5jdGlvbiAoY29sb3IpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEaW1lbnNpb24oY29sb3IucmdiWzJdKTtcbiAgICB9LFxuICAgIGFscGhhOiBmdW5jdGlvbiAoY29sb3IpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEaW1lbnNpb24oY29sb3IudG9IU0woKS5hKTtcbiAgICB9LFxuICAgIGx1bWE6IGZ1bmN0aW9uIChjb2xvcikge1xuICAgICAgICByZXR1cm4gbmV3IERpbWVuc2lvbihjb2xvci5sdW1hKCkgKiBjb2xvci5hbHBoYSAqIDEwMCwgJyUnKTtcbiAgICB9LFxuICAgIGx1bWluYW5jZTogZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgICAgIHZhciBsdW1pbmFuY2UgPVxuICAgICAgICAgICAgKDAuMjEyNiAqIGNvbG9yLnJnYlswXSAvIDI1NSkgK1xuICAgICAgICAgICAgICAgICgwLjcxNTIgKiBjb2xvci5yZ2JbMV0gLyAyNTUpICtcbiAgICAgICAgICAgICAgICAoMC4wNzIyICogY29sb3IucmdiWzJdIC8gMjU1KTtcblxuICAgICAgICByZXR1cm4gbmV3IERpbWVuc2lvbihsdW1pbmFuY2UgKiBjb2xvci5hbHBoYSAqIDEwMCwgJyUnKTtcbiAgICB9LFxuICAgIHNhdHVyYXRlOiBmdW5jdGlvbiAoY29sb3IsIGFtb3VudCwgbWV0aG9kKSB7XG4gICAgICAgIC8vIGZpbHRlcjogc2F0dXJhdGUoMy4yKTtcbiAgICAgICAgLy8gc2hvdWxkIGJlIGtlcHQgYXMgaXMsIHNvIGNoZWNrIGZvciBjb2xvclxuICAgICAgICBpZiAoIWNvbG9yLnJnYikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhzbCA9IGNvbG9yLnRvSFNMKCk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBtZXRob2QgIT09ICd1bmRlZmluZWQnICYmIG1ldGhvZC52YWx1ZSA9PT0gJ3JlbGF0aXZlJykge1xuICAgICAgICAgICAgaHNsLnMgKz0gIGhzbC5zICogYW1vdW50LnZhbHVlIC8gMTAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaHNsLnMgKz0gYW1vdW50LnZhbHVlIC8gMTAwO1xuICAgICAgICB9XG4gICAgICAgIGhzbC5zID0gY2xhbXAoaHNsLnMpO1xuICAgICAgICByZXR1cm4gaHNsYShjb2xvciwgaHNsKTtcbiAgICB9LFxuICAgIGRlc2F0dXJhdGU6IGZ1bmN0aW9uIChjb2xvciwgYW1vdW50LCBtZXRob2QpIHtcbiAgICAgICAgdmFyIGhzbCA9IGNvbG9yLnRvSFNMKCk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBtZXRob2QgIT09ICd1bmRlZmluZWQnICYmIG1ldGhvZC52YWx1ZSA9PT0gJ3JlbGF0aXZlJykge1xuICAgICAgICAgICAgaHNsLnMgLT0gIGhzbC5zICogYW1vdW50LnZhbHVlIC8gMTAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaHNsLnMgLT0gYW1vdW50LnZhbHVlIC8gMTAwO1xuICAgICAgICB9XG4gICAgICAgIGhzbC5zID0gY2xhbXAoaHNsLnMpO1xuICAgICAgICByZXR1cm4gaHNsYShjb2xvciwgaHNsKTtcbiAgICB9LFxuICAgIGxpZ2h0ZW46IGZ1bmN0aW9uIChjb2xvciwgYW1vdW50LCBtZXRob2QpIHtcbiAgICAgICAgdmFyIGhzbCA9IGNvbG9yLnRvSFNMKCk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBtZXRob2QgIT09ICd1bmRlZmluZWQnICYmIG1ldGhvZC52YWx1ZSA9PT0gJ3JlbGF0aXZlJykge1xuICAgICAgICAgICAgaHNsLmwgKz0gIGhzbC5sICogYW1vdW50LnZhbHVlIC8gMTAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaHNsLmwgKz0gYW1vdW50LnZhbHVlIC8gMTAwO1xuICAgICAgICB9XG4gICAgICAgIGhzbC5sID0gY2xhbXAoaHNsLmwpO1xuICAgICAgICByZXR1cm4gaHNsYShjb2xvciwgaHNsKTtcbiAgICB9LFxuICAgIGRhcmtlbjogZnVuY3Rpb24gKGNvbG9yLCBhbW91bnQsIG1ldGhvZCkge1xuICAgICAgICB2YXIgaHNsID0gY29sb3IudG9IU0woKTtcblxuICAgICAgICBpZiAodHlwZW9mIG1ldGhvZCAhPT0gJ3VuZGVmaW5lZCcgJiYgbWV0aG9kLnZhbHVlID09PSAncmVsYXRpdmUnKSB7XG4gICAgICAgICAgICBoc2wubCAtPSAgaHNsLmwgKiBhbW91bnQudmFsdWUgLyAxMDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBoc2wubCAtPSBhbW91bnQudmFsdWUgLyAxMDA7XG4gICAgICAgIH1cbiAgICAgICAgaHNsLmwgPSBjbGFtcChoc2wubCk7XG4gICAgICAgIHJldHVybiBoc2xhKGNvbG9yLCBoc2wpO1xuICAgIH0sXG4gICAgZmFkZWluOiBmdW5jdGlvbiAoY29sb3IsIGFtb3VudCwgbWV0aG9kKSB7XG4gICAgICAgIHZhciBoc2wgPSBjb2xvci50b0hTTCgpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgbWV0aG9kICE9PSAndW5kZWZpbmVkJyAmJiBtZXRob2QudmFsdWUgPT09ICdyZWxhdGl2ZScpIHtcbiAgICAgICAgICAgIGhzbC5hICs9ICBoc2wuYSAqIGFtb3VudC52YWx1ZSAvIDEwMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGhzbC5hICs9IGFtb3VudC52YWx1ZSAvIDEwMDtcbiAgICAgICAgfVxuICAgICAgICBoc2wuYSA9IGNsYW1wKGhzbC5hKTtcbiAgICAgICAgcmV0dXJuIGhzbGEoY29sb3IsIGhzbCk7XG4gICAgfSxcbiAgICBmYWRlb3V0OiBmdW5jdGlvbiAoY29sb3IsIGFtb3VudCwgbWV0aG9kKSB7XG4gICAgICAgIHZhciBoc2wgPSBjb2xvci50b0hTTCgpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgbWV0aG9kICE9PSAndW5kZWZpbmVkJyAmJiBtZXRob2QudmFsdWUgPT09ICdyZWxhdGl2ZScpIHtcbiAgICAgICAgICAgIGhzbC5hIC09ICBoc2wuYSAqIGFtb3VudC52YWx1ZSAvIDEwMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGhzbC5hIC09IGFtb3VudC52YWx1ZSAvIDEwMDtcbiAgICAgICAgfVxuICAgICAgICBoc2wuYSA9IGNsYW1wKGhzbC5hKTtcbiAgICAgICAgcmV0dXJuIGhzbGEoY29sb3IsIGhzbCk7XG4gICAgfSxcbiAgICBmYWRlOiBmdW5jdGlvbiAoY29sb3IsIGFtb3VudCkge1xuICAgICAgICB2YXIgaHNsID0gY29sb3IudG9IU0woKTtcblxuICAgICAgICBoc2wuYSA9IGFtb3VudC52YWx1ZSAvIDEwMDtcbiAgICAgICAgaHNsLmEgPSBjbGFtcChoc2wuYSk7XG4gICAgICAgIHJldHVybiBoc2xhKGNvbG9yLCBoc2wpO1xuICAgIH0sXG4gICAgc3BpbjogZnVuY3Rpb24gKGNvbG9yLCBhbW91bnQpIHtcbiAgICAgICAgdmFyIGhzbCA9IGNvbG9yLnRvSFNMKCk7XG4gICAgICAgIHZhciBodWUgPSAoaHNsLmggKyBhbW91bnQudmFsdWUpICUgMzYwO1xuXG4gICAgICAgIGhzbC5oID0gaHVlIDwgMCA/IDM2MCArIGh1ZSA6IGh1ZTtcblxuICAgICAgICByZXR1cm4gaHNsYShjb2xvciwgaHNsKTtcbiAgICB9LFxuICAgIC8vXG4gICAgLy8gQ29weXJpZ2h0IChjKSAyMDA2LTIwMDkgSGFtcHRvbiBDYXRsaW4sIE5hdGFsaWUgV2VpemVuYmF1bSwgYW5kIENocmlzIEVwcHN0ZWluXG4gICAgLy8gaHR0cDovL3Nhc3MtbGFuZy5jb21cbiAgICAvL1xuICAgIG1peDogZnVuY3Rpb24gKGNvbG9yMSwgY29sb3IyLCB3ZWlnaHQpIHtcbiAgICAgICAgaWYgKCFjb2xvcjEudG9IU0wgfHwgIWNvbG9yMi50b0hTTCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coY29sb3IyLnR5cGUpO1xuICAgICAgICAgICAgY29uc29sZS5kaXIoY29sb3IyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXdlaWdodCkge1xuICAgICAgICAgICAgd2VpZ2h0ID0gbmV3IERpbWVuc2lvbig1MCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHAgPSB3ZWlnaHQudmFsdWUgLyAxMDAuMDtcbiAgICAgICAgdmFyIHcgPSBwICogMiAtIDE7XG4gICAgICAgIHZhciBhID0gY29sb3IxLnRvSFNMKCkuYSAtIGNvbG9yMi50b0hTTCgpLmE7XG5cbiAgICAgICAgdmFyIHcxID0gKCgodyAqIGEgPT0gLTEpID8gdyA6ICh3ICsgYSkgLyAoMSArIHcgKiBhKSkgKyAxKSAvIDIuMDtcbiAgICAgICAgdmFyIHcyID0gMSAtIHcxO1xuXG4gICAgICAgIHZhciByZ2IgPSBbY29sb3IxLnJnYlswXSAqIHcxICsgY29sb3IyLnJnYlswXSAqIHcyLFxuICAgICAgICAgICAgY29sb3IxLnJnYlsxXSAqIHcxICsgY29sb3IyLnJnYlsxXSAqIHcyLFxuICAgICAgICAgICAgY29sb3IxLnJnYlsyXSAqIHcxICsgY29sb3IyLnJnYlsyXSAqIHcyXTtcblxuICAgICAgICB2YXIgYWxwaGEgPSBjb2xvcjEuYWxwaGEgKiBwICsgY29sb3IyLmFscGhhICogKDEgLSBwKTtcblxuICAgICAgICByZXR1cm4gbmV3IENvbG9yKHJnYiwgYWxwaGEpO1xuICAgIH0sXG4gICAgZ3JleXNjYWxlOiBmdW5jdGlvbiAoY29sb3IpIHtcbiAgICAgICAgcmV0dXJuIGNvbG9yRnVuY3Rpb25zLmRlc2F0dXJhdGUoY29sb3IsIG5ldyBEaW1lbnNpb24oMTAwKSk7XG4gICAgfSxcbiAgICBjb250cmFzdDogZnVuY3Rpb24gKGNvbG9yLCBkYXJrLCBsaWdodCwgdGhyZXNob2xkKSB7XG4gICAgICAgIC8vIGZpbHRlcjogY29udHJhc3QoMy4yKTtcbiAgICAgICAgLy8gc2hvdWxkIGJlIGtlcHQgYXMgaXMsIHNvIGNoZWNrIGZvciBjb2xvclxuICAgICAgICBpZiAoIWNvbG9yLnJnYikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBsaWdodCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGxpZ2h0ID0gY29sb3JGdW5jdGlvbnMucmdiYSgyNTUsIDI1NSwgMjU1LCAxLjApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZGFyayA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGRhcmsgPSBjb2xvckZ1bmN0aW9ucy5yZ2JhKDAsIDAsIDAsIDEuMCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmlndXJlIG91dCB3aGljaCBpcyBhY3R1YWxseSBsaWdodCBhbmQgZGFyazpcbiAgICAgICAgaWYgKGRhcmsubHVtYSgpID4gbGlnaHQubHVtYSgpKSB7XG4gICAgICAgICAgICB2YXIgdCA9IGxpZ2h0O1xuICAgICAgICAgICAgbGlnaHQgPSBkYXJrO1xuICAgICAgICAgICAgZGFyayA9IHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0aHJlc2hvbGQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJlc2hvbGQgPSAwLjQzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyZXNob2xkID0gbnVtYmVyKHRocmVzaG9sZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbG9yLmx1bWEoKSA8IHRocmVzaG9sZCkge1xuICAgICAgICAgICAgcmV0dXJuIGxpZ2h0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGRhcms7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8vIENoYW5nZXMgbWFkZSBpbiAyLjcuMCAtIFJldmVydGVkIGluIDMuMC4wXG4gICAgLy8gY29udHJhc3Q6IGZ1bmN0aW9uIChjb2xvciwgY29sb3IxLCBjb2xvcjIsIHRocmVzaG9sZCkge1xuICAgIC8vICAgICAvLyBSZXR1cm4gd2hpY2ggb2YgYGNvbG9yMWAgYW5kIGBjb2xvcjJgIGhhcyB0aGUgZ3JlYXRlc3QgY29udHJhc3Qgd2l0aCBgY29sb3JgXG4gICAgLy8gICAgIC8vIGFjY29yZGluZyB0byB0aGUgc3RhbmRhcmQgV0NBRyBjb250cmFzdCByYXRpbyBjYWxjdWxhdGlvbi5cbiAgICAvLyAgICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvV0NBRzIwLyNjb250cmFzdC1yYXRpb2RlZlxuICAgIC8vICAgICAvLyBUaGUgdGhyZXNob2xkIHBhcmFtIGlzIG5vIGxvbmdlciB1c2VkLCBpbiBsaW5lIHdpdGggU0FTUy5cbiAgICAvLyAgICAgLy8gZmlsdGVyOiBjb250cmFzdCgzLjIpO1xuICAgIC8vICAgICAvLyBzaG91bGQgYmUga2VwdCBhcyBpcywgc28gY2hlY2sgZm9yIGNvbG9yXG4gICAgLy8gICAgIGlmICghY29sb3IucmdiKSB7XG4gICAgLy8gICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAvLyAgICAgfVxuICAgIC8vICAgICBpZiAodHlwZW9mIGNvbG9yMSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyAgICAgICAgIGNvbG9yMSA9IGNvbG9yRnVuY3Rpb25zLnJnYmEoMCwgMCwgMCwgMS4wKTtcbiAgICAvLyAgICAgfVxuICAgIC8vICAgICBpZiAodHlwZW9mIGNvbG9yMiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyAgICAgICAgIGNvbG9yMiA9IGNvbG9yRnVuY3Rpb25zLnJnYmEoMjU1LCAyNTUsIDI1NSwgMS4wKTtcbiAgICAvLyAgICAgfVxuICAgIC8vICAgICB2YXIgY29udHJhc3QxLCBjb250cmFzdDI7XG4gICAgLy8gICAgIHZhciBsdW1hID0gY29sb3IubHVtYSgpO1xuICAgIC8vICAgICB2YXIgbHVtYTEgPSBjb2xvcjEubHVtYSgpO1xuICAgIC8vICAgICB2YXIgbHVtYTIgPSBjb2xvcjIubHVtYSgpO1xuICAgIC8vICAgICAvLyBDYWxjdWxhdGUgY29udHJhc3QgcmF0aW9zIGZvciBlYWNoIGNvbG9yXG4gICAgLy8gICAgIGlmIChsdW1hID4gbHVtYTEpIHtcbiAgICAvLyAgICAgICAgIGNvbnRyYXN0MSA9IChsdW1hICsgMC4wNSkgLyAobHVtYTEgKyAwLjA1KTtcbiAgICAvLyAgICAgfSBlbHNlIHtcbiAgICAvLyAgICAgICAgIGNvbnRyYXN0MSA9IChsdW1hMSArIDAuMDUpIC8gKGx1bWEgKyAwLjA1KTtcbiAgICAvLyAgICAgfVxuICAgIC8vICAgICBpZiAobHVtYSA+IGx1bWEyKSB7XG4gICAgLy8gICAgICAgICBjb250cmFzdDIgPSAobHVtYSArIDAuMDUpIC8gKGx1bWEyICsgMC4wNSk7XG4gICAgLy8gICAgIH0gZWxzZSB7XG4gICAgLy8gICAgICAgICBjb250cmFzdDIgPSAobHVtYTIgKyAwLjA1KSAvIChsdW1hICsgMC4wNSk7XG4gICAgLy8gICAgIH1cbiAgICAvLyAgICAgaWYgKGNvbnRyYXN0MSA+IGNvbnRyYXN0Mikge1xuICAgIC8vICAgICAgICAgcmV0dXJuIGNvbG9yMTtcbiAgICAvLyAgICAgfSBlbHNlIHtcbiAgICAvLyAgICAgICAgIHJldHVybiBjb2xvcjI7XG4gICAgLy8gICAgIH1cbiAgICAvLyB9LFxuICAgIGFyZ2I6IGZ1bmN0aW9uIChjb2xvcikge1xuICAgICAgICByZXR1cm4gbmV3IEFub255bW91cyhjb2xvci50b0FSR0IoKSk7XG4gICAgfSxcbiAgICBjb2xvcjogZnVuY3Rpb24oYykge1xuICAgICAgICBpZiAoKGMgaW5zdGFuY2VvZiBRdW90ZWQpICYmXG4gICAgICAgICAgICAoL14jKFtBLUZhLWYwLTldezh9fFtBLUZhLWYwLTldezZ9fFtBLUZhLWYwLTldezMsNH0pJC9pLnRlc3QoYy52YWx1ZSkpKSB7XG4gICAgICAgICAgICB2YXIgdmFsID0gYy52YWx1ZS5zbGljZSgxKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29sb3IodmFsLCB1bmRlZmluZWQsICcjJyArIHZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChjIGluc3RhbmNlb2YgQ29sb3IpIHx8IChjID0gQ29sb3IuZnJvbUtleXdvcmQoYy52YWx1ZSkpKSB7XG4gICAgICAgICAgICBjLnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgcmV0dXJuIGM7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgdHlwZTogICAgJ0FyZ3VtZW50JyxcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdhcmd1bWVudCBtdXN0IGJlIGEgY29sb3Iga2V5d29yZCBvciAzfDR8Nnw4IGRpZ2l0IGhleCBlLmcuICNGRkYnXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0aW50OiBmdW5jdGlvbihjb2xvciwgYW1vdW50KSB7XG4gICAgICAgIHJldHVybiBjb2xvckZ1bmN0aW9ucy5taXgoY29sb3JGdW5jdGlvbnMucmdiKDI1NSwgMjU1LCAyNTUpLCBjb2xvciwgYW1vdW50KTtcbiAgICB9LFxuICAgIHNoYWRlOiBmdW5jdGlvbihjb2xvciwgYW1vdW50KSB7XG4gICAgICAgIHJldHVybiBjb2xvckZ1bmN0aW9ucy5taXgoY29sb3JGdW5jdGlvbnMucmdiKDAsIDAsIDApLCBjb2xvciwgYW1vdW50KTtcbiAgICB9XG59O1xuZnVuY3Rpb25SZWdpc3RyeS5hZGRNdWx0aXBsZShjb2xvckZ1bmN0aW9ucyk7XG5cbn0se1wiLi4vdHJlZS9hbm9ueW1vdXNcIjo1MCxcIi4uL3RyZWUvY29sb3JcIjo1NSxcIi4uL3RyZWUvZGltZW5zaW9uXCI6NjIsXCIuLi90cmVlL3F1b3RlZFwiOjgwLFwiLi9mdW5jdGlvbi1yZWdpc3RyeVwiOjI3fV0sMjQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihlbnZpcm9ubWVudCkge1xuICAgIHZhciBRdW90ZWQgPSByZXF1aXJlKCcuLi90cmVlL3F1b3RlZCcpLFxuICAgICAgICBVUkwgPSByZXF1aXJlKCcuLi90cmVlL3VybCcpLFxuICAgICAgICB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyksXG4gICAgICAgIGZ1bmN0aW9uUmVnaXN0cnkgPSByZXF1aXJlKCcuL2Z1bmN0aW9uLXJlZ2lzdHJ5JyksXG4gICAgICAgIGZhbGxiYWNrID0gZnVuY3Rpb24oZnVuY3Rpb25UaGlzLCBub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVSTChub2RlLCBmdW5jdGlvblRoaXMuaW5kZXgsIGZ1bmN0aW9uVGhpcy5jdXJyZW50RmlsZUluZm8pLmV2YWwoZnVuY3Rpb25UaGlzLmNvbnRleHQpO1xuICAgICAgICB9LFxuICAgICAgICBsb2dnZXIgPSByZXF1aXJlKCcuLi9sb2dnZXInKTtcblxuICAgIGZ1bmN0aW9uUmVnaXN0cnkuYWRkKCdkYXRhLXVyaScsIGZ1bmN0aW9uKG1pbWV0eXBlTm9kZSwgZmlsZVBhdGhOb2RlKSB7XG5cbiAgICAgICAgaWYgKCFmaWxlUGF0aE5vZGUpIHtcbiAgICAgICAgICAgIGZpbGVQYXRoTm9kZSA9IG1pbWV0eXBlTm9kZTtcbiAgICAgICAgICAgIG1pbWV0eXBlTm9kZSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWltZXR5cGUgPSBtaW1ldHlwZU5vZGUgJiYgbWltZXR5cGVOb2RlLnZhbHVlO1xuICAgICAgICB2YXIgZmlsZVBhdGggPSBmaWxlUGF0aE5vZGUudmFsdWU7XG4gICAgICAgIHZhciBjdXJyZW50RmlsZUluZm8gPSB0aGlzLmN1cnJlbnRGaWxlSW5mbztcbiAgICAgICAgdmFyIGN1cnJlbnREaXJlY3RvcnkgPSBjdXJyZW50RmlsZUluZm8ucmV3cml0ZVVybHMgP1xuICAgICAgICAgICAgY3VycmVudEZpbGVJbmZvLmN1cnJlbnREaXJlY3RvcnkgOiBjdXJyZW50RmlsZUluZm8uZW50cnlQYXRoO1xuXG4gICAgICAgIHZhciBmcmFnbWVudFN0YXJ0ID0gZmlsZVBhdGguaW5kZXhPZignIycpO1xuICAgICAgICB2YXIgZnJhZ21lbnQgPSAnJztcbiAgICAgICAgaWYgKGZyYWdtZW50U3RhcnQgIT09IC0xKSB7XG4gICAgICAgICAgICBmcmFnbWVudCA9IGZpbGVQYXRoLnNsaWNlKGZyYWdtZW50U3RhcnQpO1xuICAgICAgICAgICAgZmlsZVBhdGggPSBmaWxlUGF0aC5zbGljZSgwLCBmcmFnbWVudFN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29udGV4dCA9IHV0aWxzLmNsb25lKHRoaXMuY29udGV4dCk7XG4gICAgICAgIGNvbnRleHQucmF3QnVmZmVyID0gdHJ1ZTtcblxuICAgICAgICB2YXIgZmlsZU1hbmFnZXIgPSBlbnZpcm9ubWVudC5nZXRGaWxlTWFuYWdlcihmaWxlUGF0aCwgY3VycmVudERpcmVjdG9yeSwgY29udGV4dCwgZW52aXJvbm1lbnQsIHRydWUpO1xuXG4gICAgICAgIGlmICghZmlsZU1hbmFnZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxsYmFjayh0aGlzLCBmaWxlUGF0aE5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHVzZUJhc2U2NCA9IGZhbHNlO1xuXG4gICAgICAgIC8vIGRldGVjdCB0aGUgbWltZXR5cGUgaWYgbm90IGdpdmVuXG4gICAgICAgIGlmICghbWltZXR5cGVOb2RlKSB7XG5cbiAgICAgICAgICAgIG1pbWV0eXBlID0gZW52aXJvbm1lbnQubWltZUxvb2t1cChmaWxlUGF0aCk7XG5cbiAgICAgICAgICAgIGlmIChtaW1ldHlwZSA9PT0gJ2ltYWdlL3N2Zyt4bWwnKSB7XG4gICAgICAgICAgICAgICAgdXNlQmFzZTY0ID0gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHVzZSBiYXNlIDY0IHVubGVzcyBpdCdzIGFuIEFTQ0lJIG9yIFVURi04IGZvcm1hdFxuICAgICAgICAgICAgICAgIHZhciBjaGFyc2V0ID0gZW52aXJvbm1lbnQuY2hhcnNldExvb2t1cChtaW1ldHlwZSk7XG4gICAgICAgICAgICAgICAgdXNlQmFzZTY0ID0gWydVUy1BU0NJSScsICdVVEYtOCddLmluZGV4T2YoY2hhcnNldCkgPCAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVzZUJhc2U2NCkgeyBtaW1ldHlwZSArPSAnO2Jhc2U2NCc7IH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHVzZUJhc2U2NCA9IC87YmFzZTY0JC8udGVzdChtaW1ldHlwZSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZmlsZVN5bmMgPSBmaWxlTWFuYWdlci5sb2FkRmlsZVN5bmMoZmlsZVBhdGgsIGN1cnJlbnREaXJlY3RvcnksIGNvbnRleHQsIGVudmlyb25tZW50KTtcbiAgICAgICAgaWYgKCFmaWxlU3luYy5jb250ZW50cykge1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oJ1NraXBwZWQgZGF0YS11cmkgZW1iZWRkaW5nIG9mICcgKyBmaWxlUGF0aCArICcgYmVjYXVzZSBmaWxlIG5vdCBmb3VuZCcpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbGxiYWNrKHRoaXMsIGZpbGVQYXRoTm9kZSB8fCBtaW1ldHlwZU5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBidWYgPSBmaWxlU3luYy5jb250ZW50cztcbiAgICAgICAgaWYgKHVzZUJhc2U2NCAmJiAhZW52aXJvbm1lbnQuZW5jb2RlQmFzZTY0KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsbGJhY2sodGhpcywgZmlsZVBhdGhOb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJ1ZiA9IHVzZUJhc2U2NCA/IGVudmlyb25tZW50LmVuY29kZUJhc2U2NChidWYpIDogZW5jb2RlVVJJQ29tcG9uZW50KGJ1Zik7XG5cbiAgICAgICAgdmFyIHVyaSA9ICdkYXRhOicgKyBtaW1ldHlwZSArICcsJyArIGJ1ZiArIGZyYWdtZW50O1xuXG4gICAgICAgIC8vIElFOCBjYW5ub3QgaGFuZGxlIGEgZGF0YS11cmkgbGFyZ2VyIHRoYW4gMzIsNzY4IGNoYXJhY3RlcnMuIElmIHRoaXMgaXMgZXhjZWVkZWRcbiAgICAgICAgLy8gYW5kIHRoZSAtLWllQ29tcGF0IGZsYWcgaXMgZW5hYmxlZCwgcmV0dXJuIGEgbm9ybWFsIHVybCgpIGluc3RlYWQuXG4gICAgICAgIHZhciBEQVRBX1VSSV9NQVggPSAzMjc2ODtcbiAgICAgICAgaWYgKHVyaS5sZW5ndGggPj0gREFUQV9VUklfTUFYKSB7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHQuaWVDb21wYXQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oJ1NraXBwZWQgZGF0YS11cmkgZW1iZWRkaW5nIG9mICcgKyBmaWxlUGF0aCArICcgYmVjYXVzZSBpdHMgc2l6ZSAoJyArIHVyaS5sZW5ndGggK1xuICAgICAgICAgICAgICAgICAgICAnIGNoYXJhY3RlcnMpIGV4Y2VlZHMgSUU4LXNhZmUgJyArIERBVEFfVVJJX01BWCArICcgY2hhcmFjdGVycyEnKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxsYmFjayh0aGlzLCBmaWxlUGF0aE5vZGUgfHwgbWltZXR5cGVOb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgVVJMKG5ldyBRdW90ZWQoJ1wiJyArIHVyaSArICdcIicsIHVyaSwgZmFsc2UsIHRoaXMuaW5kZXgsIHRoaXMuY3VycmVudEZpbGVJbmZvKSwgdGhpcy5pbmRleCwgdGhpcy5jdXJyZW50RmlsZUluZm8pO1xuICAgIH0pO1xufTtcblxufSx7XCIuLi9sb2dnZXJcIjozOSxcIi4uL3RyZWUvcXVvdGVkXCI6ODAsXCIuLi90cmVlL3VybFwiOjg1LFwiLi4vdXRpbHNcIjo4OSxcIi4vZnVuY3Rpb24tcmVnaXN0cnlcIjoyN31dLDI1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBLZXl3b3JkID0gcmVxdWlyZSgnLi4vdHJlZS9rZXl3b3JkJyksXG4gICAgZnVuY3Rpb25SZWdpc3RyeSA9IHJlcXVpcmUoJy4vZnVuY3Rpb24tcmVnaXN0cnknKTtcblxudmFyIGRlZmF1bHRGdW5jID0ge1xuICAgIGV2YWw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHYgPSB0aGlzLnZhbHVlXywgZSA9IHRoaXMuZXJyb3JfO1xuICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodiAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdiA/IEtleXdvcmQuVHJ1ZSA6IEtleXdvcmQuRmFsc2U7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHZhbHVlOiBmdW5jdGlvbiAodikge1xuICAgICAgICB0aGlzLnZhbHVlXyA9IHY7XG4gICAgfSxcbiAgICBlcnJvcjogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdGhpcy5lcnJvcl8gPSBlO1xuICAgIH0sXG4gICAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy52YWx1ZV8gPSB0aGlzLmVycm9yXyA9IG51bGw7XG4gICAgfVxufTtcblxuZnVuY3Rpb25SZWdpc3RyeS5hZGQoJ2RlZmF1bHQnLCBkZWZhdWx0RnVuYy5ldmFsLmJpbmQoZGVmYXVsdEZ1bmMpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBkZWZhdWx0RnVuYztcblxufSx7XCIuLi90cmVlL2tleXdvcmRcIjo3MCxcIi4vZnVuY3Rpb24tcmVnaXN0cnlcIjoyN31dLDI2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBFeHByZXNzaW9uID0gcmVxdWlyZSgnLi4vdHJlZS9leHByZXNzaW9uJyk7XG5cbnZhciBmdW5jdGlvbkNhbGxlciA9IGZ1bmN0aW9uKG5hbWUsIGNvbnRleHQsIGluZGV4LCBjdXJyZW50RmlsZUluZm8pIHtcbiAgICB0aGlzLm5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5jdXJyZW50RmlsZUluZm8gPSBjdXJyZW50RmlsZUluZm87XG5cbiAgICB0aGlzLmZ1bmMgPSBjb250ZXh0LmZyYW1lc1swXS5mdW5jdGlvblJlZ2lzdHJ5LmdldCh0aGlzLm5hbWUpO1xufTtcbmZ1bmN0aW9uQ2FsbGVyLnByb3RvdHlwZS5pc1ZhbGlkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4odGhpcy5mdW5jKTtcbn07XG5cbmZ1bmN0aW9uQ2FsbGVyLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24oYXJncykge1xuICAgIC8vIFRoaXMgY29kZSBpcyB0ZXJyaWJsZSBhbmQgc2hvdWxkIGJlIHJlcGxhY2VkIGFzIHBlciB0aGlzIGlzc3VlLi4uXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2xlc3MvbGVzcy5qcy9pc3N1ZXMvMjQ3N1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFyZ3MpKSB7XG4gICAgICAgIGFyZ3MgPSBhcmdzLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgaWYgKGl0ZW0udHlwZSA9PT0gJ0NvbW1lbnQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pXG4gICAgICAgIC5tYXAoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgaWYgKGl0ZW0udHlwZSA9PT0gJ0V4cHJlc3Npb24nKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1Yk5vZGVzID0gaXRlbS52YWx1ZS5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0udHlwZSA9PT0gJ0NvbW1lbnQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHN1Yk5vZGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3ViTm9kZXNbMF07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFeHByZXNzaW9uKHN1Yk5vZGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb25DYWxsZXI7XG5cbn0se1wiLi4vdHJlZS9leHByZXNzaW9uXCI6NjR9XSwyNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5mdW5jdGlvbiBtYWtlUmVnaXN0cnkoIGJhc2UgKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgX2RhdGE6IHt9LFxuICAgICAgICBhZGQ6IGZ1bmN0aW9uKG5hbWUsIGZ1bmMpIHtcbiAgICAgICAgICAgIC8vIHByZWNhdXRpb25hcnkgY2FzZSBjb252ZXJzaW9uLCBhcyBsYXRlciBxdWVyeWluZyBvZlxuICAgICAgICAgICAgLy8gdGhlIHJlZ2lzdHJ5IGJ5IGZ1bmN0aW9uLWNhbGxlciB1c2VzIGxvd2VyIGNhc2UgYXMgd2VsbC5cbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9kYXRhLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyB3YXJuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9kYXRhW25hbWVdID0gZnVuYztcbiAgICAgICAgfSxcbiAgICAgICAgYWRkTXVsdGlwbGU6IGZ1bmN0aW9uKGZ1bmN0aW9ucykge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoZnVuY3Rpb25zKS5mb3JFYWNoKFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGQobmFtZSwgZnVuY3Rpb25zW25hbWVdKTtcbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICB9LFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhW25hbWVdIHx8ICggYmFzZSAmJiBiYXNlLmdldCggbmFtZSApKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0TG9jYWxGdW5jdGlvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gICAgICAgIH0sXG4gICAgICAgIGluaGVyaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIG1ha2VSZWdpc3RyeSggdGhpcyApO1xuICAgICAgICB9LFxuICAgICAgICBjcmVhdGU6IGZ1bmN0aW9uKGJhc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBtYWtlUmVnaXN0cnkoYmFzZSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1ha2VSZWdpc3RyeSggbnVsbCApO1xufSx7fV0sMjg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihlbnZpcm9ubWVudCkge1xuICAgIHZhciBmdW5jdGlvbnMgPSB7XG4gICAgICAgIGZ1bmN0aW9uUmVnaXN0cnk6IHJlcXVpcmUoJy4vZnVuY3Rpb24tcmVnaXN0cnknKSxcbiAgICAgICAgZnVuY3Rpb25DYWxsZXI6IHJlcXVpcmUoJy4vZnVuY3Rpb24tY2FsbGVyJylcbiAgICB9O1xuXG4gICAgLy8gcmVnaXN0ZXIgZnVuY3Rpb25zXG4gICAgcmVxdWlyZSgnLi9ib29sZWFuJyk7XG4gICAgcmVxdWlyZSgnLi9kZWZhdWx0Jyk7XG4gICAgcmVxdWlyZSgnLi9jb2xvcicpO1xuICAgIHJlcXVpcmUoJy4vY29sb3ItYmxlbmRpbmcnKTtcbiAgICByZXF1aXJlKCcuL2RhdGEtdXJpJykoZW52aXJvbm1lbnQpO1xuICAgIHJlcXVpcmUoJy4vbGlzdCcpO1xuICAgIHJlcXVpcmUoJy4vbWF0aCcpO1xuICAgIHJlcXVpcmUoJy4vbnVtYmVyJyk7XG4gICAgcmVxdWlyZSgnLi9zdHJpbmcnKTtcbiAgICByZXF1aXJlKCcuL3N2ZycpKGVudmlyb25tZW50KTtcbiAgICByZXF1aXJlKCcuL3R5cGVzJyk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb25zO1xufTtcblxufSx7XCIuL2Jvb2xlYW5cIjoyMSxcIi4vY29sb3JcIjoyMyxcIi4vY29sb3ItYmxlbmRpbmdcIjoyMixcIi4vZGF0YS11cmlcIjoyNCxcIi4vZGVmYXVsdFwiOjI1LFwiLi9mdW5jdGlvbi1jYWxsZXJcIjoyNixcIi4vZnVuY3Rpb24tcmVnaXN0cnlcIjoyNyxcIi4vbGlzdFwiOjI5LFwiLi9tYXRoXCI6MzEsXCIuL251bWJlclwiOjMyLFwiLi9zdHJpbmdcIjozMyxcIi4vc3ZnXCI6MzQsXCIuL3R5cGVzXCI6MzV9XSwyOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgQ29tbWVudCA9IHJlcXVpcmUoJy4uL3RyZWUvY29tbWVudCcpLFxuICAgIERpbWVuc2lvbiA9IHJlcXVpcmUoJy4uL3RyZWUvZGltZW5zaW9uJyksXG4gICAgRGVjbGFyYXRpb24gPSByZXF1aXJlKCcuLi90cmVlL2RlY2xhcmF0aW9uJyksXG4gICAgRXhwcmVzc2lvbiA9IHJlcXVpcmUoJy4uL3RyZWUvZXhwcmVzc2lvbicpLFxuICAgIFJ1bGVzZXQgPSByZXF1aXJlKCcuLi90cmVlL3J1bGVzZXQnKSxcbiAgICBTZWxlY3RvciA9IHJlcXVpcmUoJy4uL3RyZWUvc2VsZWN0b3InKSxcbiAgICBFbGVtZW50ID0gcmVxdWlyZSgnLi4vdHJlZS9lbGVtZW50JyksXG4gICAgZnVuY3Rpb25SZWdpc3RyeSA9IHJlcXVpcmUoJy4vZnVuY3Rpb24tcmVnaXN0cnknKTtcblxudmFyIGdldEl0ZW1zRnJvbU5vZGUgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgLy8gaGFuZGxlIG5vbi1hcnJheSB2YWx1ZXMgYXMgYW4gYXJyYXkgb2YgbGVuZ3RoIDFcbiAgICAvLyByZXR1cm4gJ3VuZGVmaW5lZCcgaWYgaW5kZXggaXMgaW52YWxpZFxuICAgIHZhciBpdGVtcyA9IEFycmF5LmlzQXJyYXkobm9kZS52YWx1ZSkgP1xuICAgICAgICBub2RlLnZhbHVlIDogQXJyYXkobm9kZSk7XG5cbiAgICByZXR1cm4gaXRlbXM7XG59O1xuXG5mdW5jdGlvblJlZ2lzdHJ5LmFkZE11bHRpcGxlKHtcbiAgICBfU0VMRjogZnVuY3Rpb24obikge1xuICAgICAgICByZXR1cm4gbjtcbiAgICB9LFxuICAgIGV4dHJhY3Q6IGZ1bmN0aW9uKHZhbHVlcywgaW5kZXgpIHtcbiAgICAgICAgaW5kZXggPSBpbmRleC52YWx1ZSAtIDE7IC8vICgxLWJhc2VkIGluZGV4KVxuXG4gICAgICAgIHJldHVybiBnZXRJdGVtc0Zyb21Ob2RlKHZhbHVlcylbaW5kZXhdO1xuICAgIH0sXG4gICAgbGVuZ3RoOiBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEaW1lbnNpb24oZ2V0SXRlbXNGcm9tTm9kZSh2YWx1ZXMpLmxlbmd0aCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgTGVzcyBsaXN0IG9mIGluY3JlbWVudGFsIHZhbHVlcy5cbiAgICAgKiBNb2RlbGVkIGFmdGVyIExvZGFzaCdzIHJhbmdlIGZ1bmN0aW9uLCBhbHNvIGV4aXN0cyBuYXRpdmVseSBpbiBQSFBcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge0RpbWVuc2lvbn0gW3N0YXJ0PTFdXG4gICAgICogQHBhcmFtIHtEaW1lbnNpb259IGVuZCAgLSBlLmcuIDEwIG9yIDEwcHggLSB1bml0IGlzIGFkZGVkIHRvIG91dHB1dFxuICAgICAqIEBwYXJhbSB7RGltZW5zaW9ufSBbc3RlcD0xXSBcbiAgICAgKi9cbiAgICByYW5nZTogZnVuY3Rpb24oc3RhcnQsIGVuZCwgc3RlcCkge1xuICAgICAgICB2YXIgZnJvbSwgdG8sIHN0ZXBWYWx1ZSA9IDEsIGxpc3QgPSBbXTtcbiAgICAgICAgaWYgKGVuZCkge1xuICAgICAgICAgICAgdG8gPSBlbmQ7XG4gICAgICAgICAgICBmcm9tID0gc3RhcnQudmFsdWU7XG4gICAgICAgICAgICBpZiAoc3RlcCkge1xuICAgICAgICAgICAgICAgIHN0ZXBWYWx1ZSA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmcm9tID0gMTtcbiAgICAgICAgICAgIHRvID0gc3RhcnQ7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gZnJvbTsgaSA8PSB0by52YWx1ZTsgaSArPSBzdGVwVmFsdWUpIHtcbiAgICAgICAgICAgIGxpc3QucHVzaChuZXcgRGltZW5zaW9uKGksIHRvLnVuaXQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgRXhwcmVzc2lvbihsaXN0KTtcbiAgICB9LFxuICAgIGVhY2g6IGZ1bmN0aW9uKGxpc3QsIHJzKSB7XG4gICAgICAgIHZhciBydWxlcyA9IFtdLCBuZXdSdWxlcywgaXRlcmF0b3I7XG5cbiAgICAgICAgaWYgKGxpc3QudmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGxpc3QudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3IgPSBsaXN0LnZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpdGVyYXRvciA9IFtsaXN0LnZhbHVlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChsaXN0LnJ1bGVzZXQpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yID0gbGlzdC5ydWxlc2V0LnJ1bGVzO1xuICAgICAgICB9IGVsc2UgaWYgKGxpc3QucnVsZXMpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yID0gbGlzdC5ydWxlcztcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGxpc3QpKSB7XG4gICAgICAgICAgICBpdGVyYXRvciA9IGxpc3Q7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpdGVyYXRvciA9IFtsaXN0XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2YWx1ZU5hbWUgPSAnQHZhbHVlJyxcbiAgICAgICAgICAgIGtleU5hbWUgPSAnQGtleScsXG4gICAgICAgICAgICBpbmRleE5hbWUgPSAnQGluZGV4JztcblxuICAgICAgICBpZiAocnMucGFyYW1zKSB7XG4gICAgICAgICAgICB2YWx1ZU5hbWUgPSBycy5wYXJhbXNbMF0gJiYgcnMucGFyYW1zWzBdLm5hbWU7XG4gICAgICAgICAgICBrZXlOYW1lID0gcnMucGFyYW1zWzFdICYmIHJzLnBhcmFtc1sxXS5uYW1lO1xuICAgICAgICAgICAgaW5kZXhOYW1lID0gcnMucGFyYW1zWzJdICYmIHJzLnBhcmFtc1syXS5uYW1lO1xuICAgICAgICAgICAgcnMgPSBycy5ydWxlcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJzID0gcnMucnVsZXNldDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlcmF0b3IubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBrZXksIHZhbHVlLCBpdGVtID0gaXRlcmF0b3JbaV07XG4gICAgICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIERlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAga2V5ID0gdHlwZW9mIGl0ZW0ubmFtZSA9PT0gJ3N0cmluZycgPyBpdGVtLm5hbWUgOiBpdGVtLm5hbWVbMF0udmFsdWU7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBpdGVtLnZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBuZXcgRGltZW5zaW9uKGkgKyAxKTtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGl0ZW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgQ29tbWVudCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBuZXdSdWxlcyA9IHJzLnJ1bGVzLnNsaWNlKDApO1xuICAgICAgICAgICAgaWYgKHZhbHVlTmFtZSkge1xuICAgICAgICAgICAgICAgIG5ld1J1bGVzLnB1c2gobmV3IERlY2xhcmF0aW9uKHZhbHVlTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIGZhbHNlLCBmYWxzZSwgdGhpcy5pbmRleCwgdGhpcy5jdXJyZW50RmlsZUluZm8pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbmRleE5hbWUpIHtcbiAgICAgICAgICAgICAgICBuZXdSdWxlcy5wdXNoKG5ldyBEZWNsYXJhdGlvbihpbmRleE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIG5ldyBEaW1lbnNpb24oaSArIDEpLFxuICAgICAgICAgICAgICAgICAgICBmYWxzZSwgZmFsc2UsIHRoaXMuaW5kZXgsIHRoaXMuY3VycmVudEZpbGVJbmZvKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoa2V5TmFtZSkge1xuICAgICAgICAgICAgICAgIG5ld1J1bGVzLnB1c2gobmV3IERlY2xhcmF0aW9uKGtleU5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgZmFsc2UsIGZhbHNlLCB0aGlzLmluZGV4LCB0aGlzLmN1cnJlbnRGaWxlSW5mbykpO1xuICAgICAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgICAgIHJ1bGVzLnB1c2gobmV3IFJ1bGVzZXQoWyBuZXcoU2VsZWN0b3IpKFsgbmV3IEVsZW1lbnQoXCJcIiwgJyYnKSBdKSBdLFxuICAgICAgICAgICAgICAgIG5ld1J1bGVzLFxuICAgICAgICAgICAgICAgIHJzLnN0cmljdEltcG9ydHMsXG4gICAgICAgICAgICAgICAgcnMudmlzaWJpbGl0eUluZm8oKVxuICAgICAgICAgICAgKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IFJ1bGVzZXQoWyBuZXcoU2VsZWN0b3IpKFsgbmV3IEVsZW1lbnQoXCJcIiwgJyYnKSBdKSBdLFxuICAgICAgICAgICAgICAgIHJ1bGVzLFxuICAgICAgICAgICAgICAgIHJzLnN0cmljdEltcG9ydHMsXG4gICAgICAgICAgICAgICAgcnMudmlzaWJpbGl0eUluZm8oKVxuICAgICAgICAgICAgKS5ldmFsKHRoaXMuY29udGV4dCk7XG5cbiAgICB9XG59KTtcblxufSx7XCIuLi90cmVlL2NvbW1lbnRcIjo1NyxcIi4uL3RyZWUvZGVjbGFyYXRpb25cIjo2MCxcIi4uL3RyZWUvZGltZW5zaW9uXCI6NjIsXCIuLi90cmVlL2VsZW1lbnRcIjo2MyxcIi4uL3RyZWUvZXhwcmVzc2lvblwiOjY0LFwiLi4vdHJlZS9ydWxlc2V0XCI6ODEsXCIuLi90cmVlL3NlbGVjdG9yXCI6ODIsXCIuL2Z1bmN0aW9uLXJlZ2lzdHJ5XCI6Mjd9XSwzMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgRGltZW5zaW9uID0gcmVxdWlyZSgnLi4vdHJlZS9kaW1lbnNpb24nKTtcblxudmFyIE1hdGhIZWxwZXIgPSBmdW5jdGlvbigpIHtcbn07XG5NYXRoSGVscGVyLl9tYXRoID0gZnVuY3Rpb24gKGZuLCB1bml0LCBuKSB7XG4gICAgaWYgKCEobiBpbnN0YW5jZW9mIERpbWVuc2lvbikpIHtcbiAgICAgICAgdGhyb3cgeyB0eXBlOiAnQXJndW1lbnQnLCBtZXNzYWdlOiAnYXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicgfTtcbiAgICB9XG4gICAgaWYgKHVuaXQgPT0gbnVsbCkge1xuICAgICAgICB1bml0ID0gbi51bml0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG4gPSBuLnVuaWZ5KCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRGltZW5zaW9uKGZuKHBhcnNlRmxvYXQobi52YWx1ZSkpLCB1bml0KTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IE1hdGhIZWxwZXI7XG59LHtcIi4uL3RyZWUvZGltZW5zaW9uXCI6NjJ9XSwzMTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgZnVuY3Rpb25SZWdpc3RyeSA9IHJlcXVpcmUoJy4vZnVuY3Rpb24tcmVnaXN0cnknKSxcbiAgICBtYXRoSGVscGVyID0gcmVxdWlyZSgnLi9tYXRoLWhlbHBlci5qcycpO1xuXG52YXIgbWF0aEZ1bmN0aW9ucyA9IHtcbiAgICAvLyBuYW1lLCAgdW5pdFxuICAgIGNlaWw6ICBudWxsLFxuICAgIGZsb29yOiBudWxsLFxuICAgIHNxcnQ6ICBudWxsLFxuICAgIGFiczogICBudWxsLFxuICAgIHRhbjogICAnJyxcbiAgICBzaW46ICAgJycsXG4gICAgY29zOiAgICcnLFxuICAgIGF0YW46ICAncmFkJyxcbiAgICBhc2luOiAgJ3JhZCcsXG4gICAgYWNvczogICdyYWQnXG59O1xuXG5mb3IgKHZhciBmIGluIG1hdGhGdW5jdGlvbnMpIHtcbiAgICBpZiAobWF0aEZ1bmN0aW9ucy5oYXNPd25Qcm9wZXJ0eShmKSkge1xuICAgICAgICBtYXRoRnVuY3Rpb25zW2ZdID0gbWF0aEhlbHBlci5fbWF0aC5iaW5kKG51bGwsIE1hdGhbZl0sIG1hdGhGdW5jdGlvbnNbZl0pO1xuICAgIH1cbn1cblxubWF0aEZ1bmN0aW9ucy5yb3VuZCA9IGZ1bmN0aW9uIChuLCBmKSB7XG4gICAgdmFyIGZyYWN0aW9uID0gdHlwZW9mIGYgPT09ICd1bmRlZmluZWQnID8gMCA6IGYudmFsdWU7XG4gICAgcmV0dXJuIG1hdGhIZWxwZXIuX21hdGgoZnVuY3Rpb24obnVtKSB7IHJldHVybiBudW0udG9GaXhlZChmcmFjdGlvbik7IH0sIG51bGwsIG4pO1xufTtcblxuZnVuY3Rpb25SZWdpc3RyeS5hZGRNdWx0aXBsZShtYXRoRnVuY3Rpb25zKTtcblxufSx7XCIuL2Z1bmN0aW9uLXJlZ2lzdHJ5XCI6MjcsXCIuL21hdGgtaGVscGVyLmpzXCI6MzB9XSwzMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgRGltZW5zaW9uID0gcmVxdWlyZSgnLi4vdHJlZS9kaW1lbnNpb24nKSxcbiAgICBBbm9ueW1vdXMgPSByZXF1aXJlKCcuLi90cmVlL2Fub255bW91cycpLFxuICAgIGZ1bmN0aW9uUmVnaXN0cnkgPSByZXF1aXJlKCcuL2Z1bmN0aW9uLXJlZ2lzdHJ5JyksXG4gICAgbWF0aEhlbHBlciA9IHJlcXVpcmUoJy4vbWF0aC1oZWxwZXIuanMnKTtcblxudmFyIG1pbk1heCA9IGZ1bmN0aW9uIChpc01pbiwgYXJncykge1xuICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzKTtcbiAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDogdGhyb3cgeyB0eXBlOiAnQXJndW1lbnQnLCBtZXNzYWdlOiAnb25lIG9yIG1vcmUgYXJndW1lbnRzIHJlcXVpcmVkJyB9O1xuICAgIH1cbiAgICB2YXIgaSwgaiwgY3VycmVudCwgY3VycmVudFVuaWZpZWQsIHJlZmVyZW5jZVVuaWZpZWQsIHVuaXQsIHVuaXRTdGF0aWMsIHVuaXRDbG9uZSxcbiAgICAgICAgb3JkZXIgID0gW10sIC8vIGVsZW1zIG9ubHkgY29udGFpbnMgb3JpZ2luYWwgYXJndW1lbnQgdmFsdWVzLlxuICAgICAgICB2YWx1ZXMgPSB7fTsgLy8ga2V5IGlzIHRoZSB1bml0LnRvU3RyaW5nKCkgZm9yIHVuaWZpZWQgRGltZW5zaW9uIHZhbHVlcyxcbiAgICAvLyB2YWx1ZSBpcyB0aGUgaW5kZXggaW50byB0aGUgb3JkZXIgYXJyYXkuXG4gICAgZm9yIChpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY3VycmVudCA9IGFyZ3NbaV07XG4gICAgICAgIGlmICghKGN1cnJlbnQgaW5zdGFuY2VvZiBEaW1lbnNpb24pKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmdzW2ldLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGFyZ3MsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3NbaV0udmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRVbmlmaWVkID0gY3VycmVudC51bml0LnRvU3RyaW5nKCkgPT09ICcnICYmIHVuaXRDbG9uZSAhPT0gdW5kZWZpbmVkID8gbmV3IERpbWVuc2lvbihjdXJyZW50LnZhbHVlLCB1bml0Q2xvbmUpLnVuaWZ5KCkgOiBjdXJyZW50LnVuaWZ5KCk7XG4gICAgICAgIHVuaXQgPSBjdXJyZW50VW5pZmllZC51bml0LnRvU3RyaW5nKCkgPT09ICcnICYmIHVuaXRTdGF0aWMgIT09IHVuZGVmaW5lZCA/IHVuaXRTdGF0aWMgOiBjdXJyZW50VW5pZmllZC51bml0LnRvU3RyaW5nKCk7XG4gICAgICAgIHVuaXRTdGF0aWMgPSB1bml0ICE9PSAnJyAmJiB1bml0U3RhdGljID09PSB1bmRlZmluZWQgfHwgdW5pdCAhPT0gJycgJiYgb3JkZXJbMF0udW5pZnkoKS51bml0LnRvU3RyaW5nKCkgPT09ICcnID8gdW5pdCA6IHVuaXRTdGF0aWM7XG4gICAgICAgIHVuaXRDbG9uZSA9IHVuaXQgIT09ICcnICYmIHVuaXRDbG9uZSA9PT0gdW5kZWZpbmVkID8gY3VycmVudC51bml0LnRvU3RyaW5nKCkgOiB1bml0Q2xvbmU7XG4gICAgICAgIGogPSB2YWx1ZXNbJyddICE9PSB1bmRlZmluZWQgJiYgdW5pdCAhPT0gJycgJiYgdW5pdCA9PT0gdW5pdFN0YXRpYyA/IHZhbHVlc1snJ10gOiB2YWx1ZXNbdW5pdF07XG4gICAgICAgIGlmIChqID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICh1bml0U3RhdGljICE9PSB1bmRlZmluZWQgJiYgdW5pdCAhPT0gdW5pdFN0YXRpYykge1xuICAgICAgICAgICAgICAgIHRocm93IHsgdHlwZTogJ0FyZ3VtZW50JywgbWVzc2FnZTogJ2luY29tcGF0aWJsZSB0eXBlcycgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlc1t1bml0XSA9IG9yZGVyLmxlbmd0aDtcbiAgICAgICAgICAgIG9yZGVyLnB1c2goY3VycmVudCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByZWZlcmVuY2VVbmlmaWVkID0gb3JkZXJbal0udW5pdC50b1N0cmluZygpID09PSAnJyAmJiB1bml0Q2xvbmUgIT09IHVuZGVmaW5lZCA/IG5ldyBEaW1lbnNpb24ob3JkZXJbal0udmFsdWUsIHVuaXRDbG9uZSkudW5pZnkoKSA6IG9yZGVyW2pdLnVuaWZ5KCk7XG4gICAgICAgIGlmICggaXNNaW4gJiYgY3VycmVudFVuaWZpZWQudmFsdWUgPCByZWZlcmVuY2VVbmlmaWVkLnZhbHVlIHx8XG4gICAgICAgICAgICAhaXNNaW4gJiYgY3VycmVudFVuaWZpZWQudmFsdWUgPiByZWZlcmVuY2VVbmlmaWVkLnZhbHVlKSB7XG4gICAgICAgICAgICBvcmRlcltqXSA9IGN1cnJlbnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9yZGVyLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgIHJldHVybiBvcmRlclswXTtcbiAgICB9XG4gICAgYXJncyA9IG9yZGVyLm1hcChmdW5jdGlvbiAoYSkgeyByZXR1cm4gYS50b0NTUyh0aGlzLmNvbnRleHQpOyB9KS5qb2luKHRoaXMuY29udGV4dC5jb21wcmVzcyA/ICcsJyA6ICcsICcpO1xuICAgIHJldHVybiBuZXcgQW5vbnltb3VzKChpc01pbiA/ICdtaW4nIDogJ21heCcpICsgJygnICsgYXJncyArICcpJyk7XG59O1xuZnVuY3Rpb25SZWdpc3RyeS5hZGRNdWx0aXBsZSh7XG4gICAgbWluOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBtaW5NYXgodHJ1ZSwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIG1heDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbWluTWF4KGZhbHNlLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgY29udmVydDogZnVuY3Rpb24gKHZhbCwgdW5pdCkge1xuICAgICAgICByZXR1cm4gdmFsLmNvbnZlcnRUbyh1bml0LnZhbHVlKTtcbiAgICB9LFxuICAgIHBpOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGltZW5zaW9uKE1hdGguUEkpO1xuICAgIH0sXG4gICAgbW9kOiBmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGltZW5zaW9uKGEudmFsdWUgJSBiLnZhbHVlLCBhLnVuaXQpO1xuICAgIH0sXG4gICAgcG93OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgeCA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHkgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB4ID0gbmV3IERpbWVuc2lvbih4KTtcbiAgICAgICAgICAgIHkgPSBuZXcgRGltZW5zaW9uKHkpO1xuICAgICAgICB9IGVsc2UgaWYgKCEoeCBpbnN0YW5jZW9mIERpbWVuc2lvbikgfHwgISh5IGluc3RhbmNlb2YgRGltZW5zaW9uKSkge1xuICAgICAgICAgICAgdGhyb3cgeyB0eXBlOiAnQXJndW1lbnQnLCBtZXNzYWdlOiAnYXJndW1lbnRzIG11c3QgYmUgbnVtYmVycycgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgRGltZW5zaW9uKE1hdGgucG93KHgudmFsdWUsIHkudmFsdWUpLCB4LnVuaXQpO1xuICAgIH0sXG4gICAgcGVyY2VudGFnZTogZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG1hdGhIZWxwZXIuX21hdGgoZnVuY3Rpb24obnVtKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVtICogMTAwO1xuICAgICAgICB9LCAnJScsIG4pO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufSk7XG5cbn0se1wiLi4vdHJlZS9hbm9ueW1vdXNcIjo1MCxcIi4uL3RyZWUvZGltZW5zaW9uXCI6NjIsXCIuL2Z1bmN0aW9uLXJlZ2lzdHJ5XCI6MjcsXCIuL21hdGgtaGVscGVyLmpzXCI6MzB9XSwzMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgUXVvdGVkID0gcmVxdWlyZSgnLi4vdHJlZS9xdW90ZWQnKSxcbiAgICBBbm9ueW1vdXMgPSByZXF1aXJlKCcuLi90cmVlL2Fub255bW91cycpLFxuICAgIEphdmFTY3JpcHQgPSByZXF1aXJlKCcuLi90cmVlL2phdmFzY3JpcHQnKSxcbiAgICBmdW5jdGlvblJlZ2lzdHJ5ID0gcmVxdWlyZSgnLi9mdW5jdGlvbi1yZWdpc3RyeScpO1xuXG5mdW5jdGlvblJlZ2lzdHJ5LmFkZE11bHRpcGxlKHtcbiAgICBlOiBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIHJldHVybiBuZXcgQW5vbnltb3VzKHN0ciBpbnN0YW5jZW9mIEphdmFTY3JpcHQgPyBzdHIuZXZhbHVhdGVkIDogc3RyLnZhbHVlKTtcbiAgICB9LFxuICAgIGVzY2FwZTogZnVuY3Rpb24gKHN0cikge1xuICAgICAgICByZXR1cm4gbmV3IEFub255bW91cyhcbiAgICAgICAgICAgIGVuY29kZVVSSShzdHIudmFsdWUpLnJlcGxhY2UoLz0vZywgJyUzRCcpLnJlcGxhY2UoLzovZywgJyUzQScpLnJlcGxhY2UoLyMvZywgJyUyMycpLnJlcGxhY2UoLzsvZywgJyUzQicpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcKC9nLCAnJTI4JykucmVwbGFjZSgvXFwpL2csICclMjknKSk7XG4gICAgfSxcbiAgICByZXBsYWNlOiBmdW5jdGlvbiAoc3RyaW5nLCBwYXR0ZXJuLCByZXBsYWNlbWVudCwgZmxhZ3MpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHN0cmluZy52YWx1ZTtcbiAgICAgICAgcmVwbGFjZW1lbnQgPSAocmVwbGFjZW1lbnQudHlwZSA9PT0gJ1F1b3RlZCcpID9cbiAgICAgICAgICAgIHJlcGxhY2VtZW50LnZhbHVlIDogcmVwbGFjZW1lbnQudG9DU1MoKTtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UobmV3IFJlZ0V4cChwYXR0ZXJuLnZhbHVlLCBmbGFncyA/IGZsYWdzLnZhbHVlIDogJycpLCByZXBsYWNlbWVudCk7XG4gICAgICAgIHJldHVybiBuZXcgUXVvdGVkKHN0cmluZy5xdW90ZSB8fCAnJywgcmVzdWx0LCBzdHJpbmcuZXNjYXBlZCk7XG4gICAgfSxcbiAgICAnJSc6IGZ1bmN0aW9uIChzdHJpbmcgLyogYXJnLCBhcmcsIC4uLiAqLykge1xuICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSksXG4gICAgICAgICAgICByZXN1bHQgPSBzdHJpbmcudmFsdWU7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAvKiBqc2hpbnQgbG9vcGZ1bmM6dHJ1ZSAqL1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UoLyVbc2RhXS9pLCBmdW5jdGlvbih0b2tlbikge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9ICgoYXJnc1tpXS50eXBlID09PSAnUXVvdGVkJykgJiZcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4ubWF0Y2goL3MvaSkpID8gYXJnc1tpXS52YWx1ZSA6IGFyZ3NbaV0udG9DU1MoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW4ubWF0Y2goL1tBLVpdJC8pID8gZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKSA6IHZhbHVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UoLyUlL2csICclJyk7XG4gICAgICAgIHJldHVybiBuZXcgUXVvdGVkKHN0cmluZy5xdW90ZSB8fCAnJywgcmVzdWx0LCBzdHJpbmcuZXNjYXBlZCk7XG4gICAgfVxufSk7XG5cbn0se1wiLi4vdHJlZS9hbm9ueW1vdXNcIjo1MCxcIi4uL3RyZWUvamF2YXNjcmlwdFwiOjY4LFwiLi4vdHJlZS9xdW90ZWRcIjo4MCxcIi4vZnVuY3Rpb24tcmVnaXN0cnlcIjoyN31dLDM0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZW52aXJvbm1lbnQpIHtcbiAgICB2YXIgRGltZW5zaW9uID0gcmVxdWlyZSgnLi4vdHJlZS9kaW1lbnNpb24nKSxcbiAgICAgICAgQ29sb3IgPSByZXF1aXJlKCcuLi90cmVlL2NvbG9yJyksXG4gICAgICAgIEV4cHJlc3Npb24gPSByZXF1aXJlKCcuLi90cmVlL2V4cHJlc3Npb24nKSxcbiAgICAgICAgUXVvdGVkID0gcmVxdWlyZSgnLi4vdHJlZS9xdW90ZWQnKSxcbiAgICAgICAgVVJMID0gcmVxdWlyZSgnLi4vdHJlZS91cmwnKSxcbiAgICAgICAgZnVuY3Rpb25SZWdpc3RyeSA9IHJlcXVpcmUoJy4vZnVuY3Rpb24tcmVnaXN0cnknKTtcblxuICAgIGZ1bmN0aW9uUmVnaXN0cnkuYWRkKCdzdmctZ3JhZGllbnQnLCBmdW5jdGlvbihkaXJlY3Rpb24pIHtcblxuICAgICAgICB2YXIgc3RvcHMsXG4gICAgICAgICAgICBncmFkaWVudERpcmVjdGlvblN2ZyxcbiAgICAgICAgICAgIGdyYWRpZW50VHlwZSA9ICdsaW5lYXInLFxuICAgICAgICAgICAgcmVjdGFuZ2xlRGltZW5zaW9uID0gJ3g9XCIwXCIgeT1cIjBcIiB3aWR0aD1cIjFcIiBoZWlnaHQ9XCIxXCInLFxuICAgICAgICAgICAgcmVuZGVyRW52ID0ge2NvbXByZXNzOiBmYWxzZX0sXG4gICAgICAgICAgICByZXR1cm5lcixcbiAgICAgICAgICAgIGRpcmVjdGlvblZhbHVlID0gZGlyZWN0aW9uLnRvQ1NTKHJlbmRlckVudiksXG4gICAgICAgICAgICBpLCBjb2xvciwgcG9zaXRpb24sIHBvc2l0aW9uVmFsdWUsIGFscGhhO1xuXG4gICAgICAgIGZ1bmN0aW9uIHRocm93QXJndW1lbnREZXNjcmlwdG9yKCkge1xuICAgICAgICAgICAgdGhyb3cgeyB0eXBlOiAnQXJndW1lbnQnLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdzdmctZ3JhZGllbnQgZXhwZWN0cyBkaXJlY3Rpb24sIHN0YXJ0X2NvbG9yIFtzdGFydF9wb3NpdGlvbl0sIFtjb2xvciBwb3NpdGlvbixdLi4uLCcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgZW5kX2NvbG9yIFtlbmRfcG9zaXRpb25dIG9yIGRpcmVjdGlvbiwgY29sb3IgbGlzdCcgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDIpIHtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHNbMV0udmFsdWUubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgICAgIHRocm93QXJndW1lbnREZXNjcmlwdG9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdG9wcyA9IGFyZ3VtZW50c1sxXS52YWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykge1xuICAgICAgICAgICAgdGhyb3dBcmd1bWVudERlc2NyaXB0b3IoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0b3BzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAoZGlyZWN0aW9uVmFsdWUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3RvIGJvdHRvbSc6XG4gICAgICAgICAgICAgICAgZ3JhZGllbnREaXJlY3Rpb25TdmcgPSAneDE9XCIwJVwiIHkxPVwiMCVcIiB4Mj1cIjAlXCIgeTI9XCIxMDAlXCInO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAndG8gcmlnaHQnOlxuICAgICAgICAgICAgICAgIGdyYWRpZW50RGlyZWN0aW9uU3ZnID0gJ3gxPVwiMCVcIiB5MT1cIjAlXCIgeDI9XCIxMDAlXCIgeTI9XCIwJVwiJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3RvIGJvdHRvbSByaWdodCc6XG4gICAgICAgICAgICAgICAgZ3JhZGllbnREaXJlY3Rpb25TdmcgPSAneDE9XCIwJVwiIHkxPVwiMCVcIiB4Mj1cIjEwMCVcIiB5Mj1cIjEwMCVcIic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd0byB0b3AgcmlnaHQnOlxuICAgICAgICAgICAgICAgIGdyYWRpZW50RGlyZWN0aW9uU3ZnID0gJ3gxPVwiMCVcIiB5MT1cIjEwMCVcIiB4Mj1cIjEwMCVcIiB5Mj1cIjAlXCInO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZWxsaXBzZSc6XG4gICAgICAgICAgICBjYXNlICdlbGxpcHNlIGF0IGNlbnRlcic6XG4gICAgICAgICAgICAgICAgZ3JhZGllbnRUeXBlID0gJ3JhZGlhbCc7XG4gICAgICAgICAgICAgICAgZ3JhZGllbnREaXJlY3Rpb25TdmcgPSAnY3g9XCI1MCVcIiBjeT1cIjUwJVwiIHI9XCI3NSVcIic7XG4gICAgICAgICAgICAgICAgcmVjdGFuZ2xlRGltZW5zaW9uID0gJ3g9XCItNTBcIiB5PVwiLTUwXCIgd2lkdGg9XCIxMDFcIiBoZWlnaHQ9XCIxMDFcIic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IHsgdHlwZTogJ0FyZ3VtZW50JywgbWVzc2FnZTogJ3N2Zy1ncmFkaWVudCBkaXJlY3Rpb24gbXVzdCBiZSBcXCd0byBib3R0b21cXCcsIFxcJ3RvIHJpZ2h0XFwnLCcgK1xuICAgICAgICAgICAgICAgICAgICAnIFxcJ3RvIGJvdHRvbSByaWdodFxcJywgXFwndG8gdG9wIHJpZ2h0XFwnIG9yIFxcJ2VsbGlwc2UgYXQgY2VudGVyXFwnJyB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybmVyID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHZpZXdCb3g9XCIwIDAgMSAxXCI+JyArXG4gICAgICAgICAgICAnPCcgKyBncmFkaWVudFR5cGUgKyAnR3JhZGllbnQgaWQ9XCJnXCIgJyArIGdyYWRpZW50RGlyZWN0aW9uU3ZnICsgJz4nO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzdG9wcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgaWYgKHN0b3BzW2ldIGluc3RhbmNlb2YgRXhwcmVzc2lvbikge1xuICAgICAgICAgICAgICAgIGNvbG9yID0gc3RvcHNbaV0udmFsdWVbMF07XG4gICAgICAgICAgICAgICAgcG9zaXRpb24gPSBzdG9wc1tpXS52YWx1ZVsxXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29sb3IgPSBzdG9wc1tpXTtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCEoY29sb3IgaW5zdGFuY2VvZiBDb2xvcikgfHwgKCEoKGkgPT09IDAgfHwgaSArIDEgPT09IHN0b3BzLmxlbmd0aCkgJiYgcG9zaXRpb24gPT09IHVuZGVmaW5lZCkgJiYgIShwb3NpdGlvbiBpbnN0YW5jZW9mIERpbWVuc2lvbikpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dBcmd1bWVudERlc2NyaXB0b3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvc2l0aW9uVmFsdWUgPSBwb3NpdGlvbiA/IHBvc2l0aW9uLnRvQ1NTKHJlbmRlckVudikgOiBpID09PSAwID8gJzAlJyA6ICcxMDAlJztcbiAgICAgICAgICAgIGFscGhhID0gY29sb3IuYWxwaGE7XG4gICAgICAgICAgICByZXR1cm5lciArPSAnPHN0b3Agb2Zmc2V0PVwiJyArIHBvc2l0aW9uVmFsdWUgKyAnXCIgc3RvcC1jb2xvcj1cIicgKyBjb2xvci50b1JHQigpICsgJ1wiJyArIChhbHBoYSA8IDEgPyAnIHN0b3Atb3BhY2l0eT1cIicgKyBhbHBoYSArICdcIicgOiAnJykgKyAnLz4nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybmVyICs9ICc8LycgKyBncmFkaWVudFR5cGUgKyAnR3JhZGllbnQ+JyArXG4gICAgICAgICAgICAnPHJlY3QgJyArIHJlY3RhbmdsZURpbWVuc2lvbiArICcgZmlsbD1cInVybCgjZylcIiAvPjwvc3ZnPic7XG5cbiAgICAgICAgcmV0dXJuZXIgPSBlbmNvZGVVUklDb21wb25lbnQocmV0dXJuZXIpO1xuXG4gICAgICAgIHJldHVybmVyID0gJ2RhdGE6aW1hZ2Uvc3ZnK3htbCwnICsgcmV0dXJuZXI7XG4gICAgICAgIHJldHVybiBuZXcgVVJMKG5ldyBRdW90ZWQoJ1xcJycgKyByZXR1cm5lciArICdcXCcnLCByZXR1cm5lciwgZmFsc2UsIHRoaXMuaW5kZXgsIHRoaXMuY3VycmVudEZpbGVJbmZvKSwgdGhpcy5pbmRleCwgdGhpcy5jdXJyZW50RmlsZUluZm8pO1xuICAgIH0pO1xufTtcblxufSx7XCIuLi90cmVlL2NvbG9yXCI6NTUsXCIuLi90cmVlL2RpbWVuc2lvblwiOjYyLFwiLi4vdHJlZS9leHByZXNzaW9uXCI6NjQsXCIuLi90cmVlL3F1b3RlZFwiOjgwLFwiLi4vdHJlZS91cmxcIjo4NSxcIi4vZnVuY3Rpb24tcmVnaXN0cnlcIjoyN31dLDM1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBLZXl3b3JkID0gcmVxdWlyZSgnLi4vdHJlZS9rZXl3b3JkJyksXG4gICAgRGV0YWNoZWRSdWxlc2V0ID0gcmVxdWlyZSgnLi4vdHJlZS9kZXRhY2hlZC1ydWxlc2V0JyksXG4gICAgRGltZW5zaW9uID0gcmVxdWlyZSgnLi4vdHJlZS9kaW1lbnNpb24nKSxcbiAgICBDb2xvciA9IHJlcXVpcmUoJy4uL3RyZWUvY29sb3InKSxcbiAgICBRdW90ZWQgPSByZXF1aXJlKCcuLi90cmVlL3F1b3RlZCcpLFxuICAgIEFub255bW91cyA9IHJlcXVpcmUoJy4uL3RyZWUvYW5vbnltb3VzJyksXG4gICAgVVJMID0gcmVxdWlyZSgnLi4vdHJlZS91cmwnKSxcbiAgICBPcGVyYXRpb24gPSByZXF1aXJlKCcuLi90cmVlL29wZXJhdGlvbicpLFxuICAgIGZ1bmN0aW9uUmVnaXN0cnkgPSByZXF1aXJlKCcuL2Z1bmN0aW9uLXJlZ2lzdHJ5Jyk7XG5cbnZhciBpc2EgPSBmdW5jdGlvbiAobiwgVHlwZSkge1xuICAgICAgICByZXR1cm4gKG4gaW5zdGFuY2VvZiBUeXBlKSA/IEtleXdvcmQuVHJ1ZSA6IEtleXdvcmQuRmFsc2U7XG4gICAgfSxcbiAgICBpc3VuaXQgPSBmdW5jdGlvbiAobiwgdW5pdCkge1xuICAgICAgICBpZiAodW5pdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyB7IHR5cGU6ICdBcmd1bWVudCcsIG1lc3NhZ2U6ICdtaXNzaW5nIHRoZSByZXF1aXJlZCBzZWNvbmQgYXJndW1lbnQgdG8gaXN1bml0LicgfTtcbiAgICAgICAgfVxuICAgICAgICB1bml0ID0gdHlwZW9mIHVuaXQudmFsdWUgPT09ICdzdHJpbmcnID8gdW5pdC52YWx1ZSA6IHVuaXQ7XG4gICAgICAgIGlmICh0eXBlb2YgdW5pdCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IHsgdHlwZTogJ0FyZ3VtZW50JywgbWVzc2FnZTogJ1NlY29uZCBhcmd1bWVudCB0byBpc3VuaXQgc2hvdWxkIGJlIGEgdW5pdCBvciBhIHN0cmluZy4nIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChuIGluc3RhbmNlb2YgRGltZW5zaW9uKSAmJiBuLnVuaXQuaXModW5pdCkgPyBLZXl3b3JkLlRydWUgOiBLZXl3b3JkLkZhbHNlO1xuICAgIH07XG5cbmZ1bmN0aW9uUmVnaXN0cnkuYWRkTXVsdGlwbGUoe1xuICAgIGlzcnVsZXNldDogZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgcmV0dXJuIGlzYShuLCBEZXRhY2hlZFJ1bGVzZXQpO1xuICAgIH0sXG4gICAgaXNjb2xvcjogZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgcmV0dXJuIGlzYShuLCBDb2xvcik7XG4gICAgfSxcbiAgICBpc251bWJlcjogZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgcmV0dXJuIGlzYShuLCBEaW1lbnNpb24pO1xuICAgIH0sXG4gICAgaXNzdHJpbmc6IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIHJldHVybiBpc2EobiwgUXVvdGVkKTtcbiAgICB9LFxuICAgIGlza2V5d29yZDogZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgcmV0dXJuIGlzYShuLCBLZXl3b3JkKTtcbiAgICB9LFxuICAgIGlzdXJsOiBmdW5jdGlvbiAobikge1xuICAgICAgICByZXR1cm4gaXNhKG4sIFVSTCk7XG4gICAgfSxcbiAgICBpc3BpeGVsOiBmdW5jdGlvbiAobikge1xuICAgICAgICByZXR1cm4gaXN1bml0KG4sICdweCcpO1xuICAgIH0sXG4gICAgaXNwZXJjZW50YWdlOiBmdW5jdGlvbiAobikge1xuICAgICAgICByZXR1cm4gaXN1bml0KG4sICclJyk7XG4gICAgfSxcbiAgICBpc2VtOiBmdW5jdGlvbiAobikge1xuICAgICAgICByZXR1cm4gaXN1bml0KG4sICdlbScpO1xuICAgIH0sXG4gICAgaXN1bml0OiBpc3VuaXQsXG4gICAgdW5pdDogZnVuY3Rpb24gKHZhbCwgdW5pdCkge1xuICAgICAgICBpZiAoISh2YWwgaW5zdGFuY2VvZiBEaW1lbnNpb24pKSB7XG4gICAgICAgICAgICB0aHJvdyB7IHR5cGU6ICdBcmd1bWVudCcsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ3RoZSBmaXJzdCBhcmd1bWVudCB0byB1bml0IG11c3QgYmUgYSBudW1iZXInICtcbiAgICAgICAgICAgICAgICAgICAgKHZhbCBpbnN0YW5jZW9mIE9wZXJhdGlvbiA/ICcuIEhhdmUgeW91IGZvcmdvdHRlbiBwYXJlbnRoZXNpcz8nIDogJycpIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVuaXQpIHtcbiAgICAgICAgICAgIGlmICh1bml0IGluc3RhbmNlb2YgS2V5d29yZCkge1xuICAgICAgICAgICAgICAgIHVuaXQgPSB1bml0LnZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB1bml0ID0gdW5pdC50b0NTUygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdW5pdCA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRGltZW5zaW9uKHZhbC52YWx1ZSwgdW5pdCk7XG4gICAgfSxcbiAgICAnZ2V0LXVuaXQnOiBmdW5jdGlvbiAobikge1xuICAgICAgICByZXR1cm4gbmV3IEFub255bW91cyhuLnVuaXQpO1xuICAgIH1cbn0pO1xuXG59LHtcIi4uL3RyZWUvYW5vbnltb3VzXCI6NTAsXCIuLi90cmVlL2NvbG9yXCI6NTUsXCIuLi90cmVlL2RldGFjaGVkLXJ1bGVzZXRcIjo2MSxcIi4uL3RyZWUvZGltZW5zaW9uXCI6NjIsXCIuLi90cmVlL2tleXdvcmRcIjo3MCxcIi4uL3RyZWUvb3BlcmF0aW9uXCI6NzcsXCIuLi90cmVlL3F1b3RlZFwiOjgwLFwiLi4vdHJlZS91cmxcIjo4NSxcIi4vZnVuY3Rpb24tcmVnaXN0cnlcIjoyN31dLDM2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBjb250ZXh0cyA9IHJlcXVpcmUoJy4vY29udGV4dHMnKSxcbiAgICBQYXJzZXIgPSByZXF1aXJlKCcuL3BhcnNlci9wYXJzZXInKSxcbiAgICBMZXNzRXJyb3IgPSByZXF1aXJlKCcuL2xlc3MtZXJyb3InKSxcbiAgICB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKSxcbiAgICBQcm9taXNlQ29uc3RydWN0b3IgPSB0eXBlb2YgUHJvbWlzZSA9PT0gJ3VuZGVmaW5lZCcgPyByZXF1aXJlKCdwcm9taXNlJykgOiBQcm9taXNlLFxuICAgIGxvZ2dlciA9IHJlcXVpcmUoJy4vbG9nZ2VyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZW52aXJvbm1lbnQpIHtcblxuICAgIC8vIEZpbGVJbmZvID0ge1xuICAgIC8vICAncmV3cml0ZVVybHMnIC0gb3B0aW9uIC0gd2hldGhlciB0byBhZGp1c3QgVVJMJ3MgdG8gYmUgcmVsYXRpdmVcbiAgICAvLyAgJ2ZpbGVuYW1lJyAtIGZ1bGwgcmVzb2x2ZWQgZmlsZW5hbWUgb2YgY3VycmVudCBmaWxlXG4gICAgLy8gICdyb290cGF0aCcgLSBwYXRoIHRvIGFwcGVuZCB0byBub3JtYWwgVVJMcyBmb3IgdGhpcyBub2RlXG4gICAgLy8gICdjdXJyZW50RGlyZWN0b3J5JyAtIHBhdGggdG8gdGhlIGN1cnJlbnQgZmlsZSwgYWJzb2x1dGVcbiAgICAvLyAgJ3Jvb3RGaWxlbmFtZScgLSBmaWxlbmFtZSBvZiB0aGUgYmFzZSBmaWxlXG4gICAgLy8gICdlbnRyeVBhdGgnIC0gYWJzb2x1dGUgcGF0aCB0byB0aGUgZW50cnkgZmlsZVxuICAgIC8vICAncmVmZXJlbmNlJyAtIHdoZXRoZXIgdGhlIGZpbGUgc2hvdWxkIG5vdCBiZSBvdXRwdXQgYW5kIG9ubHkgb3V0cHV0IHBhcnRzIHRoYXQgYXJlIHJlZmVyZW5jZWRcblxuICAgIHZhciBJbXBvcnRNYW5hZ2VyID0gZnVuY3Rpb24obGVzcywgY29udGV4dCwgcm9vdEZpbGVJbmZvKSB7XG4gICAgICAgIHRoaXMubGVzcyA9IGxlc3M7XG4gICAgICAgIHRoaXMucm9vdEZpbGVuYW1lID0gcm9vdEZpbGVJbmZvLmZpbGVuYW1lO1xuICAgICAgICB0aGlzLnBhdGhzID0gY29udGV4dC5wYXRocyB8fCBbXTsgIC8vIFNlYXJjaCBwYXRocywgd2hlbiBpbXBvcnRpbmdcbiAgICAgICAgdGhpcy5jb250ZW50cyA9IHt9OyAgICAgICAgICAgICAvLyBtYXAgLSBmaWxlbmFtZSB0byBjb250ZW50cyBvZiBhbGwgdGhlIGZpbGVzXG4gICAgICAgIHRoaXMuY29udGVudHNJZ25vcmVkQ2hhcnMgPSB7fTsgLy8gbWFwIC0gZmlsZW5hbWUgdG8gbGluZXMgYXQgdGhlIGJlZ2lubmluZyBvZiBlYWNoIGZpbGUgdG8gaWdub3JlXG4gICAgICAgIHRoaXMubWltZSA9IGNvbnRleHQubWltZTtcbiAgICAgICAgdGhpcy5lcnJvciA9IG51bGw7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIC8vIERlcHJlY2F0ZWQ/IFVudXNlZCBvdXRzaWRlIG9mIGhlcmUsIGNvdWxkIGJlIHVzZWZ1bC5cbiAgICAgICAgdGhpcy5xdWV1ZSA9IFtdOyAgICAgICAgLy8gRmlsZXMgd2hpY2ggaGF2ZW4ndCBiZWVuIGltcG9ydGVkIHlldFxuICAgICAgICB0aGlzLmZpbGVzID0ge307ICAgICAgICAvLyBIb2xkcyB0aGUgaW1wb3J0ZWQgcGFyc2UgdHJlZXMuXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFkZCBhbiBpbXBvcnQgdG8gYmUgaW1wb3J0ZWRcbiAgICAgKiBAcGFyYW0gcGF0aCAtIHRoZSByYXcgcGF0aFxuICAgICAqIEBwYXJhbSB0cnlBcHBlbmRFeHRlbnNpb24gLSB3aGV0aGVyIHRvIHRyeSBhcHBlbmRpbmcgYSBmaWxlIGV4dGVuc2lvbiAoLmxlc3Mgb3IgLmpzIGlmIHRoZSBwYXRoIGhhcyBubyBleHRlbnNpb24pXG4gICAgICogQHBhcmFtIGN1cnJlbnRGaWxlSW5mbyAtIHRoZSBjdXJyZW50IGZpbGUgaW5mbyAodXNlZCBmb3IgaW5zdGFuY2UgdG8gd29yayBvdXQgcmVsYXRpdmUgcGF0aHMpXG4gICAgICogQHBhcmFtIGltcG9ydE9wdGlvbnMgLSBpbXBvcnQgb3B0aW9uc1xuICAgICAqIEBwYXJhbSBjYWxsYmFjayAtIGNhbGxiYWNrIGZvciB3aGVuIGl0IGlzIGltcG9ydGVkXG4gICAgICovXG4gICAgSW1wb3J0TWFuYWdlci5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChwYXRoLCB0cnlBcHBlbmRFeHRlbnNpb24sIGN1cnJlbnRGaWxlSW5mbywgaW1wb3J0T3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGltcG9ydE1hbmFnZXIgPSB0aGlzLFxuICAgICAgICAgICAgcGx1Z2luTG9hZGVyID0gdGhpcy5jb250ZXh0LnBsdWdpbk1hbmFnZXIuTG9hZGVyO1xuXG4gICAgICAgIHRoaXMucXVldWUucHVzaChwYXRoKTtcblxuICAgICAgICB2YXIgZmlsZVBhcnNlZEZ1bmMgPSBmdW5jdGlvbiAoZSwgcm9vdCwgZnVsbFBhdGgpIHtcbiAgICAgICAgICAgIGltcG9ydE1hbmFnZXIucXVldWUuc3BsaWNlKGltcG9ydE1hbmFnZXIucXVldWUuaW5kZXhPZihwYXRoKSwgMSk7IC8vIFJlbW92ZSB0aGUgcGF0aCBmcm9tIHRoZSBxdWV1ZVxuXG4gICAgICAgICAgICB2YXIgaW1wb3J0ZWRFcXVhbHNSb290ID0gZnVsbFBhdGggPT09IGltcG9ydE1hbmFnZXIucm9vdEZpbGVuYW1lO1xuICAgICAgICAgICAgaWYgKGltcG9ydE9wdGlvbnMub3B0aW9uYWwgJiYgZSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHtydWxlczpbXX0sIGZhbHNlLCBudWxsKTtcbiAgICAgICAgICAgICAgICBsb2dnZXIuaW5mbygnVGhlIGZpbGUgJyArIGZ1bGxQYXRoICsgJyB3YXMgc2tpcHBlZCBiZWNhdXNlIGl0IHdhcyBub3QgZm91bmQgYW5kIHRoZSBpbXBvcnQgd2FzIG1hcmtlZCBvcHRpb25hbC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIElubGluZSBpbXBvcnRzIGFyZW4ndCBjYWNoZWQgaGVyZS5cbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBzdGFydCB0byBjYWNoZSB0aGVtLCBwbGVhc2UgbWFrZSBzdXJlIHRoZXkgd29uJ3QgY29uZmxpY3Qgd2l0aCBub24taW5saW5lIGltcG9ydHMgb2YgdGhlXG4gICAgICAgICAgICAgICAgLy8gc2FtZSBuYW1lIGFzIHRoZXkgdXNlZCB0byBkbyBiZWZvcmUgdGhpcyBjb21tZW50IGFuZCB0aGUgY29uZGl0aW9uIGJlbG93IGhhdmUgYmVlbiBhZGRlZC5cbiAgICAgICAgICAgICAgICBpZiAoIWltcG9ydE1hbmFnZXIuZmlsZXNbZnVsbFBhdGhdICYmICFpbXBvcnRPcHRpb25zLmlubGluZSkge1xuICAgICAgICAgICAgICAgICAgICBpbXBvcnRNYW5hZ2VyLmZpbGVzW2Z1bGxQYXRoXSA9IHsgcm9vdDogcm9vdCwgb3B0aW9uczogaW1wb3J0T3B0aW9ucyB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZSAmJiAhaW1wb3J0TWFuYWdlci5lcnJvcikgeyBpbXBvcnRNYW5hZ2VyLmVycm9yID0gZTsgfVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGUsIHJvb3QsIGltcG9ydGVkRXF1YWxzUm9vdCwgZnVsbFBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBuZXdGaWxlSW5mbyA9IHtcbiAgICAgICAgICAgIHJld3JpdGVVcmxzOiB0aGlzLmNvbnRleHQucmV3cml0ZVVybHMsXG4gICAgICAgICAgICBlbnRyeVBhdGg6IGN1cnJlbnRGaWxlSW5mby5lbnRyeVBhdGgsXG4gICAgICAgICAgICByb290cGF0aDogY3VycmVudEZpbGVJbmZvLnJvb3RwYXRoLFxuICAgICAgICAgICAgcm9vdEZpbGVuYW1lOiBjdXJyZW50RmlsZUluZm8ucm9vdEZpbGVuYW1lXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGZpbGVNYW5hZ2VyID0gZW52aXJvbm1lbnQuZ2V0RmlsZU1hbmFnZXIocGF0aCwgY3VycmVudEZpbGVJbmZvLmN1cnJlbnREaXJlY3RvcnksIHRoaXMuY29udGV4dCwgZW52aXJvbm1lbnQpO1xuXG4gICAgICAgIGlmICghZmlsZU1hbmFnZXIpIHtcbiAgICAgICAgICAgIGZpbGVQYXJzZWRGdW5jKHsgbWVzc2FnZTogJ0NvdWxkIG5vdCBmaW5kIGEgZmlsZS1tYW5hZ2VyIGZvciAnICsgcGF0aCB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsb2FkRmlsZUNhbGxiYWNrID0gZnVuY3Rpb24obG9hZGVkRmlsZSkge1xuICAgICAgICAgICAgdmFyIHBsdWdpbixcbiAgICAgICAgICAgICAgICByZXNvbHZlZEZpbGVuYW1lID0gbG9hZGVkRmlsZS5maWxlbmFtZSxcbiAgICAgICAgICAgICAgICBjb250ZW50cyA9IGxvYWRlZEZpbGUuY29udGVudHMucmVwbGFjZSgvXlxcdUZFRkYvLCAnJyk7XG5cbiAgICAgICAgICAgIC8vIFBhc3Mgb24gYW4gdXBkYXRlZCByb290cGF0aCBpZiBwYXRoIG9mIGltcG9ydGVkIGZpbGUgaXMgcmVsYXRpdmUgYW5kIGZpbGVcbiAgICAgICAgICAgIC8vIGlzIGluIGEgKHN1YnxzdXApIGRpcmVjdG9yeVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIEV4YW1wbGVzOlxuICAgICAgICAgICAgLy8gLSBJZiBwYXRoIG9mIGltcG9ydGVkIGZpbGUgaXMgJ21vZHVsZS9uYXYvbmF2Lmxlc3MnIGFuZCByb290cGF0aCBpcyAnbGVzcy8nLFxuICAgICAgICAgICAgLy8gICB0aGVuIHJvb3RwYXRoIHNob3VsZCBiZWNvbWUgJ2xlc3MvbW9kdWxlL25hdi8nXG4gICAgICAgICAgICAvLyAtIElmIHBhdGggb2YgaW1wb3J0ZWQgZmlsZSBpcyAnLi4vbWl4aW5zLmxlc3MnIGFuZCByb290cGF0aCBpcyAnbGVzcy8nLFxuICAgICAgICAgICAgLy8gICB0aGVuIHJvb3RwYXRoIHNob3VsZCBiZWNvbWUgJ2xlc3MvLi4vJ1xuICAgICAgICAgICAgbmV3RmlsZUluZm8uY3VycmVudERpcmVjdG9yeSA9IGZpbGVNYW5hZ2VyLmdldFBhdGgocmVzb2x2ZWRGaWxlbmFtZSk7XG4gICAgICAgICAgICBpZiAobmV3RmlsZUluZm8ucmV3cml0ZVVybHMpIHtcbiAgICAgICAgICAgICAgICBuZXdGaWxlSW5mby5yb290cGF0aCA9IGZpbGVNYW5hZ2VyLmpvaW4oXG4gICAgICAgICAgICAgICAgICAgIChpbXBvcnRNYW5hZ2VyLmNvbnRleHQucm9vdHBhdGggfHwgJycpLFxuICAgICAgICAgICAgICAgICAgICBmaWxlTWFuYWdlci5wYXRoRGlmZihuZXdGaWxlSW5mby5jdXJyZW50RGlyZWN0b3J5LCBuZXdGaWxlSW5mby5lbnRyeVBhdGgpKTtcblxuICAgICAgICAgICAgICAgIGlmICghZmlsZU1hbmFnZXIuaXNQYXRoQWJzb2x1dGUobmV3RmlsZUluZm8ucm9vdHBhdGgpICYmIGZpbGVNYW5hZ2VyLmFsd2F5c01ha2VQYXRoc0Fic29sdXRlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3RmlsZUluZm8ucm9vdHBhdGggPSBmaWxlTWFuYWdlci5qb2luKG5ld0ZpbGVJbmZvLmVudHJ5UGF0aCwgbmV3RmlsZUluZm8ucm9vdHBhdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld0ZpbGVJbmZvLmZpbGVuYW1lID0gcmVzb2x2ZWRGaWxlbmFtZTtcblxuICAgICAgICAgICAgdmFyIG5ld0VudiA9IG5ldyBjb250ZXh0cy5QYXJzZShpbXBvcnRNYW5hZ2VyLmNvbnRleHQpO1xuXG4gICAgICAgICAgICBuZXdFbnYucHJvY2Vzc0ltcG9ydHMgPSBmYWxzZTtcbiAgICAgICAgICAgIGltcG9ydE1hbmFnZXIuY29udGVudHNbcmVzb2x2ZWRGaWxlbmFtZV0gPSBjb250ZW50cztcblxuICAgICAgICAgICAgaWYgKGN1cnJlbnRGaWxlSW5mby5yZWZlcmVuY2UgfHwgaW1wb3J0T3B0aW9ucy5yZWZlcmVuY2UpIHtcbiAgICAgICAgICAgICAgICBuZXdGaWxlSW5mby5yZWZlcmVuY2UgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaW1wb3J0T3B0aW9ucy5pc1BsdWdpbikge1xuICAgICAgICAgICAgICAgIHBsdWdpbiA9IHBsdWdpbkxvYWRlci5ldmFsUGx1Z2luKGNvbnRlbnRzLCBuZXdFbnYsIGltcG9ydE1hbmFnZXIsIGltcG9ydE9wdGlvbnMucGx1Z2luQXJncywgbmV3RmlsZUluZm8pO1xuICAgICAgICAgICAgICAgIGlmIChwbHVnaW4gaW5zdGFuY2VvZiBMZXNzRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsZVBhcnNlZEZ1bmMocGx1Z2luLCBudWxsLCByZXNvbHZlZEZpbGVuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGVQYXJzZWRGdW5jKG51bGwsIHBsdWdpbiwgcmVzb2x2ZWRGaWxlbmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChpbXBvcnRPcHRpb25zLmlubGluZSkge1xuICAgICAgICAgICAgICAgIGZpbGVQYXJzZWRGdW5jKG51bGwsIGNvbnRlbnRzLCByZXNvbHZlZEZpbGVuYW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAvLyBpbXBvcnQgKG11bHRpcGxlKSBwYXJzZSB0cmVlcyBhcHBhcmVudGx5IGdldCBhbHRlcmVkIGFuZCBjYW4ndCBiZSBjYWNoZWQuXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogaW52ZXN0aWdhdGUgd2h5IHRoaXMgaXNcbiAgICAgICAgICAgICAgICBpZiAoaW1wb3J0TWFuYWdlci5maWxlc1tyZXNvbHZlZEZpbGVuYW1lXVxuICAgICAgICAgICAgICAgICAgICAmJiAhaW1wb3J0TWFuYWdlci5maWxlc1tyZXNvbHZlZEZpbGVuYW1lXS5vcHRpb25zLm11bHRpcGxlXG4gICAgICAgICAgICAgICAgICAgICYmICFpbXBvcnRPcHRpb25zLm11bHRpcGxlKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgZmlsZVBhcnNlZEZ1bmMobnVsbCwgaW1wb3J0TWFuYWdlci5maWxlc1tyZXNvbHZlZEZpbGVuYW1lXS5yb290LCByZXNvbHZlZEZpbGVuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5ldyBQYXJzZXIobmV3RW52LCBpbXBvcnRNYW5hZ2VyLCBuZXdGaWxlSW5mbykucGFyc2UoY29udGVudHMsIGZ1bmN0aW9uIChlLCByb290KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlUGFyc2VkRnVuYyhlLCByb290LCByZXNvbHZlZEZpbGVuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgcHJvbWlzZSwgY29udGV4dCA9IHV0aWxzLmNsb25lKHRoaXMuY29udGV4dCk7XG5cbiAgICAgICAgaWYgKHRyeUFwcGVuZEV4dGVuc2lvbikge1xuICAgICAgICAgICAgY29udGV4dC5leHQgPSBpbXBvcnRPcHRpb25zLmlzUGx1Z2luID8gJy5qcycgOiAnLmxlc3MnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGltcG9ydE9wdGlvbnMuaXNQbHVnaW4pIHtcbiAgICAgICAgICAgIHByb21pc2UgPSBwbHVnaW5Mb2FkZXIubG9hZFBsdWdpbihwYXRoLCBjdXJyZW50RmlsZUluZm8uY3VycmVudERpcmVjdG9yeSwgY29udGV4dCwgZW52aXJvbm1lbnQsIGZpbGVNYW5hZ2VyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHByb21pc2UgPSBmaWxlTWFuYWdlci5sb2FkRmlsZShwYXRoLCBjdXJyZW50RmlsZUluZm8uY3VycmVudERpcmVjdG9yeSwgY29udGV4dCwgZW52aXJvbm1lbnQsXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24oZXJyLCBsb2FkZWRGaWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVQYXJzZWRGdW5jKGVycik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2FkRmlsZUNhbGxiYWNrKGxvYWRlZEZpbGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb21pc2UpIHtcbiAgICAgICAgICAgIHByb21pc2UudGhlbihsb2FkRmlsZUNhbGxiYWNrLCBmaWxlUGFyc2VkRnVuYyk7XG4gICAgICAgIH1cblxuICAgIH07XG4gICAgcmV0dXJuIEltcG9ydE1hbmFnZXI7XG59O1xuXG59LHtcIi4vY29udGV4dHNcIjoxMyxcIi4vbGVzcy1lcnJvclwiOjM4LFwiLi9sb2dnZXJcIjozOSxcIi4vcGFyc2VyL3BhcnNlclwiOjQ0LFwiLi91dGlsc1wiOjg5LFwicHJvbWlzZVwiOnVuZGVmaW5lZH1dLDM3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZW52aXJvbm1lbnQsIGZpbGVNYW5hZ2Vycykge1xuICAgIHZhciBTb3VyY2VNYXBPdXRwdXQsIFNvdXJjZU1hcEJ1aWxkZXIsIFBhcnNlVHJlZSwgSW1wb3J0TWFuYWdlciwgRW52aXJvbm1lbnQ7XG5cbiAgICB2YXIgaW5pdGlhbCA9IHtcbiAgICAgICAgdmVyc2lvbjogWzMsIDksIDBdLFxuICAgICAgICBkYXRhOiByZXF1aXJlKCcuL2RhdGEnKSxcbiAgICAgICAgdHJlZTogcmVxdWlyZSgnLi90cmVlJyksXG4gICAgICAgIEVudmlyb25tZW50OiAoRW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL2Vudmlyb25tZW50L2Vudmlyb25tZW50JykpLFxuICAgICAgICBBYnN0cmFjdEZpbGVNYW5hZ2VyOiByZXF1aXJlKCcuL2Vudmlyb25tZW50L2Fic3RyYWN0LWZpbGUtbWFuYWdlcicpLFxuICAgICAgICBBYnN0cmFjdFBsdWdpbkxvYWRlcjogcmVxdWlyZSgnLi9lbnZpcm9ubWVudC9hYnN0cmFjdC1wbHVnaW4tbG9hZGVyJyksXG4gICAgICAgIGVudmlyb25tZW50OiAoZW52aXJvbm1lbnQgPSBuZXcgRW52aXJvbm1lbnQoZW52aXJvbm1lbnQsIGZpbGVNYW5hZ2VycykpLFxuICAgICAgICB2aXNpdG9yczogcmVxdWlyZSgnLi92aXNpdG9ycycpLFxuICAgICAgICBQYXJzZXI6IHJlcXVpcmUoJy4vcGFyc2VyL3BhcnNlcicpLFxuICAgICAgICBmdW5jdGlvbnM6IHJlcXVpcmUoJy4vZnVuY3Rpb25zJykoZW52aXJvbm1lbnQpLFxuICAgICAgICBjb250ZXh0czogcmVxdWlyZSgnLi9jb250ZXh0cycpLFxuICAgICAgICBTb3VyY2VNYXBPdXRwdXQ6IChTb3VyY2VNYXBPdXRwdXQgPSByZXF1aXJlKCcuL3NvdXJjZS1tYXAtb3V0cHV0JykoZW52aXJvbm1lbnQpKSxcbiAgICAgICAgU291cmNlTWFwQnVpbGRlcjogKFNvdXJjZU1hcEJ1aWxkZXIgPSByZXF1aXJlKCcuL3NvdXJjZS1tYXAtYnVpbGRlcicpKFNvdXJjZU1hcE91dHB1dCwgZW52aXJvbm1lbnQpKSxcbiAgICAgICAgUGFyc2VUcmVlOiAoUGFyc2VUcmVlID0gcmVxdWlyZSgnLi9wYXJzZS10cmVlJykoU291cmNlTWFwQnVpbGRlcikpLFxuICAgICAgICBJbXBvcnRNYW5hZ2VyOiAoSW1wb3J0TWFuYWdlciA9IHJlcXVpcmUoJy4vaW1wb3J0LW1hbmFnZXInKShlbnZpcm9ubWVudCkpLFxuICAgICAgICByZW5kZXI6IHJlcXVpcmUoJy4vcmVuZGVyJykoZW52aXJvbm1lbnQsIFBhcnNlVHJlZSwgSW1wb3J0TWFuYWdlciksXG4gICAgICAgIHBhcnNlOiByZXF1aXJlKCcuL3BhcnNlJykoZW52aXJvbm1lbnQsIFBhcnNlVHJlZSwgSW1wb3J0TWFuYWdlciksXG4gICAgICAgIExlc3NFcnJvcjogcmVxdWlyZSgnLi9sZXNzLWVycm9yJyksXG4gICAgICAgIHRyYW5zZm9ybVRyZWU6IHJlcXVpcmUoJy4vdHJhbnNmb3JtLXRyZWUnKSxcbiAgICAgICAgdXRpbHM6IHJlcXVpcmUoJy4vdXRpbHMnKSxcbiAgICAgICAgUGx1Z2luTWFuYWdlcjogcmVxdWlyZSgnLi9wbHVnaW4tbWFuYWdlcicpLFxuICAgICAgICBsb2dnZXI6IHJlcXVpcmUoJy4vbG9nZ2VyJylcbiAgICB9O1xuXG4gICAgLy8gQ3JlYXRlIGEgcHVibGljIEFQSVxuXG4gICAgdmFyIGN0b3IgPSBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBvYmogPSBPYmplY3QuY3JlYXRlKHQucHJvdG90eXBlKTtcbiAgICAgICAgICAgIHQuYXBwbHkob2JqLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApKTtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICB2YXIgdCwgYXBpID0gT2JqZWN0LmNyZWF0ZShpbml0aWFsKTtcbiAgICBmb3IgKHZhciBuIGluIGluaXRpYWwudHJlZSkge1xuICAgICAgICAvKiBlc2xpbnQgZ3VhcmQtZm9yLWluOiAwICovXG4gICAgICAgIHQgPSBpbml0aWFsLnRyZWVbbl07XG4gICAgICAgIGlmICh0eXBlb2YgdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgYXBpW24udG9Mb3dlckNhc2UoKV0gPSBjdG9yKHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXBpW25dID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgIGZvciAodmFyIG8gaW4gdCkge1xuICAgICAgICAgICAgICAgIC8qIGVzbGludCBndWFyZC1mb3ItaW46IDAgKi9cbiAgICAgICAgICAgICAgICBhcGlbbl1bby50b0xvd2VyQ2FzZSgpXSA9IGN0b3IodFtvXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYXBpO1xufTtcblxufSx7XCIuL2NvbnRleHRzXCI6MTMsXCIuL2RhdGFcIjoxNSxcIi4vZW52aXJvbm1lbnQvYWJzdHJhY3QtZmlsZS1tYW5hZ2VyXCI6MTgsXCIuL2Vudmlyb25tZW50L2Fic3RyYWN0LXBsdWdpbi1sb2FkZXJcIjoxOSxcIi4vZW52aXJvbm1lbnQvZW52aXJvbm1lbnRcIjoyMCxcIi4vZnVuY3Rpb25zXCI6MjgsXCIuL2ltcG9ydC1tYW5hZ2VyXCI6MzYsXCIuL2xlc3MtZXJyb3JcIjozOCxcIi4vbG9nZ2VyXCI6MzksXCIuL3BhcnNlXCI6NDEsXCIuL3BhcnNlLXRyZWVcIjo0MCxcIi4vcGFyc2VyL3BhcnNlclwiOjQ0LFwiLi9wbHVnaW4tbWFuYWdlclwiOjQ1LFwiLi9yZW5kZXJcIjo0NixcIi4vc291cmNlLW1hcC1idWlsZGVyXCI6NDcsXCIuL3NvdXJjZS1tYXAtb3V0cHV0XCI6NDgsXCIuL3RyYW5zZm9ybS10cmVlXCI6NDksXCIuL3RyZWVcIjo2NyxcIi4vdXRpbHNcIjo4OSxcIi4vdmlzaXRvcnNcIjo5M31dLDM4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbi8qKlxuICogVGhpcyBpcyBhIGNlbnRyYWxpemVkIGNsYXNzIG9mIGFueSBlcnJvciB0aGF0IGNvdWxkIGJlIHRocm93biBpbnRlcm5hbGx5IChtb3N0bHkgYnkgdGhlIHBhcnNlcikuXG4gKiBCZXNpZGVzIHN0YW5kYXJkIC5tZXNzYWdlIGl0IGtlZXBzIHNvbWUgYWRkaXRpb25hbCBkYXRhIGxpa2UgYSBwYXRoIHRvIHRoZSBmaWxlIHdoZXJlIHRoZSBlcnJvclxuICogb2NjdXJyZWQgYWxvbmcgd2l0aCBsaW5lIGFuZCBjb2x1bW4gbnVtYmVycy5cbiAqXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIEVycm9yXG4gKiBAdHlwZSB7bW9kdWxlLkxlc3NFcnJvcn1cbiAqXG4gKiBAcHJvcCB7c3RyaW5nfSB0eXBlXG4gKiBAcHJvcCB7c3RyaW5nfSBmaWxlbmFtZVxuICogQHByb3Age251bWJlcn0gaW5kZXhcbiAqIEBwcm9wIHtudW1iZXJ9IGxpbmVcbiAqIEBwcm9wIHtudW1iZXJ9IGNvbHVtblxuICogQHByb3Age251bWJlcn0gY2FsbExpbmVcbiAqIEBwcm9wIHtudW1iZXJ9IGNhbGxFeHRyYWN0XG4gKiBAcHJvcCB7c3RyaW5nW119IGV4dHJhY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZSAgICAgICAgICAgICAgLSBBbiBlcnJvciBvYmplY3QgdG8gd3JhcCBhcm91bmQgb3IganVzdCBhIGRlc2NyaXB0aXZlIG9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IGZpbGVDb250ZW50TWFwIC0gQW4gb2JqZWN0IHdpdGggZmlsZSBjb250ZW50cyBpbiAnY29udGVudHMnIHByb3BlcnR5IChsaWtlIGltcG9ydE1hbmFnZXIpIEB0b2RvIC0gbW92ZSB0byBmaWxlTWFuYWdlcj9cbiAqIEBwYXJhbSB7c3RyaW5nfSBbY3VycmVudEZpbGVuYW1lXVxuICovXG52YXIgTGVzc0Vycm9yID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBMZXNzRXJyb3IoZSwgZmlsZUNvbnRlbnRNYXAsIGN1cnJlbnRGaWxlbmFtZSkge1xuICAgIEVycm9yLmNhbGwodGhpcyk7XG5cbiAgICB2YXIgZmlsZW5hbWUgPSBlLmZpbGVuYW1lIHx8IGN1cnJlbnRGaWxlbmFtZTtcblxuICAgIHRoaXMubWVzc2FnZSA9IGUubWVzc2FnZTtcbiAgICB0aGlzLnN0YWNrID0gZS5zdGFjaztcblxuICAgIGlmIChmaWxlQ29udGVudE1hcCAmJiBmaWxlbmFtZSkge1xuICAgICAgICB2YXIgaW5wdXQgPSBmaWxlQ29udGVudE1hcC5jb250ZW50c1tmaWxlbmFtZV0sXG4gICAgICAgICAgICBsb2MgPSB1dGlscy5nZXRMb2NhdGlvbihlLmluZGV4LCBpbnB1dCksXG4gICAgICAgICAgICBsaW5lID0gbG9jLmxpbmUsXG4gICAgICAgICAgICBjb2wgID0gbG9jLmNvbHVtbixcbiAgICAgICAgICAgIGNhbGxMaW5lID0gZS5jYWxsICYmIHV0aWxzLmdldExvY2F0aW9uKGUuY2FsbCwgaW5wdXQpLmxpbmUsXG4gICAgICAgICAgICBsaW5lcyA9IGlucHV0ID8gaW5wdXQuc3BsaXQoJ1xcbicpIDogJyc7XG5cbiAgICAgICAgdGhpcy50eXBlID0gZS50eXBlIHx8ICdTeW50YXgnO1xuICAgICAgICB0aGlzLmZpbGVuYW1lID0gZmlsZW5hbWU7XG4gICAgICAgIHRoaXMuaW5kZXggPSBlLmluZGV4O1xuICAgICAgICB0aGlzLmxpbmUgPSB0eXBlb2YgbGluZSA9PT0gJ251bWJlcicgPyBsaW5lICsgMSA6IG51bGw7XG4gICAgICAgIHRoaXMuY29sdW1uID0gY29sO1xuXG4gICAgICAgIGlmICghdGhpcy5saW5lICYmIHRoaXMuc3RhY2spIHtcbiAgICAgICAgICAgIHZhciBmb3VuZCA9IHRoaXMuc3RhY2subWF0Y2goLyg8YW5vbnltb3VzPnxGdW5jdGlvbik6KFxcZCspOihcXGQrKS8pO1xuXG4gICAgICAgICAgICBpZiAoZm91bmQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZm91bmRbMl0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5lID0gcGFyc2VJbnQoZm91bmRbMl0pIC0gMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kWzNdKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uID0gcGFyc2VJbnQoZm91bmRbM10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2FsbExpbmUgPSBjYWxsTGluZSArIDE7XG4gICAgICAgIHRoaXMuY2FsbEV4dHJhY3QgPSBsaW5lc1tjYWxsTGluZV07XG5cbiAgICAgICAgdGhpcy5leHRyYWN0ID0gW1xuICAgICAgICAgICAgbGluZXNbdGhpcy5saW5lIC0gMl0sXG4gICAgICAgICAgICBsaW5lc1t0aGlzLmxpbmUgLSAxXSxcbiAgICAgICAgICAgIGxpbmVzW3RoaXMubGluZV1cbiAgICAgICAgXTtcblxuICAgIH1cblxufTtcblxuaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAndW5kZWZpbmVkJykge1xuICAgIHZhciBGID0gZnVuY3Rpb24gKCkge307XG4gICAgRi5wcm90b3R5cGUgPSBFcnJvci5wcm90b3R5cGU7XG4gICAgTGVzc0Vycm9yLnByb3RvdHlwZSA9IG5ldyBGKCk7XG59IGVsc2Uge1xuICAgIExlc3NFcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG59XG5cbkxlc3NFcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMZXNzRXJyb3I7XG5cbi8qKlxuICogQW4gb3ZlcnJpZGRlbiB2ZXJzaW9uIG9mIHRoZSBkZWZhdWx0IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcbiAqIHdoaWNoIHVzZXMgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiB0byBjcmVhdGUgYSBoZWxwZnVsIG1lc3NhZ2UuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbkxlc3NFcnJvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICB2YXIgbWVzc2FnZSA9ICcnO1xuICAgIHZhciBleHRyYWN0ID0gdGhpcy5leHRyYWN0IHx8IFtdO1xuICAgIHZhciBlcnJvciA9IFtdO1xuICAgIHZhciBzdHlsaXplID0gZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gc3RyOyB9O1xuICAgIGlmIChvcHRpb25zLnN0eWxpemUpIHtcbiAgICAgICAgdmFyIHR5cGUgPSB0eXBlb2Ygb3B0aW9ucy5zdHlsaXplO1xuICAgICAgICBpZiAodHlwZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ29wdGlvbnMuc3R5bGl6ZSBzaG91bGQgYmUgYSBmdW5jdGlvbiwgZ290IGEgJyArIHR5cGUgKyAnIScpO1xuICAgICAgICB9XG4gICAgICAgIHN0eWxpemUgPSBvcHRpb25zLnN0eWxpemU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubGluZSAhPT0gbnVsbCkge1xuICAgICAgICBpZiAodHlwZW9mIGV4dHJhY3RbMF0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBlcnJvci5wdXNoKHN0eWxpemUoKHRoaXMubGluZSAtIDEpICsgJyAnICsgZXh0cmFjdFswXSwgJ2dyZXknKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGV4dHJhY3RbMV0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2YXIgZXJyb3JUeHQgPSB0aGlzLmxpbmUgKyAnICc7XG4gICAgICAgICAgICBpZiAoZXh0cmFjdFsxXSkge1xuICAgICAgICAgICAgICAgIGVycm9yVHh0ICs9IGV4dHJhY3RbMV0uc2xpY2UoMCwgdGhpcy5jb2x1bW4pICtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGl6ZShzdHlsaXplKHN0eWxpemUoZXh0cmFjdFsxXS5zdWJzdHIodGhpcy5jb2x1bW4sIDEpLCAnYm9sZCcpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhY3RbMV0uc2xpY2UodGhpcy5jb2x1bW4gKyAxKSwgJ3JlZCcpLCAnaW52ZXJzZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXJyb3IucHVzaChlcnJvclR4dCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGV4dHJhY3RbMl0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBlcnJvci5wdXNoKHN0eWxpemUoKHRoaXMubGluZSArIDEpICsgJyAnICsgZXh0cmFjdFsyXSwgJ2dyZXknKSk7XG4gICAgICAgIH1cbiAgICAgICAgZXJyb3IgPSBlcnJvci5qb2luKCdcXG4nKSArIHN0eWxpemUoJycsICdyZXNldCcpICsgJ1xcbic7XG4gICAgfVxuXG4gICAgbWVzc2FnZSArPSBzdHlsaXplKHRoaXMudHlwZSArICdFcnJvcjogJyArIHRoaXMubWVzc2FnZSwgJ3JlZCcpO1xuICAgIGlmICh0aGlzLmZpbGVuYW1lKSB7XG4gICAgICAgIG1lc3NhZ2UgKz0gc3R5bGl6ZSgnIGluICcsICdyZWQnKSArIHRoaXMuZmlsZW5hbWU7XG4gICAgfVxuICAgIGlmICh0aGlzLmxpbmUpIHtcbiAgICAgICAgbWVzc2FnZSArPSBzdHlsaXplKCcgb24gbGluZSAnICsgdGhpcy5saW5lICsgJywgY29sdW1uICcgKyAodGhpcy5jb2x1bW4gKyAxKSArICc6JywgJ2dyZXknKTtcbiAgICB9XG5cbiAgICBtZXNzYWdlICs9ICdcXG4nICsgZXJyb3I7XG5cbiAgICBpZiAodGhpcy5jYWxsTGluZSkge1xuICAgICAgICBtZXNzYWdlICs9IHN0eWxpemUoJ2Zyb20gJywgJ3JlZCcpICsgKHRoaXMuZmlsZW5hbWUgfHwgJycpICsgJy9uJztcbiAgICAgICAgbWVzc2FnZSArPSBzdHlsaXplKHRoaXMuY2FsbExpbmUsICdncmV5JykgKyAnICcgKyB0aGlzLmNhbGxFeHRyYWN0ICsgJy9uJztcbiAgICB9XG5cbiAgICByZXR1cm4gbWVzc2FnZTtcbn07XG5cbn0se1wiLi91dGlsc1wiOjg5fV0sMzk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZXJyb3I6IGZ1bmN0aW9uKG1zZykge1xuICAgICAgICB0aGlzLl9maXJlRXZlbnQoJ2Vycm9yJywgbXNnKTtcbiAgICB9LFxuICAgIHdhcm46IGZ1bmN0aW9uKG1zZykge1xuICAgICAgICB0aGlzLl9maXJlRXZlbnQoJ3dhcm4nLCBtc2cpO1xuICAgIH0sXG4gICAgaW5mbzogZnVuY3Rpb24obXNnKSB7XG4gICAgICAgIHRoaXMuX2ZpcmVFdmVudCgnaW5mbycsIG1zZyk7XG4gICAgfSxcbiAgICBkZWJ1ZzogZnVuY3Rpb24obXNnKSB7XG4gICAgICAgIHRoaXMuX2ZpcmVFdmVudCgnZGVidWcnLCBtc2cpO1xuICAgIH0sXG4gICAgYWRkTGlzdGVuZXI6IGZ1bmN0aW9uKGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuX2xpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9LFxuICAgIHJlbW92ZUxpc3RlbmVyOiBmdW5jdGlvbihsaXN0ZW5lcikge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2xpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2xpc3RlbmVyc1tpXSA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgX2ZpcmVFdmVudDogZnVuY3Rpb24odHlwZSwgbXNnKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbG9nRnVuY3Rpb24gPSB0aGlzLl9saXN0ZW5lcnNbaV1bdHlwZV07XG4gICAgICAgICAgICBpZiAobG9nRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBsb2dGdW5jdGlvbihtc2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBfbGlzdGVuZXJzOiBbXVxufTtcblxufSx7fV0sNDA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIExlc3NFcnJvciA9IHJlcXVpcmUoJy4vbGVzcy1lcnJvcicpLFxuICAgIHRyYW5zZm9ybVRyZWUgPSByZXF1aXJlKCcuL3RyYW5zZm9ybS10cmVlJyksXG4gICAgbG9nZ2VyID0gcmVxdWlyZSgnLi9sb2dnZXInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihTb3VyY2VNYXBCdWlsZGVyKSB7XG4gICAgdmFyIFBhcnNlVHJlZSA9IGZ1bmN0aW9uKHJvb3QsIGltcG9ydHMpIHtcbiAgICAgICAgdGhpcy5yb290ID0gcm9vdDtcbiAgICAgICAgdGhpcy5pbXBvcnRzID0gaW1wb3J0cztcbiAgICB9O1xuXG4gICAgUGFyc2VUcmVlLnByb3RvdHlwZS50b0NTUyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGV2YWxkUm9vdCwgcmVzdWx0ID0ge30sIHNvdXJjZU1hcEJ1aWxkZXI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBldmFsZFJvb3QgPSB0cmFuc2Zvcm1UcmVlKHRoaXMucm9vdCwgb3B0aW9ucyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBMZXNzRXJyb3IoZSwgdGhpcy5pbXBvcnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgY29tcHJlc3MgPSBCb29sZWFuKG9wdGlvbnMuY29tcHJlc3MpO1xuICAgICAgICAgICAgaWYgKGNvbXByZXNzKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oJ1RoZSBjb21wcmVzcyBvcHRpb24gaGFzIGJlZW4gZGVwcmVjYXRlZC4gV2UgcmVjb21tZW5kIHlvdSB1c2UgYSBkZWRpY2F0ZWQgY3NzIG1pbmlmaWVyLCBmb3IgaW5zdGFuY2Ugc2VlIGxlc3MtcGx1Z2luLWNsZWFuLWNzcy4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHRvQ1NTT3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBjb21wcmVzczogY29tcHJlc3MsXG4gICAgICAgICAgICAgICAgZHVtcExpbmVOdW1iZXJzOiBvcHRpb25zLmR1bXBMaW5lTnVtYmVycyxcbiAgICAgICAgICAgICAgICBzdHJpY3RVbml0czogQm9vbGVhbihvcHRpb25zLnN0cmljdFVuaXRzKSxcbiAgICAgICAgICAgICAgICBudW1QcmVjaXNpb246IDh9O1xuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zb3VyY2VNYXApIHtcbiAgICAgICAgICAgICAgICBzb3VyY2VNYXBCdWlsZGVyID0gbmV3IFNvdXJjZU1hcEJ1aWxkZXIob3B0aW9ucy5zb3VyY2VNYXApO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5jc3MgPSBzb3VyY2VNYXBCdWlsZGVyLnRvQ1NTKGV2YWxkUm9vdCwgdG9DU1NPcHRpb25zLCB0aGlzLmltcG9ydHMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuY3NzID0gZXZhbGRSb290LnRvQ1NTKHRvQ1NTT3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBMZXNzRXJyb3IoZSwgdGhpcy5pbXBvcnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLnBsdWdpbk1hbmFnZXIpIHtcbiAgICAgICAgICAgIHZhciBwb3N0UHJvY2Vzc29ycyA9IG9wdGlvbnMucGx1Z2luTWFuYWdlci5nZXRQb3N0UHJvY2Vzc29ycygpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb3N0UHJvY2Vzc29ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5jc3MgPSBwb3N0UHJvY2Vzc29yc1tpXS5wcm9jZXNzKHJlc3VsdC5jc3MsIHsgc291cmNlTWFwOiBzb3VyY2VNYXBCdWlsZGVyLCBvcHRpb25zOiBvcHRpb25zLCBpbXBvcnRzOiB0aGlzLmltcG9ydHMgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuc291cmNlTWFwKSB7XG4gICAgICAgICAgICByZXN1bHQubWFwID0gc291cmNlTWFwQnVpbGRlci5nZXRFeHRlcm5hbFNvdXJjZU1hcCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0LmltcG9ydHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgZmlsZSBpbiB0aGlzLmltcG9ydHMuZmlsZXMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmltcG9ydHMuZmlsZXMuaGFzT3duUHJvcGVydHkoZmlsZSkgJiYgZmlsZSAhPT0gdGhpcy5pbXBvcnRzLnJvb3RGaWxlbmFtZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5pbXBvcnRzLnB1c2goZmlsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIHJldHVybiBQYXJzZVRyZWU7XG59O1xuXG59LHtcIi4vbGVzcy1lcnJvclwiOjM4LFwiLi9sb2dnZXJcIjozOSxcIi4vdHJhbnNmb3JtLXRyZWVcIjo0OX1dLDQxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBQcm9taXNlQ29uc3RydWN0b3IsXG4gICAgY29udGV4dHMgPSByZXF1aXJlKCcuL2NvbnRleHRzJyksXG4gICAgUGFyc2VyID0gcmVxdWlyZSgnLi9wYXJzZXIvcGFyc2VyJyksXG4gICAgUGx1Z2luTWFuYWdlciA9IHJlcXVpcmUoJy4vcGx1Z2luLW1hbmFnZXInKSxcbiAgICBMZXNzRXJyb3IgPSByZXF1aXJlKCcuL2xlc3MtZXJyb3InKSxcbiAgICB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihlbnZpcm9ubWVudCwgUGFyc2VUcmVlLCBJbXBvcnRNYW5hZ2VyKSB7XG4gICAgdmFyIHBhcnNlID0gZnVuY3Rpb24gKGlucHV0LCBvcHRpb25zLCBjYWxsYmFjaykge1xuXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgICAgICAgICAgb3B0aW9ucyA9IHV0aWxzLmNvcHlPcHRpb25zKHRoaXMub3B0aW9ucywge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHV0aWxzLmNvcHlPcHRpb25zKHRoaXMub3B0aW9ucywgb3B0aW9ucyB8fCB7fSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpZiAoIVByb21pc2VDb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgICAgIFByb21pc2VDb25zdHJ1Y3RvciA9IHR5cGVvZiBQcm9taXNlID09PSAndW5kZWZpbmVkJyA/IHJlcXVpcmUoJ3Byb21pc2UnKSA6IFByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2VDb25zdHJ1Y3RvcihmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgcGFyc2UuY2FsbChzZWxmLCBpbnB1dCwgb3B0aW9ucywgZnVuY3Rpb24oZXJyLCBvdXRwdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG91dHB1dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGNvbnRleHQsXG4gICAgICAgICAgICAgICAgcm9vdEZpbGVJbmZvLFxuICAgICAgICAgICAgICAgIHBsdWdpbk1hbmFnZXIgPSBuZXcgUGx1Z2luTWFuYWdlcih0aGlzLCAhb3B0aW9ucy5yZVVzZVBsdWdpbk1hbmFnZXIpO1xuXG4gICAgICAgICAgICBvcHRpb25zLnBsdWdpbk1hbmFnZXIgPSBwbHVnaW5NYW5hZ2VyO1xuXG4gICAgICAgICAgICBjb250ZXh0ID0gbmV3IGNvbnRleHRzLlBhcnNlKG9wdGlvbnMpO1xuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5yb290RmlsZUluZm8pIHtcbiAgICAgICAgICAgICAgICByb290RmlsZUluZm8gPSBvcHRpb25zLnJvb3RGaWxlSW5mbztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpbGVuYW1lID0gb3B0aW9ucy5maWxlbmFtZSB8fCAnaW5wdXQnO1xuICAgICAgICAgICAgICAgIHZhciBlbnRyeVBhdGggPSBmaWxlbmFtZS5yZXBsYWNlKC9bXlxcL1xcXFxdKiQvLCAnJyk7XG4gICAgICAgICAgICAgICAgcm9vdEZpbGVJbmZvID0ge1xuICAgICAgICAgICAgICAgICAgICBmaWxlbmFtZTogZmlsZW5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHJld3JpdGVVcmxzOiBjb250ZXh0LnJld3JpdGVVcmxzLFxuICAgICAgICAgICAgICAgICAgICByb290cGF0aDogY29udGV4dC5yb290cGF0aCB8fCAnJyxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudERpcmVjdG9yeTogZW50cnlQYXRoLFxuICAgICAgICAgICAgICAgICAgICBlbnRyeVBhdGg6IGVudHJ5UGF0aCxcbiAgICAgICAgICAgICAgICAgICAgcm9vdEZpbGVuYW1lOiBmaWxlbmFtZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgLy8gYWRkIGluIGEgbWlzc2luZyB0cmFpbGluZyBzbGFzaFxuICAgICAgICAgICAgICAgIGlmIChyb290RmlsZUluZm8ucm9vdHBhdGggJiYgcm9vdEZpbGVJbmZvLnJvb3RwYXRoLnNsaWNlKC0xKSAhPT0gJy8nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3RGaWxlSW5mby5yb290cGF0aCArPSAnLyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaW1wb3J0cyA9IG5ldyBJbXBvcnRNYW5hZ2VyKHRoaXMsIGNvbnRleHQsIHJvb3RGaWxlSW5mbyk7XG4gICAgICAgICAgICB0aGlzLmltcG9ydE1hbmFnZXIgPSBpbXBvcnRzO1xuXG4gICAgICAgICAgICAvLyBUT0RPOiBhbGxvdyB0aGUgcGx1Z2lucyB0byBiZSBqdXN0IGEgbGlzdCBvZiBwYXRocyBvciBuYW1lc1xuICAgICAgICAgICAgLy8gRG8gYW4gYXN5bmMgcGx1Z2luIHF1ZXVlIGxpa2UgbGVzc2NcblxuICAgICAgICAgICAgaWYgKG9wdGlvbnMucGx1Z2lucykge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMucGx1Z2lucy5mb3JFYWNoKGZ1bmN0aW9uKHBsdWdpbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXZhbFJlc3VsdCwgY29udGVudHM7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwbHVnaW4uZmlsZUNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRzID0gcGx1Z2luLmZpbGVDb250ZW50LnJlcGxhY2UoL15cXHVGRUZGLywgJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZhbFJlc3VsdCA9IHBsdWdpbk1hbmFnZXIuTG9hZGVyLmV2YWxQbHVnaW4oY29udGVudHMsIGNvbnRleHQsIGltcG9ydHMsIHBsdWdpbi5vcHRpb25zLCBwbHVnaW4uZmlsZW5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2YWxSZXN1bHQgaW5zdGFuY2VvZiBMZXNzRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXZhbFJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwbHVnaW5NYW5hZ2VyLmFkZFBsdWdpbihwbHVnaW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5ldyBQYXJzZXIoY29udGV4dCwgaW1wb3J0cywgcm9vdEZpbGVJbmZvKVxuICAgICAgICAgICAgICAgIC5wYXJzZShpbnB1dCwgZnVuY3Rpb24gKGUsIHJvb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUpIHsgcmV0dXJuIGNhbGxiYWNrKGUpOyB9XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHJvb3QsIGltcG9ydHMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH0sIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gcGFyc2U7XG59O1xuXG59LHtcIi4vY29udGV4dHNcIjoxMyxcIi4vbGVzcy1lcnJvclwiOjM4LFwiLi9wYXJzZXIvcGFyc2VyXCI6NDQsXCIuL3BsdWdpbi1tYW5hZ2VyXCI6NDUsXCIuL3V0aWxzXCI6ODksXCJwcm9taXNlXCI6dW5kZWZpbmVkfV0sNDI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLy8gU3BsaXQgdGhlIGlucHV0IGludG8gY2h1bmtzLlxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5wdXQsIGZhaWwpIHtcbiAgICB2YXIgbGVuID0gaW5wdXQubGVuZ3RoLCBsZXZlbCA9IDAsIHBhcmVuTGV2ZWwgPSAwLFxuICAgICAgICBsYXN0T3BlbmluZywgbGFzdE9wZW5pbmdQYXJlbiwgbGFzdE11bHRpQ29tbWVudCwgbGFzdE11bHRpQ29tbWVudEVuZEJyYWNlLFxuICAgICAgICBjaHVua3MgPSBbXSwgZW1pdEZyb20gPSAwLFxuICAgICAgICBjaHVua2VyQ3VycmVudEluZGV4LCBjdXJyZW50Q2h1bmtTdGFydEluZGV4LCBjYywgY2MyLCBtYXRjaGVkO1xuXG4gICAgZnVuY3Rpb24gZW1pdENodW5rKGZvcmNlKSB7XG4gICAgICAgIHZhciBsZW4gPSBjaHVua2VyQ3VycmVudEluZGV4IC0gZW1pdEZyb207XG4gICAgICAgIGlmICgoKGxlbiA8IDUxMikgJiYgIWZvcmNlKSB8fCAhbGVuKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2h1bmtzLnB1c2goaW5wdXQuc2xpY2UoZW1pdEZyb20sIGNodW5rZXJDdXJyZW50SW5kZXggKyAxKSk7XG4gICAgICAgIGVtaXRGcm9tID0gY2h1bmtlckN1cnJlbnRJbmRleCArIDE7XG4gICAgfVxuXG4gICAgZm9yIChjaHVua2VyQ3VycmVudEluZGV4ID0gMDsgY2h1bmtlckN1cnJlbnRJbmRleCA8IGxlbjsgY2h1bmtlckN1cnJlbnRJbmRleCsrKSB7XG4gICAgICAgIGNjID0gaW5wdXQuY2hhckNvZGVBdChjaHVua2VyQ3VycmVudEluZGV4KTtcbiAgICAgICAgaWYgKCgoY2MgPj0gOTcpICYmIChjYyA8PSAxMjIpKSB8fCAoY2MgPCAzNCkpIHtcbiAgICAgICAgICAgIC8vIGEteiBvciB3aGl0ZXNwYWNlXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAoY2MpIHtcbiAgICAgICAgICAgIGNhc2UgNDA6ICAgICAgICAgICAgICAgICAgICAgICAgLy8gKFxuICAgICAgICAgICAgICAgIHBhcmVuTGV2ZWwrKztcbiAgICAgICAgICAgICAgICBsYXN0T3BlbmluZ1BhcmVuID0gY2h1bmtlckN1cnJlbnRJbmRleDtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGNhc2UgNDE6ICAgICAgICAgICAgICAgICAgICAgICAgLy8gKVxuICAgICAgICAgICAgICAgIGlmICgtLXBhcmVuTGV2ZWwgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWlsKCdtaXNzaW5nIG9wZW5pbmcgYChgJywgY2h1bmtlckN1cnJlbnRJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgY2FzZSA1OTogICAgICAgICAgICAgICAgICAgICAgICAvLyA7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJlbkxldmVsKSB7IGVtaXRDaHVuaygpOyB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjYXNlIDEyMzogICAgICAgICAgICAgICAgICAgICAgIC8vIHtcbiAgICAgICAgICAgICAgICBsZXZlbCsrO1xuICAgICAgICAgICAgICAgIGxhc3RPcGVuaW5nID0gY2h1bmtlckN1cnJlbnRJbmRleDtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGNhc2UgMTI1OiAgICAgICAgICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgIGlmICgtLWxldmVsIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFpbCgnbWlzc2luZyBvcGVuaW5nIGB7YCcsIGNodW5rZXJDdXJyZW50SW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWxldmVsICYmICFwYXJlbkxldmVsKSB7IGVtaXRDaHVuaygpOyB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjYXNlIDkyOiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFxcXG4gICAgICAgICAgICAgICAgaWYgKGNodW5rZXJDdXJyZW50SW5kZXggPCBsZW4gLSAxKSB7IGNodW5rZXJDdXJyZW50SW5kZXgrKzsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFpbCgndW5lc2NhcGVkIGBcXFxcYCcsIGNodW5rZXJDdXJyZW50SW5kZXgpO1xuICAgICAgICAgICAgY2FzZSAzNDpcbiAgICAgICAgICAgIGNhc2UgMzk6XG4gICAgICAgICAgICBjYXNlIDk2OiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFwiLCAnIGFuZCBgXG4gICAgICAgICAgICAgICAgbWF0Y2hlZCA9IDA7XG4gICAgICAgICAgICAgICAgY3VycmVudENodW5rU3RhcnRJbmRleCA9IGNodW5rZXJDdXJyZW50SW5kZXg7XG4gICAgICAgICAgICAgICAgZm9yIChjaHVua2VyQ3VycmVudEluZGV4ID0gY2h1bmtlckN1cnJlbnRJbmRleCArIDE7IGNodW5rZXJDdXJyZW50SW5kZXggPCBsZW47IGNodW5rZXJDdXJyZW50SW5kZXgrKykge1xuICAgICAgICAgICAgICAgICAgICBjYzIgPSBpbnB1dC5jaGFyQ29kZUF0KGNodW5rZXJDdXJyZW50SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2MyID4gOTYpIHsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNjMiA9PSBjYykgeyBtYXRjaGVkID0gMTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNjMiA9PSA5MikgeyAgICAgICAgLy8gXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaHVua2VyQ3VycmVudEluZGV4ID09IGxlbiAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFpbCgndW5lc2NhcGVkIGBcXFxcYCcsIGNodW5rZXJDdXJyZW50SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmtlckN1cnJlbnRJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtYXRjaGVkKSB7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhaWwoJ3VubWF0Y2hlZCBgJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoY2MpICsgJ2AnLCBjdXJyZW50Q2h1bmtTdGFydEluZGV4KTtcbiAgICAgICAgICAgIGNhc2UgNDc6ICAgICAgICAgICAgICAgICAgICAgICAgLy8gLywgY2hlY2sgZm9yIGNvbW1lbnRcbiAgICAgICAgICAgICAgICBpZiAocGFyZW5MZXZlbCB8fCAoY2h1bmtlckN1cnJlbnRJbmRleCA9PSBsZW4gLSAxKSkgeyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgIGNjMiA9IGlucHV0LmNoYXJDb2RlQXQoY2h1bmtlckN1cnJlbnRJbmRleCArIDEpO1xuICAgICAgICAgICAgICAgIGlmIChjYzIgPT0gNDcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gLy8sIGZpbmQgbG5mZWVkXG4gICAgICAgICAgICAgICAgICAgIGZvciAoY2h1bmtlckN1cnJlbnRJbmRleCA9IGNodW5rZXJDdXJyZW50SW5kZXggKyAyOyBjaHVua2VyQ3VycmVudEluZGV4IDwgbGVuOyBjaHVua2VyQ3VycmVudEluZGV4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNjMiA9IGlucHV0LmNoYXJDb2RlQXQoY2h1bmtlckN1cnJlbnRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGNjMiA8PSAxMykgJiYgKChjYzIgPT0gMTApIHx8IChjYzIgPT0gMTMpKSkgeyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjYzIgPT0gNDIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gLyosIGZpbmQgKi9cbiAgICAgICAgICAgICAgICAgICAgbGFzdE11bHRpQ29tbWVudCA9IGN1cnJlbnRDaHVua1N0YXJ0SW5kZXggPSBjaHVua2VyQ3VycmVudEluZGV4O1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNodW5rZXJDdXJyZW50SW5kZXggPSBjaHVua2VyQ3VycmVudEluZGV4ICsgMjsgY2h1bmtlckN1cnJlbnRJbmRleCA8IGxlbiAtIDE7IGNodW5rZXJDdXJyZW50SW5kZXgrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2MyID0gaW5wdXQuY2hhckNvZGVBdChjaHVua2VyQ3VycmVudEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYzIgPT0gMTI1KSB7IGxhc3RNdWx0aUNvbW1lbnRFbmRCcmFjZSA9IGNodW5rZXJDdXJyZW50SW5kZXg7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYzIgIT0gNDIpIHsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KGNodW5rZXJDdXJyZW50SW5kZXggKyAxKSA9PSA0NykgeyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaHVua2VyQ3VycmVudEluZGV4ID09IGxlbiAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWlsKCdtaXNzaW5nIGNsb3NpbmcgYCovYCcsIGN1cnJlbnRDaHVua1N0YXJ0SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNodW5rZXJDdXJyZW50SW5kZXgrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjYXNlIDQyOiAgICAgICAgICAgICAgICAgICAgICAgLy8gKiwgY2hlY2sgZm9yIHVubWF0Y2hlZCAqL1xuICAgICAgICAgICAgICAgIGlmICgoY2h1bmtlckN1cnJlbnRJbmRleCA8IGxlbiAtIDEpICYmIChpbnB1dC5jaGFyQ29kZUF0KGNodW5rZXJDdXJyZW50SW5kZXggKyAxKSA9PSA0NykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhaWwoJ3VubWF0Y2hlZCBgLypgJywgY2h1bmtlckN1cnJlbnRJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGxldmVsICE9PSAwKSB7XG4gICAgICAgIGlmICgobGFzdE11bHRpQ29tbWVudCA+IGxhc3RPcGVuaW5nKSAmJiAobGFzdE11bHRpQ29tbWVudEVuZEJyYWNlID4gbGFzdE11bHRpQ29tbWVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWlsKCdtaXNzaW5nIGNsb3NpbmcgYH1gIG9yIGAqL2AnLCBsYXN0T3BlbmluZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFpbCgnbWlzc2luZyBjbG9zaW5nIGB9YCcsIGxhc3RPcGVuaW5nKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAocGFyZW5MZXZlbCAhPT0gMCkge1xuICAgICAgICByZXR1cm4gZmFpbCgnbWlzc2luZyBjbG9zaW5nIGApYCcsIGxhc3RPcGVuaW5nUGFyZW4pO1xuICAgIH1cblxuICAgIGVtaXRDaHVuayh0cnVlKTtcbiAgICByZXR1cm4gY2h1bmtzO1xufTtcblxufSx7fV0sNDM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIGNodW5rZXIgPSByZXF1aXJlKCcuL2NodW5rZXInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaW5wdXQsICAgICAgIC8vIExlc3MgaW5wdXQgc3RyaW5nXG4gICAgICAgIGosICAgICAgICAgICAvLyBjdXJyZW50IGNodW5rXG4gICAgICAgIHNhdmVTdGFjayA9IFtdLCAgIC8vIGhvbGRzIHN0YXRlIGZvciBiYWNrdHJhY2tpbmdcbiAgICAgICAgZnVydGhlc3QsICAgIC8vIGZ1cnRoZXN0IGluZGV4IHRoZSBwYXJzZXIgaGFzIGdvbmUgdG9cbiAgICAgICAgZnVydGhlc3RQb3NzaWJsZUVycm9yTWVzc2FnZSwgLy8gaWYgdGhpcyBpcyBmdXJ0aGVzdCB3ZSBnb3QgdG8sIHRoaXMgaXMgdGhlIHByb2JhYmx5IGNhdXNlXG4gICAgICAgIGNodW5rcywgICAgICAvLyBjaHVua2lmaWVkIGlucHV0XG4gICAgICAgIGN1cnJlbnQsICAgICAvLyBjdXJyZW50IGNodW5rXG4gICAgICAgIGN1cnJlbnRQb3MsICAvLyBpbmRleCBvZiBjdXJyZW50IGNodW5rLCBpbiBgaW5wdXRgXG4gICAgICAgIHBhcnNlcklucHV0ID0ge307XG5cbiAgICB2YXIgQ0hBUkNPREVfU1BBQ0UgPSAzMixcbiAgICAgICAgQ0hBUkNPREVfVEFCID0gOSxcbiAgICAgICAgQ0hBUkNPREVfTEYgPSAxMCxcbiAgICAgICAgQ0hBUkNPREVfQ1IgPSAxMyxcbiAgICAgICAgQ0hBUkNPREVfUExVUyA9IDQzLFxuICAgICAgICBDSEFSQ09ERV9DT01NQSA9IDQ0LFxuICAgICAgICBDSEFSQ09ERV9GT1JXQVJEX1NMQVNIID0gNDcsXG4gICAgICAgIENIQVJDT0RFXzkgPSA1NztcblxuICAgIGZ1bmN0aW9uIHNraXBXaGl0ZXNwYWNlKGxlbmd0aCkge1xuICAgICAgICB2YXIgb2xkaSA9IHBhcnNlcklucHV0LmksIG9sZGogPSBqLFxuICAgICAgICAgICAgY3VyciA9IHBhcnNlcklucHV0LmkgLSBjdXJyZW50UG9zLFxuICAgICAgICAgICAgZW5kSW5kZXggPSBwYXJzZXJJbnB1dC5pICsgY3VycmVudC5sZW5ndGggLSBjdXJyLFxuICAgICAgICAgICAgbWVtID0gKHBhcnNlcklucHV0LmkgKz0gbGVuZ3RoKSxcbiAgICAgICAgICAgIGlucCA9IGlucHV0LFxuICAgICAgICAgICAgYywgbmV4dENoYXIsIGNvbW1lbnQ7XG5cbiAgICAgICAgZm9yICg7IHBhcnNlcklucHV0LmkgPCBlbmRJbmRleDsgcGFyc2VySW5wdXQuaSsrKSB7XG4gICAgICAgICAgICBjID0gaW5wLmNoYXJDb2RlQXQocGFyc2VySW5wdXQuaSk7XG5cbiAgICAgICAgICAgIGlmIChwYXJzZXJJbnB1dC5hdXRvQ29tbWVudEFic29yYiAmJiBjID09PSBDSEFSQ09ERV9GT1JXQVJEX1NMQVNIKSB7XG4gICAgICAgICAgICAgICAgbmV4dENoYXIgPSBpbnAuY2hhckF0KHBhcnNlcklucHV0LmkgKyAxKTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dENoYXIgPT09ICcvJykge1xuICAgICAgICAgICAgICAgICAgICBjb21tZW50ID0ge2luZGV4OiBwYXJzZXJJbnB1dC5pLCBpc0xpbmVDb21tZW50OiB0cnVlfTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5leHROZXdMaW5lID0gaW5wLmluZGV4T2YoJ1xcbicsIHBhcnNlcklucHV0LmkgKyAyKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHROZXdMaW5lIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dE5ld0xpbmUgPSBlbmRJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5pID0gbmV4dE5ld0xpbmU7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnQudGV4dCA9IGlucC5zdWJzdHIoY29tbWVudC5pbmRleCwgcGFyc2VySW5wdXQuaSAtIGNvbW1lbnQuaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5jb21tZW50U3RvcmUucHVzaChjb21tZW50KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChuZXh0Q2hhciA9PT0gJyonKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0U3RhclNsYXNoID0gaW5wLmluZGV4T2YoJyovJywgcGFyc2VySW5wdXQuaSArIDIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dFN0YXJTbGFzaCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBwYXJzZXJJbnB1dC5pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGlucC5zdWJzdHIocGFyc2VySW5wdXQuaSwgbmV4dFN0YXJTbGFzaCArIDIgLSBwYXJzZXJJbnB1dC5pKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0xpbmVDb21tZW50OiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmkgKz0gY29tbWVudC50ZXh0Lmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5jb21tZW50U3RvcmUucHVzaChjb21tZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoKGMgIT09IENIQVJDT0RFX1NQQUNFKSAmJiAoYyAhPT0gQ0hBUkNPREVfTEYpICYmIChjICE9PSBDSEFSQ09ERV9UQUIpICYmIChjICE9PSBDSEFSQ09ERV9DUikpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnNsaWNlKGxlbmd0aCArIHBhcnNlcklucHV0LmkgLSBtZW0gKyBjdXJyKTtcbiAgICAgICAgY3VycmVudFBvcyA9IHBhcnNlcklucHV0Lmk7XG5cbiAgICAgICAgaWYgKCFjdXJyZW50Lmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGogPCBjaHVua3MubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjaHVua3NbKytqXTtcbiAgICAgICAgICAgICAgICBza2lwV2hpdGVzcGFjZSgwKTsgLy8gc2tpcCBzcGFjZSBhdCB0aGUgYmVnaW5uaW5nIG9mIGEgY2h1bmtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gdGhpbmdzIGNoYW5nZWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcnNlcklucHV0LmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvbGRpICE9PSBwYXJzZXJJbnB1dC5pIHx8IG9sZGogIT09IGo7XG4gICAgfVxuXG4gICAgcGFyc2VySW5wdXQuc2F2ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjdXJyZW50UG9zID0gcGFyc2VySW5wdXQuaTtcbiAgICAgICAgc2F2ZVN0YWNrLnB1c2goIHsgY3VycmVudDogY3VycmVudCwgaTogcGFyc2VySW5wdXQuaSwgajogaiB9KTtcbiAgICB9O1xuICAgIHBhcnNlcklucHV0LnJlc3RvcmUgPSBmdW5jdGlvbihwb3NzaWJsZUVycm9yTWVzc2FnZSkge1xuXG4gICAgICAgIGlmIChwYXJzZXJJbnB1dC5pID4gZnVydGhlc3QgfHwgKHBhcnNlcklucHV0LmkgPT09IGZ1cnRoZXN0ICYmIHBvc3NpYmxlRXJyb3JNZXNzYWdlICYmICFmdXJ0aGVzdFBvc3NpYmxlRXJyb3JNZXNzYWdlKSkge1xuICAgICAgICAgICAgZnVydGhlc3QgPSBwYXJzZXJJbnB1dC5pO1xuICAgICAgICAgICAgZnVydGhlc3RQb3NzaWJsZUVycm9yTWVzc2FnZSA9IHBvc3NpYmxlRXJyb3JNZXNzYWdlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdGF0ZSA9IHNhdmVTdGFjay5wb3AoKTtcbiAgICAgICAgY3VycmVudCA9IHN0YXRlLmN1cnJlbnQ7XG4gICAgICAgIGN1cnJlbnRQb3MgPSBwYXJzZXJJbnB1dC5pID0gc3RhdGUuaTtcbiAgICAgICAgaiA9IHN0YXRlLmo7XG4gICAgfTtcbiAgICBwYXJzZXJJbnB1dC5mb3JnZXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgc2F2ZVN0YWNrLnBvcCgpO1xuICAgIH07XG4gICAgcGFyc2VySW5wdXQuaXNXaGl0ZXNwYWNlID0gZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgICB2YXIgcG9zID0gcGFyc2VySW5wdXQuaSArIChvZmZzZXQgfHwgMCksXG4gICAgICAgICAgICBjb2RlID0gaW5wdXQuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICByZXR1cm4gKGNvZGUgPT09IENIQVJDT0RFX1NQQUNFIHx8IGNvZGUgPT09IENIQVJDT0RFX0NSIHx8IGNvZGUgPT09IENIQVJDT0RFX1RBQiB8fCBjb2RlID09PSBDSEFSQ09ERV9MRik7XG4gICAgfTtcblxuICAgIC8vIFNwZWNpYWxpemF0aW9uIG9mICQodG9rKVxuICAgIHBhcnNlcklucHV0LiRyZSA9IGZ1bmN0aW9uKHRvaykge1xuICAgICAgICBpZiAocGFyc2VySW5wdXQuaSA+IGN1cnJlbnRQb3MpIHtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnNsaWNlKHBhcnNlcklucHV0LmkgLSBjdXJyZW50UG9zKTtcbiAgICAgICAgICAgIGN1cnJlbnRQb3MgPSBwYXJzZXJJbnB1dC5pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG0gPSB0b2suZXhlYyhjdXJyZW50KTtcbiAgICAgICAgaWYgKCFtKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHNraXBXaGl0ZXNwYWNlKG1bMF0ubGVuZ3RoKTtcbiAgICAgICAgaWYgKHR5cGVvZiBtID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIG07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbS5sZW5ndGggPT09IDEgPyBtWzBdIDogbTtcbiAgICB9O1xuXG4gICAgcGFyc2VySW5wdXQuJGNoYXIgPSBmdW5jdGlvbih0b2spIHtcbiAgICAgICAgaWYgKGlucHV0LmNoYXJBdChwYXJzZXJJbnB1dC5pKSAhPT0gdG9rKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBza2lwV2hpdGVzcGFjZSgxKTtcbiAgICAgICAgcmV0dXJuIHRvaztcbiAgICB9O1xuXG4gICAgcGFyc2VySW5wdXQuJHN0ciA9IGZ1bmN0aW9uKHRvaykge1xuICAgICAgICB2YXIgdG9rTGVuZ3RoID0gdG9rLmxlbmd0aDtcblxuICAgICAgICAvLyBodHRwczovL2pzcGVyZi5jb20vc3RyaW5nLXN0YXJ0c3dpdGgvMjFcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJBdChwYXJzZXJJbnB1dC5pICsgaSkgIT09IHRvay5jaGFyQXQoaSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHNraXBXaGl0ZXNwYWNlKHRva0xlbmd0aCk7XG4gICAgICAgIHJldHVybiB0b2s7XG4gICAgfTtcblxuICAgIHBhcnNlcklucHV0LiRxdW90ZWQgPSBmdW5jdGlvbihsb2MpIHtcbiAgICAgICAgdmFyIHBvcyA9IGxvYyB8fCBwYXJzZXJJbnB1dC5pLFxuICAgICAgICAgICAgc3RhcnRDaGFyID0gaW5wdXQuY2hhckF0KHBvcyk7XG5cbiAgICAgICAgaWYgKHN0YXJ0Q2hhciAhPT0gJ1xcJycgJiYgc3RhcnRDaGFyICE9PSAnXCInKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxlbmd0aCA9IGlucHV0Lmxlbmd0aCxcbiAgICAgICAgICAgIGN1cnJlbnRQb3NpdGlvbiA9IHBvcztcblxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSArIGN1cnJlbnRQb3NpdGlvbiA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbmV4dENoYXIgPSBpbnB1dC5jaGFyQXQoaSArIGN1cnJlbnRQb3NpdGlvbik7XG4gICAgICAgICAgICBzd2l0Y2ggKG5leHRDaGFyKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnXFxcXCc6XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSAnXFxyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdcXG4nOlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIHN0YXJ0Q2hhcjpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0ciA9IGlucHV0LnN1YnN0cihjdXJyZW50UG9zaXRpb24sIGkgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFsb2MgJiYgbG9jICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBza2lwV2hpdGVzcGFjZShpICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtzdGFydENoYXIsIHN0cl07XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUGVybWlzc2l2ZSBwYXJzaW5nLiBJZ25vcmVzIGV2ZXJ5dGhpbmcgZXhjZXB0IG1hdGNoaW5nIHt9IFtdICgpIGFuZCBxdW90ZXNcbiAgICAgKiB1bnRpbCBtYXRjaGluZyB0b2tlbiAob3V0c2lkZSBvZiBibG9ja3MpXG4gICAgICovXG4gICAgcGFyc2VySW5wdXQuJHBhcnNlVW50aWwgPSBmdW5jdGlvbih0b2spIHtcbiAgICAgICAgdmFyIHF1b3RlID0gJycsXG4gICAgICAgICAgICByZXR1cm5WYWwgPSBudWxsLFxuICAgICAgICAgICAgaW5Db21tZW50ID0gZmFsc2UsXG4gICAgICAgICAgICBibG9ja0RlcHRoID0gMCxcbiAgICAgICAgICAgIGJsb2NrU3RhY2sgPSBbXSxcbiAgICAgICAgICAgIHBhcnNlR3JvdXBzID0gW10sXG4gICAgICAgICAgICBsZW5ndGggPSBpbnB1dC5sZW5ndGgsXG4gICAgICAgICAgICBzdGFydFBvcyA9IHBhcnNlcklucHV0LmksXG4gICAgICAgICAgICBsYXN0UG9zID0gcGFyc2VySW5wdXQuaSxcbiAgICAgICAgICAgIGkgPSBwYXJzZXJJbnB1dC5pLFxuICAgICAgICAgICAgbG9vcCA9IHRydWUsXG4gICAgICAgICAgICB0ZXN0Q2hhcjtcblxuICAgICAgICBpZiAodHlwZW9mIHRvayA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRlc3RDaGFyID0gZnVuY3Rpb24oY2hhcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGFyID09PSB0b2s7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZXN0Q2hhciA9IGZ1bmN0aW9uKGNoYXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rLnRlc3QoY2hhcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBkbyB7XG4gICAgICAgICAgICB2YXIgcHJldkNoYXIsIG5leHRDaGFyID0gaW5wdXQuY2hhckF0KGkpO1xuICAgICAgICAgICAgaWYgKGJsb2NrRGVwdGggPT09IDAgJiYgdGVzdENoYXIobmV4dENoYXIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuVmFsID0gaW5wdXQuc3Vic3RyKGxhc3RQb3MsIGkgLSBsYXN0UG9zKTtcbiAgICAgICAgICAgICAgICBpZiAocmV0dXJuVmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlR3JvdXBzLnB1c2gocmV0dXJuVmFsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlR3JvdXBzLnB1c2goJyAnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuVmFsID0gcGFyc2VHcm91cHM7XG4gICAgICAgICAgICAgICAgc2tpcFdoaXRlc3BhY2UoaSAtIHN0YXJ0UG9zKTtcbiAgICAgICAgICAgICAgICBsb29wID0gZmFsc2VcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGluQ29tbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dENoYXIgPT09ICcqJyAmJiBcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0LmNoYXJBdChpICsgMSkgPT09ICcvJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tEZXB0aC0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5Db21tZW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3dpdGNoIChuZXh0Q2hhcikge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdcXFxcJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRDaGFyID0gaW5wdXQuY2hhckF0KGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VHcm91cHMucHVzaChpbnB1dC5zdWJzdHIobGFzdFBvcywgaSAtIGxhc3RQb3MgKyAxKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0UG9zID0gaSArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnLyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhckF0KGkgKyAxKSA9PT0gJyonKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluQ29tbWVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tEZXB0aCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1xcJyc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1wiJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1b3RlID0gcGFyc2VySW5wdXQuJHF1b3RlZChpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChxdW90ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlR3JvdXBzLnB1c2goaW5wdXQuc3Vic3RyKGxhc3RQb3MsIGkgLSBsYXN0UG9zKSwgcXVvdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgKz0gcXVvdGVbMV0ubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0UG9zID0gaSArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBza2lwV2hpdGVzcGFjZShpIC0gc3RhcnRQb3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblZhbCA9IG5leHRDaGFyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvb3AgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICd7JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrU3RhY2sucHVzaCgnfScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tEZXB0aCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJygnOlxuICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tTdGFjay5wdXNoKCcpJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBibG9ja0RlcHRoKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnWyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBibG9ja1N0YWNrLnB1c2goJ10nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrRGVwdGgrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICd9JzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnKSc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ10nOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV4cGVjdGVkID0gYmxvY2tTdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0Q2hhciA9PT0gZXhwZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja0RlcHRoLS07XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1vdmUgdGhlIHBhcnNlciB0byB0aGUgZXJyb3IgYW5kIHJldHVybiBleHBlY3RlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNraXBXaGl0ZXNwYWNlKGkgLSBzdGFydFBvcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuVmFsID0gZXhwZWN0ZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9vcCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgaWYgKGkgPiBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9vcCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXZDaGFyID0gbmV4dENoYXI7XG4gICAgICAgIH0gd2hpbGUgKGxvb3ApO1xuXG4gICAgICAgIHJldHVybiByZXR1cm5WYWwgPyByZXR1cm5WYWwgOiBudWxsO1xuICAgIH1cblxuICAgIHBhcnNlcklucHV0LmF1dG9Db21tZW50QWJzb3JiID0gdHJ1ZTtcbiAgICBwYXJzZXJJbnB1dC5jb21tZW50U3RvcmUgPSBbXTtcbiAgICBwYXJzZXJJbnB1dC5maW5pc2hlZCA9IGZhbHNlO1xuXG4gICAgLy8gU2FtZSBhcyAkKCksIGJ1dCBkb24ndCBjaGFuZ2UgdGhlIHN0YXRlIG9mIHRoZSBwYXJzZXIsXG4gICAgLy8ganVzdCByZXR1cm4gdGhlIG1hdGNoLlxuICAgIHBhcnNlcklucHV0LnBlZWsgPSBmdW5jdGlvbih0b2spIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0b2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAvLyBodHRwczovL2pzcGVyZi5jb20vc3RyaW5nLXN0YXJ0c3dpdGgvMjFcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJBdChwYXJzZXJJbnB1dC5pICsgaSkgIT09IHRvay5jaGFyQXQoaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRvay50ZXN0KGN1cnJlbnQpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIFNwZWNpYWxpemF0aW9uIG9mIHBlZWsoKVxuICAgIC8vIFRPRE8gcmVtb3ZlIG9yIGNoYW5nZSBzb21lIGN1cnJlbnRDaGFyIGNhbGxzIHRvIHBlZWtDaGFyXG4gICAgcGFyc2VySW5wdXQucGVla0NoYXIgPSBmdW5jdGlvbih0b2spIHtcbiAgICAgICAgcmV0dXJuIGlucHV0LmNoYXJBdChwYXJzZXJJbnB1dC5pKSA9PT0gdG9rO1xuICAgIH07XG5cbiAgICBwYXJzZXJJbnB1dC5jdXJyZW50Q2hhciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaW5wdXQuY2hhckF0KHBhcnNlcklucHV0LmkpO1xuICAgIH07XG5cbiAgICBwYXJzZXJJbnB1dC5wcmV2Q2hhciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaW5wdXQuY2hhckF0KHBhcnNlcklucHV0LmkgLSAxKTtcbiAgICB9O1xuXG4gICAgcGFyc2VySW5wdXQuZ2V0SW5wdXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgIH07XG5cbiAgICBwYXJzZXJJbnB1dC5wZWVrTm90TnVtZXJpYyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYyA9IGlucHV0LmNoYXJDb2RlQXQocGFyc2VySW5wdXQuaSk7XG4gICAgICAgIC8vIElzIHRoZSBmaXJzdCBjaGFyIG9mIHRoZSBkaW1lbnNpb24gMC05LCAnLicsICcrJyBvciAnLSdcbiAgICAgICAgcmV0dXJuIChjID4gQ0hBUkNPREVfOSB8fCBjIDwgQ0hBUkNPREVfUExVUykgfHwgYyA9PT0gQ0hBUkNPREVfRk9SV0FSRF9TTEFTSCB8fCBjID09PSBDSEFSQ09ERV9DT01NQTtcbiAgICB9O1xuXG4gICAgcGFyc2VySW5wdXQuc3RhcnQgPSBmdW5jdGlvbihzdHIsIGNodW5rSW5wdXQsIGZhaWxGdW5jdGlvbikge1xuICAgICAgICBpbnB1dCA9IHN0cjtcbiAgICAgICAgcGFyc2VySW5wdXQuaSA9IGogPSBjdXJyZW50UG9zID0gZnVydGhlc3QgPSAwO1xuXG4gICAgICAgIC8vIGNodW5raW5nIGFwcGFyZW50bHkgbWFrZXMgdGhpbmdzIHF1aWNrZXIgKGJ1dCBteSB0ZXN0cyBpbmRpY2F0ZVxuICAgICAgICAvLyBpdCBtaWdodCBhY3R1YWxseSBtYWtlIHRoaW5ncyBzbG93ZXIgaW4gbm9kZSBhdCBsZWFzdClcbiAgICAgICAgLy8gYW5kIGl0IGlzIGEgbm9uLXBlcmZlY3QgcGFyc2UgLSBpdCBjYW4ndCByZWNvZ25pc2VcbiAgICAgICAgLy8gdW5xdW90ZWQgdXJscywgbWVhbmluZyBpdCBjYW4ndCBkaXN0aW5ndWlzaCBjb21tZW50c1xuICAgICAgICAvLyBtZWFuaW5nIGNvbW1lbnRzIHdpdGggcXVvdGVzIG9yIHt9KCkgaW4gdGhlbSBnZXQgJ2NvdW50ZWQnXG4gICAgICAgIC8vIGFuZCB0aGVuIGxlYWQgdG8gcGFyc2UgZXJyb3JzLlxuICAgICAgICAvLyBJbiBhZGRpdGlvbiBpZiB0aGUgY2h1bmtpbmcgY2h1bmtzIGluIHRoZSB3cm9uZyBwbGFjZSB3ZSBtaWdodFxuICAgICAgICAvLyBub3QgYmUgYWJsZSB0byBwYXJzZSBhIHBhcnNlciBzdGF0ZW1lbnQgaW4gb25lIGdvXG4gICAgICAgIC8vIHRoaXMgaXMgb2ZmaWNpYWxseSBkZXByZWNhdGVkIGJ1dCBjYW4gYmUgc3dpdGNoZWQgb24gdmlhIGFuIG9wdGlvblxuICAgICAgICAvLyBpbiB0aGUgY2FzZSBpdCBjYXVzZXMgdG9vIG11Y2ggcGVyZm9ybWFuY2UgaXNzdWVzLlxuICAgICAgICBpZiAoY2h1bmtJbnB1dCkge1xuICAgICAgICAgICAgY2h1bmtzID0gY2h1bmtlcihzdHIsIGZhaWxGdW5jdGlvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaHVua3MgPSBbc3RyXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnQgPSBjaHVua3NbMF07XG5cbiAgICAgICAgc2tpcFdoaXRlc3BhY2UoMCk7XG4gICAgfTtcblxuICAgIHBhcnNlcklucHV0LmVuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbWVzc2FnZSxcbiAgICAgICAgICAgIGlzRmluaXNoZWQgPSBwYXJzZXJJbnB1dC5pID49IGlucHV0Lmxlbmd0aDtcblxuICAgICAgICBpZiAocGFyc2VySW5wdXQuaSA8IGZ1cnRoZXN0KSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gZnVydGhlc3RQb3NzaWJsZUVycm9yTWVzc2FnZTtcbiAgICAgICAgICAgIHBhcnNlcklucHV0LmkgPSBmdXJ0aGVzdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaXNGaW5pc2hlZDogaXNGaW5pc2hlZCxcbiAgICAgICAgICAgIGZ1cnRoZXN0OiBwYXJzZXJJbnB1dC5pLFxuICAgICAgICAgICAgZnVydGhlc3RQb3NzaWJsZUVycm9yTWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgICAgIGZ1cnRoZXN0UmVhY2hlZEVuZDogcGFyc2VySW5wdXQuaSA+PSBpbnB1dC5sZW5ndGggLSAxLFxuICAgICAgICAgICAgZnVydGhlc3RDaGFyOiBpbnB1dFtwYXJzZXJJbnB1dC5pXVxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICByZXR1cm4gcGFyc2VySW5wdXQ7XG59O1xuXG59LHtcIi4vY2h1bmtlclwiOjQyfV0sNDQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIExlc3NFcnJvciA9IHJlcXVpcmUoJy4uL2xlc3MtZXJyb3InKSxcbiAgICB0cmVlID0gcmVxdWlyZSgnLi4vdHJlZScpLFxuICAgIHZpc2l0b3JzID0gcmVxdWlyZSgnLi4vdmlzaXRvcnMnKSxcbiAgICBnZXRQYXJzZXJJbnB1dCA9IHJlcXVpcmUoJy4vcGFyc2VyLWlucHV0JyksXG4gICAgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpLFxuICAgIGZ1bmN0aW9uUmVnaXN0cnkgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvZnVuY3Rpb24tcmVnaXN0cnknKTtcblxuLy9cbi8vIGxlc3MuanMgLSBwYXJzZXJcbi8vXG4vLyAgICBBIHJlbGF0aXZlbHkgc3RyYWlnaHQtZm9yd2FyZCBwcmVkaWN0aXZlIHBhcnNlci5cbi8vICAgIFRoZXJlIGlzIG5vIHRva2VuaXphdGlvbi9sZXhpbmcgc3RhZ2UsIHRoZSBpbnB1dCBpcyBwYXJzZWRcbi8vICAgIGluIG9uZSBzd2VlcC5cbi8vXG4vLyAgICBUbyBtYWtlIHRoZSBwYXJzZXIgZmFzdCBlbm91Z2ggdG8gcnVuIGluIHRoZSBicm93c2VyLCBzZXZlcmFsXG4vLyAgICBvcHRpbWl6YXRpb24gaGFkIHRvIGJlIG1hZGU6XG4vL1xuLy8gICAgLSBNYXRjaGluZyBhbmQgc2xpY2luZyBvbiBhIGh1Z2UgaW5wdXQgaXMgb2Z0ZW4gY2F1c2Ugb2Ygc2xvd2Rvd25zLlxuLy8gICAgICBUaGUgc29sdXRpb24gaXMgdG8gY2h1bmtpZnkgdGhlIGlucHV0IGludG8gc21hbGxlciBzdHJpbmdzLlxuLy8gICAgICBUaGUgY2h1bmtzIGFyZSBzdG9yZWQgaW4gdGhlIGBjaHVua3NgIHZhcixcbi8vICAgICAgYGpgIGhvbGRzIHRoZSBjdXJyZW50IGNodW5rIGluZGV4LCBhbmQgYGN1cnJlbnRQb3NgIGhvbGRzXG4vLyAgICAgIHRoZSBpbmRleCBvZiB0aGUgY3VycmVudCBjaHVuayBpbiByZWxhdGlvbiB0byBgaW5wdXRgLlxuLy8gICAgICBUaGlzIGdpdmVzIHVzIGFuIGFsbW9zdCA0eCBzcGVlZC11cC5cbi8vXG4vLyAgICAtIEluIG1hbnkgY2FzZXMsIHdlIGRvbid0IG5lZWQgdG8gbWF0Y2ggaW5kaXZpZHVhbCB0b2tlbnM7XG4vLyAgICAgIGZvciBleGFtcGxlLCBpZiBhIHZhbHVlIGRvZXNuJ3QgaG9sZCBhbnkgdmFyaWFibGVzLCBvcGVyYXRpb25zXG4vLyAgICAgIG9yIGR5bmFtaWMgcmVmZXJlbmNlcywgdGhlIHBhcnNlciBjYW4gZWZmZWN0aXZlbHkgJ3NraXAnIGl0LFxuLy8gICAgICB0cmVhdGluZyBpdCBhcyBhIGxpdGVyYWwuXG4vLyAgICAgIEFuIGV4YW1wbGUgd291bGQgYmUgJzFweCBzb2xpZCAjMDAwJyAtIHdoaWNoIGV2YWx1YXRlcyB0byBpdHNlbGYsXG4vLyAgICAgIHdlIGRvbid0IG5lZWQgdG8ga25vdyB3aGF0IHRoZSBpbmRpdmlkdWFsIGNvbXBvbmVudHMgYXJlLlxuLy8gICAgICBUaGUgZHJhd2JhY2ssIG9mIGNvdXJzZSBpcyB0aGF0IHlvdSBkb24ndCBnZXQgdGhlIGJlbmVmaXRzIG9mXG4vLyAgICAgIHN5bnRheC1jaGVja2luZyBvbiB0aGUgQ1NTLiBUaGlzIGdpdmVzIHVzIGEgNTAlIHNwZWVkLXVwIGluIHRoZSBwYXJzZXIsXG4vLyAgICAgIGFuZCBhIHNtYWxsZXIgc3BlZWQtdXAgaW4gdGhlIGNvZGUtZ2VuLlxuLy9cbi8vXG4vLyAgICBUb2tlbiBtYXRjaGluZyBpcyBkb25lIHdpdGggdGhlIGAkYCBmdW5jdGlvbiwgd2hpY2ggZWl0aGVyIHRha2VzXG4vLyAgICBhIHRlcm1pbmFsIHN0cmluZyBvciByZWdleHAsIG9yIGEgbm9uLXRlcm1pbmFsIGZ1bmN0aW9uIHRvIGNhbGwuXG4vLyAgICBJdCBhbHNvIHRha2VzIGNhcmUgb2YgbW92aW5nIGFsbCB0aGUgaW5kaWNlcyBmb3J3YXJkcy5cbi8vXG5cbnZhciBQYXJzZXIgPSBmdW5jdGlvbiBQYXJzZXIoY29udGV4dCwgaW1wb3J0cywgZmlsZUluZm8pIHtcbiAgICB2YXIgcGFyc2VycyxcbiAgICAgICAgcGFyc2VySW5wdXQgPSBnZXRQYXJzZXJJbnB1dCgpO1xuXG4gICAgZnVuY3Rpb24gZXJyb3IobXNnLCB0eXBlKSB7XG4gICAgICAgIHRocm93IG5ldyBMZXNzRXJyb3IoXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW5kZXg6IHBhcnNlcklucHV0LmksXG4gICAgICAgICAgICAgICAgZmlsZW5hbWU6IGZpbGVJbmZvLmZpbGVuYW1lLFxuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUgfHwgJ1N5bnRheCcsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogbXNnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW1wb3J0c1xuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4cGVjdChhcmcsIG1zZykge1xuICAgICAgICAvLyBzb21lIG9sZGVyIGJyb3dzZXJzIHJldHVybiB0eXBlb2YgJ2Z1bmN0aW9uJyBmb3IgUmVnRXhwXG4gICAgICAgIHZhciByZXN1bHQgPSAoYXJnIGluc3RhbmNlb2YgRnVuY3Rpb24pID8gYXJnLmNhbGwocGFyc2VycykgOiBwYXJzZXJJbnB1dC4kcmUoYXJnKTtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgZXJyb3IobXNnIHx8ICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgPyAnZXhwZWN0ZWQgXFwnJyArIGFyZyArICdcXCcgZ290IFxcJycgKyBwYXJzZXJJbnB1dC5jdXJyZW50Q2hhcigpICsgJ1xcJydcbiAgICAgICAgICAgIDogJ3VuZXhwZWN0ZWQgdG9rZW4nKSk7XG4gICAgfVxuXG4gICAgLy8gU3BlY2lhbGl6YXRpb24gb2YgZXhwZWN0KClcbiAgICBmdW5jdGlvbiBleHBlY3RDaGFyKGFyZywgbXNnKSB7XG4gICAgICAgIGlmIChwYXJzZXJJbnB1dC4kY2hhcihhcmcpKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJnO1xuICAgICAgICB9XG4gICAgICAgIGVycm9yKG1zZyB8fCAnZXhwZWN0ZWQgXFwnJyArIGFyZyArICdcXCcgZ290IFxcJycgKyBwYXJzZXJJbnB1dC5jdXJyZW50Q2hhcigpICsgJ1xcJycpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldERlYnVnSW5mbyhpbmRleCkge1xuICAgICAgICB2YXIgZmlsZW5hbWUgPSBmaWxlSW5mby5maWxlbmFtZTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGluZU51bWJlcjogdXRpbHMuZ2V0TG9jYXRpb24oaW5kZXgsIHBhcnNlcklucHV0LmdldElucHV0KCkpLmxpbmUgKyAxLFxuICAgICAgICAgICAgZmlsZU5hbWU6IGZpbGVuYW1lXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIFVzZWQgYWZ0ZXIgaW5pdGlhbCBwYXJzaW5nIHRvIGNyZWF0ZSBub2RlcyBvbiB0aGUgZmx5XG4gICAgICogXG4gICAgICogIEBwYXJhbSB7U3RyaW5nfSBzdHIgICAgICAgICAgLSBzdHJpbmcgdG8gcGFyc2UgXG4gICAgICogIEBwYXJhbSB7QXJyYXl9ICBwYXJzZUxpc3QgICAgLSBhcnJheSBvZiBwYXJzZXJzIHRvIHJ1biBpbnB1dCB0aHJvdWdoIGUuZy4gW1widmFsdWVcIiwgXCJpbXBvcnRhbnRcIl1cbiAgICAgKiAgQHBhcmFtIHtOdW1iZXJ9IGN1cnJlbnRJbmRleCAtIHN0YXJ0IG51bWJlciB0byBiZWdpbiBpbmRleGluZ1xuICAgICAqICBAcGFyYW0ge09iamVjdH0gZmlsZUluZm8gICAgIC0gZmlsZUluZm8gdG8gYXR0YWNoIHRvIGNyZWF0ZWQgbm9kZXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXJzZU5vZGUoc3RyLCBwYXJzZUxpc3QsIGN1cnJlbnRJbmRleCwgZmlsZUluZm8sIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciByZXN1bHQsIHJldHVybk5vZGVzID0gW107XG4gICAgICAgIHZhciBwYXJzZXIgPSBwYXJzZXJJbnB1dDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXJ0KHN0ciwgZmFsc2UsIGZ1bmN0aW9uIGZhaWwobXNnLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogbXNnLFxuICAgICAgICAgICAgICAgICAgICBpbmRleDogaW5kZXggKyBjdXJyZW50SW5kZXhcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZm9yICh2YXIgeCA9IDAsIHAsIGk7IChwID0gcGFyc2VMaXN0W3hdKTsgeCsrKSB7XG4gICAgICAgICAgICAgICAgaSA9IHBhcnNlci5pO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHBhcnNlcnNbcF0oKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5faW5kZXggPSBpICsgY3VycmVudEluZGV4O1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuX2ZpbGVJbmZvID0gZmlsZUluZm87XG4gICAgICAgICAgICAgICAgICAgIHJldHVybk5vZGVzLnB1c2gocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybk5vZGVzLnB1c2gobnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZW5kSW5mbyA9IHBhcnNlci5lbmQoKTtcbiAgICAgICAgICAgIGlmIChlbmRJbmZvLmlzRmluaXNoZWQpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCByZXR1cm5Ob2Rlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayh0cnVlLCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IExlc3NFcnJvcih7XG4gICAgICAgICAgICAgICAgaW5kZXg6IGUuaW5kZXggKyBjdXJyZW50SW5kZXgsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogZS5tZXNzYWdlXG4gICAgICAgICAgICB9LCBpbXBvcnRzLCBmaWxlSW5mby5maWxlbmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy9cbiAgICAvLyBUaGUgUGFyc2VyXG4gICAgLy9cbiAgICByZXR1cm4ge1xuICAgICAgICBwYXJzZXJJbnB1dDogcGFyc2VySW5wdXQsXG4gICAgICAgIGltcG9ydHM6IGltcG9ydHMsXG4gICAgICAgIGZpbGVJbmZvOiBmaWxlSW5mbyxcbiAgICAgICAgcGFyc2VOb2RlOiBwYXJzZU5vZGUsXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFBhcnNlIGFuIGlucHV0IHN0cmluZyBpbnRvIGFuIGFic3RyYWN0IHN5bnRheCB0cmVlLFxuICAgICAgICAvLyBAcGFyYW0gc3RyIEEgc3RyaW5nIGNvbnRhaW5pbmcgJ2xlc3MnIG1hcmt1cFxuICAgICAgICAvLyBAcGFyYW0gY2FsbGJhY2sgY2FsbCBgY2FsbGJhY2tgIHdoZW4gZG9uZS5cbiAgICAgICAgLy8gQHBhcmFtIFthZGRpdGlvbmFsRGF0YV0gQW4gb3B0aW9uYWwgbWFwIHdoaWNoIGNhbiBjb250YWlucyB2YXJzIC0gYSBtYXAgKGtleSwgdmFsdWUpIG9mIHZhcmlhYmxlcyB0byBhcHBseVxuICAgICAgICAvL1xuICAgICAgICBwYXJzZTogZnVuY3Rpb24gKHN0ciwgY2FsbGJhY2ssIGFkZGl0aW9uYWxEYXRhKSB7XG4gICAgICAgICAgICB2YXIgcm9vdCwgZXJyb3IgPSBudWxsLCBnbG9iYWxWYXJzLCBtb2RpZnlWYXJzLCBpZ25vcmVkLCBwcmVUZXh0ID0gJyc7XG5cbiAgICAgICAgICAgIGdsb2JhbFZhcnMgPSAoYWRkaXRpb25hbERhdGEgJiYgYWRkaXRpb25hbERhdGEuZ2xvYmFsVmFycykgPyBQYXJzZXIuc2VyaWFsaXplVmFycyhhZGRpdGlvbmFsRGF0YS5nbG9iYWxWYXJzKSArICdcXG4nIDogJyc7XG4gICAgICAgICAgICBtb2RpZnlWYXJzID0gKGFkZGl0aW9uYWxEYXRhICYmIGFkZGl0aW9uYWxEYXRhLm1vZGlmeVZhcnMpID8gJ1xcbicgKyBQYXJzZXIuc2VyaWFsaXplVmFycyhhZGRpdGlvbmFsRGF0YS5tb2RpZnlWYXJzKSA6ICcnO1xuXG4gICAgICAgICAgICBpZiAoY29udGV4dC5wbHVnaW5NYW5hZ2VyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByZVByb2Nlc3NvcnMgPSBjb250ZXh0LnBsdWdpbk1hbmFnZXIuZ2V0UHJlUHJvY2Vzc29ycygpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJlUHJvY2Vzc29ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBzdHIgPSBwcmVQcm9jZXNzb3JzW2ldLnByb2Nlc3Moc3RyLCB7IGNvbnRleHQ6IGNvbnRleHQsIGltcG9ydHM6IGltcG9ydHMsIGZpbGVJbmZvOiBmaWxlSW5mbyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChnbG9iYWxWYXJzIHx8IChhZGRpdGlvbmFsRGF0YSAmJiBhZGRpdGlvbmFsRGF0YS5iYW5uZXIpKSB7XG4gICAgICAgICAgICAgICAgcHJlVGV4dCA9ICgoYWRkaXRpb25hbERhdGEgJiYgYWRkaXRpb25hbERhdGEuYmFubmVyKSA/IGFkZGl0aW9uYWxEYXRhLmJhbm5lciA6ICcnKSArIGdsb2JhbFZhcnM7XG4gICAgICAgICAgICAgICAgaWdub3JlZCA9IGltcG9ydHMuY29udGVudHNJZ25vcmVkQ2hhcnM7XG4gICAgICAgICAgICAgICAgaWdub3JlZFtmaWxlSW5mby5maWxlbmFtZV0gPSBpZ25vcmVkW2ZpbGVJbmZvLmZpbGVuYW1lXSB8fCAwO1xuICAgICAgICAgICAgICAgIGlnbm9yZWRbZmlsZUluZm8uZmlsZW5hbWVdICs9IHByZVRleHQubGVuZ3RoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSgvXFxyXFxuPy9nLCAnXFxuJyk7XG4gICAgICAgICAgICAvLyBSZW1vdmUgcG90ZW50aWFsIFVURiBCeXRlIE9yZGVyIE1hcmtcbiAgICAgICAgICAgIHN0ciA9IHByZVRleHQgKyBzdHIucmVwbGFjZSgvXlxcdUZFRkYvLCAnJykgKyBtb2RpZnlWYXJzO1xuICAgICAgICAgICAgaW1wb3J0cy5jb250ZW50c1tmaWxlSW5mby5maWxlbmFtZV0gPSBzdHI7XG5cbiAgICAgICAgICAgIC8vIFN0YXJ0IHdpdGggdGhlIHByaW1hcnkgcnVsZS5cbiAgICAgICAgICAgIC8vIFRoZSB3aG9sZSBzeW50YXggdHJlZSBpcyBoZWxkIHVuZGVyIGEgUnVsZXNldCBub2RlLFxuICAgICAgICAgICAgLy8gd2l0aCB0aGUgYHJvb3RgIHByb3BlcnR5IHNldCB0byB0cnVlLCBzbyBubyBge31gIGFyZVxuICAgICAgICAgICAgLy8gb3V0cHV0LiBUaGUgY2FsbGJhY2sgaXMgY2FsbGVkIHdoZW4gdGhlIGlucHV0IGlzIHBhcnNlZC5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuc3RhcnQoc3RyLCBjb250ZXh0LmNodW5rSW5wdXQsIGZ1bmN0aW9uIGZhaWwobXNnLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTGVzc0Vycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdQYXJzZScsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBtc2csXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlbmFtZTogZmlsZUluZm8uZmlsZW5hbWVcbiAgICAgICAgICAgICAgICAgICAgfSwgaW1wb3J0cyk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB0cmVlLk5vZGUucHJvdG90eXBlLnBhcnNlID0gdGhpcztcbiAgICAgICAgICAgICAgICByb290ID0gbmV3IHRyZWUuUnVsZXNldChudWxsLCB0aGlzLnBhcnNlcnMucHJpbWFyeSgpKTtcbiAgICAgICAgICAgICAgICB0cmVlLk5vZGUucHJvdG90eXBlLnJvb3ROb2RlID0gcm9vdDtcbiAgICAgICAgICAgICAgICByb290LnJvb3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJvb3QuZmlyc3RSb290ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByb290LmZ1bmN0aW9uUmVnaXN0cnkgPSBmdW5jdGlvblJlZ2lzdHJ5LmluaGVyaXQoKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobmV3IExlc3NFcnJvcihlLCBpbXBvcnRzLCBmaWxlSW5mby5maWxlbmFtZSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiBgaWAgaXMgc21hbGxlciB0aGFuIHRoZSBgaW5wdXQubGVuZ3RoIC0gMWAsXG4gICAgICAgICAgICAvLyBpdCBtZWFucyB0aGUgcGFyc2VyIHdhc24ndCBhYmxlIHRvIHBhcnNlIHRoZSB3aG9sZVxuICAgICAgICAgICAgLy8gc3RyaW5nLCBzbyB3ZSd2ZSBnb3QgYSBwYXJzaW5nIGVycm9yLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFdlIHRyeSB0byBleHRyYWN0IGEgXFxuIGRlbGltaXRlZCBzdHJpbmcsXG4gICAgICAgICAgICAvLyBzaG93aW5nIHRoZSBsaW5lIHdoZXJlIHRoZSBwYXJzZSBlcnJvciBvY2N1cnJlZC5cbiAgICAgICAgICAgIC8vIFdlIHNwbGl0IGl0IHVwIGludG8gdHdvIHBhcnRzICh0aGUgcGFydCB3aGljaCBwYXJzZWQsXG4gICAgICAgICAgICAvLyBhbmQgdGhlIHBhcnQgd2hpY2ggZGlkbid0KSwgc28gd2UgY2FuIGNvbG9yIHRoZW0gZGlmZmVyZW50bHkuXG4gICAgICAgICAgICB2YXIgZW5kSW5mbyA9IHBhcnNlcklucHV0LmVuZCgpO1xuICAgICAgICAgICAgaWYgKCFlbmRJbmZvLmlzRmluaXNoZWQpIHtcblxuICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gZW5kSW5mby5mdXJ0aGVzdFBvc3NpYmxlRXJyb3JNZXNzYWdlO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSAnVW5yZWNvZ25pc2VkIGlucHV0JztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuZEluZm8uZnVydGhlc3RDaGFyID09PSAnfScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gJy4gUG9zc2libHkgbWlzc2luZyBvcGVuaW5nIFxcJ3tcXCcnO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVuZEluZm8uZnVydGhlc3RDaGFyID09PSAnKScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gJy4gUG9zc2libHkgbWlzc2luZyBvcGVuaW5nIFxcJyhcXCcnO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVuZEluZm8uZnVydGhlc3RSZWFjaGVkRW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlICs9ICcuIFBvc3NpYmx5IG1pc3Npbmcgc29tZXRoaW5nJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGVycm9yID0gbmV3IExlc3NFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdQYXJzZScsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBlbmRJbmZvLmZ1cnRoZXN0LFxuICAgICAgICAgICAgICAgICAgICBmaWxlbmFtZTogZmlsZUluZm8uZmlsZW5hbWVcbiAgICAgICAgICAgICAgICB9LCBpbXBvcnRzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGZpbmlzaCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgZSA9IGVycm9yIHx8IGUgfHwgaW1wb3J0cy5lcnJvcjtcblxuICAgICAgICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKGUgaW5zdGFuY2VvZiBMZXNzRXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlID0gbmV3IExlc3NFcnJvcihlLCBpbXBvcnRzLCBmaWxlSW5mby5maWxlbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgcm9vdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKGNvbnRleHQucHJvY2Vzc0ltcG9ydHMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgbmV3IHZpc2l0b3JzLkltcG9ydFZpc2l0b3IoaW1wb3J0cywgZmluaXNoKVxuICAgICAgICAgICAgICAgICAgICAucnVuKHJvb3QpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmluaXNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gSGVyZSBpbiwgdGhlIHBhcnNpbmcgcnVsZXMvZnVuY3Rpb25zXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRoZSBiYXNpYyBzdHJ1Y3R1cmUgb2YgdGhlIHN5bnRheCB0cmVlIGdlbmVyYXRlZCBpcyBhcyBmb2xsb3dzOlxuICAgICAgICAvL1xuICAgICAgICAvLyAgIFJ1bGVzZXQgLT4gIERlY2xhcmF0aW9uIC0+IFZhbHVlIC0+IEV4cHJlc3Npb24gLT4gRW50aXR5XG4gICAgICAgIC8vXG4gICAgICAgIC8vIEhlcmUncyBzb21lIExlc3MgY29kZTpcbiAgICAgICAgLy9cbiAgICAgICAgLy8gICAgLmNsYXNzIHtcbiAgICAgICAgLy8gICAgICBjb2xvcjogI2ZmZjtcbiAgICAgICAgLy8gICAgICBib3JkZXI6IDFweCBzb2xpZCAjMDAwO1xuICAgICAgICAvLyAgICAgIHdpZHRoOiBAdyArIDRweDtcbiAgICAgICAgLy8gICAgICA+IC5jaGlsZCB7Li4ufVxuICAgICAgICAvLyAgICB9XG4gICAgICAgIC8vXG4gICAgICAgIC8vIEFuZCBoZXJlJ3Mgd2hhdCB0aGUgcGFyc2UgdHJlZSBtaWdodCBsb29rIGxpa2U6XG4gICAgICAgIC8vXG4gICAgICAgIC8vICAgICBSdWxlc2V0IChTZWxlY3RvciAnLmNsYXNzJywgW1xuICAgICAgICAvLyAgICAgICAgIERlY2xhcmF0aW9uIChcImNvbG9yXCIsICBWYWx1ZSAoW0V4cHJlc3Npb24gW0NvbG9yICNmZmZdXSkpXG4gICAgICAgIC8vICAgICAgICAgRGVjbGFyYXRpb24gKFwiYm9yZGVyXCIsIFZhbHVlIChbRXhwcmVzc2lvbiBbRGltZW5zaW9uIDFweF1bS2V5d29yZCBcInNvbGlkXCJdW0NvbG9yICMwMDBdXSkpXG4gICAgICAgIC8vICAgICAgICAgRGVjbGFyYXRpb24gKFwid2lkdGhcIiwgIFZhbHVlIChbRXhwcmVzc2lvbiBbT3BlcmF0aW9uIFwiICsgXCIgW1ZhcmlhYmxlIFwiQHdcIl1bRGltZW5zaW9uIDRweF1dXSkpXG4gICAgICAgIC8vICAgICAgICAgUnVsZXNldCAoU2VsZWN0b3IgW0VsZW1lbnQgJz4nLCAnLmNoaWxkJ10sIFsuLi5dKVxuICAgICAgICAvLyAgICAgXSlcbiAgICAgICAgLy9cbiAgICAgICAgLy8gIEluIGdlbmVyYWwsIG1vc3QgcnVsZXMgd2lsbCB0cnkgdG8gcGFyc2UgYSB0b2tlbiB3aXRoIHRoZSBgJHJlKClgIGZ1bmN0aW9uLCBhbmQgaWYgdGhlIHJldHVyblxuICAgICAgICAvLyAgdmFsdWUgaXMgdHJ1bHksIHdpbGwgcmV0dXJuIGEgbmV3IG5vZGUsIG9mIHRoZSByZWxldmFudCB0eXBlLiBTb21ldGltZXMsIHdlIG5lZWQgdG8gY2hlY2tcbiAgICAgICAgLy8gIGZpcnN0LCBiZWZvcmUgcGFyc2luZywgdGhhdCdzIHdoZW4gd2UgdXNlIGBwZWVrKClgLlxuICAgICAgICAvL1xuICAgICAgICBwYXJzZXJzOiBwYXJzZXJzID0ge1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFRoZSBgcHJpbWFyeWAgcnVsZSBpcyB0aGUgKmVudHJ5KiBhbmQgKmV4aXQqIHBvaW50IG9mIHRoZSBwYXJzZXIuXG4gICAgICAgICAgICAvLyBUaGUgcnVsZXMgaGVyZSBjYW4gYXBwZWFyIGF0IGFueSBsZXZlbCBvZiB0aGUgcGFyc2UgdHJlZS5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBUaGUgcmVjdXJzaXZlIG5hdHVyZSBvZiB0aGUgZ3JhbW1hciBpcyBhbiBpbnRlcnBsYXkgYmV0d2VlbiB0aGUgYGJsb2NrYFxuICAgICAgICAgICAgLy8gcnVsZSwgd2hpY2ggcmVwcmVzZW50cyBgeyAuLi4gfWAsIHRoZSBgcnVsZXNldGAgcnVsZSwgYW5kIHRoaXMgYHByaW1hcnlgIHJ1bGUsXG4gICAgICAgICAgICAvLyBhcyByZXByZXNlbnRlZCBieSB0aGlzIHNpbXBsaWZpZWQgZ3JhbW1hcjpcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyAgICAgcHJpbWFyeSAg4oaSICAocnVsZXNldCB8IGRlY2xhcmF0aW9uKStcbiAgICAgICAgICAgIC8vICAgICBydWxlc2V0ICDihpIgIHNlbGVjdG9yKyBibG9ja1xuICAgICAgICAgICAgLy8gICAgIGJsb2NrICAgIOKGkiAgJ3snIHByaW1hcnkgJ30nXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gT25seSBhdCBvbmUgcG9pbnQgaXMgdGhlIHByaW1hcnkgcnVsZSBub3QgY2FsbGVkIGZyb20gdGhlXG4gICAgICAgICAgICAvLyBibG9jayBydWxlOiBhdCB0aGUgcm9vdCBsZXZlbC5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICBwcmltYXJ5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1peGluID0gdGhpcy5taXhpbiwgcm9vdCA9IFtdLCBub2RlO1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSB0aGlzLmNvbW1lbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbm9kZSkgeyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcm9vdC5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGFsd2F5cyBwcm9jZXNzIGNvbW1lbnRzIGJlZm9yZSBkZWNpZGluZyBpZiBmaW5pc2hlZFxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VySW5wdXQuZmluaXNoZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXJJbnB1dC5wZWVrKCd9JykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHRoaXMuZXh0ZW5kUnVsZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm9vdCA9IHJvb3QuY29uY2F0KG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBub2RlID0gbWl4aW4uZGVmaW5pdGlvbigpIHx8IHRoaXMuZGVjbGFyYXRpb24oKSB8fCB0aGlzLnJ1bGVzZXQoKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgbWl4aW4uY2FsbChmYWxzZSwgZmFsc2UpIHx8IHRoaXMudmFyaWFibGVDYWxsKCkgfHwgdGhpcy5lbnRpdGllcy5jYWxsKCkgfHwgdGhpcy5hdHJ1bGUoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvb3QucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmb3VuZFNlbWlDb2xvbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHBhcnNlcklucHV0LiRjaGFyKCc7JykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VuZFNlbWlDb2xvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWZvdW5kU2VtaUNvbG9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcm9vdDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIGNvbW1lbnRzIGFyZSBjb2xsZWN0ZWQgYnkgdGhlIG1haW4gcGFyc2luZyBtZWNoYW5pc20gYW5kIHRoZW4gYXNzaWduZWQgdG8gbm9kZXNcbiAgICAgICAgICAgIC8vIHdoZXJlIHRoZSBjdXJyZW50IHN0cnVjdHVyZSBhbGxvd3MgaXRcbiAgICAgICAgICAgIGNvbW1lbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VySW5wdXQuY29tbWVudFN0b3JlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29tbWVudCA9IHBhcnNlcklucHV0LmNvbW1lbnRTdG9yZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3KHRyZWUuQ29tbWVudCkoY29tbWVudC50ZXh0LCBjb21tZW50LmlzTGluZUNvbW1lbnQsIGNvbW1lbnQuaW5kZXgsIGZpbGVJbmZvKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gRW50aXRpZXMgYXJlIHRva2VucyB3aGljaCBjYW4gYmUgZm91bmQgaW5zaWRlIGFuIEV4cHJlc3Npb25cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICBlbnRpdGllczoge1xuICAgICAgICAgICAgICAgIG1peGluTG9va3VwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlcnMubWl4aW4uY2FsbCh0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gQSBzdHJpbmcsIHdoaWNoIHN1cHBvcnRzIGVzY2FwaW5nIFwiIGFuZCAnXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyAgICAgXCJtaWxreSB3YXlcIiAnaGVcXCdzIHRoZSBvbmUhJ1xuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgcXVvdGVkOiBmdW5jdGlvbiAoZm9yY2VFc2NhcGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHIsIGluZGV4ID0gcGFyc2VySW5wdXQuaSwgaXNFc2NhcGVkID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuc2F2ZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VySW5wdXQuJGNoYXIoJ34nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNFc2NhcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChmb3JjZUVzY2FwZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHN0ciA9IHBhcnNlcklucHV0LiRxdW90ZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5mb3JnZXQoKTtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3KHRyZWUuUXVvdGVkKShzdHIuY2hhckF0KDApLCBzdHIuc3Vic3RyKDEsIHN0ci5sZW5ndGggLSAyKSwgaXNFc2NhcGVkLCBpbmRleCwgZmlsZUluZm8pO1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIEEgY2F0Y2gtYWxsIHdvcmQsIHN1Y2ggYXM6XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyAgICAgYmxhY2sgYm9yZGVyLWNvbGxhcHNlXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICBrZXl3b3JkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrID0gcGFyc2VySW5wdXQuJGNoYXIoJyUnKSB8fCBwYXJzZXJJbnB1dC4kcmUoL15cXFs/KD86W1xcdy1dfFxcXFwoPzpbQS1GYS1mMC05XXsxLDZ9ID98W15BLUZhLWYwLTldKSkrXFxdPy8pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRyZWUuQ29sb3IuZnJvbUtleXdvcmQoaykgfHwgbmV3KHRyZWUuS2V5d29yZCkoayk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBBIGZ1bmN0aW9uIGNhbGxcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vICAgICByZ2IoMjU1LCAwLCAyNTUpXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBUaGUgYXJndW1lbnRzIGFyZSBwYXJzZWQgd2l0aCB0aGUgYGVudGl0aWVzLmFyZ3VtZW50c2AgcGFyc2VyLlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgY2FsbDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSwgYXJncywgZnVuYywgaW5kZXggPSBwYXJzZXJJbnB1dC5pO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly9qc3BlcmYuY29tL2Nhc2UtaW5zZW5zaXRpdmUtcmVnZXgtdnMtc3RydG9sb3dlci10aGVuLXJlZ2V4LzE4XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXJJbnB1dC5wZWVrKC9edXJsXFwoL2kpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5zYXZlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IHBhcnNlcklucHV0LiRyZSgvXihbXFx3LV0rfCV8cHJvZ2lkOltcXHdcXC5dKylcXCgvKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5mb3JnZXQoKTsgXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBuYW1lID0gbmFtZVsxXTtcbiAgICAgICAgICAgICAgICAgICAgZnVuYyA9IHRoaXMuY3VzdG9tRnVuY0NhbGwobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmdW5jKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzID0gZnVuYy5wYXJzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3MgJiYgZnVuYy5zdG9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuZm9yZ2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyZ3M7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBhcmdzID0gdGhpcy5hcmd1bWVudHMoYXJncyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJzZXJJbnB1dC4kY2hhcignKScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5yZXN0b3JlKCdDb3VsZCBub3QgcGFyc2UgY2FsbCBhcmd1bWVudHMgb3IgbWlzc2luZyBcXCcpXFwnJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5mb3JnZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcodHJlZS5DYWxsKShuYW1lLCBhcmdzLCBpbmRleCwgZmlsZUluZm8pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBQYXJzaW5nIHJ1bGVzIGZvciBmdW5jdGlvbnMgd2l0aCBub24tc3RhbmRhcmQgYXJncywgZS5nLjpcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vICAgICBib29sZWFuKG5vdCgyID4gMSkpXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyAgICAgVGhpcyBpcyBhIHF1aWNrIHByb3RvdHlwZSwgdG8gYmUgbW9kaWZpZWQvaW1wcm92ZWQgd2hlblxuICAgICAgICAgICAgICAgIC8vICAgICBtb3JlIGN1c3RvbS1wYXJzZWQgZnVuY3MgY29tZSAoZS5nLiBgc2VsZWN0b3IoLi4uKWApXG4gICAgICAgICAgICAgICAgLy9cblxuICAgICAgICAgICAgICAgIGN1c3RvbUZ1bmNDYWxsOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAvKiBJZGVhbGx5IHRoZSB0YWJsZSBpcyB0byBiZSBtb3ZlZCBvdXQgb2YgaGVyZSBmb3IgZmFzdGVyIHBlcmYuLFxuICAgICAgICAgICAgICAgICAgICAgICBidXQgaXQncyBxdWl0ZSB0cmlja3kgc2luY2UgaXQgcmVsaWVzIG9uIGFsbCB0aGVzZSBgcGFyc2Vyc2BcbiAgICAgICAgICAgICAgICAgICAgICAgYW5kIGBleHBlY3RgIGF2YWlsYWJsZSBvbmx5IGhlcmUgKi9cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhOiAgIGYocGFyc2Vycy5pZUFscGhhLCB0cnVlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvb2xlYW46IGYoY29uZGl0aW9uKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdpZic6ICAgIGYoY29uZGl0aW9uKVxuICAgICAgICAgICAgICAgICAgICB9W25hbWUudG9Mb3dlckNhc2UoKV07XG5cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZihwYXJzZSwgc3RvcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZTogcGFyc2UsIC8vIHBhcnNpbmcgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9wOiAgc3RvcCAgIC8vIHdoZW4gdHJ1ZSAtIHN0b3AgYWZ0ZXIgcGFyc2UoKSBhbmQgcmV0dXJuIGl0cyByZXN1bHQsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGNvbnRpbnVlIGZvciBwbGFpbiBhcmdzXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGNvbmRpdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbZXhwZWN0KHBhcnNlcnMuY29uZGl0aW9uLCAnZXhwZWN0ZWQgY29uZGl0aW9uJyldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIGFyZ3VtZW50czogZnVuY3Rpb24gKHByZXZBcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmdzQ29tbWEgPSBwcmV2QXJncyB8fCBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3NTZW1pQ29sb24gPSBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzU2VtaUNvbG9uU2VwYXJhdGVkLCB2YWx1ZTtcblxuICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5zYXZlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmV2QXJncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZBcmdzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyc2Vycy5kZXRhY2hlZFJ1bGVzZXQoKSB8fCB0aGlzLmFzc2lnbm1lbnQoKSB8fCBwYXJzZXJzLmV4cHJlc3Npb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS52YWx1ZSAmJiB2YWx1ZS52YWx1ZS5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnZhbHVlWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3NDb21tYS5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlcklucHV0LiRjaGFyKCcsJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlcklucHV0LiRjaGFyKCc7JykgfHwgaXNTZW1pQ29sb25TZXBhcmF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1NlbWlDb2xvblNlcGFyYXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAoYXJnc0NvbW1hLmxlbmd0aCA8IDEpID8gYXJnc0NvbW1hWzBdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbmV3IHRyZWUuVmFsdWUoYXJnc0NvbW1hKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzU2VtaUNvbG9uLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3NDb21tYSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuZm9yZ2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpc1NlbWlDb2xvblNlcGFyYXRlZCA/IGFyZ3NTZW1pQ29sb24gOiBhcmdzQ29tbWE7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBsaXRlcmFsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRpbWVuc2lvbigpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbG9yKCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucXVvdGVkKCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudW5pY29kZURlc2NyaXB0b3IoKTtcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgLy8gQXNzaWdubWVudHMgYXJlIGFyZ3VtZW50IGVudGl0aWVzIGZvciBjYWxscy5cbiAgICAgICAgICAgICAgICAvLyBUaGV5IGFyZSBwcmVzZW50IGluIGllIGZpbHRlciBwcm9wZXJ0aWVzIGFzIHNob3duIGJlbG93LlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gICAgIGZpbHRlcjogcHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LkFscGhhKCAqb3BhY2l0eT01MCogKVxuICAgICAgICAgICAgICAgIC8vXG5cbiAgICAgICAgICAgICAgICBhc3NpZ25tZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXksIHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgICAgIGtleSA9IHBhcnNlcklucHV0LiRyZSgvXlxcdysoPz1cXHM/PSkvaSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICgha2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5yZXN0b3JlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJzZXJJbnB1dC4kY2hhcignPScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5yZXN0b3JlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZXJzLmVudGl0eSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmZvcmdldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyh0cmVlLkFzc2lnbm1lbnQpKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgdXJsKCkgdG9rZW5zXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBXZSB1c2UgYSBzcGVjaWZpYyBydWxlIGZvciB1cmxzLCBiZWNhdXNlIHRoZXkgZG9uJ3QgcmVhbGx5IGJlaGF2ZSBsaWtlXG4gICAgICAgICAgICAgICAgLy8gc3RhbmRhcmQgZnVuY3Rpb24gY2FsbHMuIFRoZSBkaWZmZXJlbmNlIGlzIHRoYXQgdGhlIGFyZ3VtZW50IGRvZXNuJ3QgaGF2ZVxuICAgICAgICAgICAgICAgIC8vIHRvIGJlIGVuY2xvc2VkIHdpdGhpbiBhIHN0cmluZywgc28gaXQgY2FuJ3QgYmUgcGFyc2VkIGFzIGFuIEV4cHJlc3Npb24uXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICB1cmw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlLCBpbmRleCA9IHBhcnNlcklucHV0Lmk7XG5cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuYXV0b0NvbW1lbnRBYnNvcmIgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcnNlcklucHV0LiRzdHIoJ3VybCgnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuYXV0b0NvbW1lbnRBYnNvcmIgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnF1b3RlZCgpIHx8IHRoaXMudmFyaWFibGUoKSB8fCB0aGlzLnByb3BlcnR5KCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC4kcmUoL14oPzooPzpcXFxcW1xcKFxcKSdcIl0pfFteXFwoXFwpJ1wiXSkrLykgfHwgJyc7XG5cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuYXV0b0NvbW1lbnRBYnNvcmIgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdENoYXIoJyknKTtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3KHRyZWUuVVJMKSgodmFsdWUudmFsdWUgIT0gbnVsbCB8fCBcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlIGluc3RhbmNlb2YgdHJlZS5WYXJpYWJsZSB8fCBcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlIGluc3RhbmNlb2YgdHJlZS5Qcm9wZXJ0eSkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgOiBuZXcodHJlZS5Bbm9ueW1vdXMpKHZhbHVlLCBpbmRleCksIGluZGV4LCBmaWxlSW5mbyk7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gQSBWYXJpYWJsZSBlbnRpdHksIHN1Y2ggYXMgYEBmaW5rYCwgaW5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vICAgICB3aWR0aDogQGZpbmsgKyAycHhcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIFdlIHVzZSBhIGRpZmZlcmVudCBwYXJzZXIgZm9yIHZhcmlhYmxlIGRlZmluaXRpb25zLFxuICAgICAgICAgICAgICAgIC8vIHNlZSBgcGFyc2Vycy52YXJpYWJsZWAuXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICB2YXJpYWJsZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2gsIG5hbWUsIGluZGV4ID0gcGFyc2VySW5wdXQuaTtcblxuICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXJJbnB1dC5jdXJyZW50Q2hhcigpID09PSAnQCcgJiYgKG5hbWUgPSBwYXJzZXJJbnB1dC4kcmUoL15AQD9bXFx3LV0rLykpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaCA9IHBhcnNlcklucHV0LmN1cnJlbnRDaGFyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICcoJyB8fCBjaCA9PT0gJ1snICYmICFwYXJzZXJJbnB1dC5wcmV2Q2hhcigpLm1hdGNoKC9eXFxzLykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIG1heSBiZSBhIFZhcmlhYmxlQ2FsbCBsb29rdXBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gcGFyc2Vycy52YXJpYWJsZUNhbGwobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5mb3JnZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5mb3JnZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcodHJlZS5WYXJpYWJsZSkobmFtZSwgaW5kZXgsIGZpbGVJbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5yZXN0b3JlKCk7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIC8vIEEgdmFyaWFibGUgZW50aXR5IHVzaW5nIHRoZSBwcm90ZWN0aXZlIHt9IGUuZy4gQHt2YXJ9XG4gICAgICAgICAgICAgICAgdmFyaWFibGVDdXJseTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3VybHksIGluZGV4ID0gcGFyc2VySW5wdXQuaTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VySW5wdXQuY3VycmVudENoYXIoKSA9PT0gJ0AnICYmIChjdXJseSA9IHBhcnNlcklucHV0LiRyZSgvXkBcXHsoW1xcdy1dKylcXH0vKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcodHJlZS5WYXJpYWJsZSkoJ0AnICsgY3VybHlbMV0sIGluZGV4LCBmaWxlSW5mbyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gQSBQcm9wZXJ0eSBhY2Nlc3Nvciwgc3VjaCBhcyBgJGNvbG9yYCwgaW5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkY29sb3JcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIHByb3BlcnR5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuYW1lLCBpbmRleCA9IHBhcnNlcklucHV0Lmk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlcklucHV0LmN1cnJlbnRDaGFyKCkgPT09ICckJyAmJiAobmFtZSA9IHBhcnNlcklucHV0LiRyZSgvXlxcJFtcXHctXSsvKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcodHJlZS5Qcm9wZXJ0eSkobmFtZSwgaW5kZXgsIGZpbGVJbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAvLyBBIHByb3BlcnR5IGVudGl0eSB1c2VpbmcgdGhlIHByb3RlY3RpdmUge30gZS5nLiAke3Byb3B9XG4gICAgICAgICAgICAgICAgcHJvcGVydHlDdXJseTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3VybHksIGluZGV4ID0gcGFyc2VySW5wdXQuaTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VySW5wdXQuY3VycmVudENoYXIoKSA9PT0gJyQnICYmIChjdXJseSA9IHBhcnNlcklucHV0LiRyZSgvXlxcJFxceyhbXFx3LV0rKVxcfS8pKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyh0cmVlLlByb3BlcnR5KSgnJCcgKyBjdXJseVsxXSwgaW5kZXgsIGZpbGVJbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBBIEhleGFkZWNpbWFsIGNvbG9yXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyAgICAgIzRGM0MyRlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gYHJnYmAgYW5kIGBoc2xgIGNvbG9ycyBhcmUgcGFyc2VkIHRocm91Z2ggdGhlIGBlbnRpdGllcy5jYWxsYCBwYXJzZXIuXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICBjb2xvcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmdiO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXJJbnB1dC5jdXJyZW50Q2hhcigpID09PSAnIycgJiYgKHJnYiA9IHBhcnNlcklucHV0LiRyZSgvXiMoW0EtRmEtZjAtOV17OH18W0EtRmEtZjAtOV17Nn18W0EtRmEtZjAtOV17Myw0fSkvKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcodHJlZS5Db2xvcikocmdiWzFdLCB1bmRlZmluZWQsIHJnYlswXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgY29sb3JLZXl3b3JkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnNhdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGF1dG9Db21tZW50QWJzb3JiID0gcGFyc2VySW5wdXQuYXV0b0NvbW1lbnRBYnNvcmI7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmF1dG9Db21tZW50QWJzb3JiID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrID0gcGFyc2VySW5wdXQuJHJlKC9eW19BLVphLXotXVtfQS1aYS16MC05LV0rLyk7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmF1dG9Db21tZW50QWJzb3JiID0gYXV0b0NvbW1lbnRBYnNvcmI7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuZm9yZ2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29sb3IgPSB0cmVlLkNvbG9yLmZyb21LZXl3b3JkKGspO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29sb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LiRzdHIoayk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29sb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBBIERpbWVuc2lvbiwgdGhhdCBpcywgYSBudW1iZXIgYW5kIGEgdW5pdFxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gICAgIDAuNWVtIDk1JVxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgZGltZW5zaW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXJJbnB1dC5wZWVrTm90TnVtZXJpYygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBwYXJzZXJJbnB1dC4kcmUoL14oWystXT9cXGQqXFwuP1xcZCspKCV8W2Etel9dKyk/L2kpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcodHJlZS5EaW1lbnNpb24pKHZhbHVlWzFdLCB2YWx1ZVsyXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBBIHVuaWNvZGUgZGVzY3JpcHRvciwgYXMgaXMgdXNlZCBpbiB1bmljb2RlLXJhbmdlXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBVKzA/PyAgb3IgVSswMEExLTAwQTlcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIHVuaWNvZGVEZXNjcmlwdG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB1ZDtcblxuICAgICAgICAgICAgICAgICAgICB1ZCA9IHBhcnNlcklucHV0LiRyZSgvXlVcXCtbMC05YS1mQS1GP10rKFxcLVswLTlhLWZBLUY/XSspPy8pO1xuICAgICAgICAgICAgICAgICAgICBpZiAodWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcodHJlZS5Vbmljb2RlRGVzY3JpcHRvcikodWRbMF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gSmF2YVNjcmlwdCBjb2RlIHRvIGJlIGV2YWx1YXRlZFxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gICAgIGB3aW5kb3cubG9jYXRpb24uaHJlZmBcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIGphdmFzY3JpcHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGpzLCBpbmRleCA9IHBhcnNlcklucHV0Lmk7XG5cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuc2F2ZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBlc2NhcGUgPSBwYXJzZXJJbnB1dC4kY2hhcignficpO1xuICAgICAgICAgICAgICAgICAgICB2YXIganNRdW90ZSA9IHBhcnNlcklucHV0LiRjaGFyKCdgJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFqc1F1b3RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5yZXN0b3JlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBqcyA9IHBhcnNlcklucHV0LiRyZSgvXlteYF0qYC8pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoanMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmZvcmdldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyh0cmVlLkphdmFTY3JpcHQpKGpzLnN1YnN0cigwLCBqcy5sZW5ndGggLSAxKSwgQm9vbGVhbihlc2NhcGUpLCBpbmRleCwgZmlsZUluZm8pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnJlc3RvcmUoJ2ludmFsaWQgamF2YXNjcmlwdCBkZWZpbml0aW9uJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFRoZSB2YXJpYWJsZSBwYXJ0IG9mIGEgdmFyaWFibGUgZGVmaW5pdGlvbi4gVXNlZCBpbiB0aGUgYHJ1bGVgIHBhcnNlclxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vICAgICBAZmluazpcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICB2YXJpYWJsZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBuYW1lO1xuXG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlcklucHV0LmN1cnJlbnRDaGFyKCkgPT09ICdAJyAmJiAobmFtZSA9IHBhcnNlcklucHV0LiRyZSgvXihAW1xcdy1dKylcXHMqOi8pKSkgeyByZXR1cm4gbmFtZVsxXTsgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIENhbGwgYSB2YXJpYWJsZSB2YWx1ZSB0byByZXRyaWV2ZSBhIGRldGFjaGVkIHJ1bGVzZXRcbiAgICAgICAgICAgIC8vIG9yIGEgdmFsdWUgZnJvbSBhIGRldGFjaGVkIHJ1bGVzZXQncyBydWxlcy5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyAgICAgQGZpbmsoKTtcbiAgICAgICAgICAgIC8vICAgICBAZmluaztcbiAgICAgICAgICAgIC8vICAgICBjb2xvcjogQGZpbmtbQGNvbG9yXTtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICB2YXJpYWJsZUNhbGw6IGZ1bmN0aW9uIChwYXJzZWROYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxvb2t1cHMsIGltcG9ydGFudCwgaSA9IHBhcnNlcklucHV0LmksXG4gICAgICAgICAgICAgICAgICAgIGluVmFsdWUgPSAhIXBhcnNlZE5hbWUsIG5hbWUgPSBwYXJzZWROYW1lO1xuXG4gICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuc2F2ZSgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG5hbWUgfHwgKHBhcnNlcklucHV0LmN1cnJlbnRDaGFyKCkgPT09ICdAJ1xuICAgICAgICAgICAgICAgICAgICAmJiAobmFtZSA9IHBhcnNlcklucHV0LiRyZSgvXihAW1xcdy1dKykoXFwoXFxzKlxcKSk/LykpKSkge1xuXG4gICAgICAgICAgICAgICAgICAgIGxvb2t1cHMgPSB0aGlzLm1peGluLnJ1bGVMb29rdXBzKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFsb29rdXBzICYmICgoaW5WYWx1ZSAmJiBwYXJzZXJJbnB1dC4kc3RyKCcoKScpICE9PSAnKCknKSB8fCAobmFtZVsyXSAhPT0gJygpJykpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5yZXN0b3JlKCdNaXNzaW5nIFxcJ1suLi5dXFwnIGxvb2t1cCBpbiB2YXJpYWJsZSBjYWxsJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWluVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lWzFdO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvb2t1cHMgJiYgcGFyc2Vycy5pbXBvcnRhbnQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW1wb3J0YW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBjYWxsID0gbmV3IHRyZWUuVmFyaWFibGVDYWxsKG5hbWUsIGksIGZpbGVJbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpblZhbHVlICYmIHBhcnNlcnMuZW5kKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmZvcmdldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5mb3JnZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdHJlZS5OYW1lc3BhY2VWYWx1ZShjYWxsLCBsb29rdXBzLCBpbXBvcnRhbnQsIGksIGZpbGVJbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnJlc3RvcmUoKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBleHRlbmQgc3ludGF4IC0gdXNlZCB0byBleHRlbmQgc2VsZWN0b3JzXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgZXh0ZW5kOiBmdW5jdGlvbihpc1J1bGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudHMsIGUsIGluZGV4ID0gcGFyc2VySW5wdXQuaSwgb3B0aW9uLCBleHRlbmRMaXN0LCBleHRlbmQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXBhcnNlcklucHV0LiRzdHIoaXNSdWxlID8gJyY6ZXh0ZW5kKCcgOiAnOmV4dGVuZCgnKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb24gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50cyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICghKG9wdGlvbiA9IHBhcnNlcklucHV0LiRyZSgvXihhbGwpKD89XFxzKihcXCl8LCkpLykpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlID0gdGhpcy5lbGVtZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2goZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzID0gWyBlIF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBvcHRpb24gPSBvcHRpb24gJiYgb3B0aW9uWzFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWVsZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcignTWlzc2luZyB0YXJnZXQgc2VsZWN0b3IgZm9yIDpleHRlbmQoKS4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBleHRlbmQgPSBuZXcodHJlZS5FeHRlbmQpKG5ldyh0cmVlLlNlbGVjdG9yKShlbGVtZW50cyksIG9wdGlvbiwgaW5kZXgsIGZpbGVJbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4dGVuZExpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuZExpc3QucHVzaChleHRlbmQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5kTGlzdCA9IFsgZXh0ZW5kIF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IHdoaWxlIChwYXJzZXJJbnB1dC4kY2hhcignLCcpKTtcblxuICAgICAgICAgICAgICAgIGV4cGVjdCgvXlxcKS8pO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzUnVsZSkge1xuICAgICAgICAgICAgICAgICAgICBleHBlY3QoL147Lyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4dGVuZExpc3Q7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gZXh0ZW5kUnVsZSAtIHVzZWQgaW4gYSBydWxlIHRvIGV4dGVuZCBhbGwgdGhlIHBhcmVudCBzZWxlY3RvcnNcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICBleHRlbmRSdWxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5leHRlbmQodHJ1ZSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gTWl4aW5zXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgbWl4aW46IHtcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIEEgTWl4aW4gY2FsbCwgd2l0aCBhbiBvcHRpb25hbCBhcmd1bWVudCBsaXN0XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyAgICAgI21peGlucyA+IC5zcXVhcmUoI2ZmZik7XG4gICAgICAgICAgICAgICAgLy8gICAgICNtaXhpbnMuc3F1YXJlKCNmZmYpO1xuICAgICAgICAgICAgICAgIC8vICAgICAucm91bmRlZCg0cHgsIGJsYWNrKTtcbiAgICAgICAgICAgICAgICAvLyAgICAgLmJ1dHRvbjtcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIFdlIGNhbiBsb29rdXAgLyByZXR1cm4gYSB2YWx1ZSB1c2luZyB0aGUgbG9va3VwIHN5bnRheDpcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vICAgICBjb2xvcjogI21peGluLnNxdWFyZSgjZmZmKVtAY29sb3JdO1xuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gVGhlIGB3aGlsZWAgbG9vcCBpcyB0aGVyZSBiZWNhdXNlIG1peGlucyBjYW4gYmVcbiAgICAgICAgICAgICAgICAvLyBuYW1lc3BhY2VkLCBidXQgd2Ugb25seSBzdXBwb3J0IHRoZSBjaGlsZCBhbmQgZGVzY2VuZGFudFxuICAgICAgICAgICAgICAgIC8vIHNlbGVjdG9yIGZvciBub3cuXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICBjYWxsOiBmdW5jdGlvbiAoaW5WYWx1ZSwgZ2V0TG9va3VwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzID0gcGFyc2VySW5wdXQuY3VycmVudENoYXIoKSwgaW1wb3J0YW50ID0gZmFsc2UsIGxvb2t1cHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHBhcnNlcklucHV0LmksIGVsZW1lbnRzLCBhcmdzLCBoYXNQYXJlbnM7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHMgIT09ICcuJyAmJiBzICE9PSAnIycpIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuc2F2ZSgpOyAvLyBzdG9wIHVzIGFic29yYmluZyBwYXJ0IG9mIGFuIGludmFsaWQgc2VsZWN0b3JcblxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50cyA9IHRoaXMuZWxlbWVudHMoKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXJJbnB1dC4kY2hhcignKCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncyA9IHRoaXMuYXJncyh0cnVlKS5hcmdzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdENoYXIoJyknKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNQYXJlbnMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ2V0TG9va3VwICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvb2t1cHMgPSB0aGlzLnJ1bGVMb29rdXBzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ2V0TG9va3VwID09PSB0cnVlICYmICFsb29rdXBzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluVmFsdWUgJiYgIWxvb2t1cHMgJiYgIWhhc1BhcmVucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXNuJ3QgYSB2YWxpZCBpbi12YWx1ZSBtaXhpbiBjYWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpblZhbHVlICYmIHBhcnNlcnMuaW1wb3J0YW50KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbXBvcnRhbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5WYWx1ZSB8fCBwYXJzZXJzLmVuZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuZm9yZ2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1peGluID0gbmV3KHRyZWUubWl4aW4uQ2FsbCkoZWxlbWVudHMsIGFyZ3MsIGluZGV4LCBmaWxlSW5mbywgIWxvb2t1cHMgJiYgaW1wb3J0YW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9va3Vwcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHRyZWUuTmFtZXNwYWNlVmFsdWUobWl4aW4sIGxvb2t1cHMsIGltcG9ydGFudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWl4aW47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogTWF0Y2hpbmcgZWxlbWVudHMgZm9yIG1peGluc1xuICAgICAgICAgICAgICAgICAqIChTdGFydCB3aXRoIC4gb3IgIyBhbmQgY2FuIGhhdmUgPiApXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZWxlbWVudHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbWVudHMsIGUsIGMsIGVsZW0sIGVsZW1JbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlID0gL15bIy5dKD86W1xcdy1dfFxcXFwoPzpbQS1GYS1mMC05XXsxLDZ9ID98W15BLUZhLWYwLTldKSkrLztcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1JbmRleCA9IHBhcnNlcklucHV0Lmk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlID0gcGFyc2VySW5wdXQuJHJlKHJlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtID0gbmV3KHRyZWUuRWxlbWVudCkoYywgZSwgZmFsc2UsIGVsZW1JbmRleCwgZmlsZUluZm8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaChlbGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMgPSBbIGVsZW0gXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGMgPSBwYXJzZXJJbnB1dC4kY2hhcignPicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50cztcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGFyZ3M6IGZ1bmN0aW9uIChpc0NhbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVudGl0aWVzID0gcGFyc2Vycy5lbnRpdGllcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybmVyID0geyBhcmdzOm51bGwsIHZhcmlhZGljOiBmYWxzZSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbnMgPSBbXSwgYXJnc1NlbWlDb2xvbiA9IFtdLCBhcmdzQ29tbWEgPSBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzU2VtaUNvbG9uU2VwYXJhdGVkLCBleHByZXNzaW9uQ29udGFpbnNOYW1lZCwgbmFtZSwgbmFtZUxvb3AsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSwgYXJnLCBleHBhbmQsIGhhc1NlcCA9IHRydWU7IFxuXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnNhdmUoKTtcblxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ2FsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZyA9IHBhcnNlcnMuZGV0YWNoZWRSdWxlc2V0KCkgfHwgcGFyc2Vycy5leHByZXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmNvbW1lbnRTdG9yZS5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXJJbnB1dC4kc3RyKCcuLi4nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5lci52YXJpYWRpYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXJJbnB1dC4kY2hhcignOycpICYmICFpc1NlbWlDb2xvblNlcGFyYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNTZW1pQ29sb25TZXBhcmF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChpc1NlbWlDb2xvblNlcGFyYXRlZCA/IGFyZ3NTZW1pQ29sb24gOiBhcmdzQ29tbWEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucHVzaCh7IHZhcmlhZGljOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnID0gZW50aXRpZXMudmFyaWFibGUoKSB8fCBlbnRpdGllcy5wcm9wZXJ0eSgpIHx8IGVudGl0aWVzLmxpdGVyYWwoKSB8fCBlbnRpdGllcy5rZXl3b3JkKCkgfHwgdGhpcy5jYWxsKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWFyZyB8fCAhaGFzU2VwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVMb29wID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcmcudGhyb3dBd2F5Q29tbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmcudGhyb3dBd2F5Q29tbWVudHMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gYXJnO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0NhbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBWYXJpYWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcmcudmFsdWUgJiYgYXJnLnZhbHVlLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IGFyZy52YWx1ZVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IGFyZztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbCAmJiAodmFsIGluc3RhbmNlb2YgdHJlZS5WYXJpYWJsZSB8fCB2YWwgaW5zdGFuY2VvZiB0cmVlLlByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXJJbnB1dC4kY2hhcignOicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHByZXNzaW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNTZW1pQ29sb25TZXBhcmF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcignQ2Fubm90IG1peCA7IGFuZCAsIGFzIGRlbGltaXRlciB0eXBlcycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbkNvbnRhaW5zTmFtZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZXJzLmRldGFjaGVkUnVsZXNldCgpIHx8IHBhcnNlcnMuZXhwcmVzc2lvbigpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0NhbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcignY291bGQgbm90IHVuZGVyc3RhbmQgdmFsdWUgZm9yIG5hbWVkIGFyZ3VtZW50Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5lci5hcmdzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldHVybmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVMb29wID0gKG5hbWUgPSB2YWwubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJzZXJJbnB1dC4kc3RyKCcuLi4nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzQ2FsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuZXIudmFyaWFkaWMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlcklucHV0LiRjaGFyKCc7JykgJiYgIWlzU2VtaUNvbG9uU2VwYXJhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNTZW1pQ29sb25TZXBhcmF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGlzU2VtaUNvbG9uU2VwYXJhdGVkID8gYXJnc1NlbWlDb2xvbiA6IGFyZ3NDb21tYSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucHVzaCh7IG5hbWU6IGFyZy5uYW1lLCB2YXJpYWRpYzogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwYW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWlzQ2FsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lID0gbmFtZUxvb3AgPSB2YWwubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbnMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3NDb21tYS5wdXNoKHsgbmFtZTpuYW1lTG9vcCwgdmFsdWU6dmFsdWUsIGV4cGFuZDpleHBhbmQgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXJJbnB1dC4kY2hhcignLCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzU2VwID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc1NlcCA9IHBhcnNlcklucHV0LiRjaGFyKCc7JykgPT09ICc7JztcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc1NlcCB8fCBpc1NlbWlDb2xvblNlcGFyYXRlZCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4cHJlc3Npb25Db250YWluc05hbWVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yKCdDYW5ub3QgbWl4IDsgYW5kICwgYXMgZGVsaW1pdGVyIHR5cGVzJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNTZW1pQ29sb25TZXBhcmF0ZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4cHJlc3Npb25zLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcodHJlZS5WYWx1ZSkoZXhwcmVzc2lvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzU2VtaUNvbG9uLnB1c2goeyBuYW1lOm5hbWUsIHZhbHVlOnZhbHVlLCBleHBhbmQ6ZXhwYW5kIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uQ29udGFpbnNOYW1lZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuZm9yZ2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybmVyLmFyZ3MgPSBpc1NlbWlDb2xvblNlcGFyYXRlZCA/IGFyZ3NTZW1pQ29sb24gOiBhcmdzQ29tbWE7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXR1cm5lcjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gQSBNaXhpbiBkZWZpbml0aW9uLCB3aXRoIGEgbGlzdCBvZiBwYXJhbWV0ZXJzXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyAgICAgLnJvdW5kZWQgKEByYWRpdXM6IDJweCwgQGNvbG9yKSB7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgIC4uLlxuICAgICAgICAgICAgICAgIC8vICAgICB9XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBVbnRpbCB3ZSBoYXZlIGEgZmluZXIgZ3JhaW5lZCBzdGF0ZS1tYWNoaW5lLCB3ZSBoYXZlIHRvXG4gICAgICAgICAgICAgICAgLy8gZG8gYSBsb29rLWFoZWFkLCB0byBtYWtlIHN1cmUgd2UgZG9uJ3QgaGF2ZSBhIG1peGluIGNhbGwuXG4gICAgICAgICAgICAgICAgLy8gU2VlIHRoZSBgcnVsZWAgZnVuY3Rpb24gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBXZSBzdGFydCBieSBtYXRjaGluZyBgLnJvdW5kZWQgKGAsIGFuZCB0aGVuIHByb2NlZWQgb24gdG9cbiAgICAgICAgICAgICAgICAvLyB0aGUgYXJndW1lbnQgbGlzdCwgd2hpY2ggaGFzIG9wdGlvbmFsIGRlZmF1bHQgdmFsdWVzLlxuICAgICAgICAgICAgICAgIC8vIFdlIHN0b3JlIHRoZSBwYXJhbWV0ZXJzIGluIGBwYXJhbXNgLCB3aXRoIGEgYHZhbHVlYCBrZXksXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgYSB2YWx1ZSwgc3VjaCBhcyBpbiB0aGUgY2FzZSBvZiBgQHJhZGl1c2AuXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBPbmNlIHdlJ3ZlIGdvdCBvdXIgcGFyYW1zIGxpc3QsIGFuZCBhIGNsb3NpbmcgYClgLCB3ZSBwYXJzZVxuICAgICAgICAgICAgICAgIC8vIHRoZSBgey4uLn1gIGJsb2NrLlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgZGVmaW5pdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSwgcGFyYW1zID0gW10sIG1hdGNoLCBydWxlc2V0LCBjb25kLCB2YXJpYWRpYyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHBhcnNlcklucHV0LmN1cnJlbnRDaGFyKCkgIT09ICcuJyAmJiBwYXJzZXJJbnB1dC5jdXJyZW50Q2hhcigpICE9PSAnIycpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5wZWVrKC9eW157XSpcXH0vKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuc2F2ZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoID0gcGFyc2VySW5wdXQuJHJlKC9eKFsjLl0oPzpbXFx3LV18XFxcXCg/OltBLUZhLWYwLTldezEsNn0gP3xbXkEtRmEtZjAtOV0pKSspXFxzKlxcKC8pO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPSBtYXRjaFsxXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ0luZm8gPSB0aGlzLmFyZ3MoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0gYXJnSW5mby5hcmdzO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyaWFkaWMgPSBhcmdJbmZvLnZhcmlhZGljO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAubWl4aW5jYWxsKFwiQHthfVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxvb2tzIGEgYml0IGxpa2UgYSBtaXhpbiBkZWZpbml0aW9uLi5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFsc29cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIC5taXhpbmNhbGwoQGE6IHtydWxlOiBzZXQ7fSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzbyB3ZSBoYXZlIHRvIGJlIG5pY2UgYW5kIHJlc3RvcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcGFyc2VySW5wdXQuJGNoYXIoJyknKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnJlc3RvcmUoJ01pc3NpbmcgY2xvc2luZyBcXCcpXFwnJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5jb21tZW50U3RvcmUubGVuZ3RoID0gMDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlcklucHV0LiRzdHIoJ3doZW4nKSkgeyAvLyBHdWFyZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmQgPSBleHBlY3QocGFyc2Vycy5jb25kaXRpb25zLCAnZXhwZWN0ZWQgY29uZGl0aW9uJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGVzZXQgPSBwYXJzZXJzLmJsb2NrKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChydWxlc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuZm9yZ2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyh0cmVlLm1peGluLkRlZmluaXRpb24pKG5hbWUsIHBhcmFtcywgcnVsZXNldCwgY29uZCwgdmFyaWFkaWMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5yZXN0b3JlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5mb3JnZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBydWxlTG9va3VwczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBydWxlLCBhcmdzLCBsb29rdXBzID0gW107XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlcklucHV0LmN1cnJlbnRDaGFyKCkgIT09ICdbJykgeyBcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnNhdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZSA9IHRoaXMubG9va3VwVmFsdWUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcnVsZSAmJiBydWxlICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxvb2t1cHMucHVzaChydWxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmZvcmdldCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChsb29rdXBzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsb29rdXBzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICBcbiAgICAgICAgICAgICAgICBsb29rdXBWYWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnNhdmUoKTtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJzZXJJbnB1dC4kY2hhcignWycpKSB7IFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gcGFyc2VySW5wdXQuJHJlKC9eKD86W0AkXXswLDJ9KVtfYS16QS1aMC05LV0qLyk7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIGlmICghcGFyc2VySW5wdXQuJGNoYXIoJ10nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9IFxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChuYW1lIHx8IG5hbWUgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5mb3JnZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIEVudGl0aWVzIGFyZSB0aGUgc21hbGxlc3QgcmVjb2duaXplZCB0b2tlbixcbiAgICAgICAgICAgIC8vIGFuZCBjYW4gYmUgZm91bmQgaW5zaWRlIGEgcnVsZSdzIHZhbHVlLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIGVudGl0eTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBlbnRpdGllcyA9IHRoaXMuZW50aXRpZXM7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb21tZW50KCkgfHwgZW50aXRpZXMubGl0ZXJhbCgpIHx8IGVudGl0aWVzLnZhcmlhYmxlKCkgfHwgZW50aXRpZXMudXJsKCkgfHxcbiAgICAgICAgICAgICAgICAgICAgZW50aXRpZXMucHJvcGVydHkoKSB8fCBlbnRpdGllcy5jYWxsKCkgfHwgZW50aXRpZXMua2V5d29yZCgpIHx8IHRoaXMubWl4aW4uY2FsbCh0cnVlKSB8fFxuICAgICAgICAgICAgICAgICAgICBlbnRpdGllcy5qYXZhc2NyaXB0KCk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gQSBEZWNsYXJhdGlvbiB0ZXJtaW5hdG9yLiBOb3RlIHRoYXQgd2UgdXNlIGBwZWVrKClgIHRvIGNoZWNrIGZvciAnfScsXG4gICAgICAgICAgICAvLyBiZWNhdXNlIHRoZSBgYmxvY2tgIHJ1bGUgd2lsbCBiZSBleHBlY3RpbmcgaXQsIGJ1dCB3ZSBzdGlsbCBuZWVkIHRvIG1ha2Ugc3VyZVxuICAgICAgICAgICAgLy8gaXQncyB0aGVyZSwgaWYgJzsnIHdhcyBvbWl0dGVkLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIGVuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZXJJbnB1dC4kY2hhcignOycpIHx8IHBhcnNlcklucHV0LnBlZWsoJ30nKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBJRSdzIGFscGhhIGZ1bmN0aW9uXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gICAgIGFscGhhKG9wYWNpdHk9ODgpXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgaWVBbHBoYTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZTtcblxuICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly9qc3BlcmYuY29tL2Nhc2UtaW5zZW5zaXRpdmUtcmVnZXgtdnMtc3RydG9sb3dlci10aGVuLXJlZ2V4LzE4XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJzZXJJbnB1dC4kcmUoL15vcGFjaXR5PS9pKSkgeyByZXR1cm47IH1cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlcklucHV0LiRyZSgvXlxcZCsvKTtcbiAgICAgICAgICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZXhwZWN0KHBhcnNlcnMuZW50aXRpZXMudmFyaWFibGUsICdDb3VsZCBub3QgcGFyc2UgYWxwaGEnKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAnQHsnICsgdmFsdWUubmFtZS5zbGljZSgxKSArICd9JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXhwZWN0Q2hhcignKScpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdHJlZS5RdW90ZWQoJycsICdhbHBoYShvcGFjaXR5PScgKyB2YWx1ZSArICcpJyk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gQSBTZWxlY3RvciBFbGVtZW50XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gICAgIGRpdlxuICAgICAgICAgICAgLy8gICAgICsgaDFcbiAgICAgICAgICAgIC8vICAgICAjc29ja3NcbiAgICAgICAgICAgIC8vICAgICBpbnB1dFt0eXBlPVwidGV4dFwiXVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIEVsZW1lbnRzIGFyZSB0aGUgYnVpbGRpbmcgYmxvY2tzIGZvciBTZWxlY3RvcnMsXG4gICAgICAgICAgICAvLyB0aGV5IGFyZSBtYWRlIG91dCBvZiBhIGBDb21iaW5hdG9yYCAoc2VlIGNvbWJpbmF0b3IgcnVsZSksXG4gICAgICAgICAgICAvLyBhbmQgYW4gZWxlbWVudCBuYW1lLCBzdWNoIGFzIGEgdGFnIGEgY2xhc3MsIG9yIGAqYC5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICBlbGVtZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGUsIGMsIHYsIGluZGV4ID0gcGFyc2VySW5wdXQuaTtcblxuICAgICAgICAgICAgICAgIGMgPSB0aGlzLmNvbWJpbmF0b3IoKTtcblxuICAgICAgICAgICAgICAgIGUgPSBwYXJzZXJJbnB1dC4kcmUoL14oPzpcXGQrXFwuXFxkK3xcXGQrKSUvKSB8fFxuICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC4kcmUoL14oPzpbLiNdP3w6KikoPzpbXFx3LV18W15cXHgwMC1cXHg5Zl18XFxcXCg/OltBLUZhLWYwLTldezEsNn0gP3xbXkEtRmEtZjAtOV0pKSsvKSB8fFxuICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC4kY2hhcignKicpIHx8IHBhcnNlcklucHV0LiRjaGFyKCcmJykgfHwgdGhpcy5hdHRyaWJ1dGUoKSB8fFxuICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC4kcmUoL15cXChbXiYoKUBdK1xcKS8pIHx8ICBwYXJzZXJJbnB1dC4kcmUoL15bXFwuIzpdKD89QCkvKSB8fFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVudGl0aWVzLnZhcmlhYmxlQ3VybHkoKTtcblxuICAgICAgICAgICAgICAgIGlmICghZSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXJJbnB1dC4kY2hhcignKCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHYgPSB0aGlzLnNlbGVjdG9yKGZhbHNlKSkgJiYgcGFyc2VySW5wdXQuJGNoYXIoJyknKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUgPSBuZXcodHJlZS5QYXJlbikodik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuZm9yZ2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnJlc3RvcmUoJ01pc3NpbmcgY2xvc2luZyBcXCcpXFwnJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5mb3JnZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChlKSB7IHJldHVybiBuZXcodHJlZS5FbGVtZW50KShjLCBlLCBlIGluc3RhbmNlb2YgdHJlZS5WYXJpYWJsZSwgaW5kZXgsIGZpbGVJbmZvKTsgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIENvbWJpbmF0b3JzIGNvbWJpbmUgZWxlbWVudHMgdG9nZXRoZXIsIGluIGEgU2VsZWN0b3IuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gQmVjYXVzZSBvdXIgcGFyc2VyIGlzbid0IHdoaXRlLXNwYWNlIHNlbnNpdGl2ZSwgc3BlY2lhbCBjYXJlXG4gICAgICAgICAgICAvLyBoYXMgdG8gYmUgdGFrZW4sIHdoZW4gcGFyc2luZyB0aGUgZGVzY2VuZGFudCBjb21iaW5hdG9yLCBgIGAsXG4gICAgICAgICAgICAvLyBhcyBpdCdzIGFuIGVtcHR5IHNwYWNlLiBXZSBoYXZlIHRvIGNoZWNrIHRoZSBwcmV2aW91cyBjaGFyYWN0ZXJcbiAgICAgICAgICAgIC8vIGluIHRoZSBpbnB1dCwgdG8gc2VlIGlmIGl0J3MgYSBgIGAgY2hhcmFjdGVyLiBNb3JlIGluZm8gb24gaG93XG4gICAgICAgICAgICAvLyB3ZSBkZWFsIHdpdGggdGhpcyBpbiAqY29tYmluYXRvci5qcyouXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgY29tYmluYXRvcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBjID0gcGFyc2VySW5wdXQuY3VycmVudENoYXIoKTtcblxuICAgICAgICAgICAgICAgIGlmIChjID09PSAnLycpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuc2F2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2xhc2hlZENvbWJpbmF0b3IgPSBwYXJzZXJJbnB1dC4kcmUoL15cXC9bYS16XStcXC8vaSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzbGFzaGVkQ29tYmluYXRvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuZm9yZ2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3KHRyZWUuQ29tYmluYXRvcikoc2xhc2hlZENvbWJpbmF0b3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoYyA9PT0gJz4nIHx8IGMgPT09ICcrJyB8fCBjID09PSAnficgfHwgYyA9PT0gJ3wnIHx8IGMgPT09ICdeJykge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5pKys7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjID09PSAnXicgJiYgcGFyc2VySW5wdXQuY3VycmVudENoYXIoKSA9PT0gJ14nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjID0gJ15eJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmkrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAocGFyc2VySW5wdXQuaXNXaGl0ZXNwYWNlKCkpIHsgcGFyc2VySW5wdXQuaSsrOyB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcodHJlZS5Db21iaW5hdG9yKShjKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBhcnNlcklucHV0LmlzV2hpdGVzcGFjZSgtMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyh0cmVlLkNvbWJpbmF0b3IpKCcgJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyh0cmVlLkNvbWJpbmF0b3IpKG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gQSBDU1MgU2VsZWN0b3JcbiAgICAgICAgICAgIC8vIHdpdGggbGVzcyBleHRlbnNpb25zIGUuZy4gdGhlIGFiaWxpdHkgdG8gZXh0ZW5kIGFuZCBndWFyZFxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vICAgICAuY2xhc3MgPiBkaXYgKyBoMVxuICAgICAgICAgICAgLy8gICAgIGxpIGE6aG92ZXJcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBTZWxlY3RvcnMgYXJlIG1hZGUgb3V0IG9mIG9uZSBvciBtb3JlIEVsZW1lbnRzLCBzZWUgYWJvdmUuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgc2VsZWN0b3I6IGZ1bmN0aW9uIChpc0xlc3MpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBwYXJzZXJJbnB1dC5pLCBlbGVtZW50cywgZXh0ZW5kTGlzdCwgYywgZSwgYWxsRXh0ZW5kcywgd2hlbiwgY29uZGl0aW9uO1xuICAgICAgICAgICAgICAgIGlzTGVzcyA9IGlzTGVzcyAhPT0gZmFsc2U7XG4gICAgICAgICAgICAgICAgd2hpbGUgKChpc0xlc3MgJiYgKGV4dGVuZExpc3QgPSB0aGlzLmV4dGVuZCgpKSkgfHwgKGlzTGVzcyAmJiAod2hlbiA9IHBhcnNlcklucHV0LiRzdHIoJ3doZW4nKSkpIHx8IChlID0gdGhpcy5lbGVtZW50KCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh3aGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25kaXRpb24gPSBleHBlY3QodGhpcy5jb25kaXRpb25zLCAnZXhwZWN0ZWQgY29uZGl0aW9uJyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29uZGl0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcignQ1NTIGd1YXJkIGNhbiBvbmx5IGJlIHVzZWQgYXQgdGhlIGVuZCBvZiBzZWxlY3RvcicpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGV4dGVuZExpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbGxFeHRlbmRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsRXh0ZW5kcyA9IGFsbEV4dGVuZHMuY29uY2F0KGV4dGVuZExpc3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxFeHRlbmRzID0gZXh0ZW5kTGlzdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbGxFeHRlbmRzKSB7IGVycm9yKCdFeHRlbmQgY2FuIG9ubHkgYmUgdXNlZCBhdCB0aGUgZW5kIG9mIHNlbGVjdG9yJyk7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGMgPSBwYXJzZXJJbnB1dC5jdXJyZW50Q2hhcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaChlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMgPSBbIGUgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjID09PSAneycgfHwgYyA9PT0gJ30nIHx8IGMgPT09ICc7JyB8fCBjID09PSAnLCcgfHwgYyA9PT0gJyknKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50cykgeyByZXR1cm4gbmV3KHRyZWUuU2VsZWN0b3IpKGVsZW1lbnRzLCBhbGxFeHRlbmRzLCBjb25kaXRpb24sIGluZGV4LCBmaWxlSW5mbyk7IH1cbiAgICAgICAgICAgICAgICBpZiAoYWxsRXh0ZW5kcykgeyBlcnJvcignRXh0ZW5kIG11c3QgYmUgdXNlZCB0byBleHRlbmQgYSBzZWxlY3RvciwgaXQgY2Fubm90IGJlIHVzZWQgb24gaXRzIG93bicpOyB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2VsZWN0b3JzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHMsIHNlbGVjdG9ycztcbiAgICAgICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBzID0gdGhpcy5zZWxlY3RvcigpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3RvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9ycy5wdXNoKHMpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3JzID0gWyBzIF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuY29tbWVudFN0b3JlLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzLmNvbmRpdGlvbiAmJiBzZWxlY3RvcnMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IoXCJHdWFyZHMgYXJlIG9ubHkgY3VycmVudGx5IGFsbG93ZWQgb24gYSBzaW5nbGUgc2VsZWN0b3IuXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghcGFyc2VySW5wdXQuJGNoYXIoJywnKSkgeyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocy5jb25kaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yKFwiR3VhcmRzIGFyZSBvbmx5IGN1cnJlbnRseSBhbGxvd2VkIG9uIGEgc2luZ2xlIHNlbGVjdG9yLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5jb21tZW50U3RvcmUubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGVjdG9ycztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhdHRyaWJ1dGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXBhcnNlcklucHV0LiRjaGFyKCdbJykpIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgICAgICAgICB2YXIgZW50aXRpZXMgPSB0aGlzLmVudGl0aWVzLFxuICAgICAgICAgICAgICAgICAgICBrZXksIHZhbCwgb3A7XG5cbiAgICAgICAgICAgICAgICBpZiAoIShrZXkgPSBlbnRpdGllcy52YXJpYWJsZUN1cmx5KCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGtleSA9IGV4cGVjdCgvXig/OltfQS1aYS16MC05LVxcKl0qXFx8KT8oPzpbX0EtWmEtejAtOS1dfFxcXFwuKSsvKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBvcCA9IHBhcnNlcklucHV0LiRyZSgvXlt8fiokXl0/PS8pO1xuICAgICAgICAgICAgICAgIGlmIChvcCkge1xuICAgICAgICAgICAgICAgICAgICB2YWwgPSBlbnRpdGllcy5xdW90ZWQoKSB8fCBwYXJzZXJJbnB1dC4kcmUoL15bMC05XSslLykgfHwgcGFyc2VySW5wdXQuJHJlKC9eW1xcdy1dKy8pIHx8IGVudGl0aWVzLnZhcmlhYmxlQ3VybHkoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBleHBlY3RDaGFyKCddJyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3KHRyZWUuQXR0cmlidXRlKShrZXksIG9wLCB2YWwpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFRoZSBgYmxvY2tgIHJ1bGUgaXMgdXNlZCBieSBgcnVsZXNldGAgYW5kIGBtaXhpbi5kZWZpbml0aW9uYC5cbiAgICAgICAgICAgIC8vIEl0J3MgYSB3cmFwcGVyIGFyb3VuZCB0aGUgYHByaW1hcnlgIHJ1bGUsIHdpdGggYWRkZWQgYHt9YC5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICBibG9jazogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBjb250ZW50O1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZXJJbnB1dC4kY2hhcigneycpICYmIChjb250ZW50ID0gdGhpcy5wcmltYXJ5KCkpICYmIHBhcnNlcklucHV0LiRjaGFyKCd9JykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgYmxvY2tSdWxlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgYmxvY2sgPSB0aGlzLmJsb2NrKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoYmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2sgPSBuZXcgdHJlZS5SdWxlc2V0KG51bGwsIGJsb2NrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJsb2NrO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZGV0YWNoZWRSdWxlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJnSW5mbywgcGFyYW1zLCB2YXJpYWRpYztcblxuICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnNhdmUoKTtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VySW5wdXQuJHJlKC9eWy4jXVxcKC8pKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBEUiBhcmdzIGN1cnJlbnRseSBvbmx5IGltcGxlbWVudGVkIGZvciBlYWNoKCkgZnVuY3Rpb24sIGFuZCBub3QgXG4gICAgICAgICAgICAgICAgICAgICAqIHlldCBzZXR0YWJsZSBhcyBgQGRyOiAjKEBhcmcpIHt9YFxuICAgICAgICAgICAgICAgICAgICAgKiBUaGlzIHNob3VsZCBiZSBkb25lIHdoZW4gRFJzIGFyZSBtZXJnZWQgd2l0aCBtaXhpbnMuXG4gICAgICAgICAgICAgICAgICAgICAqIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2xlc3MvbGVzcy1tZXRhL2lzc3Vlcy8xNlxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgYXJnSW5mbyA9IHRoaXMubWl4aW4uYXJncyhmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcyA9IGFyZ0luZm8uYXJncztcbiAgICAgICAgICAgICAgICAgICAgdmFyaWFkaWMgPSBhcmdJbmZvLnZhcmlhZGljO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcnNlcklucHV0LiRjaGFyKCcpJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgYmxvY2tSdWxlc2V0ID0gdGhpcy5ibG9ja1J1bGVzZXQoKTtcbiAgICAgICAgICAgICAgICBpZiAoYmxvY2tSdWxlc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmZvcmdldCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHRyZWUubWl4aW4uRGVmaW5pdGlvbihudWxsLCBwYXJhbXMsIGJsb2NrUnVsZXNldCwgbnVsbCwgdmFyaWFkaWMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdHJlZS5EZXRhY2hlZFJ1bGVzZXQoYmxvY2tSdWxlc2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFyc2VySW5wdXQucmVzdG9yZSgpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIGRpdiwgLmNsYXNzLCBib2R5ID4gcCB7Li4ufVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIHJ1bGVzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZWN0b3JzLCBydWxlcywgZGVidWdJbmZvO1xuXG4gICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuc2F2ZSgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRleHQuZHVtcExpbmVOdW1iZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnSW5mbyA9IGdldERlYnVnSW5mbyhwYXJzZXJJbnB1dC5pKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzZWxlY3RvcnMgPSB0aGlzLnNlbGVjdG9ycygpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdG9ycyAmJiAocnVsZXMgPSB0aGlzLmJsb2NrKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmZvcmdldCgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcnVsZXNldCA9IG5ldyh0cmVlLlJ1bGVzZXQpKHNlbGVjdG9ycywgcnVsZXMsIGNvbnRleHQuc3RyaWN0SW1wb3J0cyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250ZXh0LmR1bXBMaW5lTnVtYmVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZXNldC5kZWJ1Z0luZm8gPSBkZWJ1Z0luZm87XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJ1bGVzZXQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWNsYXJhdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBuYW1lLCB2YWx1ZSwgaW5kZXggPSBwYXJzZXJJbnB1dC5pLCBoYXNEUixcbiAgICAgICAgICAgICAgICAgICAgYyA9IHBhcnNlcklucHV0LmN1cnJlbnRDaGFyKCksIGltcG9ydGFudCwgbWVyZ2UsIGlzVmFyaWFibGU7XG5cbiAgICAgICAgICAgICAgICBpZiAoYyA9PT0gJy4nIHx8IGMgPT09ICcjJyB8fCBjID09PSAnJicgfHwgYyA9PT0gJzonKSB7IHJldHVybjsgfVxuXG4gICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuc2F2ZSgpO1xuXG4gICAgICAgICAgICAgICAgbmFtZSA9IHRoaXMudmFyaWFibGUoKSB8fCB0aGlzLnJ1bGVQcm9wZXJ0eSgpO1xuICAgICAgICAgICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzVmFyaWFibGUgPSB0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZyc7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVmFyaWFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5kZXRhY2hlZFJ1bGVzZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc0RSID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmNvbW1lbnRTdG9yZS5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhIG5hbWUgcmV0dXJuZWQgYnkgdGhpcy5ydWxlUHJvcGVydHkoKSBpcyBhbHdheXMgYW4gYXJyYXkgb2YgdGhlIGZvcm06XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBbc3RyaW5nLTEsIC4uLiwgc3RyaW5nLW4sIFwiXCJdIG9yIFtzdHJpbmctMSwgLi4uLCBzdHJpbmctbiwgXCIrXCJdXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3aGVyZSBlYWNoIGl0ZW0gaXMgYSB0cmVlLktleXdvcmQgb3IgdHJlZS5WYXJpYWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVyZ2UgPSAhaXNWYXJpYWJsZSAmJiBuYW1lLmxlbmd0aCA+IDEgJiYgbmFtZS5wb3AoKS52YWx1ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ3VzdG9tIHByb3BlcnR5IHZhbHVlcyBnZXQgcGVybWlzc2l2ZSBwYXJzaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmFtZVswXS52YWx1ZSAmJiBuYW1lWzBdLnZhbHVlLnNsaWNlKDAsIDIpID09PSAnLS0nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnBlcm1pc3NpdmVWYWx1ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJ5IHRvIHN0b3JlIHZhbHVlcyBhcyBhbm9ueW1vdXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIG5lZWQgdGhlIHZhbHVlIGxhdGVyIHdlJ2xsIHJlLXBhcnNlIGl0IGluIHJ1bGVzZXQucGFyc2VWYWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmFub255bW91c1ZhbHVlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5mb3JnZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbm9ueW1vdXMgdmFsdWVzIGFic29yYiB0aGUgZW5kICc7JyB3aGljaCBpcyByZXF1aXJlZCBmb3IgdGhlbSB0byB3b3JrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyAodHJlZS5EZWNsYXJhdGlvbikobmFtZSwgdmFsdWUsIGZhbHNlLCBtZXJnZSwgaW5kZXgsIGZpbGVJbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy52YWx1ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbXBvcnRhbnQgPSB0aGlzLmltcG9ydGFudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc1ZhcmlhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXMgYSBsYXN0IHJlc29ydCwgdHJ5IHBlcm1pc3NpdmVWYWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5wZXJtaXNzaXZlVmFsdWUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAmJiAodGhpcy5lbmQoKSB8fCBoYXNEUikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmZvcmdldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyAodHJlZS5EZWNsYXJhdGlvbikobmFtZSwgdmFsdWUsIGltcG9ydGFudCwgbWVyZ2UsIGluZGV4LCBmaWxlSW5mbyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5yZXN0b3JlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5yZXN0b3JlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFub255bW91c1ZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gcGFyc2VySW5wdXQuaTtcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSBwYXJzZXJJbnB1dC4kcmUoL14oW14uI0BcXCQrXFwvJ1wiKmAoO3t9LV0qKTsvKTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyh0cmVlLkFub255bW91cykobWF0Y2hbMV0sIGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBVc2VkIGZvciBjdXN0b20gcHJvcGVydGllcywgYXQtcnVsZXMsIGFuZCB2YXJpYWJsZXMgKGFzIGZhbGxiYWNrKVxuICAgICAgICAgICAgICogUGFyc2VzIGFsbW9zdCBhbnl0aGluZyBpbnNpZGUgb2Yge30gW10gKCkgXCJcIiBibG9ja3NcbiAgICAgICAgICAgICAqIHVudGlsIGl0IHJlYWNoZXMgb3V0ZXItbW9zdCB0b2tlbnMuXG4gICAgICAgICAgICAgKiBcbiAgICAgICAgICAgICAqIEZpcnN0LCBpdCB3aWxsIHRyeSB0byBwYXJzZSBjb21tZW50cyBhbmQgZW50aXRpZXMgdG8gcmVhY2hcbiAgICAgICAgICAgICAqIHRoZSBlbmQuIFRoaXMgaXMgbW9zdGx5IGxpa2UgdGhlIEV4cHJlc3Npb24gcGFyc2VyIGV4Y2VwdCBub1xuICAgICAgICAgICAgICogbWF0aCBpcyBhbGxvd2VkLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBwZXJtaXNzaXZlVmFsdWU6IGZ1bmN0aW9uICh1bnRpbFRva2Vucykge1xuICAgICAgICAgICAgICAgIHZhciBpLCBlLCBkb25lLCB2YWx1ZSwgXG4gICAgICAgICAgICAgICAgICAgIHRvayA9IHVudGlsVG9rZW5zIHx8ICc7JyxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBwYXJzZXJJbnB1dC5pLCByZXN1bHQgPSBbXTtcblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHRlc3RDdXJyZW50Q2hhcigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoYXIgPSBwYXJzZXJJbnB1dC5jdXJyZW50Q2hhcigpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRvayA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGFyID09PSB0b2s7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rLnRlc3QoY2hhcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRlc3RDdXJyZW50Q2hhcigpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBbXTtcbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIGUgPSB0aGlzLmNvbW1lbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLnB1c2goZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlID0gdGhpcy5lbnRpdHkoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLnB1c2goZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IHdoaWxlIChlKTtcblxuICAgICAgICAgICAgICAgIGRvbmUgPSB0ZXN0Q3VycmVudENoYXIoKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyh0cmVlLkV4cHJlc3Npb24pKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBQcmVzZXJ2ZSBzcGFjZSBiZWZvcmUgJHBhcnNlVW50aWwgYXMgaXQgd2lsbCBub3RcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlcklucHV0LnByZXZDaGFyKCkgPT09ICcgJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3IHRyZWUuQW5vbnltb3VzKCcgJywgaW5kZXgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZXJJbnB1dC4kcGFyc2VVbnRpbCh0b2spO1xuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcignRXhwZWN0ZWQgXFwnJyArIHZhbHVlICsgJ1xcJycsICdQYXJzZScpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDEgJiYgdmFsdWVbMF0gPT09ICcgJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuZm9yZ2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHRyZWUuQW5vbnltb3VzKCcnLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW07XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbSA9IHZhbHVlW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUcmVhdCBhY3R1YWwgcXVvdGVzIGFzIG5vcm1hbCBxdW90ZWQgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3IHRyZWUuUXVvdGVkKGl0ZW1bMF0sIGl0ZW1bMV0sIHRydWUsIGluZGV4LCBmaWxlSW5mbykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IHZhbHVlLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbSA9IGl0ZW0udHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUcmVhdCBsaWtlIHF1b3RlZCB2YWx1ZXMsIGJ1dCByZXBsYWNlIHZhcnMgbGlrZSB1bnF1b3RlZCBleHByZXNzaW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBxdW90ZSA9IG5ldyB0cmVlLlF1b3RlZCgnXFwnJywgaXRlbSwgdHJ1ZSwgaW5kZXgsIGZpbGVJbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdW90ZS52YXJpYWJsZVJlZ2V4ID0gL0AoW1xcdy1dKykvZztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdW90ZS5wcm9wUmVnZXggPSAvXFwkKFtcXHctXSspL2c7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gocXVvdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmZvcmdldCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHRyZWUuRXhwcmVzc2lvbihyZXN1bHQsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5yZXN0b3JlKCk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gQW4gQGltcG9ydCBhdHJ1bGVcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyAgICAgQGltcG9ydCBcImxpYlwiO1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIERlcGVuZGluZyBvbiBvdXIgZW52aXJvbm1lbnQsIGltcG9ydGluZyBpcyBkb25lIGRpZmZlcmVudGx5OlxuICAgICAgICAgICAgLy8gSW4gdGhlIGJyb3dzZXIsIGl0J3MgYW4gWEhSIHJlcXVlc3QsIGluIE5vZGUsIGl0IHdvdWxkIGJlIGFcbiAgICAgICAgICAgIC8vIGZpbGUtc3lzdGVtIG9wZXJhdGlvbi4gVGhlIGZ1bmN0aW9uIHVzZWQgZm9yIGltcG9ydGluZyBpc1xuICAgICAgICAgICAgLy8gc3RvcmVkIGluIGBpbXBvcnRgLCB3aGljaCB3ZSBwYXNzIHRvIHRoZSBJbXBvcnQgY29uc3RydWN0b3IuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgJ2ltcG9ydCc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGF0aCwgZmVhdHVyZXMsIGluZGV4ID0gcGFyc2VySW5wdXQuaTtcblxuICAgICAgICAgICAgICAgIHZhciBkaXIgPSBwYXJzZXJJbnB1dC4kcmUoL15AaW1wb3J0P1xccysvKTtcblxuICAgICAgICAgICAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSAoZGlyID8gdGhpcy5pbXBvcnRPcHRpb25zKCkgOiBudWxsKSB8fCB7fTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoKHBhdGggPSB0aGlzLmVudGl0aWVzLnF1b3RlZCgpIHx8IHRoaXMuZW50aXRpZXMudXJsKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmZWF0dXJlcyA9IHRoaXMubWVkaWFGZWF0dXJlcygpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcnNlcklucHV0LiRjaGFyKCc7JykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5pID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IoJ21pc3Npbmcgc2VtaS1jb2xvbiBvciB1bnJlY29nbmlzZWQgbWVkaWEgZmVhdHVyZXMgb24gaW1wb3J0Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmZWF0dXJlcyA9IGZlYXR1cmVzICYmIG5ldyh0cmVlLlZhbHVlKShmZWF0dXJlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3KHRyZWUuSW1wb3J0KShwYXRoLCBmZWF0dXJlcywgb3B0aW9ucywgaW5kZXgsIGZpbGVJbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmkgPSBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yKCdtYWxmb3JtZWQgaW1wb3J0IHN0YXRlbWVudCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgaW1wb3J0T3B0aW9uczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIG8sIG9wdGlvbnMgPSB7fSwgb3B0aW9uTmFtZSwgdmFsdWU7XG5cbiAgICAgICAgICAgICAgICAvLyBsaXN0IG9mIG9wdGlvbnMsIHN1cnJvdW5kZWQgYnkgcGFyZW5zXG4gICAgICAgICAgICAgICAgaWYgKCFwYXJzZXJJbnB1dC4kY2hhcignKCcpKSB7IHJldHVybiBudWxsOyB9XG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBvID0gdGhpcy5pbXBvcnRPcHRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbk5hbWUgPSBvO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChvcHRpb25OYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnY3NzJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uTmFtZSA9ICdsZXNzJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnb25jZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbk5hbWUgPSAnbXVsdGlwbGUnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnNbb3B0aW9uTmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcGFyc2VySW5wdXQuJGNoYXIoJywnKSkgeyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAobyk7XG4gICAgICAgICAgICAgICAgZXhwZWN0Q2hhcignKScpO1xuICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgaW1wb3J0T3B0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3B0ID0gcGFyc2VySW5wdXQuJHJlKC9eKGxlc3N8Y3NzfG11bHRpcGxlfG9uY2V8aW5saW5lfHJlZmVyZW5jZXxvcHRpb25hbCkvKTtcbiAgICAgICAgICAgICAgICBpZiAob3B0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRbMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgbWVkaWFGZWF0dXJlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVudGl0aWVzID0gdGhpcy5lbnRpdGllcywgbm9kZXMgPSBbXSwgZSwgcDtcbiAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBlID0gZW50aXRpZXMua2V5d29yZCgpIHx8IGVudGl0aWVzLnZhcmlhYmxlKCkgfHwgZW50aXRpZXMubWl4aW5Mb29rdXAoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzLnB1c2goZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyc2VySW5wdXQuJGNoYXIoJygnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcCA9IHRoaXMucHJvcGVydHkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUgPSB0aGlzLnZhbHVlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VySW5wdXQuJGNoYXIoJyknKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwICYmIGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXMucHVzaChuZXcodHJlZS5QYXJlbikobmV3KHRyZWUuRGVjbGFyYXRpb24pKHAsIGUsIG51bGwsIG51bGwsIHBhcnNlcklucHV0LmksIGZpbGVJbmZvLCB0cnVlKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKG5ldyh0cmVlLlBhcmVuKShlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IoJ2JhZGx5IGZvcm1lZCBtZWRpYSBmZWF0dXJlIGRlZmluaXRpb24nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yKCdNaXNzaW5nIGNsb3NpbmcgXFwnKVxcJycsICdQYXJzZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAoZSk7XG5cbiAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5mb3JnZXQoKTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3KHRyZWUuRXhwcmVzc2lvbikobm9kZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIG1lZGlhRmVhdHVyZXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZW50aXRpZXMgPSB0aGlzLmVudGl0aWVzLCBmZWF0dXJlcyA9IFtdLCBlO1xuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgZSA9IHRoaXMubWVkaWFGZWF0dXJlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmZWF0dXJlcy5wdXNoKGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJzZXJJbnB1dC4kY2hhcignLCcpKSB7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlID0gZW50aXRpZXMudmFyaWFibGUoKSB8fCBlbnRpdGllcy5taXhpbkxvb2t1cCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZWF0dXJlcy5wdXNoKGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcGFyc2VySW5wdXQuJGNoYXIoJywnKSkgeyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAoZSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZmVhdHVyZXMubGVuZ3RoID4gMCA/IGZlYXR1cmVzIDogbnVsbDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIG1lZGlhOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZlYXR1cmVzLCBydWxlcywgbWVkaWEsIGRlYnVnSW5mbywgaW5kZXggPSBwYXJzZXJJbnB1dC5pO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRleHQuZHVtcExpbmVOdW1iZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnSW5mbyA9IGdldERlYnVnSW5mbyhpbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuc2F2ZSgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlcklucHV0LiRzdHIoJ0BtZWRpYScpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmVzID0gdGhpcy5tZWRpYUZlYXR1cmVzKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgcnVsZXMgPSB0aGlzLmJsb2NrKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFydWxlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IoJ21lZGlhIGRlZmluaXRpb25zIHJlcXVpcmUgYmxvY2sgc3RhdGVtZW50cyBhZnRlciBhbnkgZmVhdHVyZXMnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmZvcmdldCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIG1lZGlhID0gbmV3KHRyZWUuTWVkaWEpKHJ1bGVzLCBmZWF0dXJlcywgaW5kZXgsIGZpbGVJbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRleHQuZHVtcExpbmVOdW1iZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZWRpYS5kZWJ1Z0luZm8gPSBkZWJ1Z0luZm87XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWVkaWE7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcGFyc2VySW5wdXQucmVzdG9yZSgpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy9cblxuICAgICAgICAgICAgLy8gQSBAcGx1Z2luIGRpcmVjdGl2ZSwgdXNlZCB0byBpbXBvcnQgcGx1Z2lucyBkeW5hbWljYWxseS5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyAgICAgQHBsdWdpbiAoYXJncykgXCJsaWJcIjtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICBwbHVnaW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGF0aCwgYXJncywgb3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBwYXJzZXJJbnB1dC5pLFxuICAgICAgICAgICAgICAgICAgICBkaXIgICA9IHBhcnNlcklucHV0LiRyZSgvXkBwbHVnaW4/XFxzKy8pO1xuXG4gICAgICAgICAgICAgICAgaWYgKGRpcikge1xuICAgICAgICAgICAgICAgICAgICBhcmdzID0gdGhpcy5wbHVnaW5BcmdzKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGx1Z2luQXJnczogYXJncyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1BsdWdpbjogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7IGlzUGx1Z2luOiB0cnVlIH07XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoKHBhdGggPSB0aGlzLmVudGl0aWVzLnF1b3RlZCgpIHx8IHRoaXMuZW50aXRpZXMudXJsKCkpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcGFyc2VySW5wdXQuJGNoYXIoJzsnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmkgPSBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcignbWlzc2luZyBzZW1pLWNvbG9uIG9uIEBwbHVnaW4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcodHJlZS5JbXBvcnQpKHBhdGgsIG51bGwsIG9wdGlvbnMsIGluZGV4LCBmaWxlSW5mbyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5pID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcignbWFsZm9ybWVkIEBwbHVnaW4gc3RhdGVtZW50Jyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBwbHVnaW5BcmdzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBsaXN0IG9mIG9wdGlvbnMsIHN1cnJvdW5kZWQgYnkgcGFyZW5zXG4gICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuc2F2ZSgpO1xuICAgICAgICAgICAgICAgIGlmICghcGFyc2VySW5wdXQuJGNoYXIoJygnKSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5yZXN0b3JlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IHBhcnNlcklucHV0LiRyZSgvXlxccyooW15cXCk7XSspXFwpXFxzKi8pO1xuICAgICAgICAgICAgICAgIGlmIChhcmdzWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmZvcmdldCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJnc1sxXS50cmltKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgeyBcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gQSBDU1MgQXRSdWxlXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gICAgIEBjaGFyc2V0IFwidXRmLThcIjtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICBhdHJ1bGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBwYXJzZXJJbnB1dC5pLCBuYW1lLCB2YWx1ZSwgcnVsZXMsIG5vblZlbmRvclNwZWNpZmljTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgaGFzSWRlbnRpZmllciwgaGFzRXhwcmVzc2lvbiwgaGFzVW5rbm93biwgaGFzQmxvY2sgPSB0cnVlLCBpc1Jvb3RlZCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICBpZiAocGFyc2VySW5wdXQuY3VycmVudENoYXIoKSAhPT0gJ0AnKSB7IHJldHVybjsgfVxuXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzWydpbXBvcnQnXSgpIHx8IHRoaXMucGx1Z2luKCkgfHwgdGhpcy5tZWRpYSgpO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuc2F2ZSgpO1xuXG4gICAgICAgICAgICAgICAgbmFtZSA9IHBhcnNlcklucHV0LiRyZSgvXkBbYS16LV0rLyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIW5hbWUpIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgICAgICAgICBub25WZW5kb3JTcGVjaWZpY05hbWUgPSBuYW1lO1xuICAgICAgICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgxKSA9PSAnLScgJiYgbmFtZS5pbmRleE9mKCctJywgMikgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vblZlbmRvclNwZWNpZmljTmFtZSA9ICdAJyArIG5hbWUuc2xpY2UobmFtZS5pbmRleE9mKCctJywgMikgKyAxKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG5vblZlbmRvclNwZWNpZmljTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdAY2hhcnNldCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNJZGVudGlmaWVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc0Jsb2NrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnQG5hbWVzcGFjZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNFeHByZXNzaW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc0Jsb2NrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnQGtleWZyYW1lcyc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0Bjb3VudGVyLXN0eWxlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc0lkZW50aWZpZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0Bkb2N1bWVudCc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0BzdXBwb3J0cyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNVbmtub3duID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzUm9vdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc1Vua25vd24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuY29tbWVudFN0b3JlLmxlbmd0aCA9IDA7XG5cbiAgICAgICAgICAgICAgICBpZiAoaGFzSWRlbnRpZmllcikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuZW50aXR5KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yKCdleHBlY3RlZCAnICsgbmFtZSArICcgaWRlbnRpZmllcicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChoYXNFeHByZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5leHByZXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yKCdleHBlY3RlZCAnICsgbmFtZSArICcgZXhwcmVzc2lvbicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChoYXNVbmtub3duKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5wZXJtaXNzaXZlVmFsdWUoL15beztdLyk7XG4gICAgICAgICAgICAgICAgICAgIGhhc0Jsb2NrID0gKHBhcnNlcklucHV0LmN1cnJlbnRDaGFyKCkgPT09ICd7Jyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaGFzQmxvY2sgJiYgcGFyc2VySW5wdXQuY3VycmVudENoYXIoKSAhPT0gJzsnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IobmFtZSArICcgcnVsZSBpcyBtaXNzaW5nIGJsb2NrIG9yIGVuZGluZyBzZW1pLWNvbG9uJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIXZhbHVlLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaGFzQmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgcnVsZXMgPSB0aGlzLmJsb2NrUnVsZXNldCgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChydWxlcyB8fCAoIWhhc0Jsb2NrICYmIHZhbHVlICYmIHBhcnNlcklucHV0LiRjaGFyKCc7JykpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmZvcmdldCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3ICh0cmVlLkF0UnVsZSkobmFtZSwgdmFsdWUsIHJ1bGVzLCBpbmRleCwgZmlsZUluZm8sXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmR1bXBMaW5lTnVtYmVycyA/IGdldERlYnVnSW5mbyhpbmRleCkgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNSb290ZWRcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5yZXN0b3JlKCdhdC1ydWxlIG9wdGlvbnMgbm90IHJlY29nbmlzZWQnKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBBIFZhbHVlIGlzIGEgY29tbWEtZGVsaW1pdGVkIGxpc3Qgb2YgRXhwcmVzc2lvbnNcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyAgICAgZm9udC1mYW1pbHk6IEJhc2tlcnZpbGxlLCBHZW9yZ2lhLCBzZXJpZjtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBJbiBhIFJ1bGUsIGEgVmFsdWUgcmVwcmVzZW50cyBldmVyeXRoaW5nIGFmdGVyIHRoZSBgOmAsXG4gICAgICAgICAgICAvLyBhbmQgYmVmb3JlIHRoZSBgO2AuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZSwgZXhwcmVzc2lvbnMgPSBbXSwgaW5kZXggPSBwYXJzZXJJbnB1dC5pO1xuXG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBlID0gdGhpcy5leHByZXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJzZXJJbnB1dC4kY2hhcignLCcpKSB7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IHdoaWxlIChlKTtcblxuICAgICAgICAgICAgICAgIGlmIChleHByZXNzaW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcodHJlZS5WYWx1ZSkoZXhwcmVzc2lvbnMsIGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW1wb3J0YW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlcklucHV0LmN1cnJlbnRDaGFyKCkgPT09ICchJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VySW5wdXQuJHJlKC9eISAqaW1wb3J0YW50Lyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN1YjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBhLCBlO1xuXG4gICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuc2F2ZSgpO1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZXJJbnB1dC4kY2hhcignKCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGEgPSB0aGlzLmFkZGl0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhICYmIHBhcnNlcklucHV0LiRjaGFyKCcpJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmZvcmdldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZSA9IG5ldyh0cmVlLkV4cHJlc3Npb24pKFthXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnBhcmVucyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5yZXN0b3JlKCdFeHBlY3RlZCBcXCcpXFwnJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFyc2VySW5wdXQucmVzdG9yZSgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG11bHRpcGxpY2F0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG0sIGEsIG9wLCBvcGVyYXRpb24sIGlzU3BhY2VkO1xuICAgICAgICAgICAgICAgIG0gPSB0aGlzLm9wZXJhbmQoKTtcbiAgICAgICAgICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgICAgICAgICBpc1NwYWNlZCA9IHBhcnNlcklucHV0LmlzV2hpdGVzcGFjZSgtMSk7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VySW5wdXQucGVlaygvXlxcL1sqXFwvXS8pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnNhdmUoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgb3AgPSBwYXJzZXJJbnB1dC4kY2hhcignLycpIHx8IHBhcnNlcklucHV0LiRjaGFyKCcqJykgfHwgcGFyc2VySW5wdXQuJHN0cignLi8nKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvcCkgeyBwYXJzZXJJbnB1dC5mb3JnZXQoKTsgYnJlYWs7IH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgYSA9IHRoaXMub3BlcmFuZCgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWEpIHsgcGFyc2VySW5wdXQucmVzdG9yZSgpOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuZm9yZ2V0KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG0ucGFyZW5zSW5PcCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBhLnBhcmVuc0luT3AgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uID0gbmV3KHRyZWUuT3BlcmF0aW9uKShvcCwgW29wZXJhdGlvbiB8fCBtLCBhXSwgaXNTcGFjZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNTcGFjZWQgPSBwYXJzZXJJbnB1dC5pc1doaXRlc3BhY2UoLTEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcGVyYXRpb24gfHwgbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYWRkaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbSwgYSwgb3AsIG9wZXJhdGlvbiwgaXNTcGFjZWQ7XG4gICAgICAgICAgICAgICAgbSA9IHRoaXMubXVsdGlwbGljYXRpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgICAgICAgICBpc1NwYWNlZCA9IHBhcnNlcklucHV0LmlzV2hpdGVzcGFjZSgtMSk7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcCA9IHBhcnNlcklucHV0LiRyZSgvXlstK11cXHMrLykgfHwgKCFpc1NwYWNlZCAmJiAocGFyc2VySW5wdXQuJGNoYXIoJysnKSB8fCBwYXJzZXJJbnB1dC4kY2hhcignLScpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBhID0gdGhpcy5tdWx0aXBsaWNhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG0ucGFyZW5zSW5PcCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBhLnBhcmVuc0luT3AgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uID0gbmV3KHRyZWUuT3BlcmF0aW9uKShvcCwgW29wZXJhdGlvbiB8fCBtLCBhXSwgaXNTcGFjZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNTcGFjZWQgPSBwYXJzZXJJbnB1dC5pc1doaXRlc3BhY2UoLTEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcGVyYXRpb24gfHwgbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29uZGl0aW9uczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBhLCBiLCBpbmRleCA9IHBhcnNlcklucHV0LmksIGNvbmRpdGlvbjtcblxuICAgICAgICAgICAgICAgIGEgPSB0aGlzLmNvbmRpdGlvbih0cnVlKTtcbiAgICAgICAgICAgICAgICBpZiAoYSkge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJzZXJJbnB1dC5wZWVrKC9eLFxccyoobm90XFxzKik/XFwoLykgfHwgIXBhcnNlcklucHV0LiRjaGFyKCcsJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGIgPSB0aGlzLmNvbmRpdGlvbih0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZGl0aW9uID0gbmV3KHRyZWUuQ29uZGl0aW9uKSgnb3InLCBjb25kaXRpb24gfHwgYSwgYiwgaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb25kaXRpb24gfHwgYTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29uZGl0aW9uOiBmdW5jdGlvbiAobmVlZHNQYXJlbnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0LCBsb2dpY2FsLCBuZXh0O1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIG9yKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VySW5wdXQuJHN0cignb3InKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLmNvbmRpdGlvbkFuZChuZWVkc1BhcmVucyk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbG9naWNhbCA9IG9yKCk7XG4gICAgICAgICAgICAgICAgaWYgKGxvZ2ljYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCA9IHRoaXMuY29uZGl0aW9uKG5lZWRzUGFyZW5zKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyh0cmVlLkNvbmRpdGlvbikobG9naWNhbCwgcmVzdWx0LCBuZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb25kaXRpb25BbmQ6IGZ1bmN0aW9uIChuZWVkc1BhcmVucykge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQsIGxvZ2ljYWwsIG5leHQsIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGluc2lkZUNvbmRpdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbmQgPSBzZWxmLm5lZ2F0ZWRDb25kaXRpb24obmVlZHNQYXJlbnMpIHx8IHNlbGYucGFyZW50aGVzaXNDb25kaXRpb24obmVlZHNQYXJlbnMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbmQgJiYgIW5lZWRzUGFyZW5zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5hdG9taWNDb25kaXRpb24obmVlZHNQYXJlbnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb25kO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBhbmQoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZXJJbnB1dC4kc3RyKCdhbmQnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXN1bHQgPSBpbnNpZGVDb25kaXRpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsb2dpY2FsID0gYW5kKCk7XG4gICAgICAgICAgICAgICAgaWYgKGxvZ2ljYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCA9IHRoaXMuY29uZGl0aW9uQW5kKG5lZWRzUGFyZW5zKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyh0cmVlLkNvbmRpdGlvbikobG9naWNhbCwgcmVzdWx0LCBuZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBuZWdhdGVkQ29uZGl0aW9uOiBmdW5jdGlvbiAobmVlZHNQYXJlbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VySW5wdXQuJHN0cignbm90JykpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMucGFyZW50aGVzaXNDb25kaXRpb24obmVlZHNQYXJlbnMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQubmVnYXRlID0gIXJlc3VsdC5uZWdhdGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGFyZW50aGVzaXNDb25kaXRpb246IGZ1bmN0aW9uIChuZWVkc1BhcmVucykge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHRyeUNvbmRpdGlvbkZvbGxvd2VkQnlQYXJlbnRoZXNpcyhtZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYm9keTtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuc2F2ZSgpO1xuICAgICAgICAgICAgICAgICAgICBib2R5ID0gbWUuY29uZGl0aW9uKG5lZWRzUGFyZW5zKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFib2R5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5yZXN0b3JlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghcGFyc2VySW5wdXQuJGNoYXIoJyknKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5mb3JnZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJvZHk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGJvZHk7XG4gICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuc2F2ZSgpO1xuICAgICAgICAgICAgICAgIGlmICghcGFyc2VySW5wdXQuJHN0cignKCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYm9keSA9IHRyeUNvbmRpdGlvbkZvbGxvd2VkQnlQYXJlbnRoZXNpcyh0aGlzKTtcbiAgICAgICAgICAgICAgICBpZiAoYm9keSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5mb3JnZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJvZHk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYm9keSA9IHRoaXMuYXRvbWljQ29uZGl0aW9uKG5lZWRzUGFyZW5zKTtcbiAgICAgICAgICAgICAgICBpZiAoIWJvZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXBhcnNlcklucHV0LiRjaGFyKCcpJykpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQucmVzdG9yZSgnZXhwZWN0ZWQgXFwnKVxcJyBnb3QgXFwnJyArIHBhcnNlcklucHV0LmN1cnJlbnRDaGFyKCkgKyAnXFwnJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmZvcmdldCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBib2R5O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGF0b21pY0NvbmRpdGlvbjogZnVuY3Rpb24gKG5lZWRzUGFyZW5zKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVudGl0aWVzID0gdGhpcy5lbnRpdGllcywgaW5kZXggPSBwYXJzZXJJbnB1dC5pLCBhLCBiLCBjLCBvcDtcblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGNvbmQoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZGl0aW9uKCkgfHwgZW50aXRpZXMua2V5d29yZCgpIHx8IGVudGl0aWVzLnF1b3RlZCgpIHx8IGVudGl0aWVzLm1peGluTG9va3VwKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbmQgPSBjb25kLmJpbmQodGhpcyk7XG5cbiAgICAgICAgICAgICAgICBhID0gY29uZCgpO1xuICAgICAgICAgICAgICAgIGlmIChhKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXJJbnB1dC4kY2hhcignPicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VySW5wdXQuJGNoYXIoJz0nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wID0gJz49JztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3AgPSAnPic7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VySW5wdXQuJGNoYXIoJzwnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlcklucHV0LiRjaGFyKCc9JykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcCA9ICc8PSc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wID0gJzwnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlcklucHV0LiRjaGFyKCc9JykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXJJbnB1dC4kY2hhcignPicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3AgPSAnPT4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJzZXJJbnB1dC4kY2hhcignPCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3AgPSAnPTwnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcCA9ICc9JztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGIgPSBjb25kKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSBuZXcodHJlZS5Db25kaXRpb24pKG9wLCBhLCBiLCBpbmRleCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcignZXhwZWN0ZWQgZXhwcmVzc2lvbicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYyA9IG5ldyh0cmVlLkNvbmRpdGlvbikoJz0nLCBhLCBuZXcodHJlZS5LZXl3b3JkKSgndHJ1ZScpLCBpbmRleCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBBbiBvcGVyYW5kIGlzIGFueXRoaW5nIHRoYXQgY2FuIGJlIHBhcnQgb2YgYW4gb3BlcmF0aW9uLFxuICAgICAgICAgICAgLy8gc3VjaCBhcyBhIENvbG9yLCBvciBhIFZhcmlhYmxlXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgb3BlcmFuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBlbnRpdGllcyA9IHRoaXMuZW50aXRpZXMsIG5lZ2F0ZTtcblxuICAgICAgICAgICAgICAgIGlmIChwYXJzZXJJbnB1dC5wZWVrKC9eLVtAXFwkXFwoXS8pKSB7XG4gICAgICAgICAgICAgICAgICAgIG5lZ2F0ZSA9IHBhcnNlcklucHV0LiRjaGFyKCctJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIG8gPSB0aGlzLnN1YigpIHx8IGVudGl0aWVzLmRpbWVuc2lvbigpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRpdGllcy5jb2xvcigpIHx8IGVudGl0aWVzLnZhcmlhYmxlKCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudGl0aWVzLnByb3BlcnR5KCkgfHwgZW50aXRpZXMuY2FsbCgpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRpdGllcy5xdW90ZWQodHJ1ZSkgfHwgZW50aXRpZXMuY29sb3JLZXl3b3JkKCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudGl0aWVzLm1peGluTG9va3VwKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAobmVnYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIG8ucGFyZW5zSW5PcCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIG8gPSBuZXcodHJlZS5OZWdhdGl2ZSkobyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG87XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gRXhwcmVzc2lvbnMgZWl0aGVyIHJlcHJlc2VudCBtYXRoZW1hdGljYWwgb3BlcmF0aW9ucyxcbiAgICAgICAgICAgIC8vIG9yIHdoaXRlLXNwYWNlIGRlbGltaXRlZCBFbnRpdGllcy5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyAgICAgMXB4IHNvbGlkIGJsYWNrXG4gICAgICAgICAgICAvLyAgICAgQHZhciAqIDJcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICBleHByZXNzaW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVudGl0aWVzID0gW10sIGUsIGRlbGltLCBpbmRleCA9IHBhcnNlcklucHV0Lmk7XG5cbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIGUgPSB0aGlzLmNvbW1lbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudGl0aWVzLnB1c2goZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlID0gdGhpcy5hZGRpdGlvbigpIHx8IHRoaXMuZW50aXR5KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRpdGllcy5wdXNoKGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3BlcmF0aW9ucyBkbyBub3QgYWxsb3cga2V5d29yZCBcIi9cIiBkaW1lbnNpb24gKGUuZy4gc21hbGwvMjBweCkgc28gd2Ugc3VwcG9ydCB0aGF0IGhlcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcGFyc2VySW5wdXQucGVlaygvXlxcL1tcXC8qXS8pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsaW0gPSBwYXJzZXJJbnB1dC4kY2hhcignLycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWxpbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRpdGllcy5wdXNoKG5ldyh0cmVlLkFub255bW91cykoZGVsaW0sIGluZGV4KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAoZSk7XG4gICAgICAgICAgICAgICAgaWYgKGVudGl0aWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyh0cmVlLkV4cHJlc3Npb24pKGVudGl0aWVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJvcGVydHk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IHBhcnNlcklucHV0LiRyZSgvXihcXCo/LT9bX2EtekEtWjAtOS1dKylcXHMqOi8pO1xuICAgICAgICAgICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuYW1lWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBydWxlUHJvcGVydHk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IFtdLCBpbmRleCA9IFtdLCBzLCBrO1xuXG4gICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuc2F2ZSgpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHNpbXBsZVByb3BlcnR5ID0gcGFyc2VySW5wdXQuJHJlKC9eKFtfYS16QS1aMC05LV0rKVxccyo6Lyk7XG4gICAgICAgICAgICAgICAgaWYgKHNpbXBsZVByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBbbmV3KHRyZWUuS2V5d29yZCkoc2ltcGxlUHJvcGVydHlbMV0pXTtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuZm9yZ2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIG1hdGNoKHJlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpID0gcGFyc2VySW5wdXQuaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rID0gcGFyc2VySW5wdXQuJHJlKHJlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNodW5rKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleC5wdXNoKGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5hbWUucHVzaChjaHVua1sxXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtYXRjaCgvXihcXCo/KS8pO1xuICAgICAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbWF0Y2goL14oKD86W1xcdy1dKyl8KD86W0BcXCRdXFx7W1xcdy1dK1xcfSkpLykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKChuYW1lLmxlbmd0aCA+IDEpICYmIG1hdGNoKC9eKCg/OlxcK198XFwrKT8pXFxzKjovKSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5mb3JnZXQoKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBhdCBsYXN0LCB3ZSBoYXZlIHRoZSBjb21wbGV0ZSBtYXRjaCBub3cuIG1vdmUgZm9yd2FyZCxcbiAgICAgICAgICAgICAgICAgICAgLy8gY29udmVydCBuYW1lIHBhcnRpY2xlcyB0byB0cmVlIG9iamVjdHMgYW5kIHJldHVybjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWVbMF0gPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBuYW1lLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzID0gbmFtZVtrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVba10gPSAocy5jaGFyQXQoMCkgIT09ICdAJyAmJiBzLmNoYXJBdCgwKSAhPT0gJyQnKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3KHRyZWUuS2V5d29yZCkocykgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChzLmNoYXJBdCgwKSA9PT0gJ0AnID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3KHRyZWUuVmFyaWFibGUpKCdAJyArIHMuc2xpY2UoMiwgLTEpLCBpbmRleFtrXSwgZmlsZUluZm8pIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3KHRyZWUuUHJvcGVydHkpKCckJyArIHMuc2xpY2UoMiwgLTEpLCBpbmRleFtrXSwgZmlsZUluZm8pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFyc2VySW5wdXQucmVzdG9yZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn07XG5QYXJzZXIuc2VyaWFsaXplVmFycyA9IGZ1bmN0aW9uKHZhcnMpIHtcbiAgICB2YXIgcyA9ICcnO1xuXG4gICAgZm9yICh2YXIgbmFtZSBpbiB2YXJzKSB7XG4gICAgICAgIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbCh2YXJzLCBuYW1lKSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gdmFyc1tuYW1lXTtcbiAgICAgICAgICAgIHMgKz0gKChuYW1lWzBdID09PSAnQCcpID8gJycgOiAnQCcpICsgbmFtZSArICc6ICcgKyB2YWx1ZSArXG4gICAgICAgICAgICAgICAgKChTdHJpbmcodmFsdWUpLnNsaWNlKC0xKSA9PT0gJzsnKSA/ICcnIDogJzsnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQYXJzZXI7XG5cbn0se1wiLi4vZnVuY3Rpb25zL2Z1bmN0aW9uLXJlZ2lzdHJ5XCI6MjcsXCIuLi9sZXNzLWVycm9yXCI6MzgsXCIuLi90cmVlXCI6NjcsXCIuLi91dGlsc1wiOjg5LFwiLi4vdmlzaXRvcnNcIjo5MyxcIi4vcGFyc2VyLWlucHV0XCI6NDN9XSw0NTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIFBsdWdpbiBNYW5hZ2VyXG4gKi9cbnZhciBQbHVnaW5NYW5hZ2VyID0gZnVuY3Rpb24obGVzcykge1xuICAgIHRoaXMubGVzcyA9IGxlc3M7XG4gICAgdGhpcy52aXNpdG9ycyA9IFtdO1xuICAgIHRoaXMucHJlUHJvY2Vzc29ycyA9IFtdO1xuICAgIHRoaXMucG9zdFByb2Nlc3NvcnMgPSBbXTtcbiAgICB0aGlzLmluc3RhbGxlZFBsdWdpbnMgPSBbXTtcbiAgICB0aGlzLmZpbGVNYW5hZ2VycyA9IFtdO1xuICAgIHRoaXMuaXRlcmF0b3IgPSAtMTtcbiAgICB0aGlzLnBsdWdpbkNhY2hlID0ge307XG4gICAgdGhpcy5Mb2FkZXIgPSBuZXcgbGVzcy5QbHVnaW5Mb2FkZXIobGVzcyk7XG59O1xuXG52YXIgcG0sIFBsdWdpbk1hbmFnZXJGYWN0b3J5ID0gZnVuY3Rpb24obGVzcywgbmV3RmFjdG9yeSkge1xuICAgICAgICBpZiAobmV3RmFjdG9yeSB8fCAhcG0pIHtcbiAgICAgICAgICAgIHBtID0gbmV3IFBsdWdpbk1hbmFnZXIobGVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBtO1xuICAgIH07XG5cbi8qKlxuICogQWRkcyBhbGwgdGhlIHBsdWdpbnMgaW4gdGhlIGFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBwbHVnaW5zXG4gKi9cblBsdWdpbk1hbmFnZXIucHJvdG90eXBlLmFkZFBsdWdpbnMgPSBmdW5jdGlvbihwbHVnaW5zKSB7XG4gICAgaWYgKHBsdWdpbnMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwbHVnaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmFkZFBsdWdpbihwbHVnaW5zW2ldKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG4vKipcbiAqXG4gKiBAcGFyYW0gcGx1Z2luXG4gKiBAcGFyYW0ge1N0cmluZ30gZmlsZW5hbWVcbiAqL1xuUGx1Z2luTWFuYWdlci5wcm90b3R5cGUuYWRkUGx1Z2luID0gZnVuY3Rpb24ocGx1Z2luLCBmaWxlbmFtZSwgZnVuY3Rpb25SZWdpc3RyeSkge1xuICAgIHRoaXMuaW5zdGFsbGVkUGx1Z2lucy5wdXNoKHBsdWdpbik7XG4gICAgaWYgKGZpbGVuYW1lKSB7XG4gICAgICAgIHRoaXMucGx1Z2luQ2FjaGVbZmlsZW5hbWVdID0gcGx1Z2luO1xuICAgIH1cbiAgICBpZiAocGx1Z2luLmluc3RhbGwpIHtcbiAgICAgICAgcGx1Z2luLmluc3RhbGwodGhpcy5sZXNzLCB0aGlzLCBmdW5jdGlvblJlZ2lzdHJ5IHx8IHRoaXMubGVzcy5mdW5jdGlvbnMuZnVuY3Rpb25SZWdpc3RyeSk7XG4gICAgfVxufTtcbi8qKlxuICpcbiAqIEBwYXJhbSBmaWxlbmFtZVxuICovXG5QbHVnaW5NYW5hZ2VyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihmaWxlbmFtZSkge1xuICAgIHJldHVybiB0aGlzLnBsdWdpbkNhY2hlW2ZpbGVuYW1lXTtcbn07XG5cbi8qKlxuICogQWRkcyBhIHZpc2l0b3IuIFRoZSB2aXNpdG9yIG9iamVjdCBoYXMgb3B0aW9ucyBvbiBpdHNlbGYgdG8gZGV0ZXJtaW5lXG4gKiB3aGVuIGl0IHNob3VsZCBydW4uXG4gKiBAcGFyYW0gdmlzaXRvclxuICovXG5QbHVnaW5NYW5hZ2VyLnByb3RvdHlwZS5hZGRWaXNpdG9yID0gZnVuY3Rpb24odmlzaXRvcikge1xuICAgIHRoaXMudmlzaXRvcnMucHVzaCh2aXNpdG9yKTtcbn07XG4vKipcbiAqIEFkZHMgYSBwcmUgcHJvY2Vzc29yIG9iamVjdFxuICogQHBhcmFtIHtvYmplY3R9IHByZVByb2Nlc3NvclxuICogQHBhcmFtIHtudW1iZXJ9IHByaW9yaXR5IC0gZ3VpZGVsaW5lcyAxID0gYmVmb3JlIGltcG9ydCwgMTAwMCA9IGltcG9ydCwgMjAwMCA9IGFmdGVyIGltcG9ydFxuICovXG5QbHVnaW5NYW5hZ2VyLnByb3RvdHlwZS5hZGRQcmVQcm9jZXNzb3IgPSBmdW5jdGlvbihwcmVQcm9jZXNzb3IsIHByaW9yaXR5KSB7XG4gICAgdmFyIGluZGV4VG9JbnNlcnRBdDtcbiAgICBmb3IgKGluZGV4VG9JbnNlcnRBdCA9IDA7IGluZGV4VG9JbnNlcnRBdCA8IHRoaXMucHJlUHJvY2Vzc29ycy5sZW5ndGg7IGluZGV4VG9JbnNlcnRBdCsrKSB7XG4gICAgICAgIGlmICh0aGlzLnByZVByb2Nlc3NvcnNbaW5kZXhUb0luc2VydEF0XS5wcmlvcml0eSA+PSBwcmlvcml0eSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5wcmVQcm9jZXNzb3JzLnNwbGljZShpbmRleFRvSW5zZXJ0QXQsIDAsIHtwcmVQcm9jZXNzb3I6IHByZVByb2Nlc3NvciwgcHJpb3JpdHk6IHByaW9yaXR5fSk7XG59O1xuLyoqXG4gKiBBZGRzIGEgcG9zdCBwcm9jZXNzb3Igb2JqZWN0XG4gKiBAcGFyYW0ge29iamVjdH0gcG9zdFByb2Nlc3NvclxuICogQHBhcmFtIHtudW1iZXJ9IHByaW9yaXR5IC0gZ3VpZGVsaW5lcyAxID0gYmVmb3JlIGNvbXByZXNzaW9uLCAxMDAwID0gY29tcHJlc3Npb24sIDIwMDAgPSBhZnRlciBjb21wcmVzc2lvblxuICovXG5QbHVnaW5NYW5hZ2VyLnByb3RvdHlwZS5hZGRQb3N0UHJvY2Vzc29yID0gZnVuY3Rpb24ocG9zdFByb2Nlc3NvciwgcHJpb3JpdHkpIHtcbiAgICB2YXIgaW5kZXhUb0luc2VydEF0O1xuICAgIGZvciAoaW5kZXhUb0luc2VydEF0ID0gMDsgaW5kZXhUb0luc2VydEF0IDwgdGhpcy5wb3N0UHJvY2Vzc29ycy5sZW5ndGg7IGluZGV4VG9JbnNlcnRBdCsrKSB7XG4gICAgICAgIGlmICh0aGlzLnBvc3RQcm9jZXNzb3JzW2luZGV4VG9JbnNlcnRBdF0ucHJpb3JpdHkgPj0gcHJpb3JpdHkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMucG9zdFByb2Nlc3NvcnMuc3BsaWNlKGluZGV4VG9JbnNlcnRBdCwgMCwge3Bvc3RQcm9jZXNzb3I6IHBvc3RQcm9jZXNzb3IsIHByaW9yaXR5OiBwcmlvcml0eX0pO1xufTtcbi8qKlxuICpcbiAqIEBwYXJhbSBtYW5hZ2VyXG4gKi9cblBsdWdpbk1hbmFnZXIucHJvdG90eXBlLmFkZEZpbGVNYW5hZ2VyID0gZnVuY3Rpb24obWFuYWdlcikge1xuICAgIHRoaXMuZmlsZU1hbmFnZXJzLnB1c2gobWFuYWdlcik7XG59O1xuLyoqXG4gKlxuICogQHJldHVybnMge0FycmF5fVxuICogQHByaXZhdGVcbiAqL1xuUGx1Z2luTWFuYWdlci5wcm90b3R5cGUuZ2V0UHJlUHJvY2Vzc29ycyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBwcmVQcm9jZXNzb3JzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnByZVByb2Nlc3NvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcHJlUHJvY2Vzc29ycy5wdXNoKHRoaXMucHJlUHJvY2Vzc29yc1tpXS5wcmVQcm9jZXNzb3IpO1xuICAgIH1cbiAgICByZXR1cm4gcHJlUHJvY2Vzc29ycztcbn07XG4vKipcbiAqXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKiBAcHJpdmF0ZVxuICovXG5QbHVnaW5NYW5hZ2VyLnByb3RvdHlwZS5nZXRQb3N0UHJvY2Vzc29ycyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBwb3N0UHJvY2Vzc29ycyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wb3N0UHJvY2Vzc29ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwb3N0UHJvY2Vzc29ycy5wdXNoKHRoaXMucG9zdFByb2Nlc3NvcnNbaV0ucG9zdFByb2Nlc3Nvcik7XG4gICAgfVxuICAgIHJldHVybiBwb3N0UHJvY2Vzc29ycztcbn07XG4vKipcbiAqXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKiBAcHJpdmF0ZVxuICovXG5QbHVnaW5NYW5hZ2VyLnByb3RvdHlwZS5nZXRWaXNpdG9ycyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnZpc2l0b3JzO1xufTtcblxuUGx1Z2luTWFuYWdlci5wcm90b3R5cGUudmlzaXRvciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICByZXR1cm4ge1xuICAgICAgICBmaXJzdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLml0ZXJhdG9yID0gLTE7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi52aXNpdG9yc1tzZWxmLml0ZXJhdG9yXTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYuaXRlcmF0b3IgKz0gMTtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLnZpc2l0b3JzW3NlbGYuaXRlcmF0b3JdO1xuICAgICAgICB9XG4gICAgfTtcbn07XG4vKipcbiAqXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKiBAcHJpdmF0ZVxuICovXG5QbHVnaW5NYW5hZ2VyLnByb3RvdHlwZS5nZXRGaWxlTWFuYWdlcnMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5maWxlTWFuYWdlcnM7XG59O1xuXG4vL1xubW9kdWxlLmV4cG9ydHMgPSBQbHVnaW5NYW5hZ2VyRmFjdG9yeTtcblxufSx7fV0sNDY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIFByb21pc2VDb25zdHJ1Y3RvcixcbiAgICB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihlbnZpcm9ubWVudCwgUGFyc2VUcmVlLCBJbXBvcnRNYW5hZ2VyKSB7XG4gICAgdmFyIHJlbmRlciA9IGZ1bmN0aW9uIChpbnB1dCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgICAgICAgICBvcHRpb25zID0gdXRpbHMuY29weU9wdGlvbnModGhpcy5vcHRpb25zLCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvcHRpb25zID0gdXRpbHMuY29weU9wdGlvbnModGhpcy5vcHRpb25zLCBvcHRpb25zIHx8IHt9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGlmICghUHJvbWlzZUNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICAgICAgUHJvbWlzZUNvbnN0cnVjdG9yID0gdHlwZW9mIFByb21pc2UgPT09ICd1bmRlZmluZWQnID8gcmVxdWlyZSgncHJvbWlzZScpIDogUHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZUNvbnN0cnVjdG9yKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICByZW5kZXIuY2FsbChzZWxmLCBpbnB1dCwgb3B0aW9ucywgZnVuY3Rpb24oZXJyLCBvdXRwdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG91dHB1dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wYXJzZShpbnB1dCwgb3B0aW9ucywgZnVuY3Rpb24oZXJyLCByb290LCBpbXBvcnRzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikgeyByZXR1cm4gY2FsbGJhY2soZXJyKTsgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyc2VUcmVlID0gbmV3IFBhcnNlVHJlZShyb290LCBpbXBvcnRzKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcGFyc2VUcmVlLnRvQ1NTKG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7IHJldHVybiBjYWxsYmFjayhlcnIpOyB9XG5cbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCByZXN1bHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIHJlbmRlcjtcbn07XG5cbn0se1wiLi91dGlsc1wiOjg5LFwicHJvbWlzZVwiOnVuZGVmaW5lZH1dLDQ3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFNvdXJjZU1hcE91dHB1dCwgZW52aXJvbm1lbnQpIHtcblxuICAgIHZhciBTb3VyY2VNYXBCdWlsZGVyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB9O1xuXG4gICAgU291cmNlTWFwQnVpbGRlci5wcm90b3R5cGUudG9DU1MgPSBmdW5jdGlvbihyb290Tm9kZSwgb3B0aW9ucywgaW1wb3J0cykge1xuICAgICAgICB2YXIgc291cmNlTWFwT3V0cHV0ID0gbmV3IFNvdXJjZU1hcE91dHB1dChcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb250ZW50c0lnbm9yZWRDaGFyc01hcDogaW1wb3J0cy5jb250ZW50c0lnbm9yZWRDaGFycyxcbiAgICAgICAgICAgICAgICByb290Tm9kZTogcm9vdE5vZGUsXG4gICAgICAgICAgICAgICAgY29udGVudHNNYXA6IGltcG9ydHMuY29udGVudHMsXG4gICAgICAgICAgICAgICAgc291cmNlTWFwRmlsZW5hbWU6IHRoaXMub3B0aW9ucy5zb3VyY2VNYXBGaWxlbmFtZSxcbiAgICAgICAgICAgICAgICBzb3VyY2VNYXBVUkw6IHRoaXMub3B0aW9ucy5zb3VyY2VNYXBVUkwsXG4gICAgICAgICAgICAgICAgb3V0cHV0RmlsZW5hbWU6IHRoaXMub3B0aW9ucy5zb3VyY2VNYXBPdXRwdXRGaWxlbmFtZSxcbiAgICAgICAgICAgICAgICBzb3VyY2VNYXBCYXNlcGF0aDogdGhpcy5vcHRpb25zLnNvdXJjZU1hcEJhc2VwYXRoLFxuICAgICAgICAgICAgICAgIHNvdXJjZU1hcFJvb3RwYXRoOiB0aGlzLm9wdGlvbnMuc291cmNlTWFwUm9vdHBhdGgsXG4gICAgICAgICAgICAgICAgb3V0cHV0U291cmNlRmlsZXM6IHRoaXMub3B0aW9ucy5vdXRwdXRTb3VyY2VGaWxlcyxcbiAgICAgICAgICAgICAgICBzb3VyY2VNYXBHZW5lcmF0b3I6IHRoaXMub3B0aW9ucy5zb3VyY2VNYXBHZW5lcmF0b3IsXG4gICAgICAgICAgICAgICAgc291cmNlTWFwRmlsZUlubGluZTogdGhpcy5vcHRpb25zLnNvdXJjZU1hcEZpbGVJbmxpbmVcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBjc3MgPSBzb3VyY2VNYXBPdXRwdXQudG9DU1Mob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuc291cmNlTWFwID0gc291cmNlTWFwT3V0cHV0LnNvdXJjZU1hcDtcbiAgICAgICAgdGhpcy5zb3VyY2VNYXBVUkwgPSBzb3VyY2VNYXBPdXRwdXQuc291cmNlTWFwVVJMO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNvdXJjZU1hcElucHV0RmlsZW5hbWUpIHtcbiAgICAgICAgICAgIHRoaXMuc291cmNlTWFwSW5wdXRGaWxlbmFtZSA9IHNvdXJjZU1hcE91dHB1dC5ub3JtYWxpemVGaWxlbmFtZSh0aGlzLm9wdGlvbnMuc291cmNlTWFwSW5wdXRGaWxlbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zb3VyY2VNYXBCYXNlcGF0aCAhPT0gdW5kZWZpbmVkICYmIHRoaXMuc291cmNlTWFwVVJMICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc291cmNlTWFwVVJMID0gc291cmNlTWFwT3V0cHV0LnJlbW92ZUJhc2VwYXRoKHRoaXMuc291cmNlTWFwVVJMKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3NzICsgdGhpcy5nZXRDU1NBcHBlbmRhZ2UoKTtcbiAgICB9O1xuXG4gICAgU291cmNlTWFwQnVpbGRlci5wcm90b3R5cGUuZ2V0Q1NTQXBwZW5kYWdlID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHNvdXJjZU1hcFVSTCA9IHRoaXMuc291cmNlTWFwVVJMO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNvdXJjZU1hcEZpbGVJbmxpbmUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNvdXJjZU1hcCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc291cmNlTWFwVVJMID0gJ2RhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsJyArIGVudmlyb25tZW50LmVuY29kZUJhc2U2NCh0aGlzLnNvdXJjZU1hcCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc291cmNlTWFwVVJMKSB7XG4gICAgICAgICAgICByZXR1cm4gJy8qIyBzb3VyY2VNYXBwaW5nVVJMPScgKyBzb3VyY2VNYXBVUkwgKyAnICovJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgfTtcblxuICAgIFNvdXJjZU1hcEJ1aWxkZXIucHJvdG90eXBlLmdldEV4dGVybmFsU291cmNlTWFwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZU1hcDtcbiAgICB9O1xuICAgIFNvdXJjZU1hcEJ1aWxkZXIucHJvdG90eXBlLnNldEV4dGVybmFsU291cmNlTWFwID0gZnVuY3Rpb24oc291cmNlTWFwKSB7XG4gICAgICAgIHRoaXMuc291cmNlTWFwID0gc291cmNlTWFwO1xuICAgIH07XG5cbiAgICBTb3VyY2VNYXBCdWlsZGVyLnByb3RvdHlwZS5pc0lubGluZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnNvdXJjZU1hcEZpbGVJbmxpbmU7XG4gICAgfTtcbiAgICBTb3VyY2VNYXBCdWlsZGVyLnByb3RvdHlwZS5nZXRTb3VyY2VNYXBVUkwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlTWFwVVJMO1xuICAgIH07XG4gICAgU291cmNlTWFwQnVpbGRlci5wcm90b3R5cGUuZ2V0T3V0cHV0RmlsZW5hbWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5zb3VyY2VNYXBPdXRwdXRGaWxlbmFtZTtcbiAgICB9O1xuICAgIFNvdXJjZU1hcEJ1aWxkZXIucHJvdG90eXBlLmdldElucHV0RmlsZW5hbWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlTWFwSW5wdXRGaWxlbmFtZTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFNvdXJjZU1hcEJ1aWxkZXI7XG59O1xuXG59LHt9XSw0ODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChlbnZpcm9ubWVudCkge1xuXG4gICAgdmFyIFNvdXJjZU1hcE91dHB1dCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX2NzcyA9IFtdO1xuICAgICAgICB0aGlzLl9yb290Tm9kZSA9IG9wdGlvbnMucm9vdE5vZGU7XG4gICAgICAgIHRoaXMuX2NvbnRlbnRzTWFwID0gb3B0aW9ucy5jb250ZW50c01hcDtcbiAgICAgICAgdGhpcy5fY29udGVudHNJZ25vcmVkQ2hhcnNNYXAgPSBvcHRpb25zLmNvbnRlbnRzSWdub3JlZENoYXJzTWFwO1xuICAgICAgICBpZiAob3B0aW9ucy5zb3VyY2VNYXBGaWxlbmFtZSkge1xuICAgICAgICAgICAgdGhpcy5fc291cmNlTWFwRmlsZW5hbWUgPSBvcHRpb25zLnNvdXJjZU1hcEZpbGVuYW1lLnJlcGxhY2UoL1xcXFwvZywgJy8nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9vdXRwdXRGaWxlbmFtZSA9IG9wdGlvbnMub3V0cHV0RmlsZW5hbWU7XG4gICAgICAgIHRoaXMuc291cmNlTWFwVVJMID0gb3B0aW9ucy5zb3VyY2VNYXBVUkw7XG4gICAgICAgIGlmIChvcHRpb25zLnNvdXJjZU1hcEJhc2VwYXRoKSB7XG4gICAgICAgICAgICB0aGlzLl9zb3VyY2VNYXBCYXNlcGF0aCA9IG9wdGlvbnMuc291cmNlTWFwQmFzZXBhdGgucmVwbGFjZSgvXFxcXC9nLCAnLycpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLnNvdXJjZU1hcFJvb3RwYXRoKSB7XG4gICAgICAgICAgICB0aGlzLl9zb3VyY2VNYXBSb290cGF0aCA9IG9wdGlvbnMuc291cmNlTWFwUm9vdHBhdGgucmVwbGFjZSgvXFxcXC9nLCAnLycpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3NvdXJjZU1hcFJvb3RwYXRoLmNoYXJBdCh0aGlzLl9zb3VyY2VNYXBSb290cGF0aC5sZW5ndGggLSAxKSAhPT0gJy8nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc291cmNlTWFwUm9vdHBhdGggKz0gJy8nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fc291cmNlTWFwUm9vdHBhdGggPSAnJztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9vdXRwdXRTb3VyY2VGaWxlcyA9IG9wdGlvbnMub3V0cHV0U291cmNlRmlsZXM7XG4gICAgICAgIHRoaXMuX3NvdXJjZU1hcEdlbmVyYXRvckNvbnN0cnVjdG9yID0gZW52aXJvbm1lbnQuZ2V0U291cmNlTWFwR2VuZXJhdG9yKCk7XG5cbiAgICAgICAgdGhpcy5fbGluZU51bWJlciA9IDA7XG4gICAgICAgIHRoaXMuX2NvbHVtbiA9IDA7XG4gICAgfTtcblxuICAgIFNvdXJjZU1hcE91dHB1dC5wcm90b3R5cGUucmVtb3ZlQmFzZXBhdGggPSBmdW5jdGlvbihwYXRoKSB7XG4gICAgICAgIGlmICh0aGlzLl9zb3VyY2VNYXBCYXNlcGF0aCAmJiBwYXRoLmluZGV4T2YodGhpcy5fc291cmNlTWFwQmFzZXBhdGgpID09PSAwKSB7XG4gICAgICAgICAgICBwYXRoID0gcGF0aC5zdWJzdHJpbmcodGhpcy5fc291cmNlTWFwQmFzZXBhdGgubGVuZ3RoKTtcbiAgICAgICAgICAgIGlmIChwYXRoLmNoYXJBdCgwKSA9PT0gJ1xcXFwnIHx8IHBhdGguY2hhckF0KDApID09PSAnLycpIHtcbiAgICAgICAgICAgICAgICBwYXRoID0gcGF0aC5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICB9O1xuXG4gICAgU291cmNlTWFwT3V0cHV0LnByb3RvdHlwZS5ub3JtYWxpemVGaWxlbmFtZSA9IGZ1bmN0aW9uKGZpbGVuYW1lKSB7XG4gICAgICAgIGZpbGVuYW1lID0gZmlsZW5hbWUucmVwbGFjZSgvXFxcXC9nLCAnLycpO1xuICAgICAgICBmaWxlbmFtZSA9IHRoaXMucmVtb3ZlQmFzZXBhdGgoZmlsZW5hbWUpO1xuICAgICAgICByZXR1cm4gKHRoaXMuX3NvdXJjZU1hcFJvb3RwYXRoIHx8ICcnKSArIGZpbGVuYW1lO1xuICAgIH07XG5cbiAgICBTb3VyY2VNYXBPdXRwdXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGNodW5rLCBmaWxlSW5mbywgaW5kZXgsIG1hcExpbmVzKSB7XG5cbiAgICAgICAgLy8gaWdub3JlIGFkZGluZyBlbXB0eSBzdHJpbmdzXG4gICAgICAgIGlmICghY2h1bmspIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsaW5lcyxcbiAgICAgICAgICAgIHNvdXJjZUxpbmVzLFxuICAgICAgICAgICAgY29sdW1ucyxcbiAgICAgICAgICAgIHNvdXJjZUNvbHVtbnMsXG4gICAgICAgICAgICBpO1xuXG4gICAgICAgIGlmIChmaWxlSW5mbyAmJiBmaWxlSW5mby5maWxlbmFtZSkge1xuICAgICAgICAgICAgdmFyIGlucHV0U291cmNlID0gdGhpcy5fY29udGVudHNNYXBbZmlsZUluZm8uZmlsZW5hbWVdO1xuXG4gICAgICAgICAgICAvLyByZW1vdmUgdmFycy9iYW5uZXIgYWRkZWQgdG8gdGhlIHRvcCBvZiB0aGUgZmlsZVxuICAgICAgICAgICAgaWYgKHRoaXMuX2NvbnRlbnRzSWdub3JlZENoYXJzTWFwW2ZpbGVJbmZvLmZpbGVuYW1lXSkge1xuICAgICAgICAgICAgICAgIC8vIGFkanVzdCB0aGUgaW5kZXhcbiAgICAgICAgICAgICAgICBpbmRleCAtPSB0aGlzLl9jb250ZW50c0lnbm9yZWRDaGFyc01hcFtmaWxlSW5mby5maWxlbmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgMCkgeyBpbmRleCA9IDA7IH1cbiAgICAgICAgICAgICAgICAvLyBhZGp1c3QgdGhlIHNvdXJjZVxuICAgICAgICAgICAgICAgIGlucHV0U291cmNlID0gaW5wdXRTb3VyY2Uuc2xpY2UodGhpcy5fY29udGVudHNJZ25vcmVkQ2hhcnNNYXBbZmlsZUluZm8uZmlsZW5hbWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlucHV0U291cmNlID0gaW5wdXRTb3VyY2Uuc3Vic3RyaW5nKDAsIGluZGV4KTtcbiAgICAgICAgICAgIHNvdXJjZUxpbmVzID0gaW5wdXRTb3VyY2Uuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgc291cmNlQ29sdW1ucyA9IHNvdXJjZUxpbmVzW3NvdXJjZUxpbmVzLmxlbmd0aCAtIDFdO1xuICAgICAgICB9XG5cbiAgICAgICAgbGluZXMgPSBjaHVuay5zcGxpdCgnXFxuJyk7XG4gICAgICAgIGNvbHVtbnMgPSBsaW5lc1tsaW5lcy5sZW5ndGggLSAxXTtcblxuICAgICAgICBpZiAoZmlsZUluZm8gJiYgZmlsZUluZm8uZmlsZW5hbWUpIHtcbiAgICAgICAgICAgIGlmICghbWFwTGluZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zb3VyY2VNYXBHZW5lcmF0b3IuYWRkTWFwcGluZyh7IGdlbmVyYXRlZDogeyBsaW5lOiB0aGlzLl9saW5lTnVtYmVyICsgMSwgY29sdW1uOiB0aGlzLl9jb2x1bW59LFxuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbDogeyBsaW5lOiBzb3VyY2VMaW5lcy5sZW5ndGgsIGNvbHVtbjogc291cmNlQ29sdW1ucy5sZW5ndGh9LFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHRoaXMubm9ybWFsaXplRmlsZW5hbWUoZmlsZUluZm8uZmlsZW5hbWUpfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zb3VyY2VNYXBHZW5lcmF0b3IuYWRkTWFwcGluZyh7IGdlbmVyYXRlZDogeyBsaW5lOiB0aGlzLl9saW5lTnVtYmVyICsgaSArIDEsIGNvbHVtbjogaSA9PT0gMCA/IHRoaXMuX2NvbHVtbiA6IDB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWw6IHsgbGluZTogc291cmNlTGluZXMubGVuZ3RoICsgaSwgY29sdW1uOiBpID09PSAwID8gc291cmNlQ29sdW1ucy5sZW5ndGggOiAwfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogdGhpcy5ub3JtYWxpemVGaWxlbmFtZShmaWxlSW5mby5maWxlbmFtZSl9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGluZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLl9jb2x1bW4gKz0gY29sdW1ucy5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9saW5lTnVtYmVyICs9IGxpbmVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICB0aGlzLl9jb2x1bW4gPSBjb2x1bW5zLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2Nzcy5wdXNoKGNodW5rKTtcbiAgICB9O1xuXG4gICAgU291cmNlTWFwT3V0cHV0LnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jc3MubGVuZ3RoID09PSAwO1xuICAgIH07XG5cbiAgICBTb3VyY2VNYXBPdXRwdXQucHJvdG90eXBlLnRvQ1NTID0gZnVuY3Rpb24oY29udGV4dCkge1xuICAgICAgICB0aGlzLl9zb3VyY2VNYXBHZW5lcmF0b3IgPSBuZXcgdGhpcy5fc291cmNlTWFwR2VuZXJhdG9yQ29uc3RydWN0b3IoeyBmaWxlOiB0aGlzLl9vdXRwdXRGaWxlbmFtZSwgc291cmNlUm9vdDogbnVsbCB9KTtcblxuICAgICAgICBpZiAodGhpcy5fb3V0cHV0U291cmNlRmlsZXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGZpbGVuYW1lIGluIHRoaXMuX2NvbnRlbnRzTWFwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NvbnRlbnRzTWFwLmhhc093blByb3BlcnR5KGZpbGVuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlID0gdGhpcy5fY29udGVudHNNYXBbZmlsZW5hbWVdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fY29udGVudHNJZ25vcmVkQ2hhcnNNYXBbZmlsZW5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2UgPSBzb3VyY2Uuc2xpY2UodGhpcy5fY29udGVudHNJZ25vcmVkQ2hhcnNNYXBbZmlsZW5hbWVdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zb3VyY2VNYXBHZW5lcmF0b3Iuc2V0U291cmNlQ29udGVudCh0aGlzLm5vcm1hbGl6ZUZpbGVuYW1lKGZpbGVuYW1lKSwgc291cmNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9yb290Tm9kZS5nZW5DU1MoY29udGV4dCwgdGhpcyk7XG5cbiAgICAgICAgaWYgKHRoaXMuX2Nzcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgc291cmNlTWFwVVJMLFxuICAgICAgICAgICAgICAgIHNvdXJjZU1hcENvbnRlbnQgPSBKU09OLnN0cmluZ2lmeSh0aGlzLl9zb3VyY2VNYXBHZW5lcmF0b3IudG9KU09OKCkpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5zb3VyY2VNYXBVUkwpIHtcbiAgICAgICAgICAgICAgICBzb3VyY2VNYXBVUkwgPSB0aGlzLnNvdXJjZU1hcFVSTDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fc291cmNlTWFwRmlsZW5hbWUpIHtcbiAgICAgICAgICAgICAgICBzb3VyY2VNYXBVUkwgPSB0aGlzLl9zb3VyY2VNYXBGaWxlbmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc291cmNlTWFwVVJMID0gc291cmNlTWFwVVJMO1xuXG4gICAgICAgICAgICB0aGlzLnNvdXJjZU1hcCA9IHNvdXJjZU1hcENvbnRlbnQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fY3NzLmpvaW4oJycpO1xuICAgIH07XG5cbiAgICByZXR1cm4gU291cmNlTWFwT3V0cHV0O1xufTtcblxufSx7fV0sNDk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIGNvbnRleHRzID0gcmVxdWlyZSgnLi9jb250ZXh0cycpLFxuICAgIHZpc2l0b3IgPSByZXF1aXJlKCcuL3Zpc2l0b3JzJyksXG4gICAgdHJlZSA9IHJlcXVpcmUoJy4vdHJlZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHJvb3QsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgZXZhbGRSb290LFxuICAgICAgICB2YXJpYWJsZXMgPSBvcHRpb25zLnZhcmlhYmxlcyxcbiAgICAgICAgZXZhbEVudiA9IG5ldyBjb250ZXh0cy5FdmFsKG9wdGlvbnMpO1xuXG4gICAgLy9cbiAgICAvLyBBbGxvd3Mgc2V0dGluZyB2YXJpYWJsZXMgd2l0aCBhIGhhc2gsIHNvOlxuICAgIC8vXG4gICAgLy8gICBgeyBjb2xvcjogbmV3IHRyZWUuQ29sb3IoJyNmMDEnKSB9YCB3aWxsIGJlY29tZTpcbiAgICAvL1xuICAgIC8vICAgbmV3IHRyZWUuRGVjbGFyYXRpb24oJ0Bjb2xvcicsXG4gICAgLy8gICAgIG5ldyB0cmVlLlZhbHVlKFtcbiAgICAvLyAgICAgICBuZXcgdHJlZS5FeHByZXNzaW9uKFtcbiAgICAvLyAgICAgICAgIG5ldyB0cmVlLkNvbG9yKCcjZjAxJylcbiAgICAvLyAgICAgICBdKVxuICAgIC8vICAgICBdKVxuICAgIC8vICAgKVxuICAgIC8vXG4gICAgaWYgKHR5cGVvZiB2YXJpYWJsZXMgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHZhcmlhYmxlcykpIHtcbiAgICAgICAgdmFyaWFibGVzID0gT2JqZWN0LmtleXModmFyaWFibGVzKS5tYXAoZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHZhcmlhYmxlc1trXTtcblxuICAgICAgICAgICAgaWYgKCEodmFsdWUgaW5zdGFuY2VvZiB0cmVlLlZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGlmICghKHZhbHVlIGluc3RhbmNlb2YgdHJlZS5FeHByZXNzaW9uKSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyB0cmVlLkV4cHJlc3Npb24oW3ZhbHVlXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3IHRyZWUuVmFsdWUoW3ZhbHVlXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IHRyZWUuRGVjbGFyYXRpb24oJ0AnICsgaywgdmFsdWUsIGZhbHNlLCBudWxsLCAwKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGV2YWxFbnYuZnJhbWVzID0gW25ldyB0cmVlLlJ1bGVzZXQobnVsbCwgdmFyaWFibGVzKV07XG4gICAgfVxuXG4gICAgdmFyIHZpc2l0b3JzID0gW1xuICAgICAgICAgICAgbmV3IHZpc2l0b3IuSm9pblNlbGVjdG9yVmlzaXRvcigpLFxuICAgICAgICAgICAgbmV3IHZpc2l0b3IuTWFya1Zpc2libGVTZWxlY3RvcnNWaXNpdG9yKHRydWUpLFxuICAgICAgICAgICAgbmV3IHZpc2l0b3IuRXh0ZW5kVmlzaXRvcigpLFxuICAgICAgICAgICAgbmV3IHZpc2l0b3IuVG9DU1NWaXNpdG9yKHtjb21wcmVzczogQm9vbGVhbihvcHRpb25zLmNvbXByZXNzKX0pXG4gICAgICAgIF0sIHByZUV2YWxWaXNpdG9ycyA9IFtdLCB2LCB2aXNpdG9ySXRlcmF0b3I7XG5cbiAgICAvKipcbiAgICAgKiBmaXJzdCgpIC8gZ2V0KCkgYWxsb3dzIHZpc2l0b3JzIHRvIGJlIGFkZGVkIHdoaWxlIHZpc2l0aW5nXG4gICAgICogXG4gICAgICogQHRvZG8gQWRkIHNjb3BpbmcgZm9yIHZpc2l0b3JzIGp1c3QgbGlrZSBmdW5jdGlvbnMgZm9yIEBwbHVnaW47IHJpZ2h0IG5vdyB0aGV5J3JlIGdsb2JhbFxuICAgICAqL1xuICAgIGlmIChvcHRpb25zLnBsdWdpbk1hbmFnZXIpIHtcbiAgICAgICAgdmlzaXRvckl0ZXJhdG9yID0gb3B0aW9ucy5wbHVnaW5NYW5hZ2VyLnZpc2l0b3IoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyOyBpKyspIHtcbiAgICAgICAgICAgIHZpc2l0b3JJdGVyYXRvci5maXJzdCgpO1xuICAgICAgICAgICAgd2hpbGUgKCh2ID0gdmlzaXRvckl0ZXJhdG9yLmdldCgpKSkge1xuICAgICAgICAgICAgICAgIGlmICh2LmlzUHJlRXZhbFZpc2l0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IDAgfHwgcHJlRXZhbFZpc2l0b3JzLmluZGV4T2YodikgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVFdmFsVmlzaXRvcnMucHVzaCh2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHYucnVuKHJvb3QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMCB8fCB2aXNpdG9ycy5pbmRleE9mKHYpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHYuaXNQcmVWaXNpdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlzaXRvcnMudW5zaGlmdCh2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpc2l0b3JzLnB1c2godik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgZXZhbGRSb290ID0gcm9vdC5ldmFsKGV2YWxFbnYpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aXNpdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2aXNpdG9yc1tpXS5ydW4oZXZhbGRSb290KTtcbiAgICB9XG5cbiAgICAvLyBSdW4gYW55IHJlbWFpbmluZyB2aXNpdG9ycyBhZGRlZCBhZnRlciBldmFsIHBhc3NcbiAgICBpZiAob3B0aW9ucy5wbHVnaW5NYW5hZ2VyKSB7XG4gICAgICAgIHZpc2l0b3JJdGVyYXRvci5maXJzdCgpO1xuICAgICAgICB3aGlsZSAoKHYgPSB2aXNpdG9ySXRlcmF0b3IuZ2V0KCkpKSB7XG4gICAgICAgICAgICBpZiAodmlzaXRvcnMuaW5kZXhPZih2KSA9PT0gLTEgJiYgcHJlRXZhbFZpc2l0b3JzLmluZGV4T2YodikgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdi5ydW4oZXZhbGRSb290KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBldmFsZFJvb3Q7XG59O1xuXG59LHtcIi4vY29udGV4dHNcIjoxMyxcIi4vdHJlZVwiOjY3LFwiLi92aXNpdG9yc1wiOjkzfV0sNTA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIE5vZGUgPSByZXF1aXJlKCcuL25vZGUnKTtcblxudmFyIEFub255bW91cyA9IGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgsIGN1cnJlbnRGaWxlSW5mbywgbWFwTGluZXMsIHJ1bGVzZXRMaWtlLCB2aXNpYmlsaXR5SW5mbykge1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLl9pbmRleCA9IGluZGV4O1xuICAgIHRoaXMuX2ZpbGVJbmZvID0gY3VycmVudEZpbGVJbmZvO1xuICAgIHRoaXMubWFwTGluZXMgPSBtYXBMaW5lcztcbiAgICB0aGlzLnJ1bGVzZXRMaWtlID0gKHR5cGVvZiBydWxlc2V0TGlrZSA9PT0gJ3VuZGVmaW5lZCcpID8gZmFsc2UgOiBydWxlc2V0TGlrZTtcbiAgICB0aGlzLmFsbG93Um9vdCA9IHRydWU7XG4gICAgdGhpcy5jb3B5VmlzaWJpbGl0eUluZm8odmlzaWJpbGl0eUluZm8pO1xufTtcbkFub255bW91cy5wcm90b3R5cGUgPSBuZXcgTm9kZSgpO1xuQW5vbnltb3VzLnByb3RvdHlwZS50eXBlID0gJ0Fub255bW91cyc7XG5Bbm9ueW1vdXMucHJvdG90eXBlLmV2YWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXModGhpcy52YWx1ZSwgdGhpcy5faW5kZXgsIHRoaXMuX2ZpbGVJbmZvLCB0aGlzLm1hcExpbmVzLCB0aGlzLnJ1bGVzZXRMaWtlLCB0aGlzLnZpc2liaWxpdHlJbmZvKCkpO1xufTtcbkFub255bW91cy5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgIHJldHVybiBvdGhlci50b0NTUyAmJiB0aGlzLnRvQ1NTKCkgPT09IG90aGVyLnRvQ1NTKCkgPyAwIDogdW5kZWZpbmVkO1xufTtcbkFub255bW91cy5wcm90b3R5cGUuaXNSdWxlc2V0TGlrZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnJ1bGVzZXRMaWtlO1xufTtcbkFub255bW91cy5wcm90b3R5cGUuZ2VuQ1NTID0gZnVuY3Rpb24gKGNvbnRleHQsIG91dHB1dCkge1xuICAgIHRoaXMubm9kZVZpc2libGUgPSBCb29sZWFuKHRoaXMudmFsdWUpO1xuICAgIGlmICh0aGlzLm5vZGVWaXNpYmxlKSB7XG4gICAgICAgIG91dHB1dC5hZGQodGhpcy52YWx1ZSwgdGhpcy5fZmlsZUluZm8sIHRoaXMuX2luZGV4LCB0aGlzLm1hcExpbmVzKTtcbiAgICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBBbm9ueW1vdXM7XG5cbn0se1wiLi9ub2RlXCI6NzZ9XSw1MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgTm9kZSA9IHJlcXVpcmUoJy4vbm9kZScpO1xuXG52YXIgQXNzaWdubWVudCA9IGZ1bmN0aW9uIChrZXksIHZhbCkge1xuICAgIHRoaXMua2V5ID0ga2V5O1xuICAgIHRoaXMudmFsdWUgPSB2YWw7XG59O1xuXG5Bc3NpZ25tZW50LnByb3RvdHlwZSA9IG5ldyBOb2RlKCk7XG5Bc3NpZ25tZW50LnByb3RvdHlwZS50eXBlID0gJ0Fzc2lnbm1lbnQnO1xuQXNzaWdubWVudC5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24gKHZpc2l0b3IpIHtcbiAgICB0aGlzLnZhbHVlID0gdmlzaXRvci52aXNpdCh0aGlzLnZhbHVlKTtcbn07XG5Bc3NpZ25tZW50LnByb3RvdHlwZS5ldmFsID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICBpZiAodGhpcy52YWx1ZS5ldmFsKSB7XG4gICAgICAgIHJldHVybiBuZXcgQXNzaWdubWVudCh0aGlzLmtleSwgdGhpcy52YWx1ZS5ldmFsKGNvbnRleHQpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuQXNzaWdubWVudC5wcm90b3R5cGUuZ2VuQ1NTID0gZnVuY3Rpb24gKGNvbnRleHQsIG91dHB1dCkge1xuICAgIG91dHB1dC5hZGQodGhpcy5rZXkgKyAnPScpO1xuICAgIGlmICh0aGlzLnZhbHVlLmdlbkNTUykge1xuICAgICAgICB0aGlzLnZhbHVlLmdlbkNTUyhjb250ZXh0LCBvdXRwdXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG91dHB1dC5hZGQodGhpcy52YWx1ZSk7XG4gICAgfVxufTtcbm1vZHVsZS5leHBvcnRzID0gQXNzaWdubWVudDtcblxufSx7XCIuL25vZGVcIjo3Nn1dLDUyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBOb2RlID0gcmVxdWlyZSgnLi9ub2RlJyksXG4gICAgU2VsZWN0b3IgPSByZXF1aXJlKCcuL3NlbGVjdG9yJyksXG4gICAgUnVsZXNldCA9IHJlcXVpcmUoJy4vcnVsZXNldCcpLFxuICAgIEFub255bW91cyA9IHJlcXVpcmUoJy4vYW5vbnltb3VzJyk7XG5cbnZhciBBdFJ1bGUgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIHJ1bGVzLCBpbmRleCwgY3VycmVudEZpbGVJbmZvLCBkZWJ1Z0luZm8sIGlzUm9vdGVkLCB2aXNpYmlsaXR5SW5mbykge1xuICAgIHZhciBpO1xuXG4gICAgdGhpcy5uYW1lICA9IG5hbWU7XG4gICAgdGhpcy52YWx1ZSA9ICh2YWx1ZSBpbnN0YW5jZW9mIE5vZGUpID8gdmFsdWUgOiAodmFsdWUgPyBuZXcgQW5vbnltb3VzKHZhbHVlKSA6IHZhbHVlKTtcbiAgICBpZiAocnVsZXMpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocnVsZXMpKSB7XG4gICAgICAgICAgICB0aGlzLnJ1bGVzID0gcnVsZXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJ1bGVzID0gW3J1bGVzXTtcbiAgICAgICAgICAgIHRoaXMucnVsZXNbMF0uc2VsZWN0b3JzID0gKG5ldyBTZWxlY3RvcihbXSwgbnVsbCwgbnVsbCwgaW5kZXgsIGN1cnJlbnRGaWxlSW5mbykpLmNyZWF0ZUVtcHR5U2VsZWN0b3JzKCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMucnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMucnVsZXNbaV0uYWxsb3dJbXBvcnRzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldFBhcmVudCh0aGlzLnJ1bGVzLCB0aGlzKTtcbiAgICB9XG4gICAgdGhpcy5faW5kZXggPSBpbmRleDtcbiAgICB0aGlzLl9maWxlSW5mbyA9IGN1cnJlbnRGaWxlSW5mbztcbiAgICB0aGlzLmRlYnVnSW5mbyA9IGRlYnVnSW5mbztcbiAgICB0aGlzLmlzUm9vdGVkID0gaXNSb290ZWQgfHwgZmFsc2U7XG4gICAgdGhpcy5jb3B5VmlzaWJpbGl0eUluZm8odmlzaWJpbGl0eUluZm8pO1xuICAgIHRoaXMuYWxsb3dSb290ID0gdHJ1ZTtcbn07XG5cbkF0UnVsZS5wcm90b3R5cGUgPSBuZXcgTm9kZSgpO1xuQXRSdWxlLnByb3RvdHlwZS50eXBlID0gJ0F0UnVsZSc7XG5BdFJ1bGUucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uICh2aXNpdG9yKSB7XG4gICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZSwgcnVsZXMgPSB0aGlzLnJ1bGVzO1xuICAgIGlmIChydWxlcykge1xuICAgICAgICB0aGlzLnJ1bGVzID0gdmlzaXRvci52aXNpdEFycmF5KHJ1bGVzKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2aXNpdG9yLnZpc2l0KHZhbHVlKTtcbiAgICB9XG59O1xuQXRSdWxlLnByb3RvdHlwZS5pc1J1bGVzZXRMaWtlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucnVsZXMgfHwgIXRoaXMuaXNDaGFyc2V0KCk7XG59O1xuQXRSdWxlLnByb3RvdHlwZS5pc0NoYXJzZXQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gJ0BjaGFyc2V0JyA9PT0gdGhpcy5uYW1lO1xufTtcbkF0UnVsZS5wcm90b3R5cGUuZ2VuQ1NTID0gZnVuY3Rpb24gKGNvbnRleHQsIG91dHB1dCkge1xuICAgIHZhciB2YWx1ZSA9IHRoaXMudmFsdWUsIHJ1bGVzID0gdGhpcy5ydWxlcztcbiAgICBvdXRwdXQuYWRkKHRoaXMubmFtZSwgdGhpcy5maWxlSW5mbygpLCB0aGlzLmdldEluZGV4KCkpO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBvdXRwdXQuYWRkKCcgJyk7XG4gICAgICAgIHZhbHVlLmdlbkNTUyhjb250ZXh0LCBvdXRwdXQpO1xuICAgIH1cbiAgICBpZiAocnVsZXMpIHtcbiAgICAgICAgdGhpcy5vdXRwdXRSdWxlc2V0KGNvbnRleHQsIG91dHB1dCwgcnVsZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG91dHB1dC5hZGQoJzsnKTtcbiAgICB9XG59O1xuQXRSdWxlLnByb3RvdHlwZS5ldmFsID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICB2YXIgbWVkaWFQYXRoQmFja3VwLCBtZWRpYUJsb2Nrc0JhY2t1cCwgdmFsdWUgPSB0aGlzLnZhbHVlLCBydWxlcyA9IHRoaXMucnVsZXM7XG5cbiAgICAvLyBtZWRpYSBzdG9yZWQgaW5zaWRlIG90aGVyIGF0cnVsZSBzaG91bGQgbm90IGJ1YmJsZSBvdmVyIGl0XG4gICAgLy8gYmFja3B1cCBtZWRpYSBidWJibGluZyBpbmZvcm1hdGlvblxuICAgIG1lZGlhUGF0aEJhY2t1cCA9IGNvbnRleHQubWVkaWFQYXRoO1xuICAgIG1lZGlhQmxvY2tzQmFja3VwID0gY29udGV4dC5tZWRpYUJsb2NrcztcbiAgICAvLyBkZWxldGVkIG1lZGlhIGJ1YmJsaW5nIGluZm9ybWF0aW9uXG4gICAgY29udGV4dC5tZWRpYVBhdGggPSBbXTtcbiAgICBjb250ZXh0Lm1lZGlhQmxvY2tzID0gW107XG5cbiAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5ldmFsKGNvbnRleHQpO1xuICAgIH1cbiAgICBpZiAocnVsZXMpIHtcbiAgICAgICAgLy8gYXNzdW1pbmcgdGhhdCB0aGVyZSBpcyBvbmx5IG9uZSBydWxlIGF0IHRoaXMgcG9pbnQgLSB0aGF0IGlzIGhvdyBwYXJzZXIgY29uc3RydWN0cyB0aGUgcnVsZVxuICAgICAgICBydWxlcyA9IFtydWxlc1swXS5ldmFsKGNvbnRleHQpXTtcbiAgICAgICAgcnVsZXNbMF0ucm9vdCA9IHRydWU7XG4gICAgfVxuICAgIC8vIHJlc3RvcmUgbWVkaWEgYnViYmxpbmcgaW5mb3JtYXRpb25cbiAgICBjb250ZXh0Lm1lZGlhUGF0aCA9IG1lZGlhUGF0aEJhY2t1cDtcbiAgICBjb250ZXh0Lm1lZGlhQmxvY2tzID0gbWVkaWFCbG9ja3NCYWNrdXA7XG5cbiAgICByZXR1cm4gbmV3IEF0UnVsZSh0aGlzLm5hbWUsIHZhbHVlLCBydWxlcyxcbiAgICAgICAgdGhpcy5nZXRJbmRleCgpLCB0aGlzLmZpbGVJbmZvKCksIHRoaXMuZGVidWdJbmZvLCB0aGlzLmlzUm9vdGVkLCB0aGlzLnZpc2liaWxpdHlJbmZvKCkpO1xufTtcbkF0UnVsZS5wcm90b3R5cGUudmFyaWFibGUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmICh0aGlzLnJ1bGVzKSB7XG4gICAgICAgIC8vIGFzc3VtaW5nIHRoYXQgdGhlcmUgaXMgb25seSBvbmUgcnVsZSBhdCB0aGlzIHBvaW50IC0gdGhhdCBpcyBob3cgcGFyc2VyIGNvbnN0cnVjdHMgdGhlIHJ1bGVcbiAgICAgICAgcmV0dXJuIFJ1bGVzZXQucHJvdG90eXBlLnZhcmlhYmxlLmNhbGwodGhpcy5ydWxlc1swXSwgbmFtZSk7XG4gICAgfVxufTtcbkF0UnVsZS5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5ydWxlcykge1xuICAgICAgICAvLyBhc3N1bWluZyB0aGF0IHRoZXJlIGlzIG9ubHkgb25lIHJ1bGUgYXQgdGhpcyBwb2ludCAtIHRoYXQgaXMgaG93IHBhcnNlciBjb25zdHJ1Y3RzIHRoZSBydWxlXG4gICAgICAgIHJldHVybiBSdWxlc2V0LnByb3RvdHlwZS5maW5kLmFwcGx5KHRoaXMucnVsZXNbMF0sIGFyZ3VtZW50cyk7XG4gICAgfVxufTtcbkF0UnVsZS5wcm90b3R5cGUucnVsZXNldHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMucnVsZXMpIHtcbiAgICAgICAgLy8gYXNzdW1pbmcgdGhhdCB0aGVyZSBpcyBvbmx5IG9uZSBydWxlIGF0IHRoaXMgcG9pbnQgLSB0aGF0IGlzIGhvdyBwYXJzZXIgY29uc3RydWN0cyB0aGUgcnVsZVxuICAgICAgICByZXR1cm4gUnVsZXNldC5wcm90b3R5cGUucnVsZXNldHMuYXBwbHkodGhpcy5ydWxlc1swXSk7XG4gICAgfVxufTtcbkF0UnVsZS5wcm90b3R5cGUub3V0cHV0UnVsZXNldCA9IGZ1bmN0aW9uIChjb250ZXh0LCBvdXRwdXQsIHJ1bGVzKSB7XG4gICAgdmFyIHJ1bGVDbnQgPSBydWxlcy5sZW5ndGgsIGk7XG4gICAgY29udGV4dC50YWJMZXZlbCA9IChjb250ZXh0LnRhYkxldmVsIHwgMCkgKyAxO1xuXG4gICAgLy8gQ29tcHJlc3NlZFxuICAgIGlmIChjb250ZXh0LmNvbXByZXNzKSB7XG4gICAgICAgIG91dHB1dC5hZGQoJ3snKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHJ1bGVDbnQ7IGkrKykge1xuICAgICAgICAgICAgcnVsZXNbaV0uZ2VuQ1NTKGNvbnRleHQsIG91dHB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0LmFkZCgnfScpO1xuICAgICAgICBjb250ZXh0LnRhYkxldmVsLS07XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBOb24tY29tcHJlc3NlZFxuICAgIHZhciB0YWJTZXRTdHIgPSAnXFxuJyArIEFycmF5KGNvbnRleHQudGFiTGV2ZWwpLmpvaW4oJyAgJyksIHRhYlJ1bGVTdHIgPSB0YWJTZXRTdHIgKyAnICAnO1xuICAgIGlmICghcnVsZUNudCkge1xuICAgICAgICBvdXRwdXQuYWRkKCcgeycgKyB0YWJTZXRTdHIgKyAnfScpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG91dHB1dC5hZGQoJyB7JyArIHRhYlJ1bGVTdHIpO1xuICAgICAgICBydWxlc1swXS5nZW5DU1MoY29udGV4dCwgb3V0cHV0KTtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IHJ1bGVDbnQ7IGkrKykge1xuICAgICAgICAgICAgb3V0cHV0LmFkZCh0YWJSdWxlU3RyKTtcbiAgICAgICAgICAgIHJ1bGVzW2ldLmdlbkNTUyhjb250ZXh0LCBvdXRwdXQpO1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dC5hZGQodGFiU2V0U3RyICsgJ30nKTtcbiAgICB9XG5cbiAgICBjb250ZXh0LnRhYkxldmVsLS07XG59O1xubW9kdWxlLmV4cG9ydHMgPSBBdFJ1bGU7XG5cbn0se1wiLi9hbm9ueW1vdXNcIjo1MCxcIi4vbm9kZVwiOjc2LFwiLi9ydWxlc2V0XCI6ODEsXCIuL3NlbGVjdG9yXCI6ODJ9XSw1MzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgTm9kZSA9IHJlcXVpcmUoJy4vbm9kZScpO1xuXG52YXIgQXR0cmlidXRlID0gZnVuY3Rpb24gKGtleSwgb3AsIHZhbHVlKSB7XG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgdGhpcy5vcCA9IG9wO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbn07XG5BdHRyaWJ1dGUucHJvdG90eXBlID0gbmV3IE5vZGUoKTtcbkF0dHJpYnV0ZS5wcm90b3R5cGUudHlwZSA9ICdBdHRyaWJ1dGUnO1xuQXR0cmlidXRlLnByb3RvdHlwZS5ldmFsID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICByZXR1cm4gbmV3IEF0dHJpYnV0ZSh0aGlzLmtleS5ldmFsID8gdGhpcy5rZXkuZXZhbChjb250ZXh0KSA6IHRoaXMua2V5LFxuICAgICAgICB0aGlzLm9wLCAodGhpcy52YWx1ZSAmJiB0aGlzLnZhbHVlLmV2YWwpID8gdGhpcy52YWx1ZS5ldmFsKGNvbnRleHQpIDogdGhpcy52YWx1ZSk7XG59O1xuQXR0cmlidXRlLnByb3RvdHlwZS5nZW5DU1MgPSBmdW5jdGlvbiAoY29udGV4dCwgb3V0cHV0KSB7XG4gICAgb3V0cHV0LmFkZCh0aGlzLnRvQ1NTKGNvbnRleHQpKTtcbn07XG5BdHRyaWJ1dGUucHJvdG90eXBlLnRvQ1NTID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLmtleS50b0NTUyA/IHRoaXMua2V5LnRvQ1NTKGNvbnRleHQpIDogdGhpcy5rZXk7XG5cbiAgICBpZiAodGhpcy5vcCkge1xuICAgICAgICB2YWx1ZSArPSB0aGlzLm9wO1xuICAgICAgICB2YWx1ZSArPSAodGhpcy52YWx1ZS50b0NTUyA/IHRoaXMudmFsdWUudG9DU1MoY29udGV4dCkgOiB0aGlzLnZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gJ1snICsgdmFsdWUgKyAnXSc7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBBdHRyaWJ1dGU7XG5cbn0se1wiLi9ub2RlXCI6NzZ9XSw1NDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgTm9kZSA9IHJlcXVpcmUoJy4vbm9kZScpLFxuICAgIEFub255bW91cyA9IHJlcXVpcmUoJy4vYW5vbnltb3VzJyksXG4gICAgRnVuY3Rpb25DYWxsZXIgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvZnVuY3Rpb24tY2FsbGVyJyk7XG4vL1xuLy8gQSBmdW5jdGlvbiBjYWxsIG5vZGUuXG4vL1xudmFyIENhbGwgPSBmdW5jdGlvbiAobmFtZSwgYXJncywgaW5kZXgsIGN1cnJlbnRGaWxlSW5mbykge1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5hcmdzID0gYXJncztcbiAgICB0aGlzLmNhbGMgPSBuYW1lID09PSAnY2FsYyc7XG4gICAgdGhpcy5faW5kZXggPSBpbmRleDtcbiAgICB0aGlzLl9maWxlSW5mbyA9IGN1cnJlbnRGaWxlSW5mbztcbn07XG5DYWxsLnByb3RvdHlwZSA9IG5ldyBOb2RlKCk7XG5DYWxsLnByb3RvdHlwZS50eXBlID0gJ0NhbGwnO1xuQ2FsbC5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24gKHZpc2l0b3IpIHtcbiAgICBpZiAodGhpcy5hcmdzKSB7XG4gICAgICAgIHRoaXMuYXJncyA9IHZpc2l0b3IudmlzaXRBcnJheSh0aGlzLmFyZ3MpO1xuICAgIH1cbn07XG4vL1xuLy8gV2hlbiBldmFsdWF0aW5nIGEgZnVuY3Rpb24gY2FsbCxcbi8vIHdlIGVpdGhlciBmaW5kIHRoZSBmdW5jdGlvbiBpbiB0aGUgZnVuY3Rpb25SZWdpc3RyeSxcbi8vIGluIHdoaWNoIGNhc2Ugd2UgY2FsbCBpdCwgcGFzc2luZyB0aGUgIGV2YWx1YXRlZCBhcmd1bWVudHMsXG4vLyBpZiB0aGlzIHJldHVybnMgbnVsbCBvciB3ZSBjYW5ub3QgZmluZCB0aGUgZnVuY3Rpb24sIHdlXG4vLyBzaW1wbHkgcHJpbnQgaXQgb3V0IGFzIGl0IGFwcGVhcmVkIG9yaWdpbmFsbHkgWzJdLlxuLy9cbi8vIFRoZSByZWFzb24gd2h5IHdlIGV2YWx1YXRlIHRoZSBhcmd1bWVudHMsIGlzIGluIHRoZSBjYXNlIHdoZXJlXG4vLyB3ZSB0cnkgdG8gcGFzcyBhIHZhcmlhYmxlIHRvIGEgZnVuY3Rpb24sIGxpa2U6IGBzYXR1cmF0ZShAY29sb3IpYC5cbi8vIFRoZSBmdW5jdGlvbiBzaG91bGQgcmVjZWl2ZSB0aGUgdmFsdWUsIG5vdCB0aGUgdmFyaWFibGUuXG4vL1xuQ2FsbC5wcm90b3R5cGUuZXZhbCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgLyoqXG4gICAgICogVHVybiBvZmYgbWF0aCBmb3IgY2FsYygpLCBhbmQgc3dpdGNoIGJhY2sgb24gZm9yIGV2YWx1YXRpbmcgbmVzdGVkIGZ1bmN0aW9uc1xuICAgICAqL1xuICAgIHZhciBjdXJyZW50TWF0aENvbnRleHQgPSBjb250ZXh0Lm1hdGhPbjtcbiAgICBjb250ZXh0Lm1hdGhPbiA9ICF0aGlzLmNhbGM7XG4gICAgaWYgKHRoaXMuY2FsYyB8fCBjb250ZXh0LmluQ2FsYykge1xuICAgICAgICBjb250ZXh0LmVudGVyQ2FsYygpO1xuICAgIH1cbiAgICB2YXIgYXJncyA9IHRoaXMuYXJncy5tYXAoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGEuZXZhbChjb250ZXh0KTsgfSk7XG4gICAgaWYgKHRoaXMuY2FsYyB8fCBjb250ZXh0LmluQ2FsYykge1xuICAgICAgICBjb250ZXh0LmV4aXRDYWxjKCk7XG4gICAgfVxuICAgIGNvbnRleHQubWF0aE9uID0gY3VycmVudE1hdGhDb250ZXh0O1xuXG4gICAgdmFyIHJlc3VsdCwgZnVuY0NhbGxlciA9IG5ldyBGdW5jdGlvbkNhbGxlcih0aGlzLm5hbWUsIGNvbnRleHQsIHRoaXMuZ2V0SW5kZXgoKSwgdGhpcy5maWxlSW5mbygpKTtcbiAgICBcbiAgICBpZiAoZnVuY0NhbGxlci5pc1ZhbGlkKCkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmNDYWxsZXIuY2FsbChhcmdzKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgeyBcbiAgICAgICAgICAgICAgICB0eXBlOiBlLnR5cGUgfHwgJ1J1bnRpbWUnLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdlcnJvciBldmFsdWF0aW5nIGZ1bmN0aW9uIGAnICsgdGhpcy5uYW1lICsgJ2AnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAoZS5tZXNzYWdlID8gJzogJyArIGUubWVzc2FnZSA6ICcnKSxcbiAgICAgICAgICAgICAgICBpbmRleDogdGhpcy5nZXRJbmRleCgpLCBcbiAgICAgICAgICAgICAgICBmaWxlbmFtZTogdGhpcy5maWxlSW5mbygpLmZpbGVuYW1lLFxuICAgICAgICAgICAgICAgIGxpbmU6IGUubGluZU51bWJlcixcbiAgICAgICAgICAgICAgICBjb2x1bW46IGUuY29sdW1uTnVtYmVyXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlc3VsdCAhPT0gbnVsbCAmJiByZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gUmVzdWx0cyB0aGF0IHRoYXQgYXJlIG5vdCBub2RlcyBhcmUgY2FzdCBhcyBBbm9ueW1vdXMgbm9kZXNcbiAgICAgICAgICAgIC8vIEZhbHN5IHZhbHVlcyBvciBib29sZWFucyBhcmUgcmV0dXJuZWQgYXMgZW1wdHkgbm9kZXNcbiAgICAgICAgICAgIGlmICghKHJlc3VsdCBpbnN0YW5jZW9mIE5vZGUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQgfHwgcmVzdWx0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBBbm9ueW1vdXMobnVsbCk7IFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEFub255bW91cyhyZXN1bHQudG9TdHJpbmcoKSk7IFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5faW5kZXggPSB0aGlzLl9pbmRleDtcbiAgICAgICAgICAgIHJlc3VsdC5fZmlsZUluZm8gPSB0aGlzLl9maWxlSW5mbztcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHJldHVybiBuZXcgQ2FsbCh0aGlzLm5hbWUsIGFyZ3MsIHRoaXMuZ2V0SW5kZXgoKSwgdGhpcy5maWxlSW5mbygpKTtcbn07XG5DYWxsLnByb3RvdHlwZS5nZW5DU1MgPSBmdW5jdGlvbiAoY29udGV4dCwgb3V0cHV0KSB7XG4gICAgb3V0cHV0LmFkZCh0aGlzLm5hbWUgKyAnKCcsIHRoaXMuZmlsZUluZm8oKSwgdGhpcy5nZXRJbmRleCgpKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuYXJnc1tpXS5nZW5DU1MoY29udGV4dCwgb3V0cHV0KTtcbiAgICAgICAgaWYgKGkgKyAxIDwgdGhpcy5hcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgb3V0cHV0LmFkZCgnLCAnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG91dHB1dC5hZGQoJyknKTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IENhbGw7XG5cbn0se1wiLi4vZnVuY3Rpb25zL2Z1bmN0aW9uLWNhbGxlclwiOjI2LFwiLi9hbm9ueW1vdXNcIjo1MCxcIi4vbm9kZVwiOjc2fV0sNTU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIE5vZGUgPSByZXF1aXJlKCcuL25vZGUnKSxcbiAgICBjb2xvcnMgPSByZXF1aXJlKCcuLi9kYXRhL2NvbG9ycycpO1xuXG4vL1xuLy8gUkdCIENvbG9ycyAtICNmZjAwMTQsICNlZWVcbi8vXG52YXIgQ29sb3IgPSBmdW5jdGlvbiAocmdiLCBhLCBvcmlnaW5hbEZvcm0pIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgLy9cbiAgICAvLyBUaGUgZW5kIGdvYWwgaGVyZSwgaXMgdG8gcGFyc2UgdGhlIGFyZ3VtZW50c1xuICAgIC8vIGludG8gYW4gaW50ZWdlciB0cmlwbGV0LCBzdWNoIGFzIGAxMjgsIDI1NSwgMGBcbiAgICAvL1xuICAgIC8vIFRoaXMgZmFjaWxpdGF0ZXMgb3BlcmF0aW9ucyBhbmQgY29udmVyc2lvbnMuXG4gICAgLy9cbiAgICBpZiAoQXJyYXkuaXNBcnJheShyZ2IpKSB7XG4gICAgICAgIHRoaXMucmdiID0gcmdiO1xuICAgIH0gZWxzZSBpZiAocmdiLmxlbmd0aCA+PSA2KSB7XG4gICAgICAgIHRoaXMucmdiID0gW107XG4gICAgICAgIHJnYi5tYXRjaCgvLnsyfS9nKS5tYXAoZnVuY3Rpb24gKGMsIGkpIHtcbiAgICAgICAgICAgIGlmIChpIDwgMykge1xuICAgICAgICAgICAgICAgIHNlbGYucmdiLnB1c2gocGFyc2VJbnQoYywgMTYpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VsZi5hbHBoYSA9IChwYXJzZUludChjLCAxNikpIC8gMjU1O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJnYiA9IFtdO1xuICAgICAgICByZ2Iuc3BsaXQoJycpLm1hcChmdW5jdGlvbiAoYywgaSkge1xuICAgICAgICAgICAgaWYgKGkgPCAzKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5yZ2IucHVzaChwYXJzZUludChjICsgYywgMTYpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VsZi5hbHBoYSA9IChwYXJzZUludChjICsgYywgMTYpKSAvIDI1NTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuYWxwaGEgPSB0aGlzLmFscGhhIHx8ICh0eXBlb2YgYSA9PT0gJ251bWJlcicgPyBhIDogMSk7XG4gICAgaWYgKHR5cGVvZiBvcmlnaW5hbEZvcm0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSBvcmlnaW5hbEZvcm07XG4gICAgfVxufTtcblxuQ29sb3IucHJvdG90eXBlID0gbmV3IE5vZGUoKTtcbkNvbG9yLnByb3RvdHlwZS50eXBlID0gJ0NvbG9yJztcblxuZnVuY3Rpb24gY2xhbXAodiwgbWF4KSB7XG4gICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KHYsIDApLCBtYXgpO1xufVxuXG5mdW5jdGlvbiB0b0hleCh2KSB7XG4gICAgcmV0dXJuICcjJyArIHYubWFwKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGMgPSBjbGFtcChNYXRoLnJvdW5kKGMpLCAyNTUpO1xuICAgICAgICByZXR1cm4gKGMgPCAxNiA/ICcwJyA6ICcnKSArIGMudG9TdHJpbmcoMTYpO1xuICAgIH0pLmpvaW4oJycpO1xufVxuXG5Db2xvci5wcm90b3R5cGUubHVtYSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgciA9IHRoaXMucmdiWzBdIC8gMjU1LFxuICAgICAgICBnID0gdGhpcy5yZ2JbMV0gLyAyNTUsXG4gICAgICAgIGIgPSB0aGlzLnJnYlsyXSAvIDI1NTtcblxuICAgIHIgPSAociA8PSAwLjAzOTI4KSA/IHIgLyAxMi45MiA6IE1hdGgucG93KCgociArIDAuMDU1KSAvIDEuMDU1KSwgMi40KTtcbiAgICBnID0gKGcgPD0gMC4wMzkyOCkgPyBnIC8gMTIuOTIgOiBNYXRoLnBvdygoKGcgKyAwLjA1NSkgLyAxLjA1NSksIDIuNCk7XG4gICAgYiA9IChiIDw9IDAuMDM5MjgpID8gYiAvIDEyLjkyIDogTWF0aC5wb3coKChiICsgMC4wNTUpIC8gMS4wNTUpLCAyLjQpO1xuXG4gICAgcmV0dXJuIDAuMjEyNiAqIHIgKyAwLjcxNTIgKiBnICsgMC4wNzIyICogYjtcbn07XG5Db2xvci5wcm90b3R5cGUuZ2VuQ1NTID0gZnVuY3Rpb24gKGNvbnRleHQsIG91dHB1dCkge1xuICAgIG91dHB1dC5hZGQodGhpcy50b0NTUyhjb250ZXh0KSk7XG59O1xuQ29sb3IucHJvdG90eXBlLnRvQ1NTID0gZnVuY3Rpb24gKGNvbnRleHQsIGRvTm90Q29tcHJlc3MpIHtcbiAgICB2YXIgY29tcHJlc3MgPSBjb250ZXh0ICYmIGNvbnRleHQuY29tcHJlc3MgJiYgIWRvTm90Q29tcHJlc3MsIGNvbG9yLCBhbHBoYSxcbiAgICAgICAgY29sb3JGdW5jdGlvbiwgYXJncyA9IFtdO1xuXG4gICAgLy8gYHZhbHVlYCBpcyBzZXQgaWYgdGhpcyBjb2xvciB3YXMgb3JpZ2luYWxseVxuICAgIC8vIGNvbnZlcnRlZCBmcm9tIGEgbmFtZWQgY29sb3Igc3RyaW5nIHNvIHdlIG5lZWRcbiAgICAvLyB0byByZXNwZWN0IHRoaXMgYW5kIHRyeSB0byBvdXRwdXQgbmFtZWQgY29sb3IgdG9vLlxuICAgIGFscGhhID0gdGhpcy5mcm91bmQoY29udGV4dCwgdGhpcy5hbHBoYSk7XG5cbiAgICBpZiAodGhpcy52YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy52YWx1ZS5pbmRleE9mKCdyZ2InKSA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKGFscGhhIDwgMSkge1xuICAgICAgICAgICAgICAgIGNvbG9yRnVuY3Rpb24gPSAncmdiYSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy52YWx1ZS5pbmRleE9mKCdoc2wnKSA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKGFscGhhIDwgMSkge1xuICAgICAgICAgICAgICAgIGNvbG9yRnVuY3Rpb24gPSAnaHNsYSc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbG9yRnVuY3Rpb24gPSAnaHNsJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGFscGhhIDwgMSkge1xuICAgICAgICAgICAgY29sb3JGdW5jdGlvbiA9ICdyZ2JhJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAoY29sb3JGdW5jdGlvbikge1xuICAgICAgICBjYXNlICdyZ2JhJzpcbiAgICAgICAgICAgIGFyZ3MgPSB0aGlzLnJnYi5tYXAoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xhbXAoTWF0aC5yb3VuZChjKSwgMjU1KTtcbiAgICAgICAgICAgIH0pLmNvbmNhdChjbGFtcChhbHBoYSwgMSkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2hzbGEnOlxuICAgICAgICAgICAgYXJncy5wdXNoKGNsYW1wKGFscGhhLCAxKSk7XG4gICAgICAgIGNhc2UgJ2hzbCc6XG4gICAgICAgICAgICBjb2xvciA9IHRoaXMudG9IU0woKTtcbiAgICAgICAgICAgIGFyZ3MgPSBbXG4gICAgICAgICAgICAgICAgdGhpcy5mcm91bmQoY29udGV4dCwgY29sb3IuaCksXG4gICAgICAgICAgICAgICAgdGhpcy5mcm91bmQoY29udGV4dCwgY29sb3IucyAqIDEwMCkgKyAnJScsXG4gICAgICAgICAgICAgICAgdGhpcy5mcm91bmQoY29udGV4dCwgY29sb3IubCAqIDEwMCkgKyAnJSdcbiAgICAgICAgICAgIF0uY29uY2F0KGFyZ3MpO1xuICAgIH1cblxuICAgIGlmIChjb2xvckZ1bmN0aW9uKSB7XG4gICAgICAgIC8vIFZhbHVlcyBhcmUgY2FwcGVkIGJldHdlZW4gYDBgIGFuZCBgMjU1YCwgcm91bmRlZCBhbmQgemVyby1wYWRkZWQuXG4gICAgICAgIHJldHVybiBjb2xvckZ1bmN0aW9uICsgJygnICsgYXJncy5qb2luKCcsJyArIChjb21wcmVzcyA/ICcnIDogJyAnKSkgKyAnKSc7XG4gICAgfVxuXG4gICAgY29sb3IgPSB0aGlzLnRvUkdCKCk7XG5cbiAgICBpZiAoY29tcHJlc3MpIHtcbiAgICAgICAgdmFyIHNwbGl0Y29sb3IgPSBjb2xvci5zcGxpdCgnJyk7XG5cbiAgICAgICAgLy8gQ29udmVydCBjb2xvciB0byBzaG9ydCBmb3JtYXRcbiAgICAgICAgaWYgKHNwbGl0Y29sb3JbMV0gPT09IHNwbGl0Y29sb3JbMl0gJiYgc3BsaXRjb2xvclszXSA9PT0gc3BsaXRjb2xvcls0XSAmJiBzcGxpdGNvbG9yWzVdID09PSBzcGxpdGNvbG9yWzZdKSB7XG4gICAgICAgICAgICBjb2xvciA9ICcjJyArIHNwbGl0Y29sb3JbMV0gKyBzcGxpdGNvbG9yWzNdICsgc3BsaXRjb2xvcls1XTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjb2xvcjtcbn07XG5cbi8vXG4vLyBPcGVyYXRpb25zIGhhdmUgdG8gYmUgZG9uZSBwZXItY2hhbm5lbCwgaWYgbm90LFxuLy8gY2hhbm5lbHMgd2lsbCBzcGlsbCBvbnRvIGVhY2ggb3RoZXIuIE9uY2Ugd2UgaGF2ZVxuLy8gb3VyIHJlc3VsdCwgaW4gdGhlIGZvcm0gb2YgYW4gaW50ZWdlciB0cmlwbGV0LFxuLy8gd2UgY3JlYXRlIGEgbmV3IENvbG9yIG5vZGUgdG8gaG9sZCB0aGUgcmVzdWx0LlxuLy9cbkNvbG9yLnByb3RvdHlwZS5vcGVyYXRlID0gZnVuY3Rpb24gKGNvbnRleHQsIG9wLCBvdGhlcikge1xuICAgIHZhciByZ2IgPSBuZXcgQXJyYXkoMyk7XG4gICAgdmFyIGFscGhhID0gdGhpcy5hbHBoYSAqICgxIC0gb3RoZXIuYWxwaGEpICsgb3RoZXIuYWxwaGE7XG4gICAgZm9yICh2YXIgYyA9IDA7IGMgPCAzOyBjKyspIHtcbiAgICAgICAgcmdiW2NdID0gdGhpcy5fb3BlcmF0ZShjb250ZXh0LCBvcCwgdGhpcy5yZ2JbY10sIG90aGVyLnJnYltjXSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQ29sb3IocmdiLCBhbHBoYSk7XG59O1xuQ29sb3IucHJvdG90eXBlLnRvUkdCID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0b0hleCh0aGlzLnJnYik7XG59O1xuQ29sb3IucHJvdG90eXBlLnRvSFNMID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByID0gdGhpcy5yZ2JbMF0gLyAyNTUsXG4gICAgICAgIGcgPSB0aGlzLnJnYlsxXSAvIDI1NSxcbiAgICAgICAgYiA9IHRoaXMucmdiWzJdIC8gMjU1LFxuICAgICAgICBhID0gdGhpcy5hbHBoYTtcblxuICAgIHZhciBtYXggPSBNYXRoLm1heChyLCBnLCBiKSwgbWluID0gTWF0aC5taW4ociwgZywgYik7XG4gICAgdmFyIGgsIHMsIGwgPSAobWF4ICsgbWluKSAvIDIsIGQgPSBtYXggLSBtaW47XG5cbiAgICBpZiAobWF4ID09PSBtaW4pIHtcbiAgICAgICAgaCA9IHMgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHMgPSBsID4gMC41ID8gZCAvICgyIC0gbWF4IC0gbWluKSA6IGQgLyAobWF4ICsgbWluKTtcblxuICAgICAgICBzd2l0Y2ggKG1heCkge1xuICAgICAgICAgICAgY2FzZSByOiBoID0gKGcgLSBiKSAvIGQgKyAoZyA8IGIgPyA2IDogMCk7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBnOiBoID0gKGIgLSByKSAvIGQgKyAyOyAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBiOiBoID0gKHIgLSBnKSAvIGQgKyA0OyAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGggLz0gNjtcbiAgICB9XG4gICAgcmV0dXJuIHsgaDogaCAqIDM2MCwgczogcywgbDogbCwgYTogYSB9O1xufTtcbi8vIEFkYXB0ZWQgZnJvbSBodHRwOi8vbWppamFja3Nvbi5jb20vMjAwOC8wMi9yZ2ItdG8taHNsLWFuZC1yZ2ItdG8taHN2LWNvbG9yLW1vZGVsLWNvbnZlcnNpb24tYWxnb3JpdGhtcy1pbi1qYXZhc2NyaXB0XG5Db2xvci5wcm90b3R5cGUudG9IU1YgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHIgPSB0aGlzLnJnYlswXSAvIDI1NSxcbiAgICAgICAgZyA9IHRoaXMucmdiWzFdIC8gMjU1LFxuICAgICAgICBiID0gdGhpcy5yZ2JbMl0gLyAyNTUsXG4gICAgICAgIGEgPSB0aGlzLmFscGhhO1xuXG4gICAgdmFyIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpLCBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKTtcbiAgICB2YXIgaCwgcywgdiA9IG1heDtcblxuICAgIHZhciBkID0gbWF4IC0gbWluO1xuICAgIGlmIChtYXggPT09IDApIHtcbiAgICAgICAgcyA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcyA9IGQgLyBtYXg7XG4gICAgfVxuXG4gICAgaWYgKG1heCA9PT0gbWluKSB7XG4gICAgICAgIGggPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHN3aXRjaCAobWF4KSB7XG4gICAgICAgICAgICBjYXNlIHI6IGggPSAoZyAtIGIpIC8gZCArIChnIDwgYiA/IDYgOiAwKTsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGc6IGggPSAoYiAtIHIpIC8gZCArIDI7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBiOiBoID0gKHIgLSBnKSAvIGQgKyA0OyBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBoIC89IDY7XG4gICAgfVxuICAgIHJldHVybiB7IGg6IGggKiAzNjAsIHM6IHMsIHY6IHYsIGE6IGEgfTtcbn07XG5Db2xvci5wcm90b3R5cGUudG9BUkdCID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0b0hleChbdGhpcy5hbHBoYSAqIDI1NV0uY29uY2F0KHRoaXMucmdiKSk7XG59O1xuQ29sb3IucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiAoeCkge1xuICAgIHJldHVybiAoeC5yZ2IgJiZcbiAgICAgICAgeC5yZ2JbMF0gPT09IHRoaXMucmdiWzBdICYmXG4gICAgICAgIHgucmdiWzFdID09PSB0aGlzLnJnYlsxXSAmJlxuICAgICAgICB4LnJnYlsyXSA9PT0gdGhpcy5yZ2JbMl0gJiZcbiAgICAgICAgeC5hbHBoYSAgPT09IHRoaXMuYWxwaGEpID8gMCA6IHVuZGVmaW5lZDtcbn07XG5cbkNvbG9yLmZyb21LZXl3b3JkID0gZnVuY3Rpb24oa2V5d29yZCkge1xuICAgIHZhciBjLCBrZXkgPSBrZXl3b3JkLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKGNvbG9ycy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIGMgPSBuZXcgQ29sb3IoY29sb3JzW2tleV0uc2xpY2UoMSkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChrZXkgPT09ICd0cmFuc3BhcmVudCcpIHtcbiAgICAgICAgYyA9IG5ldyBDb2xvcihbMCwgMCwgMF0sIDApO1xuICAgIH1cblxuICAgIGlmIChjKSB7XG4gICAgICAgIGMudmFsdWUgPSBrZXl3b3JkO1xuICAgICAgICByZXR1cm4gYztcbiAgICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBDb2xvcjtcblxufSx7XCIuLi9kYXRhL2NvbG9yc1wiOjE0LFwiLi9ub2RlXCI6NzZ9XSw1NjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgTm9kZSA9IHJlcXVpcmUoJy4vbm9kZScpO1xuXG52YXIgQ29tYmluYXRvciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gJyAnKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSAnICc7XG4gICAgICAgIHRoaXMuZW1wdHlPcldoaXRlc3BhY2UgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZSA/IHZhbHVlLnRyaW0oKSA6ICcnO1xuICAgICAgICB0aGlzLmVtcHR5T3JXaGl0ZXNwYWNlID0gdGhpcy52YWx1ZSA9PT0gJyc7XG4gICAgfVxufTtcbkNvbWJpbmF0b3IucHJvdG90eXBlID0gbmV3IE5vZGUoKTtcbkNvbWJpbmF0b3IucHJvdG90eXBlLnR5cGUgPSAnQ29tYmluYXRvcic7XG52YXIgX25vU3BhY2VDb21iaW5hdG9ycyA9IHtcbiAgICAnJzogdHJ1ZSxcbiAgICAnICc6IHRydWUsXG4gICAgJ3wnOiB0cnVlXG59O1xuQ29tYmluYXRvci5wcm90b3R5cGUuZ2VuQ1NTID0gZnVuY3Rpb24gKGNvbnRleHQsIG91dHB1dCkge1xuICAgIHZhciBzcGFjZU9yRW1wdHkgPSAoY29udGV4dC5jb21wcmVzcyB8fCBfbm9TcGFjZUNvbWJpbmF0b3JzW3RoaXMudmFsdWVdKSA/ICcnIDogJyAnO1xuICAgIG91dHB1dC5hZGQoc3BhY2VPckVtcHR5ICsgdGhpcy52YWx1ZSArIHNwYWNlT3JFbXB0eSk7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBDb21iaW5hdG9yO1xuXG59LHtcIi4vbm9kZVwiOjc2fV0sNTc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIE5vZGUgPSByZXF1aXJlKCcuL25vZGUnKSxcbiAgICBnZXREZWJ1Z0luZm8gPSByZXF1aXJlKCcuL2RlYnVnLWluZm8nKTtcblxudmFyIENvbW1lbnQgPSBmdW5jdGlvbiAodmFsdWUsIGlzTGluZUNvbW1lbnQsIGluZGV4LCBjdXJyZW50RmlsZUluZm8pIHtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5pc0xpbmVDb21tZW50ID0gaXNMaW5lQ29tbWVudDtcbiAgICB0aGlzLl9pbmRleCA9IGluZGV4O1xuICAgIHRoaXMuX2ZpbGVJbmZvID0gY3VycmVudEZpbGVJbmZvO1xuICAgIHRoaXMuYWxsb3dSb290ID0gdHJ1ZTtcbn07XG5Db21tZW50LnByb3RvdHlwZSA9IG5ldyBOb2RlKCk7XG5Db21tZW50LnByb3RvdHlwZS50eXBlID0gJ0NvbW1lbnQnO1xuQ29tbWVudC5wcm90b3R5cGUuZ2VuQ1NTID0gZnVuY3Rpb24gKGNvbnRleHQsIG91dHB1dCkge1xuICAgIGlmICh0aGlzLmRlYnVnSW5mbykge1xuICAgICAgICBvdXRwdXQuYWRkKGdldERlYnVnSW5mbyhjb250ZXh0LCB0aGlzKSwgdGhpcy5maWxlSW5mbygpLCB0aGlzLmdldEluZGV4KCkpO1xuICAgIH1cbiAgICBvdXRwdXQuYWRkKHRoaXMudmFsdWUpO1xufTtcbkNvbW1lbnQucHJvdG90eXBlLmlzU2lsZW50ID0gZnVuY3Rpb24oY29udGV4dCkge1xuICAgIHZhciBpc0NvbXByZXNzZWQgPSBjb250ZXh0LmNvbXByZXNzICYmIHRoaXMudmFsdWVbMl0gIT09ICchJztcbiAgICByZXR1cm4gdGhpcy5pc0xpbmVDb21tZW50IHx8IGlzQ29tcHJlc3NlZDtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IENvbW1lbnQ7XG5cbn0se1wiLi9kZWJ1Zy1pbmZvXCI6NTksXCIuL25vZGVcIjo3Nn1dLDU4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBOb2RlID0gcmVxdWlyZSgnLi9ub2RlJyk7XG5cbnZhciBDb25kaXRpb24gPSBmdW5jdGlvbiAob3AsIGwsIHIsIGksIG5lZ2F0ZSkge1xuICAgIHRoaXMub3AgPSBvcC50cmltKCk7XG4gICAgdGhpcy5sdmFsdWUgPSBsO1xuICAgIHRoaXMucnZhbHVlID0gcjtcbiAgICB0aGlzLl9pbmRleCA9IGk7XG4gICAgdGhpcy5uZWdhdGUgPSBuZWdhdGU7XG59O1xuQ29uZGl0aW9uLnByb3RvdHlwZSA9IG5ldyBOb2RlKCk7XG5Db25kaXRpb24ucHJvdG90eXBlLnR5cGUgPSAnQ29uZGl0aW9uJztcbkNvbmRpdGlvbi5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24gKHZpc2l0b3IpIHtcbiAgICB0aGlzLmx2YWx1ZSA9IHZpc2l0b3IudmlzaXQodGhpcy5sdmFsdWUpO1xuICAgIHRoaXMucnZhbHVlID0gdmlzaXRvci52aXNpdCh0aGlzLnJ2YWx1ZSk7XG59O1xuQ29uZGl0aW9uLnByb3RvdHlwZS5ldmFsID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0ID0gKGZ1bmN0aW9uIChvcCwgYSwgYikge1xuICAgICAgICBzd2l0Y2ggKG9wKSB7XG4gICAgICAgICAgICBjYXNlICdhbmQnOiByZXR1cm4gYSAmJiBiO1xuICAgICAgICAgICAgY2FzZSAnb3InOiAgcmV0dXJuIGEgfHwgYjtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgc3dpdGNoIChOb2RlLmNvbXBhcmUoYSwgYikpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAtMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvcCA9PT0gJzwnIHx8IG9wID09PSAnPTwnIHx8IG9wID09PSAnPD0nO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3AgPT09ICc9JyB8fCBvcCA9PT0gJz49JyB8fCBvcCA9PT0gJz08JyB8fCBvcCA9PT0gJzw9JztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wID09PSAnPicgfHwgb3AgPT09ICc+PSc7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSkodGhpcy5vcCwgdGhpcy5sdmFsdWUuZXZhbChjb250ZXh0KSwgdGhpcy5ydmFsdWUuZXZhbChjb250ZXh0KSk7XG5cbiAgICByZXR1cm4gdGhpcy5uZWdhdGUgPyAhcmVzdWx0IDogcmVzdWx0O1xufTtcbm1vZHVsZS5leHBvcnRzID0gQ29uZGl0aW9uO1xuXG59LHtcIi4vbm9kZVwiOjc2fV0sNTk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIGRlYnVnSW5mbyA9IGZ1bmN0aW9uKGNvbnRleHQsIGN0eCwgbGluZVNlcGFyYXRvcikge1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICBpZiAoY29udGV4dC5kdW1wTGluZU51bWJlcnMgJiYgIWNvbnRleHQuY29tcHJlc3MpIHtcbiAgICAgICAgc3dpdGNoIChjb250ZXh0LmR1bXBMaW5lTnVtYmVycykge1xuICAgICAgICAgICAgY2FzZSAnY29tbWVudHMnOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGRlYnVnSW5mby5hc0NvbW1lbnQoY3R4KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21lZGlhcXVlcnknOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGRlYnVnSW5mby5hc01lZGlhUXVlcnkoY3R4KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2FsbCc6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZGVidWdJbmZvLmFzQ29tbWVudChjdHgpICsgKGxpbmVTZXBhcmF0b3IgfHwgJycpICsgZGVidWdJbmZvLmFzTWVkaWFRdWVyeShjdHgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5kZWJ1Z0luZm8uYXNDb21tZW50ID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgcmV0dXJuICcvKiBsaW5lICcgKyBjdHguZGVidWdJbmZvLmxpbmVOdW1iZXIgKyAnLCAnICsgY3R4LmRlYnVnSW5mby5maWxlTmFtZSArICcgKi9cXG4nO1xufTtcblxuZGVidWdJbmZvLmFzTWVkaWFRdWVyeSA9IGZ1bmN0aW9uKGN0eCkge1xuICAgIHZhciBmaWxlbmFtZVdpdGhQcm90b2NvbCA9IGN0eC5kZWJ1Z0luZm8uZmlsZU5hbWU7XG4gICAgaWYgKCEvXlthLXpdKzpcXC9cXC8vaS50ZXN0KGZpbGVuYW1lV2l0aFByb3RvY29sKSkge1xuICAgICAgICBmaWxlbmFtZVdpdGhQcm90b2NvbCA9ICdmaWxlOi8vJyArIGZpbGVuYW1lV2l0aFByb3RvY29sO1xuICAgIH1cbiAgICByZXR1cm4gJ0BtZWRpYSAtc2Fzcy1kZWJ1Zy1pbmZve2ZpbGVuYW1le2ZvbnQtZmFtaWx5OicgK1xuICAgICAgICBmaWxlbmFtZVdpdGhQcm90b2NvbC5yZXBsYWNlKC8oWy46XFwvXFxcXF0pL2csIGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICBpZiAoYSA9PSAnXFxcXCcpIHtcbiAgICAgICAgICAgICAgICBhID0gJ1xcLyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJ1xcXFwnICsgYTtcbiAgICAgICAgfSkgK1xuICAgICAgICAnfWxpbmV7Zm9udC1mYW1pbHk6XFxcXDAwMDAzJyArIGN0eC5kZWJ1Z0luZm8ubGluZU51bWJlciArICd9fVxcbic7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlYnVnSW5mbztcblxufSx7fV0sNjA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIE5vZGUgPSByZXF1aXJlKCcuL25vZGUnKSxcbiAgICBWYWx1ZSA9IHJlcXVpcmUoJy4vdmFsdWUnKSxcbiAgICBLZXl3b3JkID0gcmVxdWlyZSgnLi9rZXl3b3JkJyksXG4gICAgQW5vbnltb3VzID0gcmVxdWlyZSgnLi9hbm9ueW1vdXMnKSxcbiAgICBNQVRIID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzJykuTWF0aDtcblxudmFyIERlY2xhcmF0aW9uID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBpbXBvcnRhbnQsIG1lcmdlLCBpbmRleCwgY3VycmVudEZpbGVJbmZvLCBpbmxpbmUsIHZhcmlhYmxlKSB7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLnZhbHVlID0gKHZhbHVlIGluc3RhbmNlb2YgTm9kZSkgPyB2YWx1ZSA6IG5ldyBWYWx1ZShbdmFsdWUgPyBuZXcgQW5vbnltb3VzKHZhbHVlKSA6IG51bGxdKTtcbiAgICB0aGlzLmltcG9ydGFudCA9IGltcG9ydGFudCA/ICcgJyArIGltcG9ydGFudC50cmltKCkgOiAnJztcbiAgICB0aGlzLm1lcmdlID0gbWVyZ2U7XG4gICAgdGhpcy5faW5kZXggPSBpbmRleDtcbiAgICB0aGlzLl9maWxlSW5mbyA9IGN1cnJlbnRGaWxlSW5mbztcbiAgICB0aGlzLmlubGluZSA9IGlubGluZSB8fCBmYWxzZTtcbiAgICB0aGlzLnZhcmlhYmxlID0gKHZhcmlhYmxlICE9PSB1bmRlZmluZWQpID8gdmFyaWFibGVcbiAgICAgICAgOiAobmFtZS5jaGFyQXQgJiYgKG5hbWUuY2hhckF0KDApID09PSAnQCcpKTtcbiAgICB0aGlzLmFsbG93Um9vdCA9IHRydWU7XG4gICAgdGhpcy5zZXRQYXJlbnQodGhpcy52YWx1ZSwgdGhpcyk7XG59O1xuXG5mdW5jdGlvbiBldmFsTmFtZShjb250ZXh0LCBuYW1lKSB7XG4gICAgdmFyIHZhbHVlID0gJycsIGksIG4gPSBuYW1lLmxlbmd0aCxcbiAgICAgICAgb3V0cHV0ID0ge2FkZDogZnVuY3Rpb24gKHMpIHt2YWx1ZSArPSBzO319O1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgbmFtZVtpXS5ldmFsKGNvbnRleHQpLmdlbkNTUyhjb250ZXh0LCBvdXRwdXQpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5cbkRlY2xhcmF0aW9uLnByb3RvdHlwZSA9IG5ldyBOb2RlKCk7XG5EZWNsYXJhdGlvbi5wcm90b3R5cGUudHlwZSA9ICdEZWNsYXJhdGlvbic7XG5EZWNsYXJhdGlvbi5wcm90b3R5cGUuZ2VuQ1NTID0gZnVuY3Rpb24gKGNvbnRleHQsIG91dHB1dCkge1xuICAgIG91dHB1dC5hZGQodGhpcy5uYW1lICsgKGNvbnRleHQuY29tcHJlc3MgPyAnOicgOiAnOiAnKSwgdGhpcy5maWxlSW5mbygpLCB0aGlzLmdldEluZGV4KCkpO1xuICAgIHRyeSB7XG4gICAgICAgIHRoaXMudmFsdWUuZ2VuQ1NTKGNvbnRleHQsIG91dHB1dCk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGUuaW5kZXggPSB0aGlzLl9pbmRleDtcbiAgICAgICAgZS5maWxlbmFtZSA9IHRoaXMuX2ZpbGVJbmZvLmZpbGVuYW1lO1xuICAgICAgICB0aHJvdyBlO1xuICAgIH1cbiAgICBvdXRwdXQuYWRkKHRoaXMuaW1wb3J0YW50ICsgKCh0aGlzLmlubGluZSB8fCAoY29udGV4dC5sYXN0UnVsZSAmJiBjb250ZXh0LmNvbXByZXNzKSkgPyAnJyA6ICc7JyksIHRoaXMuX2ZpbGVJbmZvLCB0aGlzLl9pbmRleCk7XG59O1xuRGVjbGFyYXRpb24ucHJvdG90eXBlLmV2YWwgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHZhciBtYXRoQnlwYXNzID0gZmFsc2UsIHByZXZNYXRoLCBuYW1lID0gdGhpcy5uYW1lLCBldmFsZFZhbHVlLCB2YXJpYWJsZSA9IHRoaXMudmFyaWFibGU7XG4gICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBleHBhbmQgJ3ByaW1pdGl2ZScgbmFtZSBkaXJlY3RseSB0byBnZXRcbiAgICAgICAgLy8gdGhpbmdzIGZhc3RlciAofjEwJSBmb3IgYmVuY2htYXJrLmxlc3MpOlxuICAgICAgICBuYW1lID0gKG5hbWUubGVuZ3RoID09PSAxKSAmJiAobmFtZVswXSBpbnN0YW5jZW9mIEtleXdvcmQpID9cbiAgICAgICAgICAgICAgICBuYW1lWzBdLnZhbHVlIDogZXZhbE5hbWUoY29udGV4dCwgbmFtZSk7XG4gICAgICAgIHZhcmlhYmxlID0gZmFsc2U7IC8vIG5ldmVyIHRyZWF0IGV4cGFuZGVkIGludGVycG9sYXRpb24gYXMgbmV3IHZhcmlhYmxlIG5hbWVcbiAgICB9XG5cbiAgICAvLyBAdG9kbyByZW1vdmUgd2hlbiBwYXJlbnMtZGl2aXNpb24gaXMgZGVmYXVsdFxuICAgIGlmIChuYW1lID09PSAnZm9udCcgJiYgY29udGV4dC5tYXRoID09PSBNQVRILkFMV0FZUykge1xuICAgICAgICBtYXRoQnlwYXNzID0gdHJ1ZTtcbiAgICAgICAgcHJldk1hdGggPSBjb250ZXh0Lm1hdGg7XG4gICAgICAgIGNvbnRleHQubWF0aCA9IE1BVEguUEFSRU5TX0RJVklTSU9OO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBjb250ZXh0LmltcG9ydGFudFNjb3BlLnB1c2goe30pO1xuICAgICAgICBldmFsZFZhbHVlID0gdGhpcy52YWx1ZS5ldmFsKGNvbnRleHQpO1xuXG4gICAgICAgIGlmICghdGhpcy52YXJpYWJsZSAmJiBldmFsZFZhbHVlLnR5cGUgPT09ICdEZXRhY2hlZFJ1bGVzZXQnKSB7XG4gICAgICAgICAgICB0aHJvdyB7IG1lc3NhZ2U6ICdSdWxlc2V0cyBjYW5ub3QgYmUgZXZhbHVhdGVkIG9uIGEgcHJvcGVydHkuJyxcbiAgICAgICAgICAgICAgICBpbmRleDogdGhpcy5nZXRJbmRleCgpLCBmaWxlbmFtZTogdGhpcy5maWxlSW5mbygpLmZpbGVuYW1lIH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGltcG9ydGFudCA9IHRoaXMuaW1wb3J0YW50LFxuICAgICAgICAgICAgaW1wb3J0YW50UmVzdWx0ID0gY29udGV4dC5pbXBvcnRhbnRTY29wZS5wb3AoKTtcbiAgICAgICAgaWYgKCFpbXBvcnRhbnQgJiYgaW1wb3J0YW50UmVzdWx0LmltcG9ydGFudCkge1xuICAgICAgICAgICAgaW1wb3J0YW50ID0gaW1wb3J0YW50UmVzdWx0LmltcG9ydGFudDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgRGVjbGFyYXRpb24obmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZXZhbGRWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaW1wb3J0YW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1lcmdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdldEluZGV4KCksIHRoaXMuZmlsZUluZm8oKSwgdGhpcy5pbmxpbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZS5pbmRleCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGUuaW5kZXggPSB0aGlzLmdldEluZGV4KCk7XG4gICAgICAgICAgICBlLmZpbGVuYW1lID0gdGhpcy5maWxlSW5mbygpLmZpbGVuYW1lO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGU7XG4gICAgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICBpZiAobWF0aEJ5cGFzcykge1xuICAgICAgICAgICAgY29udGV4dC5tYXRoID0gcHJldk1hdGg7XG4gICAgICAgIH1cbiAgICB9XG59O1xuRGVjbGFyYXRpb24ucHJvdG90eXBlLm1ha2VJbXBvcnRhbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBEZWNsYXJhdGlvbih0aGlzLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICchaW1wb3J0YW50JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tZXJnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRJbmRleCgpLCB0aGlzLmZpbGVJbmZvKCksIHRoaXMuaW5saW5lKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRGVjbGFyYXRpb247XG59LHtcIi4uL2NvbnN0YW50c1wiOjEyLFwiLi9hbm9ueW1vdXNcIjo1MCxcIi4va2V5d29yZFwiOjcwLFwiLi9ub2RlXCI6NzYsXCIuL3ZhbHVlXCI6ODZ9XSw2MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgTm9kZSA9IHJlcXVpcmUoJy4vbm9kZScpLFxuICAgIGNvbnRleHRzID0gcmVxdWlyZSgnLi4vY29udGV4dHMnKSxcbiAgICB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbnZhciBEZXRhY2hlZFJ1bGVzZXQgPSBmdW5jdGlvbiAocnVsZXNldCwgZnJhbWVzKSB7XG4gICAgdGhpcy5ydWxlc2V0ID0gcnVsZXNldDtcbiAgICB0aGlzLmZyYW1lcyA9IGZyYW1lcztcbiAgICB0aGlzLnNldFBhcmVudCh0aGlzLnJ1bGVzZXQsIHRoaXMpO1xufTtcbkRldGFjaGVkUnVsZXNldC5wcm90b3R5cGUgPSBuZXcgTm9kZSgpO1xuRGV0YWNoZWRSdWxlc2V0LnByb3RvdHlwZS50eXBlID0gJ0RldGFjaGVkUnVsZXNldCc7XG5EZXRhY2hlZFJ1bGVzZXQucHJvdG90eXBlLmV2YWxGaXJzdCA9IHRydWU7XG5EZXRhY2hlZFJ1bGVzZXQucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uICh2aXNpdG9yKSB7XG4gICAgdGhpcy5ydWxlc2V0ID0gdmlzaXRvci52aXNpdCh0aGlzLnJ1bGVzZXQpO1xufTtcbkRldGFjaGVkUnVsZXNldC5wcm90b3R5cGUuZXZhbCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgdmFyIGZyYW1lcyA9IHRoaXMuZnJhbWVzIHx8IHV0aWxzLmNvcHlBcnJheShjb250ZXh0LmZyYW1lcyk7XG4gICAgcmV0dXJuIG5ldyBEZXRhY2hlZFJ1bGVzZXQodGhpcy5ydWxlc2V0LCBmcmFtZXMpO1xufTtcbkRldGFjaGVkUnVsZXNldC5wcm90b3R5cGUuY2FsbEV2YWwgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHJldHVybiB0aGlzLnJ1bGVzZXQuZXZhbCh0aGlzLmZyYW1lcyA/IG5ldyBjb250ZXh0cy5FdmFsKGNvbnRleHQsIHRoaXMuZnJhbWVzLmNvbmNhdChjb250ZXh0LmZyYW1lcykpIDogY29udGV4dCk7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBEZXRhY2hlZFJ1bGVzZXQ7XG5cbn0se1wiLi4vY29udGV4dHNcIjoxMyxcIi4uL3V0aWxzXCI6ODksXCIuL25vZGVcIjo3Nn1dLDYyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBOb2RlID0gcmVxdWlyZSgnLi9ub2RlJyksXG4gICAgdW5pdENvbnZlcnNpb25zID0gcmVxdWlyZSgnLi4vZGF0YS91bml0LWNvbnZlcnNpb25zJyksXG4gICAgVW5pdCA9IHJlcXVpcmUoJy4vdW5pdCcpLFxuICAgIENvbG9yID0gcmVxdWlyZSgnLi9jb2xvcicpO1xuXG4vL1xuLy8gQSBudW1iZXIgd2l0aCBhIHVuaXRcbi8vXG52YXIgRGltZW5zaW9uID0gZnVuY3Rpb24gKHZhbHVlLCB1bml0KSB7XG4gICAgdGhpcy52YWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICAgIGlmIChpc05hTih0aGlzLnZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RpbWVuc2lvbiBpcyBub3QgYSBudW1iZXIuJyk7XG4gICAgfVxuICAgIHRoaXMudW5pdCA9ICh1bml0ICYmIHVuaXQgaW5zdGFuY2VvZiBVbml0KSA/IHVuaXQgOlxuICAgICAgbmV3IFVuaXQodW5pdCA/IFt1bml0XSA6IHVuZGVmaW5lZCk7XG4gICAgdGhpcy5zZXRQYXJlbnQodGhpcy51bml0LCB0aGlzKTtcbn07XG5cbkRpbWVuc2lvbi5wcm90b3R5cGUgPSBuZXcgTm9kZSgpO1xuRGltZW5zaW9uLnByb3RvdHlwZS50eXBlID0gJ0RpbWVuc2lvbic7XG5EaW1lbnNpb24ucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uICh2aXNpdG9yKSB7XG4gICAgdGhpcy51bml0ID0gdmlzaXRvci52aXNpdCh0aGlzLnVuaXQpO1xufTtcbkRpbWVuc2lvbi5wcm90b3R5cGUuZXZhbCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuRGltZW5zaW9uLnByb3RvdHlwZS50b0NvbG9yID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgQ29sb3IoW3RoaXMudmFsdWUsIHRoaXMudmFsdWUsIHRoaXMudmFsdWVdKTtcbn07XG5EaW1lbnNpb24ucHJvdG90eXBlLmdlbkNTUyA9IGZ1bmN0aW9uIChjb250ZXh0LCBvdXRwdXQpIHtcbiAgICBpZiAoKGNvbnRleHQgJiYgY29udGV4dC5zdHJpY3RVbml0cykgJiYgIXRoaXMudW5pdC5pc1Npbmd1bGFyKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdWx0aXBsZSB1bml0cyBpbiBkaW1lbnNpb24uIENvcnJlY3QgdGhlIHVuaXRzIG9yIHVzZSB0aGUgdW5pdCBmdW5jdGlvbi4gQmFkIHVuaXQ6ICcgKyB0aGlzLnVuaXQudG9TdHJpbmcoKSk7XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlID0gdGhpcy5mcm91bmQoY29udGV4dCwgdGhpcy52YWx1ZSksXG4gICAgICAgIHN0clZhbHVlID0gU3RyaW5nKHZhbHVlKTtcblxuICAgIGlmICh2YWx1ZSAhPT0gMCAmJiB2YWx1ZSA8IDAuMDAwMDAxICYmIHZhbHVlID4gLTAuMDAwMDAxKSB7XG4gICAgICAgIC8vIHdvdWxkIGJlIG91dHB1dCAxZS02IGV0Yy5cbiAgICAgICAgc3RyVmFsdWUgPSB2YWx1ZS50b0ZpeGVkKDIwKS5yZXBsYWNlKC8wKyQvLCAnJyk7XG4gICAgfVxuXG4gICAgaWYgKGNvbnRleHQgJiYgY29udGV4dC5jb21wcmVzcykge1xuICAgICAgICAvLyBaZXJvIHZhbHVlcyBkb2Vzbid0IG5lZWQgYSB1bml0XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gMCAmJiB0aGlzLnVuaXQuaXNMZW5ndGgoKSkge1xuICAgICAgICAgICAgb3V0cHV0LmFkZChzdHJWYWx1ZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGbG9hdCB2YWx1ZXMgZG9lc24ndCBuZWVkIGEgbGVhZGluZyB6ZXJvXG4gICAgICAgIGlmICh2YWx1ZSA+IDAgJiYgdmFsdWUgPCAxKSB7XG4gICAgICAgICAgICBzdHJWYWx1ZSA9IChzdHJWYWx1ZSkuc3Vic3RyKDEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb3V0cHV0LmFkZChzdHJWYWx1ZSk7XG4gICAgdGhpcy51bml0LmdlbkNTUyhjb250ZXh0LCBvdXRwdXQpO1xufTtcblxuLy8gSW4gYW4gb3BlcmF0aW9uIGJldHdlZW4gdHdvIERpbWVuc2lvbnMsXG4vLyB3ZSBkZWZhdWx0IHRvIHRoZSBmaXJzdCBEaW1lbnNpb24ncyB1bml0LFxuLy8gc28gYDFweCArIDJgIHdpbGwgeWllbGQgYDNweGAuXG5EaW1lbnNpb24ucHJvdG90eXBlLm9wZXJhdGUgPSBmdW5jdGlvbiAoY29udGV4dCwgb3AsIG90aGVyKSB7XG4gICAgLyoganNoaW50IG5vZW1wdHk6ZmFsc2UgKi9cbiAgICB2YXIgdmFsdWUgPSB0aGlzLl9vcGVyYXRlKGNvbnRleHQsIG9wLCB0aGlzLnZhbHVlLCBvdGhlci52YWx1ZSksXG4gICAgICAgIHVuaXQgPSB0aGlzLnVuaXQuY2xvbmUoKTtcblxuICAgIGlmIChvcCA9PT0gJysnIHx8IG9wID09PSAnLScpIHtcbiAgICAgICAgaWYgKHVuaXQubnVtZXJhdG9yLmxlbmd0aCA9PT0gMCAmJiB1bml0LmRlbm9taW5hdG9yLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdW5pdCA9IG90aGVyLnVuaXQuY2xvbmUoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnVuaXQuYmFja3VwVW5pdCkge1xuICAgICAgICAgICAgICAgIHVuaXQuYmFja3VwVW5pdCA9IHRoaXMudW5pdC5iYWNrdXBVbml0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG90aGVyLnVuaXQubnVtZXJhdG9yLmxlbmd0aCA9PT0gMCAmJiB1bml0LmRlbm9taW5hdG9yLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gZG8gbm90aGluZ1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3RoZXIgPSBvdGhlci5jb252ZXJ0VG8odGhpcy51bml0LnVzZWRVbml0cygpKTtcblxuICAgICAgICAgICAgaWYgKGNvbnRleHQuc3RyaWN0VW5pdHMgJiYgb3RoZXIudW5pdC50b1N0cmluZygpICE9PSB1bml0LnRvU3RyaW5nKCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luY29tcGF0aWJsZSB1bml0cy4gQ2hhbmdlIHRoZSB1bml0cyBvciB1c2UgdGhlIHVuaXQgZnVuY3Rpb24uIEJhZCB1bml0czogXFwnJyArIHVuaXQudG9TdHJpbmcoKSArXG4gICAgICAgICAgICAgICAgICAgICdcXCcgYW5kIFxcJycgKyBvdGhlci51bml0LnRvU3RyaW5nKCkgKyAnXFwnLicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMuX29wZXJhdGUoY29udGV4dCwgb3AsIHRoaXMudmFsdWUsIG90aGVyLnZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAob3AgPT09ICcqJykge1xuICAgICAgICB1bml0Lm51bWVyYXRvciA9IHVuaXQubnVtZXJhdG9yLmNvbmNhdChvdGhlci51bml0Lm51bWVyYXRvcikuc29ydCgpO1xuICAgICAgICB1bml0LmRlbm9taW5hdG9yID0gdW5pdC5kZW5vbWluYXRvci5jb25jYXQob3RoZXIudW5pdC5kZW5vbWluYXRvcikuc29ydCgpO1xuICAgICAgICB1bml0LmNhbmNlbCgpO1xuICAgIH0gZWxzZSBpZiAob3AgPT09ICcvJykge1xuICAgICAgICB1bml0Lm51bWVyYXRvciA9IHVuaXQubnVtZXJhdG9yLmNvbmNhdChvdGhlci51bml0LmRlbm9taW5hdG9yKS5zb3J0KCk7XG4gICAgICAgIHVuaXQuZGVub21pbmF0b3IgPSB1bml0LmRlbm9taW5hdG9yLmNvbmNhdChvdGhlci51bml0Lm51bWVyYXRvcikuc29ydCgpO1xuICAgICAgICB1bml0LmNhbmNlbCgpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IERpbWVuc2lvbih2YWx1ZSwgdW5pdCk7XG59O1xuRGltZW5zaW9uLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgdmFyIGEsIGI7XG5cbiAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIERpbWVuc2lvbikpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy51bml0LmlzRW1wdHkoKSB8fCBvdGhlci51bml0LmlzRW1wdHkoKSkge1xuICAgICAgICBhID0gdGhpcztcbiAgICAgICAgYiA9IG90aGVyO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGEgPSB0aGlzLnVuaWZ5KCk7XG4gICAgICAgIGIgPSBvdGhlci51bmlmeSgpO1xuICAgICAgICBpZiAoYS51bml0LmNvbXBhcmUoYi51bml0KSAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBOb2RlLm51bWVyaWNDb21wYXJlKGEudmFsdWUsIGIudmFsdWUpO1xufTtcbkRpbWVuc2lvbi5wcm90b3R5cGUudW5pZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udmVydFRvKHsgbGVuZ3RoOiAncHgnLCBkdXJhdGlvbjogJ3MnLCBhbmdsZTogJ3JhZCcgfSk7XG59O1xuRGltZW5zaW9uLnByb3RvdHlwZS5jb252ZXJ0VG8gPSBmdW5jdGlvbiAoY29udmVyc2lvbnMpIHtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlLCB1bml0ID0gdGhpcy51bml0LmNsb25lKCksXG4gICAgICAgIGksIGdyb3VwTmFtZSwgZ3JvdXAsIHRhcmdldFVuaXQsIGRlcml2ZWRDb252ZXJzaW9ucyA9IHt9LCBhcHBseVVuaXQ7XG5cbiAgICBpZiAodHlwZW9mIGNvbnZlcnNpb25zID09PSAnc3RyaW5nJykge1xuICAgICAgICBmb3IgKGkgaW4gdW5pdENvbnZlcnNpb25zKSB7XG4gICAgICAgICAgICBpZiAodW5pdENvbnZlcnNpb25zW2ldLmhhc093blByb3BlcnR5KGNvbnZlcnNpb25zKSkge1xuICAgICAgICAgICAgICAgIGRlcml2ZWRDb252ZXJzaW9ucyA9IHt9O1xuICAgICAgICAgICAgICAgIGRlcml2ZWRDb252ZXJzaW9uc1tpXSA9IGNvbnZlcnNpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnZlcnNpb25zID0gZGVyaXZlZENvbnZlcnNpb25zO1xuICAgIH1cbiAgICBhcHBseVVuaXQgPSBmdW5jdGlvbiAoYXRvbWljVW5pdCwgZGVub21pbmF0b3IpIHtcbiAgICAgICAgLyoganNoaW50IGxvb3BmdW5jOnRydWUgKi9cbiAgICAgICAgaWYgKGdyb3VwLmhhc093blByb3BlcnR5KGF0b21pY1VuaXQpKSB7XG4gICAgICAgICAgICBpZiAoZGVub21pbmF0b3IpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlIC8gKGdyb3VwW2F0b21pY1VuaXRdIC8gZ3JvdXBbdGFyZ2V0VW5pdF0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlICogKGdyb3VwW2F0b21pY1VuaXRdIC8gZ3JvdXBbdGFyZ2V0VW5pdF0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0VW5pdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhdG9taWNVbml0O1xuICAgIH07XG5cbiAgICBmb3IgKGdyb3VwTmFtZSBpbiBjb252ZXJzaW9ucykge1xuICAgICAgICBpZiAoY29udmVyc2lvbnMuaGFzT3duUHJvcGVydHkoZ3JvdXBOYW1lKSkge1xuICAgICAgICAgICAgdGFyZ2V0VW5pdCA9IGNvbnZlcnNpb25zW2dyb3VwTmFtZV07XG4gICAgICAgICAgICBncm91cCA9IHVuaXRDb252ZXJzaW9uc1tncm91cE5hbWVdO1xuXG4gICAgICAgICAgICB1bml0Lm1hcChhcHBseVVuaXQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdW5pdC5jYW5jZWwoKTtcblxuICAgIHJldHVybiBuZXcgRGltZW5zaW9uKHZhbHVlLCB1bml0KTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IERpbWVuc2lvbjtcblxufSx7XCIuLi9kYXRhL3VuaXQtY29udmVyc2lvbnNcIjoxNixcIi4vY29sb3JcIjo1NSxcIi4vbm9kZVwiOjc2LFwiLi91bml0XCI6ODR9XSw2MzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgTm9kZSA9IHJlcXVpcmUoJy4vbm9kZScpLFxuICAgIFBhcmVuID0gcmVxdWlyZSgnLi9wYXJlbicpLFxuICAgIENvbWJpbmF0b3IgPSByZXF1aXJlKCcuL2NvbWJpbmF0b3InKTtcblxudmFyIEVsZW1lbnQgPSBmdW5jdGlvbiAoY29tYmluYXRvciwgdmFsdWUsIGlzVmFyaWFibGUsIGluZGV4LCBjdXJyZW50RmlsZUluZm8sIHZpc2liaWxpdHlJbmZvKSB7XG4gICAgdGhpcy5jb21iaW5hdG9yID0gY29tYmluYXRvciBpbnN0YW5jZW9mIENvbWJpbmF0b3IgP1xuICAgICAgICAgICAgICAgICAgICAgIGNvbWJpbmF0b3IgOiBuZXcgQ29tYmluYXRvcihjb21iaW5hdG9yKTtcblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZS50cmltKCk7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9ICcnO1xuICAgIH1cbiAgICB0aGlzLmlzVmFyaWFibGUgPSBpc1ZhcmlhYmxlO1xuICAgIHRoaXMuX2luZGV4ID0gaW5kZXg7XG4gICAgdGhpcy5fZmlsZUluZm8gPSBjdXJyZW50RmlsZUluZm87XG4gICAgdGhpcy5jb3B5VmlzaWJpbGl0eUluZm8odmlzaWJpbGl0eUluZm8pO1xuICAgIHRoaXMuc2V0UGFyZW50KHRoaXMuY29tYmluYXRvciwgdGhpcyk7XG59O1xuRWxlbWVudC5wcm90b3R5cGUgPSBuZXcgTm9kZSgpO1xuRWxlbWVudC5wcm90b3R5cGUudHlwZSA9ICdFbGVtZW50JztcbkVsZW1lbnQucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uICh2aXNpdG9yKSB7XG4gICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICB0aGlzLmNvbWJpbmF0b3IgPSB2aXNpdG9yLnZpc2l0KHRoaXMuY29tYmluYXRvcik7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZpc2l0b3IudmlzaXQodmFsdWUpO1xuICAgIH1cbn07XG5FbGVtZW50LnByb3RvdHlwZS5ldmFsID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICByZXR1cm4gbmV3IEVsZW1lbnQodGhpcy5jb21iaW5hdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlLmV2YWwgPyB0aGlzLnZhbHVlLmV2YWwoY29udGV4dCkgOiB0aGlzLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlzVmFyaWFibGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0SW5kZXgoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5maWxlSW5mbygpLCB0aGlzLnZpc2liaWxpdHlJbmZvKCkpO1xufTtcbkVsZW1lbnQucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgRWxlbWVudCh0aGlzLmNvbWJpbmF0b3IsXG4gICAgICAgIHRoaXMudmFsdWUsXG4gICAgICAgIHRoaXMuaXNWYXJpYWJsZSxcbiAgICAgICAgdGhpcy5nZXRJbmRleCgpLFxuICAgICAgICB0aGlzLmZpbGVJbmZvKCksIHRoaXMudmlzaWJpbGl0eUluZm8oKSk7XG59O1xuRWxlbWVudC5wcm90b3R5cGUuZ2VuQ1NTID0gZnVuY3Rpb24gKGNvbnRleHQsIG91dHB1dCkge1xuICAgIG91dHB1dC5hZGQodGhpcy50b0NTUyhjb250ZXh0KSwgdGhpcy5maWxlSW5mbygpLCB0aGlzLmdldEluZGV4KCkpO1xufTtcbkVsZW1lbnQucHJvdG90eXBlLnRvQ1NTID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICBjb250ZXh0ID0gY29udGV4dCB8fCB7fTtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlLCBmaXJzdFNlbGVjdG9yID0gY29udGV4dC5maXJzdFNlbGVjdG9yO1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFBhcmVuKSB7XG4gICAgICAgIC8vIHNlbGVjdG9yIGluIHBhcmVucyBzaG91bGQgbm90IGJlIGFmZmVjdGVkIGJ5IG91dGVyIHNlbGVjdG9yXG4gICAgICAgIC8vIGZsYWdzIChicmVha3Mgb25seSBpbnRlcnBvbGF0ZWQgc2VsZWN0b3JzIC0gc2VlICMxOTczKVxuICAgICAgICBjb250ZXh0LmZpcnN0U2VsZWN0b3IgPSB0cnVlO1xuICAgIH1cbiAgICB2YWx1ZSA9IHZhbHVlLnRvQ1NTID8gdmFsdWUudG9DU1MoY29udGV4dCkgOiB2YWx1ZTtcbiAgICBjb250ZXh0LmZpcnN0U2VsZWN0b3IgPSBmaXJzdFNlbGVjdG9yO1xuICAgIGlmICh2YWx1ZSA9PT0gJycgJiYgdGhpcy5jb21iaW5hdG9yLnZhbHVlLmNoYXJBdCgwKSA9PT0gJyYnKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21iaW5hdG9yLnRvQ1NTKGNvbnRleHQpICsgdmFsdWU7XG4gICAgfVxufTtcbm1vZHVsZS5leHBvcnRzID0gRWxlbWVudDtcblxufSx7XCIuL2NvbWJpbmF0b3JcIjo1NixcIi4vbm9kZVwiOjc2LFwiLi9wYXJlblwiOjc4fV0sNjQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIE5vZGUgPSByZXF1aXJlKCcuL25vZGUnKSxcbiAgICBQYXJlbiA9IHJlcXVpcmUoJy4vcGFyZW4nKSxcbiAgICBDb21tZW50ID0gcmVxdWlyZSgnLi9jb21tZW50JyksXG4gICAgRGltZW5zaW9uID0gcmVxdWlyZSgnLi9kaW1lbnNpb24nKSxcbiAgICBNQVRIID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzJykuTWF0aDtcblxudmFyIEV4cHJlc3Npb24gPSBmdW5jdGlvbiAodmFsdWUsIG5vU3BhY2luZykge1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLm5vU3BhY2luZyA9IG5vU3BhY2luZztcbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwcmVzc2lvbiByZXF1aXJlcyBhbiBhcnJheSBwYXJhbWV0ZXInKTtcbiAgICB9XG59O1xuRXhwcmVzc2lvbi5wcm90b3R5cGUgPSBuZXcgTm9kZSgpO1xuRXhwcmVzc2lvbi5wcm90b3R5cGUudHlwZSA9ICdFeHByZXNzaW9uJztcbkV4cHJlc3Npb24ucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uICh2aXNpdG9yKSB7XG4gICAgdGhpcy52YWx1ZSA9IHZpc2l0b3IudmlzaXRBcnJheSh0aGlzLnZhbHVlKTtcbn07XG5FeHByZXNzaW9uLnByb3RvdHlwZS5ldmFsID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICB2YXIgcmV0dXJuVmFsdWUsXG4gICAgICAgIG1hdGhPbiA9IGNvbnRleHQuaXNNYXRoT24oKSxcbiAgICAgICAgaW5QYXJlbnRoZXNpcyA9IHRoaXMucGFyZW5zICYmIFxuICAgICAgICAgICAgKGNvbnRleHQubWF0aCAhPT0gTUFUSC5TVFJJQ1RfTEVHQUNZIHx8ICF0aGlzLnBhcmVuc0luT3ApLFxuICAgICAgICBkb3VibGVQYXJlbiA9IGZhbHNlO1xuICAgIGlmIChpblBhcmVudGhlc2lzKSB7XG4gICAgICAgIGNvbnRleHQuaW5QYXJlbnRoZXNpcygpO1xuICAgIH1cbiAgICBpZiAodGhpcy52YWx1ZS5sZW5ndGggPiAxKSB7XG4gICAgICAgIHJldHVyblZhbHVlID0gbmV3IEV4cHJlc3Npb24odGhpcy52YWx1ZS5tYXAoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGlmICghZS5ldmFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZS5ldmFsKGNvbnRleHQpO1xuICAgICAgICB9KSwgdGhpcy5ub1NwYWNpbmcpO1xuICAgIH0gZWxzZSBpZiAodGhpcy52YWx1ZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWVbMF0ucGFyZW5zICYmICF0aGlzLnZhbHVlWzBdLnBhcmVuc0luT3AgJiYgIWNvbnRleHQuaW5DYWxjKSB7XG4gICAgICAgICAgICBkb3VibGVQYXJlbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuVmFsdWUgPSB0aGlzLnZhbHVlWzBdLmV2YWwoY29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuVmFsdWUgPSB0aGlzO1xuICAgIH1cbiAgICBpZiAoaW5QYXJlbnRoZXNpcykge1xuICAgICAgICBjb250ZXh0Lm91dE9mUGFyZW50aGVzaXMoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMucGFyZW5zICYmIHRoaXMucGFyZW5zSW5PcCAmJiAhbWF0aE9uICYmICFkb3VibGVQYXJlbiBcbiAgICAgICAgJiYgKCEocmV0dXJuVmFsdWUgaW5zdGFuY2VvZiBEaW1lbnNpb24pKSkge1xuICAgICAgICByZXR1cm5WYWx1ZSA9IG5ldyBQYXJlbihyZXR1cm5WYWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbn07XG5FeHByZXNzaW9uLnByb3RvdHlwZS5nZW5DU1MgPSBmdW5jdGlvbiAoY29udGV4dCwgb3V0cHV0KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMudmFsdWVbaV0uZ2VuQ1NTKGNvbnRleHQsIG91dHB1dCk7XG4gICAgICAgIGlmICghdGhpcy5ub1NwYWNpbmcgJiYgaSArIDEgPCB0aGlzLnZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgb3V0cHV0LmFkZCgnICcpO1xuICAgICAgICB9XG4gICAgfVxufTtcbkV4cHJlc3Npb24ucHJvdG90eXBlLnRocm93QXdheUNvbW1lbnRzID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMudmFsdWUgPSB0aGlzLnZhbHVlLmZpbHRlcihmdW5jdGlvbih2KSB7XG4gICAgICAgIHJldHVybiAhKHYgaW5zdGFuY2VvZiBDb21tZW50KTtcbiAgICB9KTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IEV4cHJlc3Npb247XG5cbn0se1wiLi4vY29uc3RhbnRzXCI6MTIsXCIuL2NvbW1lbnRcIjo1NyxcIi4vZGltZW5zaW9uXCI6NjIsXCIuL25vZGVcIjo3NixcIi4vcGFyZW5cIjo3OH1dLDY1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBOb2RlID0gcmVxdWlyZSgnLi9ub2RlJyksXG4gICAgU2VsZWN0b3IgPSByZXF1aXJlKCcuL3NlbGVjdG9yJyk7XG5cbnZhciBFeHRlbmQgPSBmdW5jdGlvbiBFeHRlbmQoc2VsZWN0b3IsIG9wdGlvbiwgaW5kZXgsIGN1cnJlbnRGaWxlSW5mbywgdmlzaWJpbGl0eUluZm8pIHtcbiAgICB0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3I7XG4gICAgdGhpcy5vcHRpb24gPSBvcHRpb247XG4gICAgdGhpcy5vYmplY3RfaWQgPSBFeHRlbmQubmV4dF9pZCsrO1xuICAgIHRoaXMucGFyZW50X2lkcyA9IFt0aGlzLm9iamVjdF9pZF07XG4gICAgdGhpcy5faW5kZXggPSBpbmRleDtcbiAgICB0aGlzLl9maWxlSW5mbyA9IGN1cnJlbnRGaWxlSW5mbztcbiAgICB0aGlzLmNvcHlWaXNpYmlsaXR5SW5mbyh2aXNpYmlsaXR5SW5mbyk7XG4gICAgdGhpcy5hbGxvd1Jvb3QgPSB0cnVlO1xuXG4gICAgc3dpdGNoIChvcHRpb24pIHtcbiAgICAgICAgY2FzZSAnYWxsJzpcbiAgICAgICAgICAgIHRoaXMuYWxsb3dCZWZvcmUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5hbGxvd0FmdGVyID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhpcy5hbGxvd0JlZm9yZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5hbGxvd0FmdGVyID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgdGhpcy5zZXRQYXJlbnQodGhpcy5zZWxlY3RvciwgdGhpcyk7XG59O1xuRXh0ZW5kLm5leHRfaWQgPSAwO1xuXG5FeHRlbmQucHJvdG90eXBlID0gbmV3IE5vZGUoKTtcbkV4dGVuZC5wcm90b3R5cGUudHlwZSA9ICdFeHRlbmQnO1xuRXh0ZW5kLnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbiAodmlzaXRvcikge1xuICAgIHRoaXMuc2VsZWN0b3IgPSB2aXNpdG9yLnZpc2l0KHRoaXMuc2VsZWN0b3IpO1xufTtcbkV4dGVuZC5wcm90b3R5cGUuZXZhbCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgcmV0dXJuIG5ldyBFeHRlbmQodGhpcy5zZWxlY3Rvci5ldmFsKGNvbnRleHQpLCB0aGlzLm9wdGlvbiwgdGhpcy5nZXRJbmRleCgpLCB0aGlzLmZpbGVJbmZvKCksIHRoaXMudmlzaWJpbGl0eUluZm8oKSk7XG59O1xuRXh0ZW5kLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgcmV0dXJuIG5ldyBFeHRlbmQodGhpcy5zZWxlY3RvciwgdGhpcy5vcHRpb24sIHRoaXMuZ2V0SW5kZXgoKSwgdGhpcy5maWxlSW5mbygpLCB0aGlzLnZpc2liaWxpdHlJbmZvKCkpO1xufTtcbi8vIGl0IGNvbmNhdGVuYXRlcyAoam9pbnMpIGFsbCBzZWxlY3RvcnMgaW4gc2VsZWN0b3IgYXJyYXlcbkV4dGVuZC5wcm90b3R5cGUuZmluZFNlbGZTZWxlY3RvcnMgPSBmdW5jdGlvbiAoc2VsZWN0b3JzKSB7XG4gICAgdmFyIHNlbGZFbGVtZW50cyA9IFtdLFxuICAgICAgICBpLFxuICAgICAgICBzZWxlY3RvckVsZW1lbnRzO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHNlbGVjdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzZWxlY3RvckVsZW1lbnRzID0gc2VsZWN0b3JzW2ldLmVsZW1lbnRzO1xuICAgICAgICAvLyBkdXBsaWNhdGUgdGhlIGxvZ2ljIGluIGdlbkNTUyBmdW5jdGlvbiBpbnNpZGUgdGhlIHNlbGVjdG9yIG5vZGUuXG4gICAgICAgIC8vIGZ1dHVyZSBUT0RPIC0gbW92ZSBib3RoIGxvZ2ljcyBpbnRvIHRoZSBzZWxlY3RvciBqb2luZXIgdmlzaXRvclxuICAgICAgICBpZiAoaSA+IDAgJiYgc2VsZWN0b3JFbGVtZW50cy5sZW5ndGggJiYgc2VsZWN0b3JFbGVtZW50c1swXS5jb21iaW5hdG9yLnZhbHVlID09PSAnJykge1xuICAgICAgICAgICAgc2VsZWN0b3JFbGVtZW50c1swXS5jb21iaW5hdG9yLnZhbHVlID0gJyAnO1xuICAgICAgICB9XG4gICAgICAgIHNlbGZFbGVtZW50cyA9IHNlbGZFbGVtZW50cy5jb25jYXQoc2VsZWN0b3JzW2ldLmVsZW1lbnRzKTtcbiAgICB9XG5cbiAgICB0aGlzLnNlbGZTZWxlY3RvcnMgPSBbbmV3IFNlbGVjdG9yKHNlbGZFbGVtZW50cyldO1xuICAgIHRoaXMuc2VsZlNlbGVjdG9yc1swXS5jb3B5VmlzaWJpbGl0eUluZm8odGhpcy52aXNpYmlsaXR5SW5mbygpKTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IEV4dGVuZDtcblxufSx7XCIuL25vZGVcIjo3NixcIi4vc2VsZWN0b3JcIjo4Mn1dLDY2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBOb2RlID0gcmVxdWlyZSgnLi9ub2RlJyksXG4gICAgTWVkaWEgPSByZXF1aXJlKCcuL21lZGlhJyksXG4gICAgVVJMID0gcmVxdWlyZSgnLi91cmwnKSxcbiAgICBRdW90ZWQgPSByZXF1aXJlKCcuL3F1b3RlZCcpLFxuICAgIFJ1bGVzZXQgPSByZXF1aXJlKCcuL3J1bGVzZXQnKSxcbiAgICBBbm9ueW1vdXMgPSByZXF1aXJlKCcuL2Fub255bW91cycpLFxuICAgIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKSxcbiAgICBMZXNzRXJyb3IgPSByZXF1aXJlKCcuLi9sZXNzLWVycm9yJyk7XG5cbi8vXG4vLyBDU1MgQGltcG9ydCBub2RlXG4vL1xuLy8gVGhlIGdlbmVyYWwgc3RyYXRlZ3kgaGVyZSBpcyB0aGF0IHdlIGRvbid0IHdhbnQgdG8gd2FpdFxuLy8gZm9yIHRoZSBwYXJzaW5nIHRvIGJlIGNvbXBsZXRlZCwgYmVmb3JlIHdlIHN0YXJ0IGltcG9ydGluZ1xuLy8gdGhlIGZpbGUuIFRoYXQncyBiZWNhdXNlIGluIHRoZSBjb250ZXh0IG9mIGEgYnJvd3Nlcixcbi8vIG1vc3Qgb2YgdGhlIHRpbWUgd2lsbCBiZSBzcGVudCB3YWl0aW5nIGZvciB0aGUgc2VydmVyIHRvIHJlc3BvbmQuXG4vL1xuLy8gT24gY3JlYXRpb24sIHdlIHB1c2ggdGhlIGltcG9ydCBwYXRoIHRvIG91ciBpbXBvcnQgcXVldWUsIHRob3VnaFxuLy8gYGltcG9ydCxwdXNoYCwgd2UgYWxzbyBwYXNzIGl0IGEgY2FsbGJhY2ssIHdoaWNoIGl0J2xsIGNhbGwgb25jZVxuLy8gdGhlIGZpbGUgaGFzIGJlZW4gZmV0Y2hlZCwgYW5kIHBhcnNlZC5cbi8vXG52YXIgSW1wb3J0ID0gZnVuY3Rpb24gKHBhdGgsIGZlYXR1cmVzLCBvcHRpb25zLCBpbmRleCwgY3VycmVudEZpbGVJbmZvLCB2aXNpYmlsaXR5SW5mbykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5faW5kZXggPSBpbmRleDtcbiAgICB0aGlzLl9maWxlSW5mbyA9IGN1cnJlbnRGaWxlSW5mbztcbiAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgIHRoaXMuZmVhdHVyZXMgPSBmZWF0dXJlcztcbiAgICB0aGlzLmFsbG93Um9vdCA9IHRydWU7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmxlc3MgIT09IHVuZGVmaW5lZCB8fCB0aGlzLm9wdGlvbnMuaW5saW5lKSB7XG4gICAgICAgIHRoaXMuY3NzID0gIXRoaXMub3B0aW9ucy5sZXNzIHx8IHRoaXMub3B0aW9ucy5pbmxpbmU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHBhdGhWYWx1ZSA9IHRoaXMuZ2V0UGF0aCgpO1xuICAgICAgICBpZiAocGF0aFZhbHVlICYmIC9bI1xcLlxcJlxcP11jc3MoW1xcPztdLiopPyQvLnRlc3QocGF0aFZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5jc3MgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMuY29weVZpc2liaWxpdHlJbmZvKHZpc2liaWxpdHlJbmZvKTtcbiAgICB0aGlzLnNldFBhcmVudCh0aGlzLmZlYXR1cmVzLCB0aGlzKTtcbiAgICB0aGlzLnNldFBhcmVudCh0aGlzLnBhdGgsIHRoaXMpO1xufTtcblxuLy9cbi8vIFRoZSBhY3R1YWwgaW1wb3J0IG5vZGUgZG9lc24ndCByZXR1cm4gYW55dGhpbmcsIHdoZW4gY29udmVydGVkIHRvIENTUy5cbi8vIFRoZSByZWFzb24gaXMgdGhhdCBpdCdzIHVzZWQgYXQgdGhlIGV2YWx1YXRpb24gc3RhZ2UsIHNvIHRoYXQgdGhlIHJ1bGVzXG4vLyBpdCBpbXBvcnRzIGNhbiBiZSB0cmVhdGVkIGxpa2UgYW55IG90aGVyIHJ1bGVzLlxuLy9cbi8vIEluIGBldmFsYCwgd2UgbWFrZSBzdXJlIGFsbCBJbXBvcnQgbm9kZXMgZ2V0IGV2YWx1YXRlZCwgcmVjdXJzaXZlbHksIHNvXG4vLyB3ZSBlbmQgdXAgd2l0aCBhIGZsYXQgc3RydWN0dXJlLCB3aGljaCBjYW4gZWFzaWx5IGJlIGltcG9ydGVkIGluIHRoZSBwYXJlbnRcbi8vIHJ1bGVzZXQuXG4vL1xuSW1wb3J0LnByb3RvdHlwZSA9IG5ldyBOb2RlKCk7XG5JbXBvcnQucHJvdG90eXBlLnR5cGUgPSAnSW1wb3J0JztcbkltcG9ydC5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24gKHZpc2l0b3IpIHtcbiAgICBpZiAodGhpcy5mZWF0dXJlcykge1xuICAgICAgICB0aGlzLmZlYXR1cmVzID0gdmlzaXRvci52aXNpdCh0aGlzLmZlYXR1cmVzKTtcbiAgICB9XG4gICAgdGhpcy5wYXRoID0gdmlzaXRvci52aXNpdCh0aGlzLnBhdGgpO1xuICAgIGlmICghdGhpcy5vcHRpb25zLmlzUGx1Z2luICYmICF0aGlzLm9wdGlvbnMuaW5saW5lICYmIHRoaXMucm9vdCkge1xuICAgICAgICB0aGlzLnJvb3QgPSB2aXNpdG9yLnZpc2l0KHRoaXMucm9vdCk7XG4gICAgfVxufTtcbkltcG9ydC5wcm90b3R5cGUuZ2VuQ1NTID0gZnVuY3Rpb24gKGNvbnRleHQsIG91dHB1dCkge1xuICAgIGlmICh0aGlzLmNzcyAmJiB0aGlzLnBhdGguX2ZpbGVJbmZvLnJlZmVyZW5jZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG91dHB1dC5hZGQoJ0BpbXBvcnQgJywgdGhpcy5fZmlsZUluZm8sIHRoaXMuX2luZGV4KTtcbiAgICAgICAgdGhpcy5wYXRoLmdlbkNTUyhjb250ZXh0LCBvdXRwdXQpO1xuICAgICAgICBpZiAodGhpcy5mZWF0dXJlcykge1xuICAgICAgICAgICAgb3V0cHV0LmFkZCgnICcpO1xuICAgICAgICAgICAgdGhpcy5mZWF0dXJlcy5nZW5DU1MoY29udGV4dCwgb3V0cHV0KTtcbiAgICAgICAgfVxuICAgICAgICBvdXRwdXQuYWRkKCc7Jyk7XG4gICAgfVxufTtcbkltcG9ydC5wcm90b3R5cGUuZ2V0UGF0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKHRoaXMucGF0aCBpbnN0YW5jZW9mIFVSTCkgP1xuICAgICAgICB0aGlzLnBhdGgudmFsdWUudmFsdWUgOiB0aGlzLnBhdGgudmFsdWU7XG59O1xuSW1wb3J0LnByb3RvdHlwZS5pc1ZhcmlhYmxlSW1wb3J0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwYXRoID0gdGhpcy5wYXRoO1xuICAgIGlmIChwYXRoIGluc3RhbmNlb2YgVVJMKSB7XG4gICAgICAgIHBhdGggPSBwYXRoLnZhbHVlO1xuICAgIH1cbiAgICBpZiAocGF0aCBpbnN0YW5jZW9mIFF1b3RlZCkge1xuICAgICAgICByZXR1cm4gcGF0aC5jb250YWluc1ZhcmlhYmxlcygpO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufTtcbkltcG9ydC5wcm90b3R5cGUuZXZhbEZvckltcG9ydCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgdmFyIHBhdGggPSB0aGlzLnBhdGg7XG5cbiAgICBpZiAocGF0aCBpbnN0YW5jZW9mIFVSTCkge1xuICAgICAgICBwYXRoID0gcGF0aC52YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEltcG9ydChwYXRoLmV2YWwoY29udGV4dCksIHRoaXMuZmVhdHVyZXMsIHRoaXMub3B0aW9ucywgdGhpcy5faW5kZXgsIHRoaXMuX2ZpbGVJbmZvLCB0aGlzLnZpc2liaWxpdHlJbmZvKCkpO1xufTtcbkltcG9ydC5wcm90b3R5cGUuZXZhbFBhdGggPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHZhciBwYXRoID0gdGhpcy5wYXRoLmV2YWwoY29udGV4dCk7XG4gICAgdmFyIGZpbGVJbmZvID0gdGhpcy5fZmlsZUluZm87XG5cbiAgICBpZiAoIShwYXRoIGluc3RhbmNlb2YgVVJMKSkge1xuICAgICAgICAvLyBBZGQgdGhlIHJvb3RwYXRoIGlmIHRoZSBVUkwgcmVxdWlyZXMgYSByZXdyaXRlXG4gICAgICAgIHZhciBwYXRoVmFsdWUgPSBwYXRoLnZhbHVlO1xuICAgICAgICBpZiAoZmlsZUluZm8gJiZcbiAgICAgICAgICAgIHBhdGhWYWx1ZSAmJlxuICAgICAgICAgICAgY29udGV4dC5wYXRoUmVxdWlyZXNSZXdyaXRlKHBhdGhWYWx1ZSkpIHtcbiAgICAgICAgICAgIHBhdGgudmFsdWUgPSBjb250ZXh0LnJld3JpdGVQYXRoKHBhdGhWYWx1ZSwgZmlsZUluZm8ucm9vdHBhdGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGF0aC52YWx1ZSA9IGNvbnRleHQubm9ybWFsaXplUGF0aChwYXRoLnZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwYXRoO1xufTtcbkltcG9ydC5wcm90b3R5cGUuZXZhbCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMuZG9FdmFsKGNvbnRleHQpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMucmVmZXJlbmNlIHx8IHRoaXMuYmxvY2tzVmlzaWJpbGl0eSgpKSB7XG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoIHx8IHJlc3VsdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJlc3VsdC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5hZGRWaXNpYmlsaXR5QmxvY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQuYWRkVmlzaWJpbGl0eUJsb2NrKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5JbXBvcnQucHJvdG90eXBlLmRvRXZhbCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgdmFyIHJ1bGVzZXQsIHJlZ2lzdHJ5LFxuICAgICAgICBmZWF0dXJlcyA9IHRoaXMuZmVhdHVyZXMgJiYgdGhpcy5mZWF0dXJlcy5ldmFsKGNvbnRleHQpO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5pc1BsdWdpbikge1xuICAgICAgICBpZiAodGhpcy5yb290ICYmIHRoaXMucm9vdC5ldmFsKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMucm9vdC5ldmFsKGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBlLm1lc3NhZ2UgPSAnUGx1Z2luIGVycm9yIGR1cmluZyBldmFsdWF0aW9uJztcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTGVzc0Vycm9yKGUsIHRoaXMucm9vdC5pbXBvcnRzLCB0aGlzLnJvb3QuZmlsZW5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlZ2lzdHJ5ID0gY29udGV4dC5mcmFtZXNbMF0gJiYgY29udGV4dC5mcmFtZXNbMF0uZnVuY3Rpb25SZWdpc3RyeTtcbiAgICAgICAgaWYgKCByZWdpc3RyeSAmJiB0aGlzLnJvb3QgJiYgdGhpcy5yb290LmZ1bmN0aW9ucyApIHtcbiAgICAgICAgICAgIHJlZ2lzdHJ5LmFkZE11bHRpcGxlKCB0aGlzLnJvb3QuZnVuY3Rpb25zICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc2tpcCkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuc2tpcCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5za2lwID0gdGhpcy5za2lwKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2tpcCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuaW5saW5lKSB7XG4gICAgICAgIHZhciBjb250ZW50cyA9IG5ldyBBbm9ueW1vdXModGhpcy5yb290LCAwLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGZpbGVuYW1lOiB0aGlzLmltcG9ydGVkRmlsZW5hbWUsXG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlOiB0aGlzLnBhdGguX2ZpbGVJbmZvICYmIHRoaXMucGF0aC5fZmlsZUluZm8ucmVmZXJlbmNlXG4gICAgICAgICAgICB9LCB0cnVlLCB0cnVlKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5mZWF0dXJlcyA/IG5ldyBNZWRpYShbY29udGVudHNdLCB0aGlzLmZlYXR1cmVzLnZhbHVlKSA6IFtjb250ZW50c107XG4gICAgfSBlbHNlIGlmICh0aGlzLmNzcykge1xuICAgICAgICB2YXIgbmV3SW1wb3J0ID0gbmV3IEltcG9ydCh0aGlzLmV2YWxQYXRoKGNvbnRleHQpLCBmZWF0dXJlcywgdGhpcy5vcHRpb25zLCB0aGlzLl9pbmRleCk7XG4gICAgICAgIGlmICghbmV3SW1wb3J0LmNzcyAmJiB0aGlzLmVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLmVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdJbXBvcnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcnVsZXNldCA9IG5ldyBSdWxlc2V0KG51bGwsIHV0aWxzLmNvcHlBcnJheSh0aGlzLnJvb3QucnVsZXMpKTtcbiAgICAgICAgcnVsZXNldC5ldmFsSW1wb3J0cyhjb250ZXh0KTtcblxuICAgICAgICByZXR1cm4gdGhpcy5mZWF0dXJlcyA/IG5ldyBNZWRpYShydWxlc2V0LnJ1bGVzLCB0aGlzLmZlYXR1cmVzLnZhbHVlKSA6IHJ1bGVzZXQucnVsZXM7XG4gICAgfVxufTtcbm1vZHVsZS5leHBvcnRzID0gSW1wb3J0O1xuXG59LHtcIi4uL2xlc3MtZXJyb3JcIjozOCxcIi4uL3V0aWxzXCI6ODksXCIuL2Fub255bW91c1wiOjUwLFwiLi9tZWRpYVwiOjcxLFwiLi9ub2RlXCI6NzYsXCIuL3F1b3RlZFwiOjgwLFwiLi9ydWxlc2V0XCI6ODEsXCIuL3VybFwiOjg1fV0sNjc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIHRyZWUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG50cmVlLk5vZGUgPSByZXF1aXJlKCcuL25vZGUnKTtcbnRyZWUuQ29sb3IgPSByZXF1aXJlKCcuL2NvbG9yJyk7XG50cmVlLkF0UnVsZSA9IHJlcXVpcmUoJy4vYXRydWxlJyk7XG50cmVlLkRldGFjaGVkUnVsZXNldCA9IHJlcXVpcmUoJy4vZGV0YWNoZWQtcnVsZXNldCcpO1xudHJlZS5PcGVyYXRpb24gPSByZXF1aXJlKCcuL29wZXJhdGlvbicpO1xudHJlZS5EaW1lbnNpb24gPSByZXF1aXJlKCcuL2RpbWVuc2lvbicpO1xudHJlZS5Vbml0ID0gcmVxdWlyZSgnLi91bml0Jyk7XG50cmVlLktleXdvcmQgPSByZXF1aXJlKCcuL2tleXdvcmQnKTtcbnRyZWUuVmFyaWFibGUgPSByZXF1aXJlKCcuL3ZhcmlhYmxlJyk7XG50cmVlLlByb3BlcnR5ID0gcmVxdWlyZSgnLi9wcm9wZXJ0eScpO1xudHJlZS5SdWxlc2V0ID0gcmVxdWlyZSgnLi9ydWxlc2V0Jyk7XG50cmVlLkVsZW1lbnQgPSByZXF1aXJlKCcuL2VsZW1lbnQnKTtcbnRyZWUuQXR0cmlidXRlID0gcmVxdWlyZSgnLi9hdHRyaWJ1dGUnKTtcbnRyZWUuQ29tYmluYXRvciA9IHJlcXVpcmUoJy4vY29tYmluYXRvcicpO1xudHJlZS5TZWxlY3RvciA9IHJlcXVpcmUoJy4vc2VsZWN0b3InKTtcbnRyZWUuUXVvdGVkID0gcmVxdWlyZSgnLi9xdW90ZWQnKTtcbnRyZWUuRXhwcmVzc2lvbiA9IHJlcXVpcmUoJy4vZXhwcmVzc2lvbicpO1xudHJlZS5EZWNsYXJhdGlvbiA9IHJlcXVpcmUoJy4vZGVjbGFyYXRpb24nKTtcbnRyZWUuQ2FsbCA9IHJlcXVpcmUoJy4vY2FsbCcpO1xudHJlZS5VUkwgPSByZXF1aXJlKCcuL3VybCcpO1xudHJlZS5JbXBvcnQgPSByZXF1aXJlKCcuL2ltcG9ydCcpO1xudHJlZS5taXhpbiA9IHtcbiAgICBDYWxsOiByZXF1aXJlKCcuL21peGluLWNhbGwnKSxcbiAgICBEZWZpbml0aW9uOiByZXF1aXJlKCcuL21peGluLWRlZmluaXRpb24nKVxufTtcbnRyZWUuQ29tbWVudCA9IHJlcXVpcmUoJy4vY29tbWVudCcpO1xudHJlZS5Bbm9ueW1vdXMgPSByZXF1aXJlKCcuL2Fub255bW91cycpO1xudHJlZS5WYWx1ZSA9IHJlcXVpcmUoJy4vdmFsdWUnKTtcbnRyZWUuSmF2YVNjcmlwdCA9IHJlcXVpcmUoJy4vamF2YXNjcmlwdCcpO1xudHJlZS5Bc3NpZ25tZW50ID0gcmVxdWlyZSgnLi9hc3NpZ25tZW50Jyk7XG50cmVlLkNvbmRpdGlvbiA9IHJlcXVpcmUoJy4vY29uZGl0aW9uJyk7XG50cmVlLlBhcmVuID0gcmVxdWlyZSgnLi9wYXJlbicpO1xudHJlZS5NZWRpYSA9IHJlcXVpcmUoJy4vbWVkaWEnKTtcbnRyZWUuVW5pY29kZURlc2NyaXB0b3IgPSByZXF1aXJlKCcuL3VuaWNvZGUtZGVzY3JpcHRvcicpO1xudHJlZS5OZWdhdGl2ZSA9IHJlcXVpcmUoJy4vbmVnYXRpdmUnKTtcbnRyZWUuRXh0ZW5kID0gcmVxdWlyZSgnLi9leHRlbmQnKTtcbnRyZWUuVmFyaWFibGVDYWxsID0gcmVxdWlyZSgnLi92YXJpYWJsZS1jYWxsJyk7XG50cmVlLk5hbWVzcGFjZVZhbHVlID0gcmVxdWlyZSgnLi9uYW1lc3BhY2UtdmFsdWUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB0cmVlO1xuXG59LHtcIi4vYW5vbnltb3VzXCI6NTAsXCIuL2Fzc2lnbm1lbnRcIjo1MSxcIi4vYXRydWxlXCI6NTIsXCIuL2F0dHJpYnV0ZVwiOjUzLFwiLi9jYWxsXCI6NTQsXCIuL2NvbG9yXCI6NTUsXCIuL2NvbWJpbmF0b3JcIjo1NixcIi4vY29tbWVudFwiOjU3LFwiLi9jb25kaXRpb25cIjo1OCxcIi4vZGVjbGFyYXRpb25cIjo2MCxcIi4vZGV0YWNoZWQtcnVsZXNldFwiOjYxLFwiLi9kaW1lbnNpb25cIjo2MixcIi4vZWxlbWVudFwiOjYzLFwiLi9leHByZXNzaW9uXCI6NjQsXCIuL2V4dGVuZFwiOjY1LFwiLi9pbXBvcnRcIjo2NixcIi4vamF2YXNjcmlwdFwiOjY4LFwiLi9rZXl3b3JkXCI6NzAsXCIuL21lZGlhXCI6NzEsXCIuL21peGluLWNhbGxcIjo3MixcIi4vbWl4aW4tZGVmaW5pdGlvblwiOjczLFwiLi9uYW1lc3BhY2UtdmFsdWVcIjo3NCxcIi4vbmVnYXRpdmVcIjo3NSxcIi4vbm9kZVwiOjc2LFwiLi9vcGVyYXRpb25cIjo3NyxcIi4vcGFyZW5cIjo3OCxcIi4vcHJvcGVydHlcIjo3OSxcIi4vcXVvdGVkXCI6ODAsXCIuL3J1bGVzZXRcIjo4MSxcIi4vc2VsZWN0b3JcIjo4MixcIi4vdW5pY29kZS1kZXNjcmlwdG9yXCI6ODMsXCIuL3VuaXRcIjo4NCxcIi4vdXJsXCI6ODUsXCIuL3ZhbHVlXCI6ODYsXCIuL3ZhcmlhYmxlXCI6ODgsXCIuL3ZhcmlhYmxlLWNhbGxcIjo4N31dLDY4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBKc0V2YWxOb2RlID0gcmVxdWlyZSgnLi9qcy1ldmFsLW5vZGUnKSxcbiAgICBEaW1lbnNpb24gPSByZXF1aXJlKCcuL2RpbWVuc2lvbicpLFxuICAgIFF1b3RlZCA9IHJlcXVpcmUoJy4vcXVvdGVkJyksXG4gICAgQW5vbnltb3VzID0gcmVxdWlyZSgnLi9hbm9ueW1vdXMnKTtcblxudmFyIEphdmFTY3JpcHQgPSBmdW5jdGlvbiAoc3RyaW5nLCBlc2NhcGVkLCBpbmRleCwgY3VycmVudEZpbGVJbmZvKSB7XG4gICAgdGhpcy5lc2NhcGVkID0gZXNjYXBlZDtcbiAgICB0aGlzLmV4cHJlc3Npb24gPSBzdHJpbmc7XG4gICAgdGhpcy5faW5kZXggPSBpbmRleDtcbiAgICB0aGlzLl9maWxlSW5mbyA9IGN1cnJlbnRGaWxlSW5mbztcbn07XG5KYXZhU2NyaXB0LnByb3RvdHlwZSA9IG5ldyBKc0V2YWxOb2RlKCk7XG5KYXZhU2NyaXB0LnByb3RvdHlwZS50eXBlID0gJ0phdmFTY3JpcHQnO1xuSmF2YVNjcmlwdC5wcm90b3R5cGUuZXZhbCA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5ldmFsdWF0ZUphdmFTY3JpcHQodGhpcy5leHByZXNzaW9uLCBjb250ZXh0KTtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiByZXN1bHQ7XG5cbiAgICBpZiAodHlwZSA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHJlc3VsdCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEaW1lbnNpb24ocmVzdWx0KTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUXVvdGVkKCdcIicgKyByZXN1bHQgKyAnXCInLCByZXN1bHQsIHRoaXMuZXNjYXBlZCwgdGhpcy5faW5kZXgpO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShyZXN1bHQpKSB7XG4gICAgICAgIHJldHVybiBuZXcgQW5vbnltb3VzKHJlc3VsdC5qb2luKCcsICcpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IEFub255bW91cyhyZXN1bHQpO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSmF2YVNjcmlwdDtcblxufSx7XCIuL2Fub255bW91c1wiOjUwLFwiLi9kaW1lbnNpb25cIjo2MixcIi4vanMtZXZhbC1ub2RlXCI6NjksXCIuL3F1b3RlZFwiOjgwfV0sNjk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIE5vZGUgPSByZXF1aXJlKCcuL25vZGUnKSxcbiAgICBWYXJpYWJsZSA9IHJlcXVpcmUoJy4vdmFyaWFibGUnKTtcblxudmFyIEpzRXZhbE5vZGUgPSBmdW5jdGlvbigpIHtcbn07XG5Kc0V2YWxOb2RlLnByb3RvdHlwZSA9IG5ldyBOb2RlKCk7XG5cbkpzRXZhbE5vZGUucHJvdG90eXBlLmV2YWx1YXRlSmF2YVNjcmlwdCA9IGZ1bmN0aW9uIChleHByZXNzaW9uLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdCxcbiAgICAgICAgdGhhdCA9IHRoaXMsXG4gICAgICAgIGV2YWxDb250ZXh0ID0ge307XG5cbiAgICBpZiAoIWNvbnRleHQuamF2YXNjcmlwdEVuYWJsZWQpIHtcbiAgICAgICAgdGhyb3cgeyBtZXNzYWdlOiAnSW5saW5lIEphdmFTY3JpcHQgaXMgbm90IGVuYWJsZWQuIElzIGl0IHNldCBpbiB5b3VyIG9wdGlvbnM/JyxcbiAgICAgICAgICAgIGZpbGVuYW1lOiB0aGlzLmZpbGVJbmZvKCkuZmlsZW5hbWUsXG4gICAgICAgICAgICBpbmRleDogdGhpcy5nZXRJbmRleCgpIH07XG4gICAgfVxuXG4gICAgZXhwcmVzc2lvbiA9IGV4cHJlc3Npb24ucmVwbGFjZSgvQFxceyhbXFx3LV0rKVxcfS9nLCBmdW5jdGlvbiAoXywgbmFtZSkge1xuICAgICAgICByZXR1cm4gdGhhdC5qc2lmeShuZXcgVmFyaWFibGUoJ0AnICsgbmFtZSwgdGhhdC5nZXRJbmRleCgpLCB0aGF0LmZpbGVJbmZvKCkpLmV2YWwoY29udGV4dCkpO1xuICAgIH0pO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgZXhwcmVzc2lvbiA9IG5ldyBGdW5jdGlvbigncmV0dXJuICgnICsgZXhwcmVzc2lvbiArICcpJyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyB7IG1lc3NhZ2U6ICdKYXZhU2NyaXB0IGV2YWx1YXRpb24gZXJyb3I6ICcgKyBlLm1lc3NhZ2UgKyAnIGZyb20gYCcgKyBleHByZXNzaW9uICsgJ2AnICxcbiAgICAgICAgICAgIGZpbGVuYW1lOiB0aGlzLmZpbGVJbmZvKCkuZmlsZW5hbWUsXG4gICAgICAgICAgICBpbmRleDogdGhpcy5nZXRJbmRleCgpIH07XG4gICAgfVxuXG4gICAgdmFyIHZhcmlhYmxlcyA9IGNvbnRleHQuZnJhbWVzWzBdLnZhcmlhYmxlcygpO1xuICAgIGZvciAodmFyIGsgaW4gdmFyaWFibGVzKSB7XG4gICAgICAgIGlmICh2YXJpYWJsZXMuaGFzT3duUHJvcGVydHkoaykpIHtcbiAgICAgICAgICAgIC8qIGpzaGludCBsb29wZnVuYzp0cnVlICovXG4gICAgICAgICAgICBldmFsQ29udGV4dFtrLnNsaWNlKDEpXSA9IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFyaWFibGVzW2tdLnZhbHVlLFxuICAgICAgICAgICAgICAgIHRvSlM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUuZXZhbChjb250ZXh0KS50b0NTUygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgICByZXN1bHQgPSBleHByZXNzaW9uLmNhbGwoZXZhbENvbnRleHQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgeyBtZXNzYWdlOiAnSmF2YVNjcmlwdCBldmFsdWF0aW9uIGVycm9yOiBcXCcnICsgZS5uYW1lICsgJzogJyArIGUubWVzc2FnZS5yZXBsYWNlKC9bXCJdL2csICdcXCcnKSArICdcXCcnICxcbiAgICAgICAgICAgIGZpbGVuYW1lOiB0aGlzLmZpbGVJbmZvKCkuZmlsZW5hbWUsXG4gICAgICAgICAgICBpbmRleDogdGhpcy5nZXRJbmRleCgpIH07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuSnNFdmFsTm9kZS5wcm90b3R5cGUuanNpZnkgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqLnZhbHVlKSAmJiAob2JqLnZhbHVlLmxlbmd0aCA+IDEpKSB7XG4gICAgICAgIHJldHVybiAnWycgKyBvYmoudmFsdWUubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiB2LnRvQ1NTKCk7IH0pLmpvaW4oJywgJykgKyAnXSc7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG9iai50b0NTUygpO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSnNFdmFsTm9kZTtcblxufSx7XCIuL25vZGVcIjo3NixcIi4vdmFyaWFibGVcIjo4OH1dLDcwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBOb2RlID0gcmVxdWlyZSgnLi9ub2RlJyk7XG5cbnZhciBLZXl3b3JkID0gZnVuY3Rpb24gKHZhbHVlKSB7IHRoaXMudmFsdWUgPSB2YWx1ZTsgfTtcbktleXdvcmQucHJvdG90eXBlID0gbmV3IE5vZGUoKTtcbktleXdvcmQucHJvdG90eXBlLnR5cGUgPSAnS2V5d29yZCc7XG5LZXl3b3JkLnByb3RvdHlwZS5nZW5DU1MgPSBmdW5jdGlvbiAoY29udGV4dCwgb3V0cHV0KSB7XG4gICAgaWYgKHRoaXMudmFsdWUgPT09ICclJykgeyB0aHJvdyB7IHR5cGU6ICdTeW50YXgnLCBtZXNzYWdlOiAnSW52YWxpZCAlIHdpdGhvdXQgbnVtYmVyJyB9OyB9XG4gICAgb3V0cHV0LmFkZCh0aGlzLnZhbHVlKTtcbn07XG5cbktleXdvcmQuVHJ1ZSA9IG5ldyBLZXl3b3JkKCd0cnVlJyk7XG5LZXl3b3JkLkZhbHNlID0gbmV3IEtleXdvcmQoJ2ZhbHNlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gS2V5d29yZDtcblxufSx7XCIuL25vZGVcIjo3Nn1dLDcxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBSdWxlc2V0ID0gcmVxdWlyZSgnLi9ydWxlc2V0JyksXG4gICAgVmFsdWUgPSByZXF1aXJlKCcuL3ZhbHVlJyksXG4gICAgU2VsZWN0b3IgPSByZXF1aXJlKCcuL3NlbGVjdG9yJyksXG4gICAgQW5vbnltb3VzID0gcmVxdWlyZSgnLi9hbm9ueW1vdXMnKSxcbiAgICBFeHByZXNzaW9uID0gcmVxdWlyZSgnLi9leHByZXNzaW9uJyksXG4gICAgQXRSdWxlID0gcmVxdWlyZSgnLi9hdHJ1bGUnKSxcbiAgICB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbnZhciBNZWRpYSA9IGZ1bmN0aW9uICh2YWx1ZSwgZmVhdHVyZXMsIGluZGV4LCBjdXJyZW50RmlsZUluZm8sIHZpc2liaWxpdHlJbmZvKSB7XG4gICAgdGhpcy5faW5kZXggPSBpbmRleDtcbiAgICB0aGlzLl9maWxlSW5mbyA9IGN1cnJlbnRGaWxlSW5mbztcblxuICAgIHZhciBzZWxlY3RvcnMgPSAobmV3IFNlbGVjdG9yKFtdLCBudWxsLCBudWxsLCB0aGlzLl9pbmRleCwgdGhpcy5fZmlsZUluZm8pKS5jcmVhdGVFbXB0eVNlbGVjdG9ycygpO1xuXG4gICAgdGhpcy5mZWF0dXJlcyA9IG5ldyBWYWx1ZShmZWF0dXJlcyk7XG4gICAgdGhpcy5ydWxlcyA9IFtuZXcgUnVsZXNldChzZWxlY3RvcnMsIHZhbHVlKV07XG4gICAgdGhpcy5ydWxlc1swXS5hbGxvd0ltcG9ydHMgPSB0cnVlO1xuICAgIHRoaXMuY29weVZpc2liaWxpdHlJbmZvKHZpc2liaWxpdHlJbmZvKTtcbiAgICB0aGlzLmFsbG93Um9vdCA9IHRydWU7XG4gICAgdGhpcy5zZXRQYXJlbnQoc2VsZWN0b3JzLCB0aGlzKTtcbiAgICB0aGlzLnNldFBhcmVudCh0aGlzLmZlYXR1cmVzLCB0aGlzKTtcbiAgICB0aGlzLnNldFBhcmVudCh0aGlzLnJ1bGVzLCB0aGlzKTtcbn07XG5NZWRpYS5wcm90b3R5cGUgPSBuZXcgQXRSdWxlKCk7XG5NZWRpYS5wcm90b3R5cGUudHlwZSA9ICdNZWRpYSc7XG5NZWRpYS5wcm90b3R5cGUuaXNSdWxlc2V0TGlrZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfTtcbk1lZGlhLnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbiAodmlzaXRvcikge1xuICAgIGlmICh0aGlzLmZlYXR1cmVzKSB7XG4gICAgICAgIHRoaXMuZmVhdHVyZXMgPSB2aXNpdG9yLnZpc2l0KHRoaXMuZmVhdHVyZXMpO1xuICAgIH1cbiAgICBpZiAodGhpcy5ydWxlcykge1xuICAgICAgICB0aGlzLnJ1bGVzID0gdmlzaXRvci52aXNpdEFycmF5KHRoaXMucnVsZXMpO1xuICAgIH1cbn07XG5NZWRpYS5wcm90b3R5cGUuZ2VuQ1NTID0gZnVuY3Rpb24gKGNvbnRleHQsIG91dHB1dCkge1xuICAgIG91dHB1dC5hZGQoJ0BtZWRpYSAnLCB0aGlzLl9maWxlSW5mbywgdGhpcy5faW5kZXgpO1xuICAgIHRoaXMuZmVhdHVyZXMuZ2VuQ1NTKGNvbnRleHQsIG91dHB1dCk7XG4gICAgdGhpcy5vdXRwdXRSdWxlc2V0KGNvbnRleHQsIG91dHB1dCwgdGhpcy5ydWxlcyk7XG59O1xuTWVkaWEucHJvdG90eXBlLmV2YWwgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIGlmICghY29udGV4dC5tZWRpYUJsb2Nrcykge1xuICAgICAgICBjb250ZXh0Lm1lZGlhQmxvY2tzID0gW107XG4gICAgICAgIGNvbnRleHQubWVkaWFQYXRoID0gW107XG4gICAgfVxuXG4gICAgdmFyIG1lZGlhID0gbmV3IE1lZGlhKG51bGwsIFtdLCB0aGlzLl9pbmRleCwgdGhpcy5fZmlsZUluZm8sIHRoaXMudmlzaWJpbGl0eUluZm8oKSk7XG4gICAgaWYgKHRoaXMuZGVidWdJbmZvKSB7XG4gICAgICAgIHRoaXMucnVsZXNbMF0uZGVidWdJbmZvID0gdGhpcy5kZWJ1Z0luZm87XG4gICAgICAgIG1lZGlhLmRlYnVnSW5mbyA9IHRoaXMuZGVidWdJbmZvO1xuICAgIH1cbiAgICBcbiAgICBtZWRpYS5mZWF0dXJlcyA9IHRoaXMuZmVhdHVyZXMuZXZhbChjb250ZXh0KTtcblxuICAgIGNvbnRleHQubWVkaWFQYXRoLnB1c2gobWVkaWEpO1xuICAgIGNvbnRleHQubWVkaWFCbG9ja3MucHVzaChtZWRpYSk7XG5cbiAgICB0aGlzLnJ1bGVzWzBdLmZ1bmN0aW9uUmVnaXN0cnkgPSBjb250ZXh0LmZyYW1lc1swXS5mdW5jdGlvblJlZ2lzdHJ5LmluaGVyaXQoKTtcbiAgICBjb250ZXh0LmZyYW1lcy51bnNoaWZ0KHRoaXMucnVsZXNbMF0pO1xuICAgIG1lZGlhLnJ1bGVzID0gW3RoaXMucnVsZXNbMF0uZXZhbChjb250ZXh0KV07XG4gICAgY29udGV4dC5mcmFtZXMuc2hpZnQoKTtcblxuICAgIGNvbnRleHQubWVkaWFQYXRoLnBvcCgpO1xuXG4gICAgcmV0dXJuIGNvbnRleHQubWVkaWFQYXRoLmxlbmd0aCA9PT0gMCA/IG1lZGlhLmV2YWxUb3AoY29udGV4dCkgOlxuICAgICAgICAgICAgICAgIG1lZGlhLmV2YWxOZXN0ZWQoY29udGV4dCk7XG59O1xuTWVkaWEucHJvdG90eXBlLmV2YWxUb3AgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHZhciByZXN1bHQgPSB0aGlzO1xuXG4gICAgLy8gUmVuZGVyIGFsbCBkZXBlbmRlbnQgTWVkaWEgYmxvY2tzLlxuICAgIGlmIChjb250ZXh0Lm1lZGlhQmxvY2tzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdmFyIHNlbGVjdG9ycyA9IChuZXcgU2VsZWN0b3IoW10sIG51bGwsIG51bGwsIHRoaXMuZ2V0SW5kZXgoKSwgdGhpcy5maWxlSW5mbygpKSkuY3JlYXRlRW1wdHlTZWxlY3RvcnMoKTtcbiAgICAgICAgcmVzdWx0ID0gbmV3IFJ1bGVzZXQoc2VsZWN0b3JzLCBjb250ZXh0Lm1lZGlhQmxvY2tzKTtcbiAgICAgICAgcmVzdWx0Lm11bHRpTWVkaWEgPSB0cnVlO1xuICAgICAgICByZXN1bHQuY29weVZpc2liaWxpdHlJbmZvKHRoaXMudmlzaWJpbGl0eUluZm8oKSk7XG4gICAgICAgIHRoaXMuc2V0UGFyZW50KHJlc3VsdCwgdGhpcyk7XG4gICAgfVxuXG4gICAgZGVsZXRlIGNvbnRleHQubWVkaWFCbG9ja3M7XG4gICAgZGVsZXRlIGNvbnRleHQubWVkaWFQYXRoO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5NZWRpYS5wcm90b3R5cGUuZXZhbE5lc3RlZCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgdmFyIGksIHZhbHVlLFxuICAgICAgICBwYXRoID0gY29udGV4dC5tZWRpYVBhdGguY29uY2F0KFt0aGlzXSk7XG5cbiAgICAvLyBFeHRyYWN0IHRoZSBtZWRpYS1xdWVyeSBjb25kaXRpb25zIHNlcGFyYXRlZCB3aXRoIGAsYCAoT1IpLlxuICAgIGZvciAoaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhbHVlID0gcGF0aFtpXS5mZWF0dXJlcyBpbnN0YW5jZW9mIFZhbHVlID9cbiAgICAgICAgICAgICAgICAgICAgcGF0aFtpXS5mZWF0dXJlcy52YWx1ZSA6IHBhdGhbaV0uZmVhdHVyZXM7XG4gICAgICAgIHBhdGhbaV0gPSBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlXTtcbiAgICB9XG5cbiAgICAvLyBUcmFjZSBhbGwgcGVybXV0YXRpb25zIHRvIGdlbmVyYXRlIHRoZSByZXN1bHRpbmcgbWVkaWEtcXVlcnkuXG4gICAgLy9cbiAgICAvLyAoYSwgYiBhbmQgYykgd2l0aCBuZXN0ZWQgKGQsIGUpIC0+XG4gICAgLy8gICAgYSBhbmQgZFxuICAgIC8vICAgIGEgYW5kIGVcbiAgICAvLyAgICBiIGFuZCBjIGFuZCBkXG4gICAgLy8gICAgYiBhbmQgYyBhbmQgZVxuICAgIHRoaXMuZmVhdHVyZXMgPSBuZXcgVmFsdWUodGhpcy5wZXJtdXRlKHBhdGgpLm1hcChmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICBwYXRoID0gcGF0aC5tYXAoZnVuY3Rpb24gKGZyYWdtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZnJhZ21lbnQudG9DU1MgPyBmcmFnbWVudCA6IG5ldyBBbm9ueW1vdXMoZnJhZ21lbnQpO1xuICAgICAgICB9KTtcblxuICAgICAgICBmb3IgKGkgPSBwYXRoLmxlbmd0aCAtIDE7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgICAgIHBhdGguc3BsaWNlKGksIDAsIG5ldyBBbm9ueW1vdXMoJ2FuZCcpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgRXhwcmVzc2lvbihwYXRoKTtcbiAgICB9KSk7XG4gICAgdGhpcy5zZXRQYXJlbnQodGhpcy5mZWF0dXJlcywgdGhpcyk7XG5cbiAgICAvLyBGYWtlIGEgdHJlZS1ub2RlIHRoYXQgZG9lc24ndCBvdXRwdXQgYW55dGhpbmcuXG4gICAgcmV0dXJuIG5ldyBSdWxlc2V0KFtdLCBbXSk7XG59O1xuTWVkaWEucHJvdG90eXBlLnBlcm11dGUgPSBmdW5jdGlvbiAoYXJyKSB7XG4gICAgaWYgKGFyci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH0gZWxzZSBpZiAoYXJyLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gYXJyWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgdmFyIHJlc3QgPSB0aGlzLnBlcm11dGUoYXJyLnNsaWNlKDEpKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGFyclswXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFthcnJbMF1bal1dLmNvbmNhdChyZXN0W2ldKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59O1xuTWVkaWEucHJvdG90eXBlLmJ1YmJsZVNlbGVjdG9ycyA9IGZ1bmN0aW9uIChzZWxlY3RvcnMpIHtcbiAgICBpZiAoIXNlbGVjdG9ycykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucnVsZXMgPSBbbmV3IFJ1bGVzZXQodXRpbHMuY29weUFycmF5KHNlbGVjdG9ycyksIFt0aGlzLnJ1bGVzWzBdXSldO1xuICAgIHRoaXMuc2V0UGFyZW50KHRoaXMucnVsZXMsIHRoaXMpO1xufTtcbm1vZHVsZS5leHBvcnRzID0gTWVkaWE7XG5cbn0se1wiLi4vdXRpbHNcIjo4OSxcIi4vYW5vbnltb3VzXCI6NTAsXCIuL2F0cnVsZVwiOjUyLFwiLi9leHByZXNzaW9uXCI6NjQsXCIuL3J1bGVzZXRcIjo4MSxcIi4vc2VsZWN0b3JcIjo4MixcIi4vdmFsdWVcIjo4Nn1dLDcyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBOb2RlID0gcmVxdWlyZSgnLi9ub2RlJyksXG4gICAgU2VsZWN0b3IgPSByZXF1aXJlKCcuL3NlbGVjdG9yJyksXG4gICAgTWl4aW5EZWZpbml0aW9uID0gcmVxdWlyZSgnLi9taXhpbi1kZWZpbml0aW9uJyksXG4gICAgZGVmYXVsdEZ1bmMgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvZGVmYXVsdCcpO1xuXG52YXIgTWl4aW5DYWxsID0gZnVuY3Rpb24gKGVsZW1lbnRzLCBhcmdzLCBpbmRleCwgY3VycmVudEZpbGVJbmZvLCBpbXBvcnRhbnQpIHtcbiAgICB0aGlzLnNlbGVjdG9yID0gbmV3IFNlbGVjdG9yKGVsZW1lbnRzKTtcbiAgICB0aGlzLmFyZ3VtZW50cyA9IGFyZ3MgfHwgW107XG4gICAgdGhpcy5faW5kZXggPSBpbmRleDtcbiAgICB0aGlzLl9maWxlSW5mbyA9IGN1cnJlbnRGaWxlSW5mbztcbiAgICB0aGlzLmltcG9ydGFudCA9IGltcG9ydGFudDtcbiAgICB0aGlzLmFsbG93Um9vdCA9IHRydWU7XG4gICAgdGhpcy5zZXRQYXJlbnQodGhpcy5zZWxlY3RvciwgdGhpcyk7XG59O1xuTWl4aW5DYWxsLnByb3RvdHlwZSA9IG5ldyBOb2RlKCk7XG5NaXhpbkNhbGwucHJvdG90eXBlLnR5cGUgPSAnTWl4aW5DYWxsJztcbk1peGluQ2FsbC5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24gKHZpc2l0b3IpIHtcbiAgICBpZiAodGhpcy5zZWxlY3Rvcikge1xuICAgICAgICB0aGlzLnNlbGVjdG9yID0gdmlzaXRvci52aXNpdCh0aGlzLnNlbGVjdG9yKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLmFyZ3VtZW50cyA9IHZpc2l0b3IudmlzaXRBcnJheSh0aGlzLmFyZ3VtZW50cyk7XG4gICAgfVxufTtcbk1peGluQ2FsbC5wcm90b3R5cGUuZXZhbCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgdmFyIG1peGlucywgbWl4aW4sIG1peGluUGF0aCwgYXJncyA9IFtdLCBhcmcsIGFyZ1ZhbHVlLFxuICAgICAgICBydWxlcyA9IFtdLCBtYXRjaCA9IGZhbHNlLCBpLCBtLCBmLCBpc1JlY3Vyc2l2ZSwgaXNPbmVGb3VuZCxcbiAgICAgICAgY2FuZGlkYXRlcyA9IFtdLCBjYW5kaWRhdGUsIGNvbmRpdGlvblJlc3VsdCA9IFtdLCBkZWZhdWx0UmVzdWx0LCBkZWZGYWxzZUVpdGhlckNhc2UgPSAtMSxcbiAgICAgICAgZGVmTm9uZSA9IDAsIGRlZlRydWUgPSAxLCBkZWZGYWxzZSA9IDIsIGNvdW50LCBvcmlnaW5hbFJ1bGVzZXQsIG5vQXJndW1lbnRzRmlsdGVyO1xuXG4gICAgdGhpcy5zZWxlY3RvciA9IHRoaXMuc2VsZWN0b3IuZXZhbChjb250ZXh0KTtcblxuICAgIGZ1bmN0aW9uIGNhbGNEZWZHcm91cChtaXhpbiwgbWl4aW5QYXRoKSB7XG4gICAgICAgIHZhciBmLCBwLCBuYW1lc3BhY2U7XG5cbiAgICAgICAgZm9yIChmID0gMDsgZiA8IDI7IGYrKykge1xuICAgICAgICAgICAgY29uZGl0aW9uUmVzdWx0W2ZdID0gdHJ1ZTtcbiAgICAgICAgICAgIGRlZmF1bHRGdW5jLnZhbHVlKGYpO1xuICAgICAgICAgICAgZm9yIChwID0gMDsgcCA8IG1peGluUGF0aC5sZW5ndGggJiYgY29uZGl0aW9uUmVzdWx0W2ZdOyBwKyspIHtcbiAgICAgICAgICAgICAgICBuYW1lc3BhY2UgPSBtaXhpblBhdGhbcF07XG4gICAgICAgICAgICAgICAgaWYgKG5hbWVzcGFjZS5tYXRjaENvbmRpdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBjb25kaXRpb25SZXN1bHRbZl0gPSBjb25kaXRpb25SZXN1bHRbZl0gJiYgbmFtZXNwYWNlLm1hdGNoQ29uZGl0aW9uKG51bGwsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtaXhpbi5tYXRjaENvbmRpdGlvbikge1xuICAgICAgICAgICAgICAgIGNvbmRpdGlvblJlc3VsdFtmXSA9IGNvbmRpdGlvblJlc3VsdFtmXSAmJiBtaXhpbi5tYXRjaENvbmRpdGlvbihhcmdzLCBjb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZGl0aW9uUmVzdWx0WzBdIHx8IGNvbmRpdGlvblJlc3VsdFsxXSkge1xuICAgICAgICAgICAgaWYgKGNvbmRpdGlvblJlc3VsdFswXSAhPSBjb25kaXRpb25SZXN1bHRbMV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29uZGl0aW9uUmVzdWx0WzFdID9cbiAgICAgICAgICAgICAgICAgICAgZGVmVHJ1ZSA6IGRlZkZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZGVmTm9uZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVmRmFsc2VFaXRoZXJDYXNlO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcmcgPSB0aGlzLmFyZ3VtZW50c1tpXTtcbiAgICAgICAgYXJnVmFsdWUgPSBhcmcudmFsdWUuZXZhbChjb250ZXh0KTtcbiAgICAgICAgaWYgKGFyZy5leHBhbmQgJiYgQXJyYXkuaXNBcnJheShhcmdWYWx1ZS52YWx1ZSkpIHtcbiAgICAgICAgICAgIGFyZ1ZhbHVlID0gYXJnVmFsdWUudmFsdWU7XG4gICAgICAgICAgICBmb3IgKG0gPSAwOyBtIDwgYXJnVmFsdWUubGVuZ3RoOyBtKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzLnB1c2goe3ZhbHVlOiBhcmdWYWx1ZVttXX0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXJncy5wdXNoKHtuYW1lOiBhcmcubmFtZSwgdmFsdWU6IGFyZ1ZhbHVlfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBub0FyZ3VtZW50c0ZpbHRlciA9IGZ1bmN0aW9uKHJ1bGUpIHtyZXR1cm4gcnVsZS5tYXRjaEFyZ3MobnVsbCwgY29udGV4dCk7fTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBjb250ZXh0LmZyYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoKG1peGlucyA9IGNvbnRleHQuZnJhbWVzW2ldLmZpbmQodGhpcy5zZWxlY3RvciwgbnVsbCwgbm9Bcmd1bWVudHNGaWx0ZXIpKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpc09uZUZvdW5kID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy8gVG8gbWFrZSBgZGVmYXVsdCgpYCBmdW5jdGlvbiBpbmRlcGVuZGVudCBvZiBkZWZpbml0aW9uIG9yZGVyIHdlIGhhdmUgdHdvIFwic3VicGFzc2VzXCIgaGVyZS5cbiAgICAgICAgICAgIC8vIEF0IGZpcnN0IHdlIGV2YWx1YXRlIGVhY2ggZ3VhcmQgKnR3aWNlKiAod2l0aCBgZGVmYXVsdCgpID09IHRydWVgIGFuZCBgZGVmYXVsdCgpID09IGZhbHNlYCksXG4gICAgICAgICAgICAvLyBhbmQgYnVpbGQgY2FuZGlkYXRlIGxpc3Qgd2l0aCBjb3JyZXNwb25kaW5nIGZsYWdzLiBUaGVuLCB3aGVuIHdlIGtub3cgYWxsIHBvc3NpYmxlIG1hdGNoZXMsXG4gICAgICAgICAgICAvLyB3ZSBtYWtlIGEgZmluYWwgZGVjaXNpb24uXG5cbiAgICAgICAgICAgIGZvciAobSA9IDA7IG0gPCBtaXhpbnMubGVuZ3RoOyBtKyspIHtcbiAgICAgICAgICAgICAgICBtaXhpbiA9IG1peGluc1ttXS5ydWxlO1xuICAgICAgICAgICAgICAgIG1peGluUGF0aCA9IG1peGluc1ttXS5wYXRoO1xuICAgICAgICAgICAgICAgIGlzUmVjdXJzaXZlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZm9yIChmID0gMDsgZiA8IGNvbnRleHQuZnJhbWVzLmxlbmd0aDsgZisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoIShtaXhpbiBpbnN0YW5jZW9mIE1peGluRGVmaW5pdGlvbikpICYmIG1peGluID09PSAoY29udGV4dC5mcmFtZXNbZl0ub3JpZ2luYWxSdWxlc2V0IHx8IGNvbnRleHQuZnJhbWVzW2ZdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNSZWN1cnNpdmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzUmVjdXJzaXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChtaXhpbi5tYXRjaEFyZ3MoYXJncywgY29udGV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FuZGlkYXRlID0ge21peGluOiBtaXhpbiwgZ3JvdXA6IGNhbGNEZWZHcm91cChtaXhpbiwgbWl4aW5QYXRoKX07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbmRpZGF0ZS5ncm91cCAhPT0gZGVmRmFsc2VFaXRoZXJDYXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYW5kaWRhdGVzLnB1c2goY2FuZGlkYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlZmF1bHRGdW5jLnJlc2V0KCk7XG5cbiAgICAgICAgICAgIGNvdW50ID0gWzAsIDAsIDBdO1xuICAgICAgICAgICAgZm9yIChtID0gMDsgbSA8IGNhbmRpZGF0ZXMubGVuZ3RoOyBtKyspIHtcbiAgICAgICAgICAgICAgICBjb3VudFtjYW5kaWRhdGVzW21dLmdyb3VwXSsrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY291bnRbZGVmTm9uZV0gPiAwKSB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdFJlc3VsdCA9IGRlZkZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0UmVzdWx0ID0gZGVmVHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoKGNvdW50W2RlZlRydWVdICsgY291bnRbZGVmRmFsc2VdKSA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgeyB0eXBlOiAnUnVudGltZScsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnQW1iaWd1b3VzIHVzZSBvZiBgZGVmYXVsdCgpYCBmb3VuZCB3aGVuIG1hdGNoaW5nIGZvciBgJyArIHRoaXMuZm9ybWF0KGFyZ3MpICsgJ2AnLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IHRoaXMuZ2V0SW5kZXgoKSwgZmlsZW5hbWU6IHRoaXMuZmlsZUluZm8oKS5maWxlbmFtZSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChtID0gMDsgbSA8IGNhbmRpZGF0ZXMubGVuZ3RoOyBtKyspIHtcbiAgICAgICAgICAgICAgICBjYW5kaWRhdGUgPSBjYW5kaWRhdGVzW21dLmdyb3VwO1xuICAgICAgICAgICAgICAgIGlmICgoY2FuZGlkYXRlID09PSBkZWZOb25lKSB8fCAoY2FuZGlkYXRlID09PSBkZWZhdWx0UmVzdWx0KSkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWl4aW4gPSBjYW5kaWRhdGVzW21dLm1peGluO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobWl4aW4gaW5zdGFuY2VvZiBNaXhpbkRlZmluaXRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxSdWxlc2V0ID0gbWl4aW4ub3JpZ2luYWxSdWxlc2V0IHx8IG1peGluO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1peGluID0gbmV3IE1peGluRGVmaW5pdGlvbignJywgW10sIG1peGluLnJ1bGVzLCBudWxsLCBmYWxzZSwgbnVsbCwgb3JpZ2luYWxSdWxlc2V0LnZpc2liaWxpdHlJbmZvKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1peGluLm9yaWdpbmFsUnVsZXNldCA9IG9yaWdpbmFsUnVsZXNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdSdWxlcyA9IG1peGluLmV2YWxDYWxsKGNvbnRleHQsIGFyZ3MsIHRoaXMuaW1wb3J0YW50KS5ydWxlcztcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldFZpc2liaWxpdHlUb1JlcGxhY2VtZW50KG5ld1J1bGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHJ1bGVzLCBuZXdSdWxlcyk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHsgbWVzc2FnZTogZS5tZXNzYWdlLCBpbmRleDogdGhpcy5nZXRJbmRleCgpLCBmaWxlbmFtZTogdGhpcy5maWxlSW5mbygpLmZpbGVuYW1lLCBzdGFjazogZS5zdGFjayB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcnVsZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzT25lRm91bmQpIHtcbiAgICAgICAgdGhyb3cgeyB0eXBlOiAgICAnUnVudGltZScsXG4gICAgICAgICAgICBtZXNzYWdlOiAnTm8gbWF0Y2hpbmcgZGVmaW5pdGlvbiB3YXMgZm91bmQgZm9yIGAnICsgdGhpcy5mb3JtYXQoYXJncykgKyAnYCcsXG4gICAgICAgICAgICBpbmRleDogICB0aGlzLmdldEluZGV4KCksIGZpbGVuYW1lOiB0aGlzLmZpbGVJbmZvKCkuZmlsZW5hbWUgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyB7IHR5cGU6ICAgICdOYW1lJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IHRoaXMuc2VsZWN0b3IudG9DU1MoKS50cmltKCkgKyAnIGlzIHVuZGVmaW5lZCcsXG4gICAgICAgICAgICBpbmRleDogICB0aGlzLmdldEluZGV4KCksIGZpbGVuYW1lOiB0aGlzLmZpbGVJbmZvKCkuZmlsZW5hbWUgfTtcbiAgICB9XG59O1xuXG5NaXhpbkNhbGwucHJvdG90eXBlLl9zZXRWaXNpYmlsaXR5VG9SZXBsYWNlbWVudCA9IGZ1bmN0aW9uIChyZXBsYWNlbWVudCkge1xuICAgIHZhciBpLCBydWxlO1xuICAgIGlmICh0aGlzLmJsb2Nrc1Zpc2liaWxpdHkoKSkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcmVwbGFjZW1lbnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJ1bGUgPSByZXBsYWNlbWVudFtpXTtcbiAgICAgICAgICAgIHJ1bGUuYWRkVmlzaWJpbGl0eUJsb2NrKCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuTWl4aW5DYWxsLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbiAoYXJncykge1xuICAgIHJldHVybiB0aGlzLnNlbGVjdG9yLnRvQ1NTKCkudHJpbSgpICsgJygnICtcbiAgICAgICAgKGFyZ3MgPyBhcmdzLm1hcChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgdmFyIGFyZ1ZhbHVlID0gJyc7XG4gICAgICAgICAgICBpZiAoYS5uYW1lKSB7XG4gICAgICAgICAgICAgICAgYXJnVmFsdWUgKz0gYS5uYW1lICsgJzonO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGEudmFsdWUudG9DU1MpIHtcbiAgICAgICAgICAgICAgICBhcmdWYWx1ZSArPSBhLnZhbHVlLnRvQ1NTKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFyZ1ZhbHVlICs9ICc/Pz8nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFyZ1ZhbHVlO1xuICAgICAgICB9KS5qb2luKCcsICcpIDogJycpICsgJyknO1xufTtcbm1vZHVsZS5leHBvcnRzID0gTWl4aW5DYWxsO1xuXG59LHtcIi4uL2Z1bmN0aW9ucy9kZWZhdWx0XCI6MjUsXCIuL21peGluLWRlZmluaXRpb25cIjo3MyxcIi4vbm9kZVwiOjc2LFwiLi9zZWxlY3RvclwiOjgyfV0sNzM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIFNlbGVjdG9yID0gcmVxdWlyZSgnLi9zZWxlY3RvcicpLFxuICAgIEVsZW1lbnQgPSByZXF1aXJlKCcuL2VsZW1lbnQnKSxcbiAgICBSdWxlc2V0ID0gcmVxdWlyZSgnLi9ydWxlc2V0JyksXG4gICAgRGVjbGFyYXRpb24gPSByZXF1aXJlKCcuL2RlY2xhcmF0aW9uJyksXG4gICAgRGV0YWNoZWRSdWxlc2V0ID0gcmVxdWlyZSgnLi9kZXRhY2hlZC1ydWxlc2V0JyksXG4gICAgRXhwcmVzc2lvbiA9IHJlcXVpcmUoJy4vZXhwcmVzc2lvbicpLFxuICAgIGNvbnRleHRzID0gcmVxdWlyZSgnLi4vY29udGV4dHMnKSxcbiAgICB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbnZhciBEZWZpbml0aW9uID0gZnVuY3Rpb24gKG5hbWUsIHBhcmFtcywgcnVsZXMsIGNvbmRpdGlvbiwgdmFyaWFkaWMsIGZyYW1lcywgdmlzaWJpbGl0eUluZm8pIHtcbiAgICB0aGlzLm5hbWUgPSBuYW1lIHx8ICdhbm9ueW1vdXMgbWl4aW4nO1xuICAgIHRoaXMuc2VsZWN0b3JzID0gW25ldyBTZWxlY3RvcihbbmV3IEVsZW1lbnQobnVsbCwgbmFtZSwgZmFsc2UsIHRoaXMuX2luZGV4LCB0aGlzLl9maWxlSW5mbyldKV07XG4gICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gICAgdGhpcy5jb25kaXRpb24gPSBjb25kaXRpb247XG4gICAgdGhpcy52YXJpYWRpYyA9IHZhcmlhZGljO1xuICAgIHRoaXMuYXJpdHkgPSBwYXJhbXMubGVuZ3RoO1xuICAgIHRoaXMucnVsZXMgPSBydWxlcztcbiAgICB0aGlzLl9sb29rdXBzID0ge307XG4gICAgdmFyIG9wdGlvbmFsUGFyYW1ldGVycyA9IFtdO1xuICAgIHRoaXMucmVxdWlyZWQgPSBwYXJhbXMucmVkdWNlKGZ1bmN0aW9uIChjb3VudCwgcCkge1xuICAgICAgICBpZiAoIXAubmFtZSB8fCAocC5uYW1lICYmICFwLnZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvdW50ICsgMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9wdGlvbmFsUGFyYW1ldGVycy5wdXNoKHAubmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgICAgIH1cbiAgICB9LCAwKTtcbiAgICB0aGlzLm9wdGlvbmFsUGFyYW1ldGVycyA9IG9wdGlvbmFsUGFyYW1ldGVycztcbiAgICB0aGlzLmZyYW1lcyA9IGZyYW1lcztcbiAgICB0aGlzLmNvcHlWaXNpYmlsaXR5SW5mbyh2aXNpYmlsaXR5SW5mbyk7XG4gICAgdGhpcy5hbGxvd1Jvb3QgPSB0cnVlO1xufTtcbkRlZmluaXRpb24ucHJvdG90eXBlID0gbmV3IFJ1bGVzZXQoKTtcbkRlZmluaXRpb24ucHJvdG90eXBlLnR5cGUgPSAnTWl4aW5EZWZpbml0aW9uJztcbkRlZmluaXRpb24ucHJvdG90eXBlLmV2YWxGaXJzdCA9IHRydWU7XG5EZWZpbml0aW9uLnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbiAodmlzaXRvcikge1xuICAgIGlmICh0aGlzLnBhcmFtcyAmJiB0aGlzLnBhcmFtcy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5wYXJhbXMgPSB2aXNpdG9yLnZpc2l0QXJyYXkodGhpcy5wYXJhbXMpO1xuICAgIH1cbiAgICB0aGlzLnJ1bGVzID0gdmlzaXRvci52aXNpdEFycmF5KHRoaXMucnVsZXMpO1xuICAgIGlmICh0aGlzLmNvbmRpdGlvbikge1xuICAgICAgICB0aGlzLmNvbmRpdGlvbiA9IHZpc2l0b3IudmlzaXQodGhpcy5jb25kaXRpb24pO1xuICAgIH1cbn07XG5EZWZpbml0aW9uLnByb3RvdHlwZS5ldmFsUGFyYW1zID0gZnVuY3Rpb24gKGNvbnRleHQsIG1peGluRW52LCBhcmdzLCBldmFsZEFyZ3VtZW50cykge1xuICAgIC8qIGpzaGludCBib3NzOnRydWUgKi9cbiAgICB2YXIgZnJhbWUgPSBuZXcgUnVsZXNldChudWxsLCBudWxsKSxcbiAgICAgICAgdmFyYXJncywgYXJnLFxuICAgICAgICBwYXJhbXMgPSB1dGlscy5jb3B5QXJyYXkodGhpcy5wYXJhbXMpLFxuICAgICAgICBpLCBqLCB2YWwsIG5hbWUsIGlzTmFtZWRGb3VuZCwgYXJnSW5kZXgsIGFyZ3NMZW5ndGggPSAwO1xuXG4gICAgaWYgKG1peGluRW52LmZyYW1lcyAmJiBtaXhpbkVudi5mcmFtZXNbMF0gJiYgbWl4aW5FbnYuZnJhbWVzWzBdLmZ1bmN0aW9uUmVnaXN0cnkpIHtcbiAgICAgICAgZnJhbWUuZnVuY3Rpb25SZWdpc3RyeSA9IG1peGluRW52LmZyYW1lc1swXS5mdW5jdGlvblJlZ2lzdHJ5LmluaGVyaXQoKTtcbiAgICB9XG4gICAgbWl4aW5FbnYgPSBuZXcgY29udGV4dHMuRXZhbChtaXhpbkVudiwgW2ZyYW1lXS5jb25jYXQobWl4aW5FbnYuZnJhbWVzKSk7XG5cbiAgICBpZiAoYXJncykge1xuICAgICAgICBhcmdzID0gdXRpbHMuY29weUFycmF5KGFyZ3MpO1xuICAgICAgICBhcmdzTGVuZ3RoID0gYXJncy5sZW5ndGg7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGFyZ3NMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnID0gYXJnc1tpXTtcbiAgICAgICAgICAgIGlmIChuYW1lID0gKGFyZyAmJiBhcmcubmFtZSkpIHtcbiAgICAgICAgICAgICAgICBpc05hbWVkRm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgcGFyYW1zLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZXZhbGRBcmd1bWVudHNbal0gJiYgbmFtZSA9PT0gcGFyYW1zW2pdLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2YWxkQXJndW1lbnRzW2pdID0gYXJnLnZhbHVlLmV2YWwoY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFtZS5wcmVwZW5kUnVsZShuZXcgRGVjbGFyYXRpb24obmFtZSwgYXJnLnZhbHVlLmV2YWwoY29udGV4dCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzTmFtZWRGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNOYW1lZEZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3Muc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IHsgdHlwZTogJ1J1bnRpbWUnLCBtZXNzYWdlOiAnTmFtZWQgYXJndW1lbnQgZm9yICcgKyB0aGlzLm5hbWUgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyAnICsgYXJnc1tpXS5uYW1lICsgJyBub3QgZm91bmQnIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFyZ0luZGV4ID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgcGFyYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChldmFsZEFyZ3VtZW50c1tpXSkgeyBjb250aW51ZTsgfVxuXG4gICAgICAgIGFyZyA9IGFyZ3MgJiYgYXJnc1thcmdJbmRleF07XG5cbiAgICAgICAgaWYgKG5hbWUgPSBwYXJhbXNbaV0ubmFtZSkge1xuICAgICAgICAgICAgaWYgKHBhcmFtc1tpXS52YXJpYWRpYykge1xuICAgICAgICAgICAgICAgIHZhcmFyZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSBhcmdJbmRleDsgaiA8IGFyZ3NMZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB2YXJhcmdzLnB1c2goYXJnc1tqXS52YWx1ZS5ldmFsKGNvbnRleHQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnJhbWUucHJlcGVuZFJ1bGUobmV3IERlY2xhcmF0aW9uKG5hbWUsIG5ldyBFeHByZXNzaW9uKHZhcmFyZ3MpLmV2YWwoY29udGV4dCkpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsID0gYXJnICYmIGFyZy52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAodmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgd2FzIGEgbWl4aW4gY2FsbCwgcGFzcyBpbiBhIGRldGFjaGVkIHJ1bGVzZXQgb2YgaXQncyBldmFsJ2QgcnVsZXNcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gbmV3IERldGFjaGVkUnVsZXNldChuZXcgUnVsZXNldCgnJywgdmFsKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSB2YWwuZXZhbChjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyYW1zW2ldLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IHBhcmFtc1tpXS52YWx1ZS5ldmFsKG1peGluRW52KTtcbiAgICAgICAgICAgICAgICAgICAgZnJhbWUucmVzZXRDYWNoZSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IHsgdHlwZTogJ1J1bnRpbWUnLCBtZXNzYWdlOiAnd3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyBmb3IgJyArIHRoaXMubmFtZSArXG4gICAgICAgICAgICAgICAgICAgICAgICAnICgnICsgYXJnc0xlbmd0aCArICcgZm9yICcgKyB0aGlzLmFyaXR5ICsgJyknIH07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnJhbWUucHJlcGVuZFJ1bGUobmV3IERlY2xhcmF0aW9uKG5hbWUsIHZhbCkpO1xuICAgICAgICAgICAgICAgIGV2YWxkQXJndW1lbnRzW2ldID0gdmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcmFtc1tpXS52YXJpYWRpYyAmJiBhcmdzKSB7XG4gICAgICAgICAgICBmb3IgKGogPSBhcmdJbmRleDsgaiA8IGFyZ3NMZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGV2YWxkQXJndW1lbnRzW2pdID0gYXJnc1tqXS52YWx1ZS5ldmFsKGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFyZ0luZGV4Kys7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZyYW1lO1xufTtcbkRlZmluaXRpb24ucHJvdG90eXBlLm1ha2VJbXBvcnRhbnQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcnVsZXMgPSAhdGhpcy5ydWxlcyA/IHRoaXMucnVsZXMgOiB0aGlzLnJ1bGVzLm1hcChmdW5jdGlvbiAocikge1xuICAgICAgICBpZiAoci5tYWtlSW1wb3J0YW50KSB7XG4gICAgICAgICAgICByZXR1cm4gci5tYWtlSW1wb3J0YW50KHRydWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgcmVzdWx0ID0gbmV3IERlZmluaXRpb24odGhpcy5uYW1lLCB0aGlzLnBhcmFtcywgcnVsZXMsIHRoaXMuY29uZGl0aW9uLCB0aGlzLnZhcmlhZGljLCB0aGlzLmZyYW1lcyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5EZWZpbml0aW9uLnByb3RvdHlwZS5ldmFsID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICByZXR1cm4gbmV3IERlZmluaXRpb24odGhpcy5uYW1lLCB0aGlzLnBhcmFtcywgdGhpcy5ydWxlcywgdGhpcy5jb25kaXRpb24sIHRoaXMudmFyaWFkaWMsIHRoaXMuZnJhbWVzIHx8IHV0aWxzLmNvcHlBcnJheShjb250ZXh0LmZyYW1lcykpO1xufTtcbkRlZmluaXRpb24ucHJvdG90eXBlLmV2YWxDYWxsID0gZnVuY3Rpb24gKGNvbnRleHQsIGFyZ3MsIGltcG9ydGFudCkge1xuICAgIHZhciBfYXJndW1lbnRzID0gW10sXG4gICAgICAgIG1peGluRnJhbWVzID0gdGhpcy5mcmFtZXMgPyB0aGlzLmZyYW1lcy5jb25jYXQoY29udGV4dC5mcmFtZXMpIDogY29udGV4dC5mcmFtZXMsXG4gICAgICAgIGZyYW1lID0gdGhpcy5ldmFsUGFyYW1zKGNvbnRleHQsIG5ldyBjb250ZXh0cy5FdmFsKGNvbnRleHQsIG1peGluRnJhbWVzKSwgYXJncywgX2FyZ3VtZW50cyksXG4gICAgICAgIHJ1bGVzLCBydWxlc2V0O1xuXG4gICAgZnJhbWUucHJlcGVuZFJ1bGUobmV3IERlY2xhcmF0aW9uKCdAYXJndW1lbnRzJywgbmV3IEV4cHJlc3Npb24oX2FyZ3VtZW50cykuZXZhbChjb250ZXh0KSkpO1xuXG4gICAgcnVsZXMgPSB1dGlscy5jb3B5QXJyYXkodGhpcy5ydWxlcyk7XG5cbiAgICBydWxlc2V0ID0gbmV3IFJ1bGVzZXQobnVsbCwgcnVsZXMpO1xuICAgIHJ1bGVzZXQub3JpZ2luYWxSdWxlc2V0ID0gdGhpcztcbiAgICBydWxlc2V0ID0gcnVsZXNldC5ldmFsKG5ldyBjb250ZXh0cy5FdmFsKGNvbnRleHQsIFt0aGlzLCBmcmFtZV0uY29uY2F0KG1peGluRnJhbWVzKSkpO1xuICAgIGlmIChpbXBvcnRhbnQpIHtcbiAgICAgICAgcnVsZXNldCA9IHJ1bGVzZXQubWFrZUltcG9ydGFudCgpO1xuICAgIH1cbiAgICByZXR1cm4gcnVsZXNldDtcbn07XG5EZWZpbml0aW9uLnByb3RvdHlwZS5tYXRjaENvbmRpdGlvbiA9IGZ1bmN0aW9uIChhcmdzLCBjb250ZXh0KSB7XG4gICAgaWYgKHRoaXMuY29uZGl0aW9uICYmICF0aGlzLmNvbmRpdGlvbi5ldmFsKFxuICAgICAgICBuZXcgY29udGV4dHMuRXZhbChjb250ZXh0LFxuICAgICAgICAgICAgW3RoaXMuZXZhbFBhcmFtcyhjb250ZXh0LCAvKiB0aGUgcGFyYW1ldGVyIHZhcmlhYmxlcyAqL1xuICAgICAgICAgICAgICAgIG5ldyBjb250ZXh0cy5FdmFsKGNvbnRleHQsIHRoaXMuZnJhbWVzID8gdGhpcy5mcmFtZXMuY29uY2F0KGNvbnRleHQuZnJhbWVzKSA6IGNvbnRleHQuZnJhbWVzKSwgYXJncywgW10pXVxuICAgICAgICAgICAgLmNvbmNhdCh0aGlzLmZyYW1lcyB8fCBbXSkgLy8gdGhlIHBhcmVudCBuYW1lc3BhY2UvbWl4aW4gZnJhbWVzXG4gICAgICAgICAgICAuY29uY2F0KGNvbnRleHQuZnJhbWVzKSkpKSB7IC8vIHRoZSBjdXJyZW50IGVudmlyb25tZW50IGZyYW1lc1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcbkRlZmluaXRpb24ucHJvdG90eXBlLm1hdGNoQXJncyA9IGZ1bmN0aW9uIChhcmdzLCBjb250ZXh0KSB7XG4gICAgdmFyIGFsbEFyZ3NDbnQgPSAoYXJncyAmJiBhcmdzLmxlbmd0aCkgfHwgMCwgbGVuLCBvcHRpb25hbFBhcmFtZXRlcnMgPSB0aGlzLm9wdGlvbmFsUGFyYW1ldGVycztcbiAgICB2YXIgcmVxdWlyZWRBcmdzQ250ID0gIWFyZ3MgPyAwIDogYXJncy5yZWR1Y2UoZnVuY3Rpb24gKGNvdW50LCBwKSB7XG4gICAgICAgIGlmIChvcHRpb25hbFBhcmFtZXRlcnMuaW5kZXhPZihwLm5hbWUpIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvdW50ICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjb3VudDtcbiAgICAgICAgfVxuICAgIH0sIDApO1xuXG4gICAgaWYgKCF0aGlzLnZhcmlhZGljKSB7XG4gICAgICAgIGlmIChyZXF1aXJlZEFyZ3NDbnQgPCB0aGlzLnJlcXVpcmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFsbEFyZ3NDbnQgPiB0aGlzLnBhcmFtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChyZXF1aXJlZEFyZ3NDbnQgPCAodGhpcy5yZXF1aXJlZCAtIDEpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjaGVjayBwYXR0ZXJuc1xuICAgIGxlbiA9IE1hdGgubWluKHJlcXVpcmVkQXJnc0NudCwgdGhpcy5hcml0eSk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmICghdGhpcy5wYXJhbXNbaV0ubmFtZSAmJiAhdGhpcy5wYXJhbXNbaV0udmFyaWFkaWMpIHtcbiAgICAgICAgICAgIGlmIChhcmdzW2ldLnZhbHVlLmV2YWwoY29udGV4dCkudG9DU1MoKSAhPSB0aGlzLnBhcmFtc1tpXS52YWx1ZS5ldmFsKGNvbnRleHQpLnRvQ1NTKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBEZWZpbml0aW9uO1xuXG59LHtcIi4uL2NvbnRleHRzXCI6MTMsXCIuLi91dGlsc1wiOjg5LFwiLi9kZWNsYXJhdGlvblwiOjYwLFwiLi9kZXRhY2hlZC1ydWxlc2V0XCI6NjEsXCIuL2VsZW1lbnRcIjo2MyxcIi4vZXhwcmVzc2lvblwiOjY0LFwiLi9ydWxlc2V0XCI6ODEsXCIuL3NlbGVjdG9yXCI6ODJ9XSw3NDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgTm9kZSA9IHJlcXVpcmUoJy4vbm9kZScpLFxuICAgIFZhcmlhYmxlID0gcmVxdWlyZSgnLi92YXJpYWJsZScpLFxuICAgIFJ1bGVzZXQgPSByZXF1aXJlKCcuL3J1bGVzZXQnKSxcbiAgICBTZWxlY3RvciA9IHJlcXVpcmUoJy4vc2VsZWN0b3InKTtcblxudmFyIE5hbWVzcGFjZVZhbHVlID0gZnVuY3Rpb24gKHJ1bGVDYWxsLCBsb29rdXBzLCBpbXBvcnRhbnQsIGluZGV4LCBmaWxlSW5mbykge1xuICAgIHRoaXMudmFsdWUgPSBydWxlQ2FsbDtcbiAgICB0aGlzLmxvb2t1cHMgPSBsb29rdXBzO1xuICAgIHRoaXMuaW1wb3J0YW50ID0gaW1wb3J0YW50O1xuICAgIHRoaXMuX2luZGV4ID0gaW5kZXg7XG4gICAgdGhpcy5fZmlsZUluZm8gPSBmaWxlSW5mbztcbn07XG5OYW1lc3BhY2VWYWx1ZS5wcm90b3R5cGUgPSBuZXcgTm9kZSgpO1xuTmFtZXNwYWNlVmFsdWUucHJvdG90eXBlLnR5cGUgPSAnTmFtZXNwYWNlVmFsdWUnO1xuTmFtZXNwYWNlVmFsdWUucHJvdG90eXBlLmV2YWwgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHZhciBpLCBqLCBuYW1lLCBydWxlcyA9IHRoaXMudmFsdWUuZXZhbChjb250ZXh0KTtcbiAgICBcbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sb29rdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG5hbWUgPSB0aGlzLmxvb2t1cHNbaV07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV2YWwnZCBEUnMgcmV0dXJuIHJ1bGVzZXRzLlxuICAgICAgICAgKiBFdmFsJ2QgbWl4aW5zIHJldHVybiBydWxlcywgc28gbGV0J3MgbWFrZSBhIHJ1bGVzZXQgaWYgd2UgbmVlZCBpdC5cbiAgICAgICAgICogV2UgbmVlZCB0byBkbyB0aGlzIGJlY2F1c2Ugb2YgbGF0ZSBwYXJzaW5nIG9mIHZhbHVlc1xuICAgICAgICAgKi9cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocnVsZXMpKSB7XG4gICAgICAgICAgICBydWxlcyA9IG5ldyBSdWxlc2V0KFtuZXcgU2VsZWN0b3IoKV0sIHJ1bGVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuYW1lID09PSAnJykge1xuICAgICAgICAgICAgcnVsZXMgPSBydWxlcy5sYXN0RGVjbGFyYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gJ0AnKSB7XG4gICAgICAgICAgICBpZiAobmFtZS5jaGFyQXQoMSkgPT09ICdAJykge1xuICAgICAgICAgICAgICAgIG5hbWUgPSAnQCcgKyBuZXcgVmFyaWFibGUobmFtZS5zdWJzdHIoMSkpLmV2YWwoY29udGV4dCkudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocnVsZXMudmFyaWFibGVzKSB7XG4gICAgICAgICAgICAgICAgcnVsZXMgPSBydWxlcy52YXJpYWJsZShuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKCFydWxlcykge1xuICAgICAgICAgICAgICAgIHRocm93IHsgdHlwZTogJ05hbWUnLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAndmFyaWFibGUgJyArIG5hbWUgKyAnIG5vdCBmb3VuZCcsXG4gICAgICAgICAgICAgICAgICAgIGZpbGVuYW1lOiB0aGlzLmZpbGVJbmZvKCkuZmlsZW5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiB0aGlzLmdldEluZGV4KCkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChuYW1lLnN1YnN0cmluZygwLCAyKSA9PT0gJyRAJykge1xuICAgICAgICAgICAgICAgIG5hbWUgPSAnJCcgKyBuZXcgVmFyaWFibGUobmFtZS5zdWJzdHIoMSkpLmV2YWwoY29udGV4dCkudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBuYW1lID0gbmFtZS5jaGFyQXQoMCkgPT09ICckJyA/IG5hbWUgOiAnJCcgKyBuYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJ1bGVzLnByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICBydWxlcyA9IHJ1bGVzLnByb3BlcnR5KG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgICAgIGlmICghcnVsZXMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB7IHR5cGU6ICdOYW1lJyxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ3Byb3BlcnR5IFwiJyArIG5hbWUuc3Vic3RyKDEpICsgJ1wiIG5vdCBmb3VuZCcsXG4gICAgICAgICAgICAgICAgICAgIGZpbGVuYW1lOiB0aGlzLmZpbGVJbmZvKCkuZmlsZW5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiB0aGlzLmdldEluZGV4KCkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFByb3BlcnRpZXMgYXJlIGFuIGFycmF5IG9mIHZhbHVlcywgc2luY2UgYSBydWxlc2V0IGNhbiBoYXZlIG11bHRpcGxlIHByb3BzLlxuICAgICAgICAgICAgLy8gV2UgcGljayB0aGUgbGFzdCBvbmUgKHRoZSBcImNhc2NhZGVkXCIgdmFsdWUpXG4gICAgICAgICAgICBydWxlcyA9IHJ1bGVzW3J1bGVzLmxlbmd0aCAtIDFdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJ1bGVzLnZhbHVlKSB7XG4gICAgICAgICAgICBydWxlcyA9IHJ1bGVzLmV2YWwoY29udGV4dCkudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJ1bGVzLnJ1bGVzZXQpIHtcbiAgICAgICAgICAgIHJ1bGVzID0gcnVsZXMucnVsZXNldC5ldmFsKGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBydWxlcztcbn07XG5tb2R1bGUuZXhwb3J0cyA9IE5hbWVzcGFjZVZhbHVlO1xuXG59LHtcIi4vbm9kZVwiOjc2LFwiLi9ydWxlc2V0XCI6ODEsXCIuL3NlbGVjdG9yXCI6ODIsXCIuL3ZhcmlhYmxlXCI6ODh9XSw3NTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgTm9kZSA9IHJlcXVpcmUoJy4vbm9kZScpLFxuICAgIE9wZXJhdGlvbiA9IHJlcXVpcmUoJy4vb3BlcmF0aW9uJyksXG4gICAgRGltZW5zaW9uID0gcmVxdWlyZSgnLi9kaW1lbnNpb24nKTtcblxudmFyIE5lZ2F0aXZlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICB0aGlzLnZhbHVlID0gbm9kZTtcbn07XG5OZWdhdGl2ZS5wcm90b3R5cGUgPSBuZXcgTm9kZSgpO1xuTmVnYXRpdmUucHJvdG90eXBlLnR5cGUgPSAnTmVnYXRpdmUnO1xuTmVnYXRpdmUucHJvdG90eXBlLmdlbkNTUyA9IGZ1bmN0aW9uIChjb250ZXh0LCBvdXRwdXQpIHtcbiAgICBvdXRwdXQuYWRkKCctJyk7XG4gICAgdGhpcy52YWx1ZS5nZW5DU1MoY29udGV4dCwgb3V0cHV0KTtcbn07XG5OZWdhdGl2ZS5wcm90b3R5cGUuZXZhbCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgaWYgKGNvbnRleHQuaXNNYXRoT24oKSkge1xuICAgICAgICByZXR1cm4gKG5ldyBPcGVyYXRpb24oJyonLCBbbmV3IERpbWVuc2lvbigtMSksIHRoaXMudmFsdWVdKSkuZXZhbChjb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBOZWdhdGl2ZSh0aGlzLnZhbHVlLmV2YWwoY29udGV4dCkpO1xufTtcbm1vZHVsZS5leHBvcnRzID0gTmVnYXRpdmU7XG5cbn0se1wiLi9kaW1lbnNpb25cIjo2MixcIi4vbm9kZVwiOjc2LFwiLi9vcGVyYXRpb25cIjo3N31dLDc2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBOb2RlID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgIHRoaXMudmlzaWJpbGl0eUJsb2NrcyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm5vZGVWaXNpYmxlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucm9vdE5vZGUgPSBudWxsO1xuICAgIHRoaXMucGFyc2VkID0gbnVsbDtcblxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2N1cnJlbnRGaWxlSW5mbycsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHNlbGYuZmlsZUluZm8oKTsgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnaW5kZXgnLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBzZWxmLmdldEluZGV4KCk7IH1cbiAgICB9KTtcblxufTtcbk5vZGUucHJvdG90eXBlLnNldFBhcmVudCA9IGZ1bmN0aW9uKG5vZGVzLCBwYXJlbnQpIHtcbiAgICBmdW5jdGlvbiBzZXQobm9kZSkge1xuICAgICAgICBpZiAobm9kZSAmJiBub2RlIGluc3RhbmNlb2YgTm9kZSkge1xuICAgICAgICAgICAgbm9kZS5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobm9kZXMpKSB7XG4gICAgICAgIG5vZGVzLmZvckVhY2goc2V0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHNldChub2Rlcyk7XG4gICAgfVxufTtcbk5vZGUucHJvdG90eXBlLmdldEluZGV4ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2luZGV4IHx8ICh0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC5nZXRJbmRleCgpKSB8fCAwO1xufTtcbk5vZGUucHJvdG90eXBlLmZpbGVJbmZvID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbGVJbmZvIHx8ICh0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC5maWxlSW5mbygpKSB8fCB7fTtcbn07XG5Ob2RlLnByb3RvdHlwZS5pc1J1bGVzZXRMaWtlID0gZnVuY3Rpb24oKSB7IHJldHVybiBmYWxzZTsgfTtcbk5vZGUucHJvdG90eXBlLnRvQ1NTID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICB2YXIgc3RycyA9IFtdO1xuICAgIHRoaXMuZ2VuQ1NTKGNvbnRleHQsIHtcbiAgICAgICAgYWRkOiBmdW5jdGlvbihjaHVuaywgZmlsZUluZm8sIGluZGV4KSB7XG4gICAgICAgICAgICBzdHJzLnB1c2goY2h1bmspO1xuICAgICAgICB9LFxuICAgICAgICBpc0VtcHR5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gc3Rycy5sZW5ndGggPT09IDA7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gc3Rycy5qb2luKCcnKTtcbn07XG5Ob2RlLnByb3RvdHlwZS5nZW5DU1MgPSBmdW5jdGlvbiAoY29udGV4dCwgb3V0cHV0KSB7XG4gICAgb3V0cHV0LmFkZCh0aGlzLnZhbHVlKTtcbn07XG5Ob2RlLnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbiAodmlzaXRvcikge1xuICAgIHRoaXMudmFsdWUgPSB2aXNpdG9yLnZpc2l0KHRoaXMudmFsdWUpO1xufTtcbk5vZGUucHJvdG90eXBlLmV2YWwgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xuTm9kZS5wcm90b3R5cGUuX29wZXJhdGUgPSBmdW5jdGlvbiAoY29udGV4dCwgb3AsIGEsIGIpIHtcbiAgICBzd2l0Y2ggKG9wKSB7XG4gICAgICAgIGNhc2UgJysnOiByZXR1cm4gYSArIGI7XG4gICAgICAgIGNhc2UgJy0nOiByZXR1cm4gYSAtIGI7XG4gICAgICAgIGNhc2UgJyonOiByZXR1cm4gYSAqIGI7XG4gICAgICAgIGNhc2UgJy8nOiByZXR1cm4gYSAvIGI7XG4gICAgfVxufTtcbk5vZGUucHJvdG90eXBlLmZyb3VuZCA9IGZ1bmN0aW9uKGNvbnRleHQsIHZhbHVlKSB7XG4gICAgdmFyIHByZWNpc2lvbiA9IGNvbnRleHQgJiYgY29udGV4dC5udW1QcmVjaXNpb247XG4gICAgLy8gYWRkIFwiZXBzaWxvblwiIHRvIGVuc3VyZSBudW1iZXJzIGxpa2UgMS4wMDAwMDAwMDUgKHJlcHJlc2VudGVkIGFzIDEuMDAwMDAwMDA0OTk5Li4uKSBhcmUgcHJvcGVybHkgcm91bmRlZDpcbiAgICByZXR1cm4gKHByZWNpc2lvbikgPyBOdW1iZXIoKHZhbHVlICsgMmUtMTYpLnRvRml4ZWQocHJlY2lzaW9uKSkgOiB2YWx1ZTtcbn07XG5Ob2RlLmNvbXBhcmUgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIC8qIHJldHVybnM6XG4gICAgIC0xOiBhIDwgYlxuICAgICAwOiBhID0gYlxuICAgICAxOiBhID4gYlxuICAgICBhbmQgKmFueSogb3RoZXIgdmFsdWUgZm9yIGEgIT0gYiAoZS5nLiB1bmRlZmluZWQsIE5hTiwgLTIgZXRjLikgKi9cblxuICAgIGlmICgoYS5jb21wYXJlKSAmJlxuICAgICAgICAvLyBmb3IgXCJzeW1tZXRyaWMgcmVzdWx0c1wiIGZvcmNlIHRvQ1NTLWJhc2VkIGNvbXBhcmlzb25cbiAgICAgICAgLy8gb2YgUXVvdGVkIG9yIEFub255bW91cyBpZiBlaXRoZXIgdmFsdWUgaXMgb25lIG9mIHRob3NlXG4gICAgICAgICEoYi50eXBlID09PSAnUXVvdGVkJyB8fCBiLnR5cGUgPT09ICdBbm9ueW1vdXMnKSkge1xuICAgICAgICByZXR1cm4gYS5jb21wYXJlKGIpO1xuICAgIH0gZWxzZSBpZiAoYi5jb21wYXJlKSB7XG4gICAgICAgIHJldHVybiAtYi5jb21wYXJlKGEpO1xuICAgIH0gZWxzZSBpZiAoYS50eXBlICE9PSBiLnR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBhID0gYS52YWx1ZTtcbiAgICBiID0gYi52YWx1ZTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYSkpIHtcbiAgICAgICAgcmV0dXJuIGEgPT09IGIgPyAwIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoTm9kZS5jb21wYXJlKGFbaV0sIGJbaV0pICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAwO1xufTtcblxuTm9kZS5udW1lcmljQ29tcGFyZSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGEgIDwgIGIgPyAtMVxuICAgICAgICA6IGEgPT09IGIgPyAgMFxuICAgICAgICA6IGEgID4gIGIgPyAgMSA6IHVuZGVmaW5lZDtcbn07XG4vLyBSZXR1cm5zIHRydWUgaWYgdGhpcyBub2RlIHJlcHJlc2VudHMgcm9vdCBvZiBhc3QgaW1wb3J0ZWQgYnkgcmVmZXJlbmNlXG5Ob2RlLnByb3RvdHlwZS5ibG9ja3NWaXNpYmlsaXR5ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnZpc2liaWxpdHlCbG9ja3MgPT0gbnVsbCkge1xuICAgICAgICB0aGlzLnZpc2liaWxpdHlCbG9ja3MgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy52aXNpYmlsaXR5QmxvY2tzICE9PSAwO1xufTtcbk5vZGUucHJvdG90eXBlLmFkZFZpc2liaWxpdHlCbG9jayA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy52aXNpYmlsaXR5QmxvY2tzID09IG51bGwpIHtcbiAgICAgICAgdGhpcy52aXNpYmlsaXR5QmxvY2tzID0gMDtcbiAgICB9XG4gICAgdGhpcy52aXNpYmlsaXR5QmxvY2tzID0gdGhpcy52aXNpYmlsaXR5QmxvY2tzICsgMTtcbn07XG5Ob2RlLnByb3RvdHlwZS5yZW1vdmVWaXNpYmlsaXR5QmxvY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMudmlzaWJpbGl0eUJsb2NrcyA9PSBudWxsKSB7XG4gICAgICAgIHRoaXMudmlzaWJpbGl0eUJsb2NrcyA9IDA7XG4gICAgfVxuICAgIHRoaXMudmlzaWJpbGl0eUJsb2NrcyA9IHRoaXMudmlzaWJpbGl0eUJsb2NrcyAtIDE7XG59O1xuLy8gVHVybnMgb24gbm9kZSB2aXNpYmlsaXR5IC0gaWYgY2FsbGVkIG5vZGUgd2lsbCBiZSBzaG93biBpbiBvdXRwdXQgcmVnYXJkbGVzc1xuLy8gb2Ygd2hldGhlciBpdCBjb21lcyBmcm9tIGltcG9ydCBieSByZWZlcmVuY2Ugb3Igbm90XG5Ob2RlLnByb3RvdHlwZS5lbnN1cmVWaXNpYmlsaXR5ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMubm9kZVZpc2libGUgPSB0cnVlO1xufTtcbi8vIFR1cm5zIG9mZiBub2RlIHZpc2liaWxpdHkgLSBpZiBjYWxsZWQgbm9kZSB3aWxsIE5PVCBiZSBzaG93biBpbiBvdXRwdXQgcmVnYXJkbGVzc1xuLy8gb2Ygd2hldGhlciBpdCBjb21lcyBmcm9tIGltcG9ydCBieSByZWZlcmVuY2Ugb3Igbm90XG5Ob2RlLnByb3RvdHlwZS5lbnN1cmVJbnZpc2liaWxpdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5ub2RlVmlzaWJsZSA9IGZhbHNlO1xufTtcbi8vIHJldHVybiB2YWx1ZXM6XG4vLyBmYWxzZSAtIHRoZSBub2RlIG11c3Qgbm90IGJlIHZpc2libGVcbi8vIHRydWUgLSB0aGUgbm9kZSBtdXN0IGJlIHZpc2libGVcbi8vIHVuZGVmaW5lZCBvciBudWxsIC0gdGhlIG5vZGUgaGFzIHRoZSBzYW1lIHZpc2liaWxpdHkgYXMgaXRzIHBhcmVudFxuTm9kZS5wcm90b3R5cGUuaXNWaXNpYmxlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm5vZGVWaXNpYmxlO1xufTtcbk5vZGUucHJvdG90eXBlLnZpc2liaWxpdHlJbmZvID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdmlzaWJpbGl0eUJsb2NrczogdGhpcy52aXNpYmlsaXR5QmxvY2tzLFxuICAgICAgICBub2RlVmlzaWJsZTogdGhpcy5ub2RlVmlzaWJsZVxuICAgIH07XG59O1xuTm9kZS5wcm90b3R5cGUuY29weVZpc2liaWxpdHlJbmZvID0gZnVuY3Rpb24oaW5mbykge1xuICAgIGlmICghaW5mbykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMudmlzaWJpbGl0eUJsb2NrcyA9IGluZm8udmlzaWJpbGl0eUJsb2NrcztcbiAgICB0aGlzLm5vZGVWaXNpYmxlID0gaW5mby5ub2RlVmlzaWJsZTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IE5vZGU7XG5cbn0se31dLDc3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBOb2RlID0gcmVxdWlyZSgnLi9ub2RlJyksXG4gICAgQ29sb3IgPSByZXF1aXJlKCcuL2NvbG9yJyksXG4gICAgRGltZW5zaW9uID0gcmVxdWlyZSgnLi9kaW1lbnNpb24nKSxcbiAgICBNQVRIID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzJykuTWF0aDtcblxudmFyIE9wZXJhdGlvbiA9IGZ1bmN0aW9uIChvcCwgb3BlcmFuZHMsIGlzU3BhY2VkKSB7XG4gICAgdGhpcy5vcCA9IG9wLnRyaW0oKTtcbiAgICB0aGlzLm9wZXJhbmRzID0gb3BlcmFuZHM7XG4gICAgdGhpcy5pc1NwYWNlZCA9IGlzU3BhY2VkO1xufTtcbk9wZXJhdGlvbi5wcm90b3R5cGUgPSBuZXcgTm9kZSgpO1xuT3BlcmF0aW9uLnByb3RvdHlwZS50eXBlID0gJ09wZXJhdGlvbic7XG5PcGVyYXRpb24ucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uICh2aXNpdG9yKSB7XG4gICAgdGhpcy5vcGVyYW5kcyA9IHZpc2l0b3IudmlzaXQodGhpcy5vcGVyYW5kcyk7XG59O1xuT3BlcmF0aW9uLnByb3RvdHlwZS5ldmFsID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICB2YXIgYSA9IHRoaXMub3BlcmFuZHNbMF0uZXZhbChjb250ZXh0KSxcbiAgICAgICAgYiA9IHRoaXMub3BlcmFuZHNbMV0uZXZhbChjb250ZXh0KSxcbiAgICAgICAgb3A7XG5cbiAgICBpZiAoY29udGV4dC5pc01hdGhPbih0aGlzLm9wKSkge1xuICAgICAgICBvcCA9IHRoaXMub3AgPT09ICcuLycgPyAnLycgOiB0aGlzLm9wO1xuICAgICAgICBpZiAoYSBpbnN0YW5jZW9mIERpbWVuc2lvbiAmJiBiIGluc3RhbmNlb2YgQ29sb3IpIHtcbiAgICAgICAgICAgIGEgPSBhLnRvQ29sb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYiBpbnN0YW5jZW9mIERpbWVuc2lvbiAmJiBhIGluc3RhbmNlb2YgQ29sb3IpIHtcbiAgICAgICAgICAgIGIgPSBiLnRvQ29sb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWEub3BlcmF0ZSkge1xuICAgICAgICAgICAgaWYgKGEgaW5zdGFuY2VvZiBPcGVyYXRpb24gJiYgYS5vcCA9PT0gJy8nICYmIGNvbnRleHQubWF0aCA9PT0gTUFUSC5QQVJFTlNfRElWSVNJT04pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE9wZXJhdGlvbih0aGlzLm9wLCBbYSwgYl0sIHRoaXMuaXNTcGFjZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgeyB0eXBlOiAnT3BlcmF0aW9uJyxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnT3BlcmF0aW9uIG9uIGFuIGludmFsaWQgdHlwZScgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhLm9wZXJhdGUoY29udGV4dCwgb3AsIGIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgT3BlcmF0aW9uKHRoaXMub3AsIFthLCBiXSwgdGhpcy5pc1NwYWNlZCk7XG4gICAgfVxufTtcbk9wZXJhdGlvbi5wcm90b3R5cGUuZ2VuQ1NTID0gZnVuY3Rpb24gKGNvbnRleHQsIG91dHB1dCkge1xuICAgIHRoaXMub3BlcmFuZHNbMF0uZ2VuQ1NTKGNvbnRleHQsIG91dHB1dCk7XG4gICAgaWYgKHRoaXMuaXNTcGFjZWQpIHtcbiAgICAgICAgb3V0cHV0LmFkZCgnICcpO1xuICAgIH1cbiAgICBvdXRwdXQuYWRkKHRoaXMub3ApO1xuICAgIGlmICh0aGlzLmlzU3BhY2VkKSB7XG4gICAgICAgIG91dHB1dC5hZGQoJyAnKTtcbiAgICB9XG4gICAgdGhpcy5vcGVyYW5kc1sxXS5nZW5DU1MoY29udGV4dCwgb3V0cHV0KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gT3BlcmF0aW9uO1xuXG59LHtcIi4uL2NvbnN0YW50c1wiOjEyLFwiLi9jb2xvclwiOjU1LFwiLi9kaW1lbnNpb25cIjo2MixcIi4vbm9kZVwiOjc2fV0sNzg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIE5vZGUgPSByZXF1aXJlKCcuL25vZGUnKTtcblxudmFyIFBhcmVuID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICB0aGlzLnZhbHVlID0gbm9kZTtcbn07XG5QYXJlbi5wcm90b3R5cGUgPSBuZXcgTm9kZSgpO1xuUGFyZW4ucHJvdG90eXBlLnR5cGUgPSAnUGFyZW4nO1xuUGFyZW4ucHJvdG90eXBlLmdlbkNTUyA9IGZ1bmN0aW9uIChjb250ZXh0LCBvdXRwdXQpIHtcbiAgICBvdXRwdXQuYWRkKCcoJyk7XG4gICAgdGhpcy52YWx1ZS5nZW5DU1MoY29udGV4dCwgb3V0cHV0KTtcbiAgICBvdXRwdXQuYWRkKCcpJyk7XG59O1xuUGFyZW4ucHJvdG90eXBlLmV2YWwgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHJldHVybiBuZXcgUGFyZW4odGhpcy52YWx1ZS5ldmFsKGNvbnRleHQpKTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IFBhcmVuO1xuXG59LHtcIi4vbm9kZVwiOjc2fV0sNzk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIE5vZGUgPSByZXF1aXJlKCcuL25vZGUnKSxcbiAgICBEZWNsYXJhdGlvbiA9IHJlcXVpcmUoJy4vZGVjbGFyYXRpb24nKTtcblxudmFyIFByb3BlcnR5ID0gZnVuY3Rpb24gKG5hbWUsIGluZGV4LCBjdXJyZW50RmlsZUluZm8pIHtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMuX2luZGV4ID0gaW5kZXg7XG4gICAgdGhpcy5fZmlsZUluZm8gPSBjdXJyZW50RmlsZUluZm87XG59O1xuUHJvcGVydHkucHJvdG90eXBlID0gbmV3IE5vZGUoKTtcblByb3BlcnR5LnByb3RvdHlwZS50eXBlID0gJ1Byb3BlcnR5JztcblByb3BlcnR5LnByb3RvdHlwZS5ldmFsID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICB2YXIgcHJvcGVydHksIG5hbWUgPSB0aGlzLm5hbWU7XG4gICAgLy8gVE9ETzogc2hvcnRlbiB0aGlzIHJlZmVyZW5jZVxuICAgIHZhciBtZXJnZVJ1bGVzID0gY29udGV4dC5wbHVnaW5NYW5hZ2VyLmxlc3MudmlzaXRvcnMuVG9DU1NWaXNpdG9yLnByb3RvdHlwZS5fbWVyZ2VSdWxlcztcblxuICAgIGlmICh0aGlzLmV2YWx1YXRpbmcpIHtcbiAgICAgICAgdGhyb3cgeyB0eXBlOiAnTmFtZScsXG4gICAgICAgICAgICBtZXNzYWdlOiAnUmVjdXJzaXZlIHByb3BlcnR5IHJlZmVyZW5jZSBmb3IgJyArIG5hbWUsXG4gICAgICAgICAgICBmaWxlbmFtZTogdGhpcy5maWxlSW5mbygpLmZpbGVuYW1lLFxuICAgICAgICAgICAgaW5kZXg6IHRoaXMuZ2V0SW5kZXgoKSB9O1xuICAgIH1cblxuICAgIHRoaXMuZXZhbHVhdGluZyA9IHRydWU7XG5cbiAgICBwcm9wZXJ0eSA9IHRoaXMuZmluZChjb250ZXh0LmZyYW1lcywgZnVuY3Rpb24gKGZyYW1lKSB7XG5cbiAgICAgICAgdmFyIHYsIHZBcnIgPSBmcmFtZS5wcm9wZXJ0eShuYW1lKTtcbiAgICAgICAgaWYgKHZBcnIpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdkFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHYgPSB2QXJyW2ldO1xuXG4gICAgICAgICAgICAgICAgdkFycltpXSA9IG5ldyBEZWNsYXJhdGlvbih2Lm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHYudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHYuaW1wb3J0YW50LFxuICAgICAgICAgICAgICAgICAgICB2Lm1lcmdlLFxuICAgICAgICAgICAgICAgICAgICB2LmluZGV4LFxuICAgICAgICAgICAgICAgICAgICB2LmN1cnJlbnRGaWxlSW5mbyxcbiAgICAgICAgICAgICAgICAgICAgdi5pbmxpbmUsXG4gICAgICAgICAgICAgICAgICAgIHYudmFyaWFibGVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWVyZ2VSdWxlcyh2QXJyKTtcblxuICAgICAgICAgICAgdiA9IHZBcnJbdkFyci5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGlmICh2LmltcG9ydGFudCkge1xuICAgICAgICAgICAgICAgIHZhciBpbXBvcnRhbnRTY29wZSA9IGNvbnRleHQuaW1wb3J0YW50U2NvcGVbY29udGV4dC5pbXBvcnRhbnRTY29wZS5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBpbXBvcnRhbnRTY29wZS5pbXBvcnRhbnQgPSB2LmltcG9ydGFudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHYgPSB2LnZhbHVlLmV2YWwoY29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChwcm9wZXJ0eSkge1xuICAgICAgICB0aGlzLmV2YWx1YXRpbmcgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHByb3BlcnR5O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IHsgdHlwZTogJ05hbWUnLFxuICAgICAgICAgICAgbWVzc2FnZTogJ1Byb3BlcnR5IFxcJycgKyBuYW1lICsgJ1xcJyBpcyB1bmRlZmluZWQnLFxuICAgICAgICAgICAgZmlsZW5hbWU6IHRoaXMuY3VycmVudEZpbGVJbmZvLmZpbGVuYW1lLFxuICAgICAgICAgICAgaW5kZXg6IHRoaXMuaW5kZXggfTtcbiAgICB9XG59O1xuUHJvcGVydHkucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbiAob2JqLCBmdW4pIHtcbiAgICBmb3IgKHZhciBpID0gMCwgcjsgaSA8IG9iai5sZW5ndGg7IGkrKykge1xuICAgICAgICByID0gZnVuLmNhbGwob2JqLCBvYmpbaV0pO1xuICAgICAgICBpZiAocikgeyByZXR1cm4gcjsgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IFByb3BlcnR5O1xuXG59LHtcIi4vZGVjbGFyYXRpb25cIjo2MCxcIi4vbm9kZVwiOjc2fV0sODA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIE5vZGUgPSByZXF1aXJlKCcuL25vZGUnKSxcbiAgICBWYXJpYWJsZSA9IHJlcXVpcmUoJy4vdmFyaWFibGUnKSxcbiAgICBQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vcHJvcGVydHknKTtcblxudmFyIFF1b3RlZCA9IGZ1bmN0aW9uIChzdHIsIGNvbnRlbnQsIGVzY2FwZWQsIGluZGV4LCBjdXJyZW50RmlsZUluZm8pIHtcbiAgICB0aGlzLmVzY2FwZWQgPSAoZXNjYXBlZCA9PSBudWxsKSA/IHRydWUgOiBlc2NhcGVkO1xuICAgIHRoaXMudmFsdWUgPSBjb250ZW50IHx8ICcnO1xuICAgIHRoaXMucXVvdGUgPSBzdHIuY2hhckF0KDApO1xuICAgIHRoaXMuX2luZGV4ID0gaW5kZXg7XG4gICAgdGhpcy5fZmlsZUluZm8gPSBjdXJyZW50RmlsZUluZm87XG4gICAgdGhpcy52YXJpYWJsZVJlZ2V4ID0gL0BcXHsoW1xcdy1dKylcXH0vZztcbiAgICB0aGlzLnByb3BSZWdleCA9IC9cXCRcXHsoW1xcdy1dKylcXH0vZztcbn07XG5RdW90ZWQucHJvdG90eXBlID0gbmV3IE5vZGUoKTtcblF1b3RlZC5wcm90b3R5cGUudHlwZSA9ICdRdW90ZWQnO1xuUXVvdGVkLnByb3RvdHlwZS5nZW5DU1MgPSBmdW5jdGlvbiAoY29udGV4dCwgb3V0cHV0KSB7XG4gICAgaWYgKCF0aGlzLmVzY2FwZWQpIHtcbiAgICAgICAgb3V0cHV0LmFkZCh0aGlzLnF1b3RlLCB0aGlzLmZpbGVJbmZvKCksIHRoaXMuZ2V0SW5kZXgoKSk7XG4gICAgfVxuICAgIG91dHB1dC5hZGQodGhpcy52YWx1ZSk7XG4gICAgaWYgKCF0aGlzLmVzY2FwZWQpIHtcbiAgICAgICAgb3V0cHV0LmFkZCh0aGlzLnF1b3RlKTtcbiAgICB9XG59O1xuUXVvdGVkLnByb3RvdHlwZS5jb250YWluc1ZhcmlhYmxlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlLm1hdGNoKHRoaXMudmFyaWFibGVSZWdleCk7XG59O1xuUXVvdGVkLnByb3RvdHlwZS5ldmFsID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXMsIHZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICB2YXIgdmFyaWFibGVSZXBsYWNlbWVudCA9IGZ1bmN0aW9uIChfLCBuYW1lKSB7XG4gICAgICAgIHZhciB2ID0gbmV3IFZhcmlhYmxlKCdAJyArIG5hbWUsIHRoYXQuZ2V0SW5kZXgoKSwgdGhhdC5maWxlSW5mbygpKS5ldmFsKGNvbnRleHQsIHRydWUpO1xuICAgICAgICByZXR1cm4gKHYgaW5zdGFuY2VvZiBRdW90ZWQpID8gdi52YWx1ZSA6IHYudG9DU1MoKTtcbiAgICB9O1xuICAgIHZhciBwcm9wZXJ0eVJlcGxhY2VtZW50ID0gZnVuY3Rpb24gKF8sIG5hbWUpIHtcbiAgICAgICAgdmFyIHYgPSBuZXcgUHJvcGVydHkoJyQnICsgbmFtZSwgdGhhdC5nZXRJbmRleCgpLCB0aGF0LmZpbGVJbmZvKCkpLmV2YWwoY29udGV4dCwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiAodiBpbnN0YW5jZW9mIFF1b3RlZCkgPyB2LnZhbHVlIDogdi50b0NTUygpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gaXRlcmF0aXZlUmVwbGFjZSh2YWx1ZSwgcmVnZXhwLCByZXBsYWNlbWVudEZuYykge1xuICAgICAgICB2YXIgZXZhbHVhdGVkVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgdmFsdWUgPSBldmFsdWF0ZWRWYWx1ZTtcbiAgICAgICAgICAgIGV2YWx1YXRlZFZhbHVlID0gdmFsdWUucmVwbGFjZShyZWdleHAsIHJlcGxhY2VtZW50Rm5jKTtcbiAgICAgICAgfSB3aGlsZSAodmFsdWUgIT09IGV2YWx1YXRlZFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGV2YWx1YXRlZFZhbHVlO1xuICAgIH1cbiAgICB2YWx1ZSA9IGl0ZXJhdGl2ZVJlcGxhY2UodmFsdWUsIHRoaXMudmFyaWFibGVSZWdleCwgdmFyaWFibGVSZXBsYWNlbWVudCk7XG4gICAgdmFsdWUgPSBpdGVyYXRpdmVSZXBsYWNlKHZhbHVlLCB0aGlzLnByb3BSZWdleCwgcHJvcGVydHlSZXBsYWNlbWVudCk7XG4gICAgcmV0dXJuIG5ldyBRdW90ZWQodGhpcy5xdW90ZSArIHZhbHVlICsgdGhpcy5xdW90ZSwgdmFsdWUsIHRoaXMuZXNjYXBlZCwgdGhpcy5nZXRJbmRleCgpLCB0aGlzLmZpbGVJbmZvKCkpO1xufTtcblF1b3RlZC5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgIC8vIHdoZW4gY29tcGFyaW5nIHF1b3RlZCBzdHJpbmdzIGFsbG93IHRoZSBxdW90ZSB0byBkaWZmZXJcbiAgICBpZiAob3RoZXIudHlwZSA9PT0gJ1F1b3RlZCcgJiYgIXRoaXMuZXNjYXBlZCAmJiAhb3RoZXIuZXNjYXBlZCkge1xuICAgICAgICByZXR1cm4gTm9kZS5udW1lcmljQ29tcGFyZSh0aGlzLnZhbHVlLCBvdGhlci52YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG90aGVyLnRvQ1NTICYmIHRoaXMudG9DU1MoKSA9PT0gb3RoZXIudG9DU1MoKSA/IDAgOiB1bmRlZmluZWQ7XG4gICAgfVxufTtcbm1vZHVsZS5leHBvcnRzID0gUXVvdGVkO1xuXG59LHtcIi4vbm9kZVwiOjc2LFwiLi9wcm9wZXJ0eVwiOjc5LFwiLi92YXJpYWJsZVwiOjg4fV0sODE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIE5vZGUgPSByZXF1aXJlKCcuL25vZGUnKSxcbiAgICBEZWNsYXJhdGlvbiA9IHJlcXVpcmUoJy4vZGVjbGFyYXRpb24nKSxcbiAgICBLZXl3b3JkID0gcmVxdWlyZSgnLi9rZXl3b3JkJyksXG4gICAgQ29tbWVudCA9IHJlcXVpcmUoJy4vY29tbWVudCcpLFxuICAgIFBhcmVuID0gcmVxdWlyZSgnLi9wYXJlbicpLFxuICAgIFNlbGVjdG9yID0gcmVxdWlyZSgnLi9zZWxlY3RvcicpLFxuICAgIEVsZW1lbnQgPSByZXF1aXJlKCcuL2VsZW1lbnQnKSxcbiAgICBBbm9ueW1vdXMgPSByZXF1aXJlKCcuL2Fub255bW91cycpLFxuICAgIGNvbnRleHRzID0gcmVxdWlyZSgnLi4vY29udGV4dHMnKSxcbiAgICBnbG9iYWxGdW5jdGlvblJlZ2lzdHJ5ID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL2Z1bmN0aW9uLXJlZ2lzdHJ5JyksXG4gICAgZGVmYXVsdEZ1bmMgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvZGVmYXVsdCcpLFxuICAgIGdldERlYnVnSW5mbyA9IHJlcXVpcmUoJy4vZGVidWctaW5mbycpLFxuICAgIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxudmFyIFJ1bGVzZXQgPSBmdW5jdGlvbiAoc2VsZWN0b3JzLCBydWxlcywgc3RyaWN0SW1wb3J0cywgdmlzaWJpbGl0eUluZm8pIHtcbiAgICB0aGlzLnNlbGVjdG9ycyA9IHNlbGVjdG9ycztcbiAgICB0aGlzLnJ1bGVzID0gcnVsZXM7XG4gICAgdGhpcy5fbG9va3VwcyA9IHt9O1xuICAgIHRoaXMuX3ZhcmlhYmxlcyA9IG51bGw7XG4gICAgdGhpcy5fcHJvcGVydGllcyA9IG51bGw7XG4gICAgdGhpcy5zdHJpY3RJbXBvcnRzID0gc3RyaWN0SW1wb3J0cztcbiAgICB0aGlzLmNvcHlWaXNpYmlsaXR5SW5mbyh2aXNpYmlsaXR5SW5mbyk7XG4gICAgdGhpcy5hbGxvd1Jvb3QgPSB0cnVlO1xuXG4gICAgdGhpcy5zZXRQYXJlbnQodGhpcy5zZWxlY3RvcnMsIHRoaXMpO1xuICAgIHRoaXMuc2V0UGFyZW50KHRoaXMucnVsZXMsIHRoaXMpO1xuXG59O1xuUnVsZXNldC5wcm90b3R5cGUgPSBuZXcgTm9kZSgpO1xuUnVsZXNldC5wcm90b3R5cGUudHlwZSA9ICdSdWxlc2V0JztcblJ1bGVzZXQucHJvdG90eXBlLmlzUnVsZXNldCA9IHRydWU7XG5SdWxlc2V0LnByb3RvdHlwZS5pc1J1bGVzZXRMaWtlID0gZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlOyB9O1xuUnVsZXNldC5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24gKHZpc2l0b3IpIHtcbiAgICBpZiAodGhpcy5wYXRocykge1xuICAgICAgICB0aGlzLnBhdGhzID0gdmlzaXRvci52aXNpdEFycmF5KHRoaXMucGF0aHMsIHRydWUpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zZWxlY3RvcnMpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RvcnMgPSB2aXNpdG9yLnZpc2l0QXJyYXkodGhpcy5zZWxlY3RvcnMpO1xuICAgIH1cbiAgICBpZiAodGhpcy5ydWxlcyAmJiB0aGlzLnJ1bGVzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLnJ1bGVzID0gdmlzaXRvci52aXNpdEFycmF5KHRoaXMucnVsZXMpO1xuICAgIH1cbn07XG5SdWxlc2V0LnByb3RvdHlwZS5ldmFsID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXMsIHNlbGVjdG9ycywgc2VsQ250LCBzZWxlY3RvciwgaSwgaGFzVmFyaWFibGUsIGhhc09uZVBhc3NpbmdTZWxlY3RvciA9IGZhbHNlO1xuXG4gICAgaWYgKHRoaXMuc2VsZWN0b3JzICYmIChzZWxDbnQgPSB0aGlzLnNlbGVjdG9ycy5sZW5ndGgpKSB7XG4gICAgICAgIHNlbGVjdG9ycyA9IG5ldyBBcnJheShzZWxDbnQpO1xuICAgICAgICBkZWZhdWx0RnVuYy5lcnJvcih7XG4gICAgICAgICAgICB0eXBlOiAnU3ludGF4JyxcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdpdCBpcyBjdXJyZW50bHkgb25seSBhbGxvd2VkIGluIHBhcmFtZXRyaWMgbWl4aW4gZ3VhcmRzLCdcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNlbENudDsgaSsrKSB7XG4gICAgICAgICAgICBzZWxlY3RvciA9IHRoaXMuc2VsZWN0b3JzW2ldLmV2YWwoY29udGV4dCk7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNlbGVjdG9yLmVsZW1lbnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdG9yLmVsZW1lbnRzW2pdLmlzVmFyaWFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzVmFyaWFibGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxlY3RvcnNbaV0gPSBzZWxlY3RvcjtcbiAgICAgICAgICAgIGlmIChzZWxlY3Rvci5ldmFsZENvbmRpdGlvbikge1xuICAgICAgICAgICAgICAgIGhhc09uZVBhc3NpbmdTZWxlY3RvciA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzVmFyaWFibGUpIHtcbiAgICAgICAgICAgIHZhciB0b1BhcnNlU2VsZWN0b3JzID0gbmV3IEFycmF5KHNlbENudCk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2VsQ250OyBpKyspIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RvciA9IHNlbGVjdG9yc1tpXTtcbiAgICAgICAgICAgICAgICB0b1BhcnNlU2VsZWN0b3JzW2ldID0gc2VsZWN0b3IudG9DU1MoY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnBhcnNlLnBhcnNlTm9kZShcbiAgICAgICAgICAgICAgICB0b1BhcnNlU2VsZWN0b3JzLmpvaW4oJywnKSxcbiAgICAgICAgICAgICAgICBbXCJzZWxlY3RvcnNcIl0sIFxuICAgICAgICAgICAgICAgIHNlbGVjdG9yc1swXS5nZXRJbmRleCgpLCBcbiAgICAgICAgICAgICAgICBzZWxlY3RvcnNbMF0uZmlsZUluZm8oKSwgXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24oZXJyLCByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3JzID0gdXRpbHMuZmxhdHRlbkFycmF5KHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlZmF1bHRGdW5jLnJlc2V0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaGFzT25lUGFzc2luZ1NlbGVjdG9yID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgcnVsZXMgPSB0aGlzLnJ1bGVzID8gdXRpbHMuY29weUFycmF5KHRoaXMucnVsZXMpIDogbnVsbCxcbiAgICAgICAgcnVsZXNldCA9IG5ldyBSdWxlc2V0KHNlbGVjdG9ycywgcnVsZXMsIHRoaXMuc3RyaWN0SW1wb3J0cywgdGhpcy52aXNpYmlsaXR5SW5mbygpKSxcbiAgICAgICAgcnVsZSwgc3ViUnVsZTtcblxuICAgIHJ1bGVzZXQub3JpZ2luYWxSdWxlc2V0ID0gdGhpcztcbiAgICBydWxlc2V0LnJvb3QgPSB0aGlzLnJvb3Q7XG4gICAgcnVsZXNldC5maXJzdFJvb3QgPSB0aGlzLmZpcnN0Um9vdDtcbiAgICBydWxlc2V0LmFsbG93SW1wb3J0cyA9IHRoaXMuYWxsb3dJbXBvcnRzO1xuXG4gICAgaWYgKHRoaXMuZGVidWdJbmZvKSB7XG4gICAgICAgIHJ1bGVzZXQuZGVidWdJbmZvID0gdGhpcy5kZWJ1Z0luZm87XG4gICAgfVxuXG4gICAgaWYgKCFoYXNPbmVQYXNzaW5nU2VsZWN0b3IpIHtcbiAgICAgICAgcnVsZXMubGVuZ3RoID0gMDtcbiAgICB9XG5cbiAgICAvLyBpbmhlcml0IGEgZnVuY3Rpb24gcmVnaXN0cnkgZnJvbSB0aGUgZnJhbWVzIHN0YWNrIHdoZW4gcG9zc2libGU7XG4gICAgLy8gb3RoZXJ3aXNlIGZyb20gdGhlIGdsb2JhbCByZWdpc3RyeVxuICAgIHJ1bGVzZXQuZnVuY3Rpb25SZWdpc3RyeSA9IChmdW5jdGlvbiAoZnJhbWVzKSB7XG4gICAgICAgIHZhciBpID0gMCxcbiAgICAgICAgICAgIG4gPSBmcmFtZXMubGVuZ3RoLFxuICAgICAgICAgICAgZm91bmQ7XG4gICAgICAgIGZvciAoIDsgaSAhPT0gbiA7ICsraSApIHtcbiAgICAgICAgICAgIGZvdW5kID0gZnJhbWVzWyBpIF0uZnVuY3Rpb25SZWdpc3RyeTtcbiAgICAgICAgICAgIGlmICggZm91bmQgKSB7IHJldHVybiBmb3VuZDsgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnbG9iYWxGdW5jdGlvblJlZ2lzdHJ5O1xuICAgIH0oY29udGV4dC5mcmFtZXMpKS5pbmhlcml0KCk7XG5cbiAgICAvLyBwdXNoIHRoZSBjdXJyZW50IHJ1bGVzZXQgdG8gdGhlIGZyYW1lcyBzdGFja1xuICAgIHZhciBjdHhGcmFtZXMgPSBjb250ZXh0LmZyYW1lcztcbiAgICBjdHhGcmFtZXMudW5zaGlmdChydWxlc2V0KTtcblxuICAgIC8vIGN1cnJyZW50IHNlbGVjdG9yc1xuICAgIHZhciBjdHhTZWxlY3RvcnMgPSBjb250ZXh0LnNlbGVjdG9ycztcbiAgICBpZiAoIWN0eFNlbGVjdG9ycykge1xuICAgICAgICBjb250ZXh0LnNlbGVjdG9ycyA9IGN0eFNlbGVjdG9ycyA9IFtdO1xuICAgIH1cbiAgICBjdHhTZWxlY3RvcnMudW5zaGlmdCh0aGlzLnNlbGVjdG9ycyk7XG5cbiAgICAvLyBFdmFsdWF0ZSBpbXBvcnRzXG4gICAgaWYgKHJ1bGVzZXQucm9vdCB8fCBydWxlc2V0LmFsbG93SW1wb3J0cyB8fCAhcnVsZXNldC5zdHJpY3RJbXBvcnRzKSB7XG4gICAgICAgIHJ1bGVzZXQuZXZhbEltcG9ydHMoY29udGV4dCk7XG4gICAgfVxuXG4gICAgLy8gU3RvcmUgdGhlIGZyYW1lcyBhcm91bmQgbWl4aW4gZGVmaW5pdGlvbnMsXG4gICAgLy8gc28gdGhleSBjYW4gYmUgZXZhbHVhdGVkIGxpa2UgY2xvc3VyZXMgd2hlbiB0aGUgdGltZSBjb21lcy5cbiAgICB2YXIgcnNSdWxlcyA9IHJ1bGVzZXQucnVsZXM7XG4gICAgZm9yIChpID0gMDsgKHJ1bGUgPSByc1J1bGVzW2ldKTsgaSsrKSB7XG4gICAgICAgIGlmIChydWxlLmV2YWxGaXJzdCkge1xuICAgICAgICAgICAgcnNSdWxlc1tpXSA9IHJ1bGUuZXZhbChjb250ZXh0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBtZWRpYUJsb2NrQ291bnQgPSAoY29udGV4dC5tZWRpYUJsb2NrcyAmJiBjb250ZXh0Lm1lZGlhQmxvY2tzLmxlbmd0aCkgfHwgMDtcblxuICAgIC8vIEV2YWx1YXRlIG1peGluIGNhbGxzLlxuICAgIGZvciAoaSA9IDA7IChydWxlID0gcnNSdWxlc1tpXSk7IGkrKykge1xuICAgICAgICBpZiAocnVsZS50eXBlID09PSAnTWl4aW5DYWxsJykge1xuICAgICAgICAgICAgLyoganNoaW50IGxvb3BmdW5jOnRydWUgKi9cbiAgICAgICAgICAgIHJ1bGVzID0gcnVsZS5ldmFsKGNvbnRleHQpLmZpbHRlcihmdW5jdGlvbihyKSB7XG4gICAgICAgICAgICAgICAgaWYgKChyIGluc3RhbmNlb2YgRGVjbGFyYXRpb24pICYmIHIudmFyaWFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZG8gbm90IHBvbGx1dGUgdGhlIHNjb3BlIGlmIHRoZSB2YXJpYWJsZSBpc1xuICAgICAgICAgICAgICAgICAgICAvLyBhbHJlYWR5IHRoZXJlLiBjb25zaWRlciByZXR1cm5pbmcgZmFsc2UgaGVyZVxuICAgICAgICAgICAgICAgICAgICAvLyBidXQgd2UgbmVlZCBhIHdheSB0byBcInJldHVyblwiIHZhcmlhYmxlIGZyb20gbWl4aW5zXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhKHJ1bGVzZXQudmFyaWFibGUoci5uYW1lKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByc1J1bGVzLnNwbGljZS5hcHBseShyc1J1bGVzLCBbaSwgMV0uY29uY2F0KHJ1bGVzKSk7XG4gICAgICAgICAgICBpICs9IHJ1bGVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBydWxlc2V0LnJlc2V0Q2FjaGUoKTtcbiAgICAgICAgfSBlbHNlIGlmIChydWxlLnR5cGUgPT09ICAnVmFyaWFibGVDYWxsJykge1xuICAgICAgICAgICAgLyoganNoaW50IGxvb3BmdW5jOnRydWUgKi9cbiAgICAgICAgICAgIHJ1bGVzID0gcnVsZS5ldmFsKGNvbnRleHQpLnJ1bGVzLmZpbHRlcihmdW5jdGlvbihyKSB7XG4gICAgICAgICAgICAgICAgaWYgKChyIGluc3RhbmNlb2YgRGVjbGFyYXRpb24pICYmIHIudmFyaWFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZG8gbm90IHBvbGx1dGUgdGhlIHNjb3BlIGF0IGFsbFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByc1J1bGVzLnNwbGljZS5hcHBseShyc1J1bGVzLCBbaSwgMV0uY29uY2F0KHJ1bGVzKSk7XG4gICAgICAgICAgICBpICs9IHJ1bGVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBydWxlc2V0LnJlc2V0Q2FjaGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEV2YWx1YXRlIGV2ZXJ5dGhpbmcgZWxzZVxuICAgIGZvciAoaSA9IDA7IChydWxlID0gcnNSdWxlc1tpXSk7IGkrKykge1xuICAgICAgICBpZiAoIXJ1bGUuZXZhbEZpcnN0KSB7XG4gICAgICAgICAgICByc1J1bGVzW2ldID0gcnVsZSA9IHJ1bGUuZXZhbCA/IHJ1bGUuZXZhbChjb250ZXh0KSA6IHJ1bGU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBFdmFsdWF0ZSBldmVyeXRoaW5nIGVsc2VcbiAgICBmb3IgKGkgPSAwOyAocnVsZSA9IHJzUnVsZXNbaV0pOyBpKyspIHtcbiAgICAgICAgLy8gZm9yIHJ1bGVzZXRzLCBjaGVjayBpZiBpdCBpcyBhIGNzcyBndWFyZCBhbmQgY2FuIGJlIHJlbW92ZWRcbiAgICAgICAgaWYgKHJ1bGUgaW5zdGFuY2VvZiBSdWxlc2V0ICYmIHJ1bGUuc2VsZWN0b3JzICYmIHJ1bGUuc2VsZWN0b3JzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgLy8gY2hlY2sgaWYgaXQgY2FuIGJlIGZvbGRlZCBpbiAoZS5nLiAmIHdoZXJlKVxuICAgICAgICAgICAgaWYgKHJ1bGUuc2VsZWN0b3JzWzBdICYmIHJ1bGUuc2VsZWN0b3JzWzBdLmlzSnVzdFBhcmVudFNlbGVjdG9yKCkpIHtcbiAgICAgICAgICAgICAgICByc1J1bGVzLnNwbGljZShpLS0sIDEpO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IChzdWJSdWxlID0gcnVsZS5ydWxlc1tqXSk7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3ViUnVsZSBpbnN0YW5jZW9mIE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YlJ1bGUuY29weVZpc2liaWxpdHlJbmZvKHJ1bGUudmlzaWJpbGl0eUluZm8oKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShzdWJSdWxlIGluc3RhbmNlb2YgRGVjbGFyYXRpb24pIHx8ICFzdWJSdWxlLnZhcmlhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnNSdWxlcy5zcGxpY2UoKytpLCAwLCBzdWJSdWxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFBvcCB0aGUgc3RhY2tcbiAgICBjdHhGcmFtZXMuc2hpZnQoKTtcbiAgICBjdHhTZWxlY3RvcnMuc2hpZnQoKTtcblxuICAgIGlmIChjb250ZXh0Lm1lZGlhQmxvY2tzKSB7XG4gICAgICAgIGZvciAoaSA9IG1lZGlhQmxvY2tDb3VudDsgaSA8IGNvbnRleHQubWVkaWFCbG9ja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnRleHQubWVkaWFCbG9ja3NbaV0uYnViYmxlU2VsZWN0b3JzKHNlbGVjdG9ycyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcnVsZXNldDtcbn07XG5SdWxlc2V0LnByb3RvdHlwZS5ldmFsSW1wb3J0cyA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICB2YXIgcnVsZXMgPSB0aGlzLnJ1bGVzLCBpLCBpbXBvcnRSdWxlcztcbiAgICBpZiAoIXJ1bGVzKSB7IHJldHVybjsgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IHJ1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChydWxlc1tpXS50eXBlID09PSAnSW1wb3J0Jykge1xuICAgICAgICAgICAgaW1wb3J0UnVsZXMgPSBydWxlc1tpXS5ldmFsKGNvbnRleHQpO1xuICAgICAgICAgICAgaWYgKGltcG9ydFJ1bGVzICYmIChpbXBvcnRSdWxlcy5sZW5ndGggfHwgaW1wb3J0UnVsZXMubGVuZ3RoID09PSAwKSkge1xuICAgICAgICAgICAgICAgIHJ1bGVzLnNwbGljZS5hcHBseShydWxlcywgW2ksIDFdLmNvbmNhdChpbXBvcnRSdWxlcykpO1xuICAgICAgICAgICAgICAgIGkgKz0gaW1wb3J0UnVsZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcnVsZXMuc3BsaWNlKGksIDEsIGltcG9ydFJ1bGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVzZXRDYWNoZSgpO1xuICAgICAgICB9XG4gICAgfVxufTtcblJ1bGVzZXQucHJvdG90eXBlLm1ha2VJbXBvcnRhbnQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVzdWx0ID0gbmV3IFJ1bGVzZXQodGhpcy5zZWxlY3RvcnMsIHRoaXMucnVsZXMubWFwKGZ1bmN0aW9uIChyKSB7XG4gICAgICAgIGlmIChyLm1ha2VJbXBvcnRhbnQpIHtcbiAgICAgICAgICAgIHJldHVybiByLm1ha2VJbXBvcnRhbnQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICB9XG4gICAgfSksIHRoaXMuc3RyaWN0SW1wb3J0cywgdGhpcy52aXNpYmlsaXR5SW5mbygpKTtcblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuUnVsZXNldC5wcm90b3R5cGUubWF0Y2hBcmdzID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICByZXR1cm4gIWFyZ3MgfHwgYXJncy5sZW5ndGggPT09IDA7XG59O1xuLy8gbGV0cyB5b3UgY2FsbCBhIGNzcyBzZWxlY3RvciB3aXRoIGEgZ3VhcmRcblJ1bGVzZXQucHJvdG90eXBlLm1hdGNoQ29uZGl0aW9uID0gZnVuY3Rpb24gKGFyZ3MsIGNvbnRleHQpIHtcbiAgICB2YXIgbGFzdFNlbGVjdG9yID0gdGhpcy5zZWxlY3RvcnNbdGhpcy5zZWxlY3RvcnMubGVuZ3RoIC0gMV07XG4gICAgaWYgKCFsYXN0U2VsZWN0b3IuZXZhbGRDb25kaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAobGFzdFNlbGVjdG9yLmNvbmRpdGlvbiAmJlxuICAgICAgICAhbGFzdFNlbGVjdG9yLmNvbmRpdGlvbi5ldmFsKFxuICAgICAgICAgICAgbmV3IGNvbnRleHRzLkV2YWwoY29udGV4dCxcbiAgICAgICAgICAgICAgICBjb250ZXh0LmZyYW1lcykpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuUnVsZXNldC5wcm90b3R5cGUucmVzZXRDYWNoZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9ydWxlc2V0cyA9IG51bGw7XG4gICAgdGhpcy5fdmFyaWFibGVzID0gbnVsbDtcbiAgICB0aGlzLl9wcm9wZXJ0aWVzID0gbnVsbDtcbiAgICB0aGlzLl9sb29rdXBzID0ge307XG59O1xuUnVsZXNldC5wcm90b3R5cGUudmFyaWFibGVzID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5fdmFyaWFibGVzKSB7XG4gICAgICAgIHRoaXMuX3ZhcmlhYmxlcyA9ICF0aGlzLnJ1bGVzID8ge30gOiB0aGlzLnJ1bGVzLnJlZHVjZShmdW5jdGlvbiAoaGFzaCwgcikge1xuICAgICAgICAgICAgaWYgKHIgaW5zdGFuY2VvZiBEZWNsYXJhdGlvbiAmJiByLnZhcmlhYmxlID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgaGFzaFtyLm5hbWVdID0gcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHdoZW4gZXZhbHVhdGluZyB2YXJpYWJsZXMgaW4gYW4gaW1wb3J0IHN0YXRlbWVudCwgaW1wb3J0cyBoYXZlIG5vdCBiZWVuIGV2YWwnZFxuICAgICAgICAgICAgLy8gc28gd2UgbmVlZCB0byBnbyBpbnNpZGUgaW1wb3J0IHN0YXRlbWVudHMuXG4gICAgICAgICAgICAvLyBndWFyZCBhZ2FpbnN0IHJvb3QgYmVpbmcgYSBzdHJpbmcgKGluIHRoZSBjYXNlIG9mIGlubGluZWQgbGVzcylcbiAgICAgICAgICAgIGlmIChyLnR5cGUgPT09ICdJbXBvcnQnICYmIHIucm9vdCAmJiByLnJvb3QudmFyaWFibGVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhcnMgPSByLnJvb3QudmFyaWFibGVzKCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB2YXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YXJzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNoW25hbWVdID0gci5yb290LnZhcmlhYmxlKG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGhhc2g7XG4gICAgICAgIH0sIHt9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3ZhcmlhYmxlcztcbn07XG5SdWxlc2V0LnByb3RvdHlwZS5wcm9wZXJ0aWVzID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5fcHJvcGVydGllcykge1xuICAgICAgICB0aGlzLl9wcm9wZXJ0aWVzID0gIXRoaXMucnVsZXMgPyB7fSA6IHRoaXMucnVsZXMucmVkdWNlKGZ1bmN0aW9uIChoYXNoLCByKSB7XG4gICAgICAgICAgICBpZiAociBpbnN0YW5jZW9mIERlY2xhcmF0aW9uICYmIHIudmFyaWFibGUgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IChyLm5hbWUubGVuZ3RoID09PSAxKSAmJiAoci5uYW1lWzBdIGluc3RhbmNlb2YgS2V5d29yZCkgP1xuICAgICAgICAgICAgICAgICAgICByLm5hbWVbMF0udmFsdWUgOiByLm5hbWU7XG4gICAgICAgICAgICAgICAgLy8gUHJvcGVydGllcyBkb24ndCBvdmVyd3JpdGUgYXMgdGhleSBjYW4gbWVyZ2VcbiAgICAgICAgICAgICAgICBpZiAoIWhhc2hbJyQnICsgbmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzaFsnJCcgKyBuYW1lXSA9IFsgciBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzaFsnJCcgKyBuYW1lXS5wdXNoKHIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBoYXNoO1xuICAgICAgICB9LCB7fSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9wcm9wZXJ0aWVzO1xufTtcblJ1bGVzZXQucHJvdG90eXBlLnZhcmlhYmxlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgZGVjbCA9IHRoaXMudmFyaWFibGVzKClbbmFtZV07XG4gICAgaWYgKGRlY2wpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VWYWx1ZShkZWNsKTtcbiAgICB9XG59O1xuUnVsZXNldC5wcm90b3R5cGUucHJvcGVydHkgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBkZWNsID0gdGhpcy5wcm9wZXJ0aWVzKClbbmFtZV07XG4gICAgaWYgKGRlY2wpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VWYWx1ZShkZWNsKTtcbiAgICB9XG59O1xuUnVsZXNldC5wcm90b3R5cGUubGFzdERlY2xhcmF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIGkgPSB0aGlzLnJ1bGVzLmxlbmd0aDsgaSA+IDA7IGktLSkge1xuICAgICAgICB2YXIgZGVjbCA9IHRoaXMucnVsZXNbaSAtIDFdO1xuICAgICAgICBpZiAoZGVjbCBpbnN0YW5jZW9mIERlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVZhbHVlKGRlY2wpO1xuICAgICAgICB9XG4gICAgfVxufTtcblJ1bGVzZXQucHJvdG90eXBlLnBhcnNlVmFsdWUgPSBmdW5jdGlvbih0b1BhcnNlKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybURlY2xhcmF0aW9uKGRlY2wpIHtcbiAgICAgICAgaWYgKGRlY2wudmFsdWUgaW5zdGFuY2VvZiBBbm9ueW1vdXMgJiYgIWRlY2wucGFyc2VkKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRlY2wudmFsdWUudmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZS5wYXJzZU5vZGUoXG4gICAgICAgICAgICAgICAgICAgIGRlY2wudmFsdWUudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIFsndmFsdWUnLCAnaW1wb3J0YW50J10sIFxuICAgICAgICAgICAgICAgICAgICBkZWNsLnZhbHVlLmdldEluZGV4KCksIFxuICAgICAgICAgICAgICAgICAgICBkZWNsLmZpbGVJbmZvKCksIFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbihlcnIsIHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY2wucGFyc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNsLnZhbHVlID0gcmVzdWx0WzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY2wuaW1wb3J0YW50ID0gcmVzdWx0WzFdIHx8ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY2wucGFyc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlY2wucGFyc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGRlY2w7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZGVjbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodG9QYXJzZSkpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybURlY2xhcmF0aW9uLmNhbGwoc2VsZiwgdG9QYXJzZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgbm9kZXMgPSBbXTtcbiAgICAgICAgdG9QYXJzZS5mb3JFYWNoKGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICAgIG5vZGVzLnB1c2godHJhbnNmb3JtRGVjbGFyYXRpb24uY2FsbChzZWxmLCBuKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbm9kZXM7XG4gICAgfVxufTtcblJ1bGVzZXQucHJvdG90eXBlLnJ1bGVzZXRzID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5ydWxlcykgeyByZXR1cm4gW107IH1cblxuICAgIHZhciBmaWx0UnVsZXMgPSBbXSwgcnVsZXMgPSB0aGlzLnJ1bGVzLFxuICAgICAgICBpLCBydWxlO1xuXG4gICAgZm9yIChpID0gMDsgKHJ1bGUgPSBydWxlc1tpXSk7IGkrKykge1xuICAgICAgICBpZiAocnVsZS5pc1J1bGVzZXQpIHtcbiAgICAgICAgICAgIGZpbHRSdWxlcy5wdXNoKHJ1bGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpbHRSdWxlcztcbn07XG5SdWxlc2V0LnByb3RvdHlwZS5wcmVwZW5kUnVsZSA9IGZ1bmN0aW9uIChydWxlKSB7XG4gICAgdmFyIHJ1bGVzID0gdGhpcy5ydWxlcztcbiAgICBpZiAocnVsZXMpIHtcbiAgICAgICAgcnVsZXMudW5zaGlmdChydWxlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJ1bGVzID0gWyBydWxlIF07XG4gICAgfVxuICAgIHRoaXMuc2V0UGFyZW50KHJ1bGUsIHRoaXMpO1xufTtcblJ1bGVzZXQucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbiAoc2VsZWN0b3IsIHNlbGYsIGZpbHRlcikge1xuICAgIHNlbGYgPSBzZWxmIHx8IHRoaXM7XG4gICAgdmFyIHJ1bGVzID0gW10sIG1hdGNoLCBmb3VuZE1peGlucyxcbiAgICAgICAga2V5ID0gc2VsZWN0b3IudG9DU1MoKTtcblxuICAgIGlmIChrZXkgaW4gdGhpcy5fbG9va3VwcykgeyByZXR1cm4gdGhpcy5fbG9va3Vwc1trZXldOyB9XG5cbiAgICB0aGlzLnJ1bGVzZXRzKCkuZm9yRWFjaChmdW5jdGlvbiAocnVsZSkge1xuICAgICAgICBpZiAocnVsZSAhPT0gc2VsZikge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBydWxlLnNlbGVjdG9ycy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIG1hdGNoID0gc2VsZWN0b3IubWF0Y2gocnVsZS5zZWxlY3RvcnNbal0pO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0b3IuZWxlbWVudHMubGVuZ3RoID4gbWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZmlsdGVyIHx8IGZpbHRlcihydWxlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kTWl4aW5zID0gcnVsZS5maW5kKG5ldyBTZWxlY3RvcihzZWxlY3Rvci5lbGVtZW50cy5zbGljZShtYXRjaCkpLCBzZWxmLCBmaWx0ZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm91bmRNaXhpbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91bmRNaXhpbnNbaV0ucGF0aC5wdXNoKHJ1bGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShydWxlcywgZm91bmRNaXhpbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZXMucHVzaCh7IHJ1bGU6IHJ1bGUsIHBhdGg6IFtdfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5fbG9va3Vwc1trZXldID0gcnVsZXM7XG4gICAgcmV0dXJuIHJ1bGVzO1xufTtcblJ1bGVzZXQucHJvdG90eXBlLmdlbkNTUyA9IGZ1bmN0aW9uIChjb250ZXh0LCBvdXRwdXQpIHtcbiAgICB2YXIgaSwgaixcbiAgICAgICAgY2hhcnNldFJ1bGVOb2RlcyA9IFtdLFxuICAgICAgICBydWxlTm9kZXMgPSBbXSxcbiAgICAgICAgZGVidWdJbmZvLCAgICAgLy8gTGluZSBudW1iZXIgZGVidWdnaW5nXG4gICAgICAgIHJ1bGUsXG4gICAgICAgIHBhdGg7XG5cbiAgICBjb250ZXh0LnRhYkxldmVsID0gKGNvbnRleHQudGFiTGV2ZWwgfHwgMCk7XG5cbiAgICBpZiAoIXRoaXMucm9vdCkge1xuICAgICAgICBjb250ZXh0LnRhYkxldmVsKys7XG4gICAgfVxuXG4gICAgdmFyIHRhYlJ1bGVTdHIgPSBjb250ZXh0LmNvbXByZXNzID8gJycgOiBBcnJheShjb250ZXh0LnRhYkxldmVsICsgMSkuam9pbignICAnKSxcbiAgICAgICAgdGFiU2V0U3RyID0gY29udGV4dC5jb21wcmVzcyA/ICcnIDogQXJyYXkoY29udGV4dC50YWJMZXZlbCkuam9pbignICAnKSxcbiAgICAgICAgc2VwO1xuXG4gICAgdmFyIGNoYXJzZXROb2RlSW5kZXggPSAwO1xuICAgIHZhciBpbXBvcnROb2RlSW5kZXggPSAwO1xuICAgIGZvciAoaSA9IDA7IChydWxlID0gdGhpcy5ydWxlc1tpXSk7IGkrKykge1xuICAgICAgICBpZiAocnVsZSBpbnN0YW5jZW9mIENvbW1lbnQpIHtcbiAgICAgICAgICAgIGlmIChpbXBvcnROb2RlSW5kZXggPT09IGkpIHtcbiAgICAgICAgICAgICAgICBpbXBvcnROb2RlSW5kZXgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJ1bGVOb2Rlcy5wdXNoKHJ1bGUpO1xuICAgICAgICB9IGVsc2UgaWYgKHJ1bGUuaXNDaGFyc2V0ICYmIHJ1bGUuaXNDaGFyc2V0KCkpIHtcbiAgICAgICAgICAgIHJ1bGVOb2Rlcy5zcGxpY2UoY2hhcnNldE5vZGVJbmRleCwgMCwgcnVsZSk7XG4gICAgICAgICAgICBjaGFyc2V0Tm9kZUluZGV4Kys7XG4gICAgICAgICAgICBpbXBvcnROb2RlSW5kZXgrKztcbiAgICAgICAgfSBlbHNlIGlmIChydWxlLnR5cGUgPT09ICdJbXBvcnQnKSB7XG4gICAgICAgICAgICBydWxlTm9kZXMuc3BsaWNlKGltcG9ydE5vZGVJbmRleCwgMCwgcnVsZSk7XG4gICAgICAgICAgICBpbXBvcnROb2RlSW5kZXgrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJ1bGVOb2Rlcy5wdXNoKHJ1bGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJ1bGVOb2RlcyA9IGNoYXJzZXRSdWxlTm9kZXMuY29uY2F0KHJ1bGVOb2Rlcyk7XG5cbiAgICAvLyBJZiB0aGlzIGlzIHRoZSByb290IG5vZGUsIHdlIGRvbid0IHJlbmRlclxuICAgIC8vIGEgc2VsZWN0b3IsIG9yIHt9LlxuICAgIGlmICghdGhpcy5yb290KSB7XG4gICAgICAgIGRlYnVnSW5mbyA9IGdldERlYnVnSW5mbyhjb250ZXh0LCB0aGlzLCB0YWJTZXRTdHIpO1xuXG4gICAgICAgIGlmIChkZWJ1Z0luZm8pIHtcbiAgICAgICAgICAgIG91dHB1dC5hZGQoZGVidWdJbmZvKTtcbiAgICAgICAgICAgIG91dHB1dC5hZGQodGFiU2V0U3RyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYXRocyA9IHRoaXMucGF0aHMsIHBhdGhDbnQgPSBwYXRocy5sZW5ndGgsXG4gICAgICAgICAgICBwYXRoU3ViQ250O1xuXG4gICAgICAgIHNlcCA9IGNvbnRleHQuY29tcHJlc3MgPyAnLCcgOiAoJyxcXG4nICsgdGFiU2V0U3RyKTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGF0aENudDsgaSsrKSB7XG4gICAgICAgICAgICBwYXRoID0gcGF0aHNbaV07XG4gICAgICAgICAgICBpZiAoIShwYXRoU3ViQ250ID0gcGF0aC5sZW5ndGgpKSB7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICBpZiAoaSA+IDApIHsgb3V0cHV0LmFkZChzZXApOyB9XG5cbiAgICAgICAgICAgIGNvbnRleHQuZmlyc3RTZWxlY3RvciA9IHRydWU7XG4gICAgICAgICAgICBwYXRoWzBdLmdlbkNTUyhjb250ZXh0LCBvdXRwdXQpO1xuXG4gICAgICAgICAgICBjb250ZXh0LmZpcnN0U2VsZWN0b3IgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAoaiA9IDE7IGogPCBwYXRoU3ViQ250OyBqKyspIHtcbiAgICAgICAgICAgICAgICBwYXRoW2pdLmdlbkNTUyhjb250ZXh0LCBvdXRwdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgb3V0cHV0LmFkZCgoY29udGV4dC5jb21wcmVzcyA/ICd7JyA6ICcge1xcbicpICsgdGFiUnVsZVN0cik7XG4gICAgfVxuXG4gICAgLy8gQ29tcGlsZSBydWxlcyBhbmQgcnVsZXNldHNcbiAgICBmb3IgKGkgPSAwOyAocnVsZSA9IHJ1bGVOb2Rlc1tpXSk7IGkrKykge1xuXG4gICAgICAgIGlmIChpICsgMSA9PT0gcnVsZU5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29udGV4dC5sYXN0UnVsZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY3VycmVudExhc3RSdWxlID0gY29udGV4dC5sYXN0UnVsZTtcbiAgICAgICAgaWYgKHJ1bGUuaXNSdWxlc2V0TGlrZShydWxlKSkge1xuICAgICAgICAgICAgY29udGV4dC5sYXN0UnVsZSA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJ1bGUuZ2VuQ1NTKSB7XG4gICAgICAgICAgICBydWxlLmdlbkNTUyhjb250ZXh0LCBvdXRwdXQpO1xuICAgICAgICB9IGVsc2UgaWYgKHJ1bGUudmFsdWUpIHtcbiAgICAgICAgICAgIG91dHB1dC5hZGQocnVsZS52YWx1ZS50b1N0cmluZygpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQubGFzdFJ1bGUgPSBjdXJyZW50TGFzdFJ1bGU7XG5cbiAgICAgICAgaWYgKCFjb250ZXh0Lmxhc3RSdWxlICYmIHJ1bGUuaXNWaXNpYmxlKCkpIHtcbiAgICAgICAgICAgIG91dHB1dC5hZGQoY29udGV4dC5jb21wcmVzcyA/ICcnIDogKCdcXG4nICsgdGFiUnVsZVN0cikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udGV4dC5sYXN0UnVsZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnJvb3QpIHtcbiAgICAgICAgb3V0cHV0LmFkZCgoY29udGV4dC5jb21wcmVzcyA/ICd9JyA6ICdcXG4nICsgdGFiU2V0U3RyICsgJ30nKSk7XG4gICAgICAgIGNvbnRleHQudGFiTGV2ZWwtLTtcbiAgICB9XG5cbiAgICBpZiAoIW91dHB1dC5pc0VtcHR5KCkgJiYgIWNvbnRleHQuY29tcHJlc3MgJiYgdGhpcy5maXJzdFJvb3QpIHtcbiAgICAgICAgb3V0cHV0LmFkZCgnXFxuJyk7XG4gICAgfVxufTtcblxuUnVsZXNldC5wcm90b3R5cGUuam9pblNlbGVjdG9ycyA9IGZ1bmN0aW9uIChwYXRocywgY29udGV4dCwgc2VsZWN0b3JzKSB7XG4gICAgZm9yICh2YXIgcyA9IDA7IHMgPCBzZWxlY3RvcnMubGVuZ3RoOyBzKyspIHtcbiAgICAgICAgdGhpcy5qb2luU2VsZWN0b3IocGF0aHMsIGNvbnRleHQsIHNlbGVjdG9yc1tzXSk7XG4gICAgfVxufTtcblxuUnVsZXNldC5wcm90b3R5cGUuam9pblNlbGVjdG9yID0gZnVuY3Rpb24gKHBhdGhzLCBjb250ZXh0LCBzZWxlY3Rvcikge1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlUGFyZW50aGVzaXMoZWxlbWVudHNUb1Bhaywgb3JpZ2luYWxFbGVtZW50KSB7XG4gICAgICAgIHZhciByZXBsYWNlbWVudFBhcmVuLCBqO1xuICAgICAgICBpZiAoZWxlbWVudHNUb1Bhay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJlcGxhY2VtZW50UGFyZW4gPSBuZXcgUGFyZW4oZWxlbWVudHNUb1Bha1swXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgaW5zaWRlUGFyZW50ID0gbmV3IEFycmF5KGVsZW1lbnRzVG9QYWsubGVuZ3RoKTtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBlbGVtZW50c1RvUGFrLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgaW5zaWRlUGFyZW50W2pdID0gbmV3IEVsZW1lbnQoXG4gICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzVG9QYWtbal0sXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsRWxlbWVudC5pc1ZhcmlhYmxlLFxuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEVsZW1lbnQuX2luZGV4LFxuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEVsZW1lbnQuX2ZpbGVJbmZvXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcGxhY2VtZW50UGFyZW4gPSBuZXcgUGFyZW4obmV3IFNlbGVjdG9yKGluc2lkZVBhcmVudCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXBsYWNlbWVudFBhcmVuO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVNlbGVjdG9yKGNvbnRhaW5lZEVsZW1lbnQsIG9yaWdpbmFsRWxlbWVudCkge1xuICAgICAgICB2YXIgZWxlbWVudCwgc2VsZWN0b3I7XG4gICAgICAgIGVsZW1lbnQgPSBuZXcgRWxlbWVudChudWxsLCBjb250YWluZWRFbGVtZW50LCBvcmlnaW5hbEVsZW1lbnQuaXNWYXJpYWJsZSwgb3JpZ2luYWxFbGVtZW50Ll9pbmRleCwgb3JpZ2luYWxFbGVtZW50Ll9maWxlSW5mbyk7XG4gICAgICAgIHNlbGVjdG9yID0gbmV3IFNlbGVjdG9yKFtlbGVtZW50XSk7XG4gICAgICAgIHJldHVybiBzZWxlY3RvcjtcbiAgICB9XG5cbiAgICAvLyBqb2lucyBzZWxlY3RvciBwYXRoIGZyb20gYGJlZ2lubmluZ1BhdGhgIHdpdGggc2VsZWN0b3IgcGF0aCBpbiBgYWRkUGF0aGBcbiAgICAvLyBgcmVwbGFjZWRFbGVtZW50YCBjb250YWlucyBlbGVtZW50IHRoYXQgaXMgYmVpbmcgcmVwbGFjZWQgYnkgYGFkZFBhdGhgXG4gICAgLy8gcmV0dXJucyBjb25jYXRlbmF0ZWQgcGF0aFxuICAgIGZ1bmN0aW9uIGFkZFJlcGxhY2VtZW50SW50b1BhdGgoYmVnaW5uaW5nUGF0aCwgYWRkUGF0aCwgcmVwbGFjZWRFbGVtZW50LCBvcmlnaW5hbFNlbGVjdG9yKSB7XG4gICAgICAgIHZhciBuZXdTZWxlY3RvclBhdGgsIGxhc3RTZWxlY3RvciwgbmV3Sm9pbmVkU2VsZWN0b3I7XG4gICAgICAgIC8vIG91ciBuZXcgc2VsZWN0b3IgcGF0aFxuICAgICAgICBuZXdTZWxlY3RvclBhdGggPSBbXTtcblxuICAgICAgICAvLyBjb25zdHJ1Y3QgdGhlIGpvaW5lZCBzZWxlY3RvciAtIGlmICYgaXMgdGhlIGZpcnN0IHRoaW5nIHRoaXMgd2lsbCBiZSBlbXB0eSxcbiAgICAgICAgLy8gaWYgbm90IG5ld0pvaW5lZFNlbGVjdG9yIHdpbGwgYmUgdGhlIGxhc3Qgc2V0IG9mIGVsZW1lbnRzIGluIHRoZSBzZWxlY3RvclxuICAgICAgICBpZiAoYmVnaW5uaW5nUGF0aC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBuZXdTZWxlY3RvclBhdGggPSB1dGlscy5jb3B5QXJyYXkoYmVnaW5uaW5nUGF0aCk7XG4gICAgICAgICAgICBsYXN0U2VsZWN0b3IgPSBuZXdTZWxlY3RvclBhdGgucG9wKCk7XG4gICAgICAgICAgICBuZXdKb2luZWRTZWxlY3RvciA9IG9yaWdpbmFsU2VsZWN0b3IuY3JlYXRlRGVyaXZlZCh1dGlscy5jb3B5QXJyYXkobGFzdFNlbGVjdG9yLmVsZW1lbnRzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuZXdKb2luZWRTZWxlY3RvciA9IG9yaWdpbmFsU2VsZWN0b3IuY3JlYXRlRGVyaXZlZChbXSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWRkUGF0aC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyAvZGVlcC8gaXMgYSBDU1M0IHNlbGVjdG9yIC0gKHJlbW92ZWQsIHNvIHNob3VsZCBkZXByZWNhdGUpXG4gICAgICAgICAgICAvLyB0aGF0IGlzIHZhbGlkIHdpdGhvdXQgYW55dGhpbmcgaW4gZnJvbnQgb2YgaXRcbiAgICAgICAgICAgIC8vIHNvIGlmIHRoZSAmIGRvZXMgbm90IGhhdmUgYSBjb21iaW5hdG9yIHRoYXQgaXMgXCJcIiBvciBcIiBcIiB0aGVuXG4gICAgICAgICAgICAvLyBhbmQgdGhlcmUgaXMgYSBjb21iaW5hdG9yIG9uIHRoZSBwYXJlbnQsIHRoZW4gZ3JhYiB0aGF0LlxuICAgICAgICAgICAgLy8gdGhpcyBhbHNvIGFsbG93cyArIGEgeyAmIC5iIHsgLmEgJiB7IC4uLiB0aG91Z2ggbm90IHN1cmUgd2h5IHlvdSB3b3VsZCB3YW50IHRvIGRvIHRoYXRcbiAgICAgICAgICAgIHZhciBjb21iaW5hdG9yID0gcmVwbGFjZWRFbGVtZW50LmNvbWJpbmF0b3IsIHBhcmVudEVsID0gYWRkUGF0aFswXS5lbGVtZW50c1swXTtcbiAgICAgICAgICAgIGlmIChjb21iaW5hdG9yLmVtcHR5T3JXaGl0ZXNwYWNlICYmICFwYXJlbnRFbC5jb21iaW5hdG9yLmVtcHR5T3JXaGl0ZXNwYWNlKSB7XG4gICAgICAgICAgICAgICAgY29tYmluYXRvciA9IHBhcmVudEVsLmNvbWJpbmF0b3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBqb2luIHRoZSBlbGVtZW50cyBzbyBmYXIgd2l0aCB0aGUgZmlyc3QgcGFydCBvZiB0aGUgcGFyZW50XG4gICAgICAgICAgICBuZXdKb2luZWRTZWxlY3Rvci5lbGVtZW50cy5wdXNoKG5ldyBFbGVtZW50KFxuICAgICAgICAgICAgICAgIGNvbWJpbmF0b3IsXG4gICAgICAgICAgICAgICAgcGFyZW50RWwudmFsdWUsXG4gICAgICAgICAgICAgICAgcmVwbGFjZWRFbGVtZW50LmlzVmFyaWFibGUsXG4gICAgICAgICAgICAgICAgcmVwbGFjZWRFbGVtZW50Ll9pbmRleCxcbiAgICAgICAgICAgICAgICByZXBsYWNlZEVsZW1lbnQuX2ZpbGVJbmZvXG4gICAgICAgICAgICApKTtcbiAgICAgICAgICAgIG5ld0pvaW5lZFNlbGVjdG9yLmVsZW1lbnRzID0gbmV3Sm9pbmVkU2VsZWN0b3IuZWxlbWVudHMuY29uY2F0KGFkZFBhdGhbMF0uZWxlbWVudHMuc2xpY2UoMSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbm93IGFkZCB0aGUgam9pbmVkIHNlbGVjdG9yIC0gYnV0IG9ubHkgaWYgaXQgaXMgbm90IGVtcHR5XG4gICAgICAgIGlmIChuZXdKb2luZWRTZWxlY3Rvci5lbGVtZW50cy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIG5ld1NlbGVjdG9yUGF0aC5wdXNoKG5ld0pvaW5lZFNlbGVjdG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHB1dCB0b2dldGhlciB0aGUgcGFyZW50IHNlbGVjdG9ycyBhZnRlciB0aGUgam9pbiAoZS5nLiB0aGUgcmVzdCBvZiB0aGUgcGFyZW50KVxuICAgICAgICBpZiAoYWRkUGF0aC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB2YXIgcmVzdE9mUGF0aCA9IGFkZFBhdGguc2xpY2UoMSk7XG4gICAgICAgICAgICByZXN0T2ZQYXRoID0gcmVzdE9mUGF0aC5tYXAoZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGVjdG9yLmNyZWF0ZURlcml2ZWQoc2VsZWN0b3IuZWxlbWVudHMsIFtdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbmV3U2VsZWN0b3JQYXRoID0gbmV3U2VsZWN0b3JQYXRoLmNvbmNhdChyZXN0T2ZQYXRoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3U2VsZWN0b3JQYXRoO1xuICAgIH1cblxuICAgIC8vIGpvaW5zIHNlbGVjdG9yIHBhdGggZnJvbSBgYmVnaW5uaW5nUGF0aGAgd2l0aCBldmVyeSBzZWxlY3RvciBwYXRoIGluIGBhZGRQYXRoc2AgYXJyYXlcbiAgICAvLyBgcmVwbGFjZWRFbGVtZW50YCBjb250YWlucyBlbGVtZW50IHRoYXQgaXMgYmVpbmcgcmVwbGFjZWQgYnkgYGFkZFBhdGhgXG4gICAgLy8gcmV0dXJucyBhcnJheSB3aXRoIGFsbCBjb25jYXRlbmF0ZWQgcGF0aHNcbiAgICBmdW5jdGlvbiBhZGRBbGxSZXBsYWNlbWVudHNJbnRvUGF0aCggYmVnaW5uaW5nUGF0aCwgYWRkUGF0aHMsIHJlcGxhY2VkRWxlbWVudCwgb3JpZ2luYWxTZWxlY3RvciwgcmVzdWx0KSB7XG4gICAgICAgIHZhciBqO1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgYmVnaW5uaW5nUGF0aC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdmFyIG5ld1NlbGVjdG9yUGF0aCA9IGFkZFJlcGxhY2VtZW50SW50b1BhdGgoYmVnaW5uaW5nUGF0aFtqXSwgYWRkUGF0aHMsIHJlcGxhY2VkRWxlbWVudCwgb3JpZ2luYWxTZWxlY3Rvcik7XG4gICAgICAgICAgICByZXN1bHQucHVzaChuZXdTZWxlY3RvclBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWVyZ2VFbGVtZW50c09uVG9TZWxlY3RvcnMoZWxlbWVudHMsIHNlbGVjdG9ycykge1xuICAgICAgICB2YXIgaSwgc2VsO1xuXG4gICAgICAgIGlmIChlbGVtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGVjdG9ycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHNlbGVjdG9ycy5wdXNoKFsgbmV3IFNlbGVjdG9yKGVsZW1lbnRzKSBdKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IChzZWwgPSBzZWxlY3RvcnNbaV0pOyBpKyspIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBwcmV2aW91cyB0aGluZyBpbiBzZWwgaXMgYSBwYXJlbnQgdGhpcyBuZWVkcyB0byBqb2luIG9uIHRvIGl0XG4gICAgICAgICAgICBpZiAoc2VsLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBzZWxbc2VsLmxlbmd0aCAtIDFdID0gc2VsW3NlbC5sZW5ndGggLSAxXS5jcmVhdGVEZXJpdmVkKHNlbFtzZWwubGVuZ3RoIC0gMV0uZWxlbWVudHMuY29uY2F0KGVsZW1lbnRzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWwucHVzaChuZXcgU2VsZWN0b3IoZWxlbWVudHMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIHJlcGxhY2UgYWxsIHBhcmVudCBzZWxlY3RvcnMgaW5zaWRlIGBpblNlbGVjdG9yYCBieSBjb250ZW50IG9mIGBjb250ZXh0YCBhcnJheVxuICAgIC8vIHJlc3VsdGluZyBzZWxlY3RvcnMgYXJlIHJldHVybmVkIGluc2lkZSBgcGF0aHNgIGFycmF5XG4gICAgLy8gcmV0dXJucyB0cnVlIGlmIGBpblNlbGVjdG9yYCBjb250YWluZWQgYXQgbGVhc3Qgb25lIHBhcmVudCBzZWxlY3RvclxuICAgIGZ1bmN0aW9uIHJlcGxhY2VQYXJlbnRTZWxlY3RvcihwYXRocywgY29udGV4dCwgaW5TZWxlY3Rvcikge1xuICAgICAgICAvLyBUaGUgcGF0aHMgYXJlIFtbU2VsZWN0b3JdXVxuICAgICAgICAvLyBUaGUgZmlyc3QgbGlzdCBpcyBhIGxpc3Qgb2YgY29tbWEgc2VwYXJhdGVkIHNlbGVjdG9yc1xuICAgICAgICAvLyBUaGUgaW5uZXIgbGlzdCBpcyBhIGxpc3Qgb2YgaW5oZXJpdGFuY2Ugc2VwYXJhdGVkIHNlbGVjdG9yc1xuICAgICAgICAvLyBlLmcuXG4gICAgICAgIC8vIC5hLCAuYiB7XG4gICAgICAgIC8vICAgLmMge1xuICAgICAgICAvLyAgIH1cbiAgICAgICAgLy8gfVxuICAgICAgICAvLyA9PSBbWy5hXSBbLmNdXSBbWy5iXSBbLmNdXVxuICAgICAgICAvL1xuICAgICAgICB2YXIgaSwgaiwgaywgY3VycmVudEVsZW1lbnRzLCBuZXdTZWxlY3RvcnMsIHNlbGVjdG9yc011bHRpcGxpZWQsIHNlbCwgZWwsIGhhZFBhcmVudFNlbGVjdG9yID0gZmFsc2UsIGxlbmd0aCwgbGFzdFNlbGVjdG9yO1xuICAgICAgICBmdW5jdGlvbiBmaW5kTmVzdGVkU2VsZWN0b3IoZWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIG1heWJlU2VsZWN0b3I7XG4gICAgICAgICAgICBpZiAoIShlbGVtZW50LnZhbHVlIGluc3RhbmNlb2YgUGFyZW4pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1heWJlU2VsZWN0b3IgPSBlbGVtZW50LnZhbHVlLnZhbHVlO1xuICAgICAgICAgICAgaWYgKCEobWF5YmVTZWxlY3RvciBpbnN0YW5jZW9mIFNlbGVjdG9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbWF5YmVTZWxlY3RvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRoZSBlbGVtZW50cyBmcm9tIHRoZSBjdXJyZW50IHNlbGVjdG9yIHNvIGZhclxuICAgICAgICBjdXJyZW50RWxlbWVudHMgPSBbXTtcbiAgICAgICAgLy8gdGhlIGN1cnJlbnQgbGlzdCBvZiBuZXcgc2VsZWN0b3JzIHRvIGFkZCB0byB0aGUgcGF0aC5cbiAgICAgICAgLy8gV2Ugd2lsbCBidWlsZCBpdCB1cC4gV2UgaW5pdGlhdGUgaXQgd2l0aCBvbmUgZW1wdHkgc2VsZWN0b3IgYXMgd2UgXCJtdWx0aXBseVwiIHRoZSBuZXcgc2VsZWN0b3JzXG4gICAgICAgIC8vIGJ5IHRoZSBwYXJlbnRzXG4gICAgICAgIG5ld1NlbGVjdG9ycyA9IFtcbiAgICAgICAgICAgIFtdXG4gICAgICAgIF07XG5cbiAgICAgICAgZm9yIChpID0gMDsgKGVsID0gaW5TZWxlY3Rvci5lbGVtZW50c1tpXSk7IGkrKykge1xuICAgICAgICAgICAgLy8gbm9uIHBhcmVudCByZWZlcmVuY2UgZWxlbWVudHMganVzdCBnZXQgYWRkZWRcbiAgICAgICAgICAgIGlmIChlbC52YWx1ZSAhPT0gJyYnKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5lc3RlZFNlbGVjdG9yID0gZmluZE5lc3RlZFNlbGVjdG9yKGVsKTtcbiAgICAgICAgICAgICAgICBpZiAobmVzdGVkU2VsZWN0b3IgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBtZXJnZSB0aGUgY3VycmVudCBsaXN0IG9mIG5vbiBwYXJlbnQgc2VsZWN0b3IgZWxlbWVudHNcbiAgICAgICAgICAgICAgICAgICAgLy8gb24gdG8gdGhlIGN1cnJlbnQgbGlzdCBvZiBzZWxlY3RvcnMgdG8gYWRkXG4gICAgICAgICAgICAgICAgICAgIG1lcmdlRWxlbWVudHNPblRvU2VsZWN0b3JzKGN1cnJlbnRFbGVtZW50cywgbmV3U2VsZWN0b3JzKTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgbmVzdGVkUGF0aHMgPSBbXSwgcmVwbGFjZWQsIHJlcGxhY2VkTmV3U2VsZWN0b3JzID0gW107XG4gICAgICAgICAgICAgICAgICAgIHJlcGxhY2VkID0gcmVwbGFjZVBhcmVudFNlbGVjdG9yKG5lc3RlZFBhdGhzLCBjb250ZXh0LCBuZXN0ZWRTZWxlY3Rvcik7XG4gICAgICAgICAgICAgICAgICAgIGhhZFBhcmVudFNlbGVjdG9yID0gaGFkUGFyZW50U2VsZWN0b3IgfHwgcmVwbGFjZWQ7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBuZXN0ZWRQYXRocyBhcnJheSBzaG91bGQgaGF2ZSBvbmx5IG9uZSBtZW1iZXIgLSByZXBsYWNlUGFyZW50U2VsZWN0b3IgZG9lcyBub3QgbXVsdGlwbHkgc2VsZWN0b3JzXG4gICAgICAgICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBuZXN0ZWRQYXRocy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcGxhY2VtZW50U2VsZWN0b3IgPSBjcmVhdGVTZWxlY3RvcihjcmVhdGVQYXJlbnRoZXNpcyhuZXN0ZWRQYXRoc1trXSwgZWwpLCBlbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRBbGxSZXBsYWNlbWVudHNJbnRvUGF0aChuZXdTZWxlY3RvcnMsIFtyZXBsYWNlbWVudFNlbGVjdG9yXSwgZWwsIGluU2VsZWN0b3IsIHJlcGxhY2VkTmV3U2VsZWN0b3JzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBuZXdTZWxlY3RvcnMgPSByZXBsYWNlZE5ld1NlbGVjdG9ycztcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEVsZW1lbnRzID0gW107XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50RWxlbWVudHMucHVzaChlbCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGhhZFBhcmVudFNlbGVjdG9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvLyB0aGUgbmV3IGxpc3Qgb2Ygc2VsZWN0b3JzIHRvIGFkZFxuICAgICAgICAgICAgICAgIHNlbGVjdG9yc011bHRpcGxpZWQgPSBbXTtcblxuICAgICAgICAgICAgICAgIC8vIG1lcmdlIHRoZSBjdXJyZW50IGxpc3Qgb2Ygbm9uIHBhcmVudCBzZWxlY3RvciBlbGVtZW50c1xuICAgICAgICAgICAgICAgIC8vIG9uIHRvIHRoZSBjdXJyZW50IGxpc3Qgb2Ygc2VsZWN0b3JzIHRvIGFkZFxuICAgICAgICAgICAgICAgIG1lcmdlRWxlbWVudHNPblRvU2VsZWN0b3JzKGN1cnJlbnRFbGVtZW50cywgbmV3U2VsZWN0b3JzKTtcblxuICAgICAgICAgICAgICAgIC8vIGxvb3AgdGhyb3VnaCBvdXIgY3VycmVudCBzZWxlY3RvcnNcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbmV3U2VsZWN0b3JzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbCA9IG5ld1NlbGVjdG9yc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgd2UgZG9uJ3QgaGF2ZSBhbnkgcGFyZW50IHBhdGhzLCB0aGUgJiBtaWdodCBiZSBpbiBhIG1peGluIHNvIHRoYXQgaXQgY2FuIGJlIHVzZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gd2hldGhlciB0aGVyZSBhcmUgcGFyZW50cyBvciBub3RcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRleHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgY29tYmluYXRvciB1c2VkIG9uIGVsIHNob3VsZCBub3cgYmUgYXBwbGllZCB0byB0aGUgbmV4dCBlbGVtZW50IGluc3RlYWQgc28gdGhhdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXQgaXMgbm90IGxvc3RcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWwubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbFswXS5lbGVtZW50cy5wdXNoKG5ldyBFbGVtZW50KGVsLmNvbWJpbmF0b3IsICcnLCBlbC5pc1ZhcmlhYmxlLCBlbC5faW5kZXgsIGVsLl9maWxlSW5mbykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3JzTXVsdGlwbGllZC5wdXNoKHNlbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgdGhlIHBhcmVudCBzZWxlY3RvcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBjb250ZXh0Lmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBwdXQgdGhlIGN1cnJlbnQgc2VsZWN0b3JzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlbiBqb2luIHRoZSBsYXN0IHNlbGVjdG9yJ3MgZWxlbWVudHMgb24gdG8gdGhlIHBhcmVudHMgc2VsZWN0b3JzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1NlbGVjdG9yUGF0aCA9IGFkZFJlcGxhY2VtZW50SW50b1BhdGgoc2VsLCBjb250ZXh0W2tdLCBlbCwgaW5TZWxlY3Rvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkIHRoYXQgdG8gb3VyIG5ldyBzZXQgb2Ygc2VsZWN0b3JzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3JzTXVsdGlwbGllZC5wdXNoKG5ld1NlbGVjdG9yUGF0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBvdXIgbmV3IHNlbGVjdG9ycyBoYXMgYmVlbiBtdWx0aXBsaWVkLCBzbyByZXNldCB0aGUgc3RhdGVcbiAgICAgICAgICAgICAgICBuZXdTZWxlY3RvcnMgPSBzZWxlY3RvcnNNdWx0aXBsaWVkO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRFbGVtZW50cyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgd2UgaGF2ZSBhbnkgZWxlbWVudHMgbGVmdCBvdmVyIChlLmcuIC5hJiAuYiA9PSAuYilcbiAgICAgICAgLy8gYWRkIHRoZW0gb24gdG8gYWxsIHRoZSBjdXJyZW50IHNlbGVjdG9yc1xuICAgICAgICBtZXJnZUVsZW1lbnRzT25Ub1NlbGVjdG9ycyhjdXJyZW50RWxlbWVudHMsIG5ld1NlbGVjdG9ycyk7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG5ld1NlbGVjdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGVuZ3RoID0gbmV3U2VsZWN0b3JzW2ldLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChsZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcGF0aHMucHVzaChuZXdTZWxlY3RvcnNbaV0pO1xuICAgICAgICAgICAgICAgIGxhc3RTZWxlY3RvciA9IG5ld1NlbGVjdG9yc1tpXVtsZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBuZXdTZWxlY3RvcnNbaV1bbGVuZ3RoIC0gMV0gPSBsYXN0U2VsZWN0b3IuY3JlYXRlRGVyaXZlZChsYXN0U2VsZWN0b3IuZWxlbWVudHMsIGluU2VsZWN0b3IuZXh0ZW5kTGlzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaGFkUGFyZW50U2VsZWN0b3I7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVyaXZlU2VsZWN0b3IodmlzaWJpbGl0eUluZm8sIGRlcml2ZUZyb20pIHtcbiAgICAgICAgdmFyIG5ld1NlbGVjdG9yID0gZGVyaXZlRnJvbS5jcmVhdGVEZXJpdmVkKGRlcml2ZUZyb20uZWxlbWVudHMsIGRlcml2ZUZyb20uZXh0ZW5kTGlzdCwgZGVyaXZlRnJvbS5ldmFsZENvbmRpdGlvbik7XG4gICAgICAgIG5ld1NlbGVjdG9yLmNvcHlWaXNpYmlsaXR5SW5mbyh2aXNpYmlsaXR5SW5mbyk7XG4gICAgICAgIHJldHVybiBuZXdTZWxlY3RvcjtcbiAgICB9XG5cbiAgICAvLyBqb2luU2VsZWN0b3IgY29kZSBmb2xsb3dzXG4gICAgdmFyIGksIG5ld1BhdGhzLCBoYWRQYXJlbnRTZWxlY3RvcjtcblxuICAgIG5ld1BhdGhzID0gW107XG4gICAgaGFkUGFyZW50U2VsZWN0b3IgPSByZXBsYWNlUGFyZW50U2VsZWN0b3IobmV3UGF0aHMsIGNvbnRleHQsIHNlbGVjdG9yKTtcblxuICAgIGlmICghaGFkUGFyZW50U2VsZWN0b3IpIHtcbiAgICAgICAgaWYgKGNvbnRleHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbmV3UGF0aHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb250ZXh0Lmxlbmd0aDsgaSsrKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgY29uY2F0ZW5hdGVkID0gY29udGV4dFtpXS5tYXAoZGVyaXZlU2VsZWN0b3IuYmluZCh0aGlzLCBzZWxlY3Rvci52aXNpYmlsaXR5SW5mbygpKSk7XG5cbiAgICAgICAgICAgICAgICBjb25jYXRlbmF0ZWQucHVzaChzZWxlY3Rvcik7XG4gICAgICAgICAgICAgICAgbmV3UGF0aHMucHVzaChjb25jYXRlbmF0ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmV3UGF0aHMgPSBbW3NlbGVjdG9yXV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbmV3UGF0aHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcGF0aHMucHVzaChuZXdQYXRoc1tpXSk7XG4gICAgfVxuXG59O1xubW9kdWxlLmV4cG9ydHMgPSBSdWxlc2V0O1xuXG59LHtcIi4uL2NvbnRleHRzXCI6MTMsXCIuLi9mdW5jdGlvbnMvZGVmYXVsdFwiOjI1LFwiLi4vZnVuY3Rpb25zL2Z1bmN0aW9uLXJlZ2lzdHJ5XCI6MjcsXCIuLi91dGlsc1wiOjg5LFwiLi9hbm9ueW1vdXNcIjo1MCxcIi4vY29tbWVudFwiOjU3LFwiLi9kZWJ1Zy1pbmZvXCI6NTksXCIuL2RlY2xhcmF0aW9uXCI6NjAsXCIuL2VsZW1lbnRcIjo2MyxcIi4va2V5d29yZFwiOjcwLFwiLi9ub2RlXCI6NzYsXCIuL3BhcmVuXCI6NzgsXCIuL3NlbGVjdG9yXCI6ODJ9XSw4MjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgTm9kZSA9IHJlcXVpcmUoJy4vbm9kZScpLFxuICAgIEVsZW1lbnQgPSByZXF1aXJlKCcuL2VsZW1lbnQnKSxcbiAgICBMZXNzRXJyb3IgPSByZXF1aXJlKCcuLi9sZXNzLWVycm9yJyk7XG5cbnZhciBTZWxlY3RvciA9IGZ1bmN0aW9uIChlbGVtZW50cywgZXh0ZW5kTGlzdCwgY29uZGl0aW9uLCBpbmRleCwgY3VycmVudEZpbGVJbmZvLCB2aXNpYmlsaXR5SW5mbykge1xuICAgIHRoaXMuZXh0ZW5kTGlzdCA9IGV4dGVuZExpc3Q7XG4gICAgdGhpcy5jb25kaXRpb24gPSBjb25kaXRpb247XG4gICAgdGhpcy5ldmFsZENvbmRpdGlvbiA9ICFjb25kaXRpb247XG4gICAgdGhpcy5faW5kZXggPSBpbmRleDtcbiAgICB0aGlzLl9maWxlSW5mbyA9IGN1cnJlbnRGaWxlSW5mbztcbiAgICB0aGlzLmVsZW1lbnRzID0gdGhpcy5nZXRFbGVtZW50cyhlbGVtZW50cyk7XG4gICAgdGhpcy5taXhpbkVsZW1lbnRzXyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNvcHlWaXNpYmlsaXR5SW5mbyh2aXNpYmlsaXR5SW5mbyk7XG4gICAgdGhpcy5zZXRQYXJlbnQodGhpcy5lbGVtZW50cywgdGhpcyk7XG59O1xuU2VsZWN0b3IucHJvdG90eXBlID0gbmV3IE5vZGUoKTtcblNlbGVjdG9yLnByb3RvdHlwZS50eXBlID0gJ1NlbGVjdG9yJztcblNlbGVjdG9yLnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbiAodmlzaXRvcikge1xuICAgIGlmICh0aGlzLmVsZW1lbnRzKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudHMgPSB2aXNpdG9yLnZpc2l0QXJyYXkodGhpcy5lbGVtZW50cyk7XG4gICAgfVxuICAgIGlmICh0aGlzLmV4dGVuZExpc3QpIHtcbiAgICAgICAgdGhpcy5leHRlbmRMaXN0ID0gdmlzaXRvci52aXNpdEFycmF5KHRoaXMuZXh0ZW5kTGlzdCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmNvbmRpdGlvbikge1xuICAgICAgICB0aGlzLmNvbmRpdGlvbiA9IHZpc2l0b3IudmlzaXQodGhpcy5jb25kaXRpb24pO1xuICAgIH1cbn07XG5TZWxlY3Rvci5wcm90b3R5cGUuY3JlYXRlRGVyaXZlZCA9IGZ1bmN0aW9uKGVsZW1lbnRzLCBleHRlbmRMaXN0LCBldmFsZENvbmRpdGlvbikge1xuICAgIGVsZW1lbnRzID0gdGhpcy5nZXRFbGVtZW50cyhlbGVtZW50cyk7XG4gICAgdmFyIG5ld1NlbGVjdG9yID0gbmV3IFNlbGVjdG9yKGVsZW1lbnRzLCBleHRlbmRMaXN0IHx8IHRoaXMuZXh0ZW5kTGlzdCxcbiAgICAgICAgbnVsbCwgdGhpcy5nZXRJbmRleCgpLCB0aGlzLmZpbGVJbmZvKCksIHRoaXMudmlzaWJpbGl0eUluZm8oKSk7XG4gICAgbmV3U2VsZWN0b3IuZXZhbGRDb25kaXRpb24gPSAoZXZhbGRDb25kaXRpb24gIT0gbnVsbCkgPyBldmFsZENvbmRpdGlvbiA6IHRoaXMuZXZhbGRDb25kaXRpb247XG4gICAgbmV3U2VsZWN0b3IubWVkaWFFbXB0eSA9IHRoaXMubWVkaWFFbXB0eTtcbiAgICByZXR1cm4gbmV3U2VsZWN0b3I7XG59O1xuU2VsZWN0b3IucHJvdG90eXBlLmdldEVsZW1lbnRzID0gZnVuY3Rpb24oZWxzKSB7XG4gICAgaWYgKCFlbHMpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgRWxlbWVudCgnJywgJyYnLCBmYWxzZSwgdGhpcy5faW5kZXgsIHRoaXMuX2ZpbGVJbmZvKV07XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZWxzID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLnBhcnNlLnBhcnNlTm9kZShcbiAgICAgICAgICAgIGVscywgXG4gICAgICAgICAgICBbJ3NlbGVjdG9yJ10sXG4gICAgICAgICAgICB0aGlzLl9pbmRleCwgXG4gICAgICAgICAgICB0aGlzLl9maWxlSW5mbywgXG4gICAgICAgICAgICBmdW5jdGlvbihlcnIsIHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IExlc3NFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogZXJyLmluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyLm1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcy5wYXJzZS5pbXBvcnRzLCB0aGlzLl9maWxlSW5mby5maWxlbmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVscyA9IHJlc3VsdFswXS5lbGVtZW50cztcbiAgICAgICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZWxzO1xufTtcblNlbGVjdG9yLnByb3RvdHlwZS5jcmVhdGVFbXB0eVNlbGVjdG9ycyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBlbCA9IG5ldyBFbGVtZW50KCcnLCAnJicsIGZhbHNlLCB0aGlzLl9pbmRleCwgdGhpcy5fZmlsZUluZm8pLFxuICAgICAgICBzZWxzID0gW25ldyBTZWxlY3RvcihbZWxdLCBudWxsLCBudWxsLCB0aGlzLl9pbmRleCwgdGhpcy5fZmlsZUluZm8pXTtcbiAgICBzZWxzWzBdLm1lZGlhRW1wdHkgPSB0cnVlO1xuICAgIHJldHVybiBzZWxzO1xufTtcblNlbGVjdG9yLnByb3RvdHlwZS5tYXRjaCA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgIHZhciBlbGVtZW50cyA9IHRoaXMuZWxlbWVudHMsXG4gICAgICAgIGxlbiA9IGVsZW1lbnRzLmxlbmd0aCxcbiAgICAgICAgb2xlbiwgaTtcblxuICAgIG90aGVyID0gb3RoZXIubWl4aW5FbGVtZW50cygpO1xuICAgIG9sZW4gPSBvdGhlci5sZW5ndGg7XG4gICAgaWYgKG9sZW4gPT09IDAgfHwgbGVuIDwgb2xlbikge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgb2xlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZWxlbWVudHNbaV0udmFsdWUgIT09IG90aGVyW2ldKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb2xlbjsgLy8gcmV0dXJuIG51bWJlciBvZiBtYXRjaGVkIGVsZW1lbnRzXG59O1xuU2VsZWN0b3IucHJvdG90eXBlLm1peGluRWxlbWVudHMgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5taXhpbkVsZW1lbnRzXykge1xuICAgICAgICByZXR1cm4gdGhpcy5taXhpbkVsZW1lbnRzXztcbiAgICB9XG5cbiAgICB2YXIgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzLm1hcCggZnVuY3Rpb24odikge1xuICAgICAgICByZXR1cm4gdi5jb21iaW5hdG9yLnZhbHVlICsgKHYudmFsdWUudmFsdWUgfHwgdi52YWx1ZSk7XG4gICAgfSkuam9pbignJykubWF0Y2goL1ssJiNcXCpcXC5cXHctXShbXFx3LV18KFxcXFwuKSkqL2cpO1xuXG4gICAgaWYgKGVsZW1lbnRzKSB7XG4gICAgICAgIGlmIChlbGVtZW50c1swXSA9PT0gJyYnKSB7XG4gICAgICAgICAgICBlbGVtZW50cy5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudHMgPSBbXTtcbiAgICB9XG5cbiAgICByZXR1cm4gKHRoaXMubWl4aW5FbGVtZW50c18gPSBlbGVtZW50cyk7XG59O1xuU2VsZWN0b3IucHJvdG90eXBlLmlzSnVzdFBhcmVudFNlbGVjdG9yID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICF0aGlzLm1lZGlhRW1wdHkgJiZcbiAgICAgICAgdGhpcy5lbGVtZW50cy5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgdGhpcy5lbGVtZW50c1swXS52YWx1ZSA9PT0gJyYnICYmXG4gICAgICAgICh0aGlzLmVsZW1lbnRzWzBdLmNvbWJpbmF0b3IudmFsdWUgPT09ICcgJyB8fCB0aGlzLmVsZW1lbnRzWzBdLmNvbWJpbmF0b3IudmFsdWUgPT09ICcnKTtcbn07XG5TZWxlY3Rvci5wcm90b3R5cGUuZXZhbCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgdmFyIGV2YWxkQ29uZGl0aW9uID0gdGhpcy5jb25kaXRpb24gJiYgdGhpcy5jb25kaXRpb24uZXZhbChjb250ZXh0KSxcbiAgICAgICAgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzLCBleHRlbmRMaXN0ID0gdGhpcy5leHRlbmRMaXN0O1xuXG4gICAgZWxlbWVudHMgPSBlbGVtZW50cyAmJiBlbGVtZW50cy5tYXAoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGUuZXZhbChjb250ZXh0KTsgfSk7XG4gICAgZXh0ZW5kTGlzdCA9IGV4dGVuZExpc3QgJiYgZXh0ZW5kTGlzdC5tYXAoZnVuY3Rpb24oZXh0ZW5kKSB7IHJldHVybiBleHRlbmQuZXZhbChjb250ZXh0KTsgfSk7XG5cbiAgICByZXR1cm4gdGhpcy5jcmVhdGVEZXJpdmVkKGVsZW1lbnRzLCBleHRlbmRMaXN0LCBldmFsZENvbmRpdGlvbik7XG59O1xuU2VsZWN0b3IucHJvdG90eXBlLmdlbkNTUyA9IGZ1bmN0aW9uIChjb250ZXh0LCBvdXRwdXQpIHtcbiAgICB2YXIgaSwgZWxlbWVudDtcbiAgICBpZiAoKCFjb250ZXh0IHx8ICFjb250ZXh0LmZpcnN0U2VsZWN0b3IpICYmIHRoaXMuZWxlbWVudHNbMF0uY29tYmluYXRvci52YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgb3V0cHV0LmFkZCgnICcsIHRoaXMuZmlsZUluZm8oKSwgdGhpcy5nZXRJbmRleCgpKTtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMuZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZWxlbWVudCA9IHRoaXMuZWxlbWVudHNbaV07XG4gICAgICAgIGVsZW1lbnQuZ2VuQ1NTKGNvbnRleHQsIG91dHB1dCk7XG4gICAgfVxufTtcblNlbGVjdG9yLnByb3RvdHlwZS5nZXRJc091dHB1dCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmV2YWxkQ29uZGl0aW9uO1xufTtcbm1vZHVsZS5leHBvcnRzID0gU2VsZWN0b3I7XG5cbn0se1wiLi4vbGVzcy1lcnJvclwiOjM4LFwiLi9lbGVtZW50XCI6NjMsXCIuL25vZGVcIjo3Nn1dLDgzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBOb2RlID0gcmVxdWlyZSgnLi9ub2RlJyk7XG5cbnZhciBVbmljb2RlRGVzY3JpcHRvciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbn07XG5Vbmljb2RlRGVzY3JpcHRvci5wcm90b3R5cGUgPSBuZXcgTm9kZSgpO1xuVW5pY29kZURlc2NyaXB0b3IucHJvdG90eXBlLnR5cGUgPSAnVW5pY29kZURlc2NyaXB0b3InO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFVuaWNvZGVEZXNjcmlwdG9yO1xuXG59LHtcIi4vbm9kZVwiOjc2fV0sODQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIE5vZGUgPSByZXF1aXJlKCcuL25vZGUnKSxcbiAgICB1bml0Q29udmVyc2lvbnMgPSByZXF1aXJlKCcuLi9kYXRhL3VuaXQtY29udmVyc2lvbnMnKSxcbiAgICB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbnZhciBVbml0ID0gZnVuY3Rpb24gKG51bWVyYXRvciwgZGVub21pbmF0b3IsIGJhY2t1cFVuaXQpIHtcbiAgICB0aGlzLm51bWVyYXRvciA9IG51bWVyYXRvciA/IHV0aWxzLmNvcHlBcnJheShudW1lcmF0b3IpLnNvcnQoKSA6IFtdO1xuICAgIHRoaXMuZGVub21pbmF0b3IgPSBkZW5vbWluYXRvciA/IHV0aWxzLmNvcHlBcnJheShkZW5vbWluYXRvcikuc29ydCgpIDogW107XG4gICAgaWYgKGJhY2t1cFVuaXQpIHtcbiAgICAgICAgdGhpcy5iYWNrdXBVbml0ID0gYmFja3VwVW5pdDtcbiAgICB9IGVsc2UgaWYgKG51bWVyYXRvciAmJiBudW1lcmF0b3IubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuYmFja3VwVW5pdCA9IG51bWVyYXRvclswXTtcbiAgICB9XG59O1xuXG5Vbml0LnByb3RvdHlwZSA9IG5ldyBOb2RlKCk7XG5Vbml0LnByb3RvdHlwZS50eXBlID0gJ1VuaXQnO1xuVW5pdC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBVbml0KHV0aWxzLmNvcHlBcnJheSh0aGlzLm51bWVyYXRvciksIHV0aWxzLmNvcHlBcnJheSh0aGlzLmRlbm9taW5hdG9yKSwgdGhpcy5iYWNrdXBVbml0KTtcbn07XG5Vbml0LnByb3RvdHlwZS5nZW5DU1MgPSBmdW5jdGlvbiAoY29udGV4dCwgb3V0cHV0KSB7XG4gICAgLy8gRGltZW5zaW9uIGNoZWNrcyB0aGUgdW5pdCBpcyBzaW5ndWxhciBhbmQgdGhyb3dzIGFuIGVycm9yIGlmIGluIHN0cmljdCBtYXRoIG1vZGUuXG4gICAgdmFyIHN0cmljdFVuaXRzID0gY29udGV4dCAmJiBjb250ZXh0LnN0cmljdFVuaXRzO1xuICAgIGlmICh0aGlzLm51bWVyYXRvci5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgb3V0cHV0LmFkZCh0aGlzLm51bWVyYXRvclswXSk7IC8vIHRoZSBpZGVhbCBzaXR1YXRpb25cbiAgICB9IGVsc2UgaWYgKCFzdHJpY3RVbml0cyAmJiB0aGlzLmJhY2t1cFVuaXQpIHtcbiAgICAgICAgb3V0cHV0LmFkZCh0aGlzLmJhY2t1cFVuaXQpO1xuICAgIH0gZWxzZSBpZiAoIXN0cmljdFVuaXRzICYmIHRoaXMuZGVub21pbmF0b3IubGVuZ3RoKSB7XG4gICAgICAgIG91dHB1dC5hZGQodGhpcy5kZW5vbWluYXRvclswXSk7XG4gICAgfVxufTtcblVuaXQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpLCByZXR1cm5TdHIgPSB0aGlzLm51bWVyYXRvci5qb2luKCcqJyk7XG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMuZGVub21pbmF0b3IubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmV0dXJuU3RyICs9ICcvJyArIHRoaXMuZGVub21pbmF0b3JbaV07XG4gICAgfVxuICAgIHJldHVybiByZXR1cm5TdHI7XG59O1xuVW5pdC5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgIHJldHVybiB0aGlzLmlzKG90aGVyLnRvU3RyaW5nKCkpID8gMCA6IHVuZGVmaW5lZDtcbn07XG5Vbml0LnByb3RvdHlwZS5pcyA9IGZ1bmN0aW9uICh1bml0U3RyaW5nKSB7XG4gICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKS50b1VwcGVyQ2FzZSgpID09PSB1bml0U3RyaW5nLnRvVXBwZXJDYXNlKCk7XG59O1xuVW5pdC5wcm90b3R5cGUuaXNMZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFJlZ0V4cCgnXihweHxlbXxleHxjaHxyZW18aW58Y218bW18cGN8cHR8ZXh8dnd8dmh8dm1pbnx2bWF4KSQnLCAnZ2knKS50ZXN0KHRoaXMudG9DU1MoKSk7XG59O1xuVW5pdC5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5udW1lcmF0b3IubGVuZ3RoID09PSAwICYmIHRoaXMuZGVub21pbmF0b3IubGVuZ3RoID09PSAwO1xufTtcblVuaXQucHJvdG90eXBlLmlzU2luZ3VsYXIgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5udW1lcmF0b3IubGVuZ3RoIDw9IDEgJiYgdGhpcy5kZW5vbWluYXRvci5sZW5ndGggPT09IDA7XG59O1xuVW5pdC5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICB2YXIgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLm51bWVyYXRvci5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLm51bWVyYXRvcltpXSA9IGNhbGxiYWNrKHRoaXMubnVtZXJhdG9yW2ldLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMuZGVub21pbmF0b3IubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5kZW5vbWluYXRvcltpXSA9IGNhbGxiYWNrKHRoaXMuZGVub21pbmF0b3JbaV0sIHRydWUpO1xuICAgIH1cbn07XG5Vbml0LnByb3RvdHlwZS51c2VkVW5pdHMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZ3JvdXAsIHJlc3VsdCA9IHt9LCBtYXBVbml0LCBncm91cE5hbWU7XG5cbiAgICBtYXBVbml0ID0gZnVuY3Rpb24gKGF0b21pY1VuaXQpIHtcbiAgICAgICAgLyoganNoaW50IGxvb3BmdW5jOnRydWUgKi9cbiAgICAgICAgaWYgKGdyb3VwLmhhc093blByb3BlcnR5KGF0b21pY1VuaXQpICYmICFyZXN1bHRbZ3JvdXBOYW1lXSkge1xuICAgICAgICAgICAgcmVzdWx0W2dyb3VwTmFtZV0gPSBhdG9taWNVbml0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF0b21pY1VuaXQ7XG4gICAgfTtcblxuICAgIGZvciAoZ3JvdXBOYW1lIGluIHVuaXRDb252ZXJzaW9ucykge1xuICAgICAgICBpZiAodW5pdENvbnZlcnNpb25zLmhhc093blByb3BlcnR5KGdyb3VwTmFtZSkpIHtcbiAgICAgICAgICAgIGdyb3VwID0gdW5pdENvbnZlcnNpb25zW2dyb3VwTmFtZV07XG5cbiAgICAgICAgICAgIHRoaXMubWFwKG1hcFVuaXQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5Vbml0LnByb3RvdHlwZS5jYW5jZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNvdW50ZXIgPSB7fSwgYXRvbWljVW5pdCwgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLm51bWVyYXRvci5sZW5ndGg7IGkrKykge1xuICAgICAgICBhdG9taWNVbml0ID0gdGhpcy5udW1lcmF0b3JbaV07XG4gICAgICAgIGNvdW50ZXJbYXRvbWljVW5pdF0gPSAoY291bnRlclthdG9taWNVbml0XSB8fCAwKSArIDE7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMuZGVub21pbmF0b3IubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXRvbWljVW5pdCA9IHRoaXMuZGVub21pbmF0b3JbaV07XG4gICAgICAgIGNvdW50ZXJbYXRvbWljVW5pdF0gPSAoY291bnRlclthdG9taWNVbml0XSB8fCAwKSAtIDE7XG4gICAgfVxuXG4gICAgdGhpcy5udW1lcmF0b3IgPSBbXTtcbiAgICB0aGlzLmRlbm9taW5hdG9yID0gW107XG5cbiAgICBmb3IgKGF0b21pY1VuaXQgaW4gY291bnRlcikge1xuICAgICAgICBpZiAoY291bnRlci5oYXNPd25Qcm9wZXJ0eShhdG9taWNVbml0KSkge1xuICAgICAgICAgICAgdmFyIGNvdW50ID0gY291bnRlclthdG9taWNVbml0XTtcblxuICAgICAgICAgICAgaWYgKGNvdW50ID4gMCkge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubnVtZXJhdG9yLnB1c2goYXRvbWljVW5pdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjb3VudCA8IDApIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgLWNvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZW5vbWluYXRvci5wdXNoKGF0b21pY1VuaXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMubnVtZXJhdG9yLnNvcnQoKTtcbiAgICB0aGlzLmRlbm9taW5hdG9yLnNvcnQoKTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IFVuaXQ7XG5cbn0se1wiLi4vZGF0YS91bml0LWNvbnZlcnNpb25zXCI6MTYsXCIuLi91dGlsc1wiOjg5LFwiLi9ub2RlXCI6NzZ9XSw4NTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgTm9kZSA9IHJlcXVpcmUoJy4vbm9kZScpO1xuXG52YXIgVVJMID0gZnVuY3Rpb24gKHZhbCwgaW5kZXgsIGN1cnJlbnRGaWxlSW5mbywgaXNFdmFsZCkge1xuICAgIHRoaXMudmFsdWUgPSB2YWw7XG4gICAgdGhpcy5faW5kZXggPSBpbmRleDtcbiAgICB0aGlzLl9maWxlSW5mbyA9IGN1cnJlbnRGaWxlSW5mbztcbiAgICB0aGlzLmlzRXZhbGQgPSBpc0V2YWxkO1xufTtcblVSTC5wcm90b3R5cGUgPSBuZXcgTm9kZSgpO1xuVVJMLnByb3RvdHlwZS50eXBlID0gJ1VybCc7XG5VUkwucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uICh2aXNpdG9yKSB7XG4gICAgdGhpcy52YWx1ZSA9IHZpc2l0b3IudmlzaXQodGhpcy52YWx1ZSk7XG59O1xuVVJMLnByb3RvdHlwZS5nZW5DU1MgPSBmdW5jdGlvbiAoY29udGV4dCwgb3V0cHV0KSB7XG4gICAgb3V0cHV0LmFkZCgndXJsKCcpO1xuICAgIHRoaXMudmFsdWUuZ2VuQ1NTKGNvbnRleHQsIG91dHB1dCk7XG4gICAgb3V0cHV0LmFkZCgnKScpO1xufTtcblVSTC5wcm90b3R5cGUuZXZhbCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgdmFyIHZhbCA9IHRoaXMudmFsdWUuZXZhbChjb250ZXh0KSxcbiAgICAgICAgcm9vdHBhdGg7XG5cbiAgICBpZiAoIXRoaXMuaXNFdmFsZCkge1xuICAgICAgICAvLyBBZGQgdGhlIHJvb3RwYXRoIGlmIHRoZSBVUkwgcmVxdWlyZXMgYSByZXdyaXRlXG4gICAgICAgIHJvb3RwYXRoID0gdGhpcy5maWxlSW5mbygpICYmIHRoaXMuZmlsZUluZm8oKS5yb290cGF0aDtcbiAgICAgICAgaWYgKHR5cGVvZiByb290cGF0aCA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWwudmFsdWUgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICBjb250ZXh0LnBhdGhSZXF1aXJlc1Jld3JpdGUodmFsLnZhbHVlKSnCoHtcbiAgICAgICAgICAgIGlmICghdmFsLnF1b3RlKSB7XG4gICAgICAgICAgICAgICAgcm9vdHBhdGggPSBlc2NhcGVQYXRoKHJvb3RwYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbC52YWx1ZSA9IGNvbnRleHQucmV3cml0ZVBhdGgodmFsLnZhbHVlLCByb290cGF0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWwudmFsdWUgPSBjb250ZXh0Lm5vcm1hbGl6ZVBhdGgodmFsLnZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCB1cmwgYXJncyBpZiBlbmFibGVkXG4gICAgICAgIGlmIChjb250ZXh0LnVybEFyZ3MpIHtcbiAgICAgICAgICAgIGlmICghdmFsLnZhbHVlLm1hdGNoKC9eXFxzKmRhdGE6LykpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVsaW1pdGVyID0gdmFsLnZhbHVlLmluZGV4T2YoJz8nKSA9PT0gLTEgPyAnPycgOiAnJic7XG4gICAgICAgICAgICAgICAgdmFyIHVybEFyZ3MgPSBkZWxpbWl0ZXIgKyBjb250ZXh0LnVybEFyZ3M7XG4gICAgICAgICAgICAgICAgaWYgKHZhbC52YWx1ZS5pbmRleE9mKCcjJykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbC52YWx1ZSA9IHZhbC52YWx1ZS5yZXBsYWNlKCcjJywgdXJsQXJncyArICcjJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsLnZhbHVlICs9IHVybEFyZ3M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBVUkwodmFsLCB0aGlzLmdldEluZGV4KCksIHRoaXMuZmlsZUluZm8oKSwgdHJ1ZSk7XG59O1xuXG5mdW5jdGlvbiBlc2NhcGVQYXRoKHBhdGgpIHtcbiAgICByZXR1cm4gcGF0aC5yZXBsYWNlKC9bXFwoXFwpJ1wiXFxzXS9nLCBmdW5jdGlvbihtYXRjaCkgeyByZXR1cm4gJ1xcXFwnICsgbWF0Y2g7IH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFVSTDtcblxufSx7XCIuL25vZGVcIjo3Nn1dLDg2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBOb2RlID0gcmVxdWlyZSgnLi9ub2RlJyk7XG5cbnZhciBWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdWYWx1ZSByZXF1aXJlcyBhbiBhcnJheSBhcmd1bWVudCcpO1xuICAgIH1cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSBbIHZhbHVlIF07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxufTtcblZhbHVlLnByb3RvdHlwZSA9IG5ldyBOb2RlKCk7XG5WYWx1ZS5wcm90b3R5cGUudHlwZSA9ICdWYWx1ZSc7XG5WYWx1ZS5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24gKHZpc2l0b3IpIHtcbiAgICBpZiAodGhpcy52YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmlzaXRvci52aXNpdEFycmF5KHRoaXMudmFsdWUpO1xuICAgIH1cbn07XG5WYWx1ZS5wcm90b3R5cGUuZXZhbCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgaWYgKHRoaXMudmFsdWUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlWzBdLmV2YWwoY29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWYWx1ZSh0aGlzLnZhbHVlLm1hcChmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgcmV0dXJuIHYuZXZhbChjb250ZXh0KTtcbiAgICAgICAgfSkpO1xuICAgIH1cbn07XG5WYWx1ZS5wcm90b3R5cGUuZ2VuQ1NTID0gZnVuY3Rpb24gKGNvbnRleHQsIG91dHB1dCkge1xuICAgIHZhciBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLnZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMudmFsdWVbaV0uZ2VuQ1NTKGNvbnRleHQsIG91dHB1dCk7XG4gICAgICAgIGlmIChpICsgMSA8IHRoaXMudmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICBvdXRwdXQuYWRkKChjb250ZXh0ICYmIGNvbnRleHQuY29tcHJlc3MpID8gJywnIDogJywgJyk7XG4gICAgICAgIH1cbiAgICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBWYWx1ZTtcblxufSx7XCIuL25vZGVcIjo3Nn1dLDg3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBOb2RlID0gcmVxdWlyZSgnLi9ub2RlJyksXG4gICAgVmFyaWFibGUgPSByZXF1aXJlKCcuL3ZhcmlhYmxlJyksXG4gICAgUnVsZXNldCA9IHJlcXVpcmUoJy4vcnVsZXNldCcpLFxuICAgIERldGFjaGVkUnVsZXNldCA9IHJlcXVpcmUoJy4vZGV0YWNoZWQtcnVsZXNldCcpLFxuICAgIExlc3NFcnJvciA9IHJlcXVpcmUoJy4uL2xlc3MtZXJyb3InKTtcblxudmFyIFZhcmlhYmxlQ2FsbCA9IGZ1bmN0aW9uICh2YXJpYWJsZSwgaW5kZXgsIGN1cnJlbnRGaWxlSW5mbykge1xuICAgIHRoaXMudmFyaWFibGUgPSB2YXJpYWJsZTtcbiAgICB0aGlzLl9pbmRleCA9IGluZGV4O1xuICAgIHRoaXMuX2ZpbGVJbmZvID0gY3VycmVudEZpbGVJbmZvO1xuICAgIHRoaXMuYWxsb3dSb290ID0gdHJ1ZTtcbn07XG5WYXJpYWJsZUNhbGwucHJvdG90eXBlID0gbmV3IE5vZGUoKTtcblZhcmlhYmxlQ2FsbC5wcm90b3R5cGUudHlwZSA9ICdWYXJpYWJsZUNhbGwnO1xuVmFyaWFibGVDYWxsLnByb3RvdHlwZS5ldmFsID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICB2YXIgcnVsZXMsIGRldGFjaGVkUnVsZXNldCA9IG5ldyBWYXJpYWJsZSh0aGlzLnZhcmlhYmxlLCB0aGlzLmdldEluZGV4KCksIHRoaXMuZmlsZUluZm8oKSkuZXZhbChjb250ZXh0KSxcbiAgICAgICAgZXJyb3IgPSBuZXcgTGVzc0Vycm9yKHttZXNzYWdlOiAnQ291bGQgbm90IGV2YWx1YXRlIHZhcmlhYmxlIGNhbGwgJyArIHRoaXMudmFyaWFibGV9KTtcblxuICAgIGlmICghZGV0YWNoZWRSdWxlc2V0LnJ1bGVzZXQpIHtcbiAgICAgICAgaWYgKGRldGFjaGVkUnVsZXNldC5ydWxlcykge1xuICAgICAgICAgICAgcnVsZXMgPSBkZXRhY2hlZFJ1bGVzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShkZXRhY2hlZFJ1bGVzZXQpKSB7XG4gICAgICAgICAgICBydWxlcyA9IG5ldyBSdWxlc2V0KCcnLCBkZXRhY2hlZFJ1bGVzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZGV0YWNoZWRSdWxlc2V0LnZhbHVlKSkge1xuICAgICAgICAgICAgcnVsZXMgPSBuZXcgUnVsZXNldCgnJywgZGV0YWNoZWRSdWxlc2V0LnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGRldGFjaGVkUnVsZXNldCA9IG5ldyBEZXRhY2hlZFJ1bGVzZXQocnVsZXMpO1xuICAgIH1cbiAgICBpZiAoZGV0YWNoZWRSdWxlc2V0LnJ1bGVzZXQpIHtcbiAgICAgICAgcmV0dXJuIGRldGFjaGVkUnVsZXNldC5jYWxsRXZhbChjb250ZXh0KTtcbiAgICB9XG4gICAgdGhyb3cgZXJyb3I7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBWYXJpYWJsZUNhbGw7XG5cbn0se1wiLi4vbGVzcy1lcnJvclwiOjM4LFwiLi9kZXRhY2hlZC1ydWxlc2V0XCI6NjEsXCIuL25vZGVcIjo3NixcIi4vcnVsZXNldFwiOjgxLFwiLi92YXJpYWJsZVwiOjg4fV0sODg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIE5vZGUgPSByZXF1aXJlKCcuL25vZGUnKSxcbiAgICBDYWxsID0gcmVxdWlyZSgnLi9jYWxsJyk7XG5cbnZhciBWYXJpYWJsZSA9IGZ1bmN0aW9uIChuYW1lLCBpbmRleCwgY3VycmVudEZpbGVJbmZvKSB7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLl9pbmRleCA9IGluZGV4O1xuICAgIHRoaXMuX2ZpbGVJbmZvID0gY3VycmVudEZpbGVJbmZvO1xufTtcblZhcmlhYmxlLnByb3RvdHlwZSA9IG5ldyBOb2RlKCk7XG5WYXJpYWJsZS5wcm90b3R5cGUudHlwZSA9ICdWYXJpYWJsZSc7XG5WYXJpYWJsZS5wcm90b3R5cGUuZXZhbCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgdmFyIHZhcmlhYmxlLCBuYW1lID0gdGhpcy5uYW1lO1xuXG4gICAgaWYgKG5hbWUuaW5kZXhPZignQEAnKSA9PT0gMCkge1xuICAgICAgICBuYW1lID0gJ0AnICsgbmV3IFZhcmlhYmxlKG5hbWUuc2xpY2UoMSksIHRoaXMuZ2V0SW5kZXgoKSwgdGhpcy5maWxlSW5mbygpKS5ldmFsKGNvbnRleHQpLnZhbHVlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmV2YWx1YXRpbmcpIHtcbiAgICAgICAgdGhyb3cgeyB0eXBlOiAnTmFtZScsXG4gICAgICAgICAgICBtZXNzYWdlOiAnUmVjdXJzaXZlIHZhcmlhYmxlIGRlZmluaXRpb24gZm9yICcgKyBuYW1lLFxuICAgICAgICAgICAgZmlsZW5hbWU6IHRoaXMuZmlsZUluZm8oKS5maWxlbmFtZSxcbiAgICAgICAgICAgIGluZGV4OiB0aGlzLmdldEluZGV4KCkgfTtcbiAgICB9XG5cbiAgICB0aGlzLmV2YWx1YXRpbmcgPSB0cnVlO1xuXG4gICAgdmFyaWFibGUgPSB0aGlzLmZpbmQoY29udGV4dC5mcmFtZXMsIGZ1bmN0aW9uIChmcmFtZSkge1xuICAgICAgICB2YXIgdiA9IGZyYW1lLnZhcmlhYmxlKG5hbWUpO1xuICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgaWYgKHYuaW1wb3J0YW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGltcG9ydGFudFNjb3BlID0gY29udGV4dC5pbXBvcnRhbnRTY29wZVtjb250ZXh0LmltcG9ydGFudFNjb3BlLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIGltcG9ydGFudFNjb3BlLmltcG9ydGFudCA9IHYuaW1wb3J0YW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgaW4gY2FsYywgd3JhcCB2YXJzIGluIGEgZnVuY3Rpb24gY2FsbCB0byBjYXNjYWRlIGV2YWx1YXRlIGFyZ3MgZmlyc3RcbiAgICAgICAgICAgIGlmIChjb250ZXh0LmluQ2FsYykge1xuICAgICAgICAgICAgICAgIHJldHVybiAobmV3IENhbGwoJ19TRUxGJywgW3YudmFsdWVdKSkuZXZhbChjb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB2LnZhbHVlLmV2YWwoY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAodmFyaWFibGUpIHtcbiAgICAgICAgdGhpcy5ldmFsdWF0aW5nID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB2YXJpYWJsZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyB7IHR5cGU6ICdOYW1lJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6ICd2YXJpYWJsZSAnICsgbmFtZSArICcgaXMgdW5kZWZpbmVkJyxcbiAgICAgICAgICAgIGZpbGVuYW1lOiB0aGlzLmZpbGVJbmZvKCkuZmlsZW5hbWUsXG4gICAgICAgICAgICBpbmRleDogdGhpcy5nZXRJbmRleCgpIH07XG4gICAgfVxufTtcblZhcmlhYmxlLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24gKG9iaiwgZnVuKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIHI7IGkgPCBvYmoubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgciA9IGZ1bi5jYWxsKG9iaiwgb2JqW2ldKTtcbiAgICAgICAgaWYgKHIpIHsgcmV0dXJuIHI7IH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBWYXJpYWJsZTtcblxufSx7XCIuL2NhbGxcIjo1NCxcIi4vbm9kZVwiOjc2fV0sODk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoganNoaW50IHByb3RvOiB0cnVlICovXG52YXIgQ29uc3RhbnRzID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcbnZhciBjbG9uZSA9IHJlcXVpcmUoJ2Nsb25lJyk7XG5cbnZhciB1dGlscyA9IHtcbiAgICBnZXRMb2NhdGlvbjogZnVuY3Rpb24oaW5kZXgsIGlucHV0U3RyZWFtKSB7XG4gICAgICAgIHZhciBuID0gaW5kZXggKyAxLFxuICAgICAgICAgICAgbGluZSA9IG51bGwsXG4gICAgICAgICAgICBjb2x1bW4gPSAtMTtcblxuICAgICAgICB3aGlsZSAoLS1uID49IDAgJiYgaW5wdXRTdHJlYW0uY2hhckF0KG4pICE9PSAnXFxuJykge1xuICAgICAgICAgICAgY29sdW1uKys7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGluZGV4ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgbGluZSA9IChpbnB1dFN0cmVhbS5zbGljZSgwLCBpbmRleCkubWF0Y2goL1xcbi9nKSB8fCAnJykubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxpbmU6IGxpbmUsXG4gICAgICAgICAgICBjb2x1bW46IGNvbHVtblxuICAgICAgICB9O1xuICAgIH0sXG4gICAgY29weUFycmF5OiBmdW5jdGlvbihhcnIpIHtcbiAgICAgICAgdmFyIGksIGxlbmd0aCA9IGFyci5sZW5ndGgsXG4gICAgICAgICAgICBjb3B5ID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gICAgICAgIFxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvcHlbaV0gPSBhcnJbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvcHk7XG4gICAgfSxcbiAgICBjbG9uZTogZnVuY3Rpb24gKG9iaikge1xuICAgICAgICB2YXIgY2xvbmVkID0ge307XG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICAgICAgY2xvbmVkW3Byb3BdID0gb2JqW3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbG9uZWQ7XG4gICAgfSxcbiAgICBjb3B5T3B0aW9uczogZnVuY3Rpb24ob2JqMSwgb2JqMikge1xuICAgICAgICBpZiAob2JqMiAmJiBvYmoyLl9kZWZhdWx0cykge1xuICAgICAgICAgICAgcmV0dXJuIG9iajI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9wdHMgPSB1dGlscy5kZWZhdWx0cyhvYmoxLCBvYmoyKTtcbiAgICAgICAgaWYgKG9wdHMuc3RyaWN0TWF0aCkge1xuICAgICAgICAgICAgb3B0cy5tYXRoID0gQ29uc3RhbnRzLk1hdGguU1RSSUNUX0xFR0FDWTtcbiAgICAgICAgfVxuICAgICAgICAvLyBCYWNrIGNvbXBhdCB3aXRoIGNoYW5nZWQgcmVsYXRpdmVVcmxzIG9wdGlvblxuICAgICAgICBpZiAob3B0cy5yZWxhdGl2ZVVybHMpIHtcbiAgICAgICAgICAgIG9wdHMucmV3cml0ZVVybHMgPSBDb25zdGFudHMuUmV3cml0ZVVybHMuQUxMO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0cy5tYXRoID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgc3dpdGNoIChvcHRzLm1hdGgudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2Fsd2F5cyc6XG4gICAgICAgICAgICAgICAgICAgIG9wdHMubWF0aCA9IENvbnN0YW50cy5NYXRoLkFMV0FZUztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAncGFyZW5zLWRpdmlzaW9uJzpcbiAgICAgICAgICAgICAgICAgICAgb3B0cy5tYXRoID0gQ29uc3RhbnRzLk1hdGguUEFSRU5TX0RJVklTSU9OO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpY3QnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3BhcmVucyc6XG4gICAgICAgICAgICAgICAgICAgIG9wdHMubWF0aCA9IENvbnN0YW50cy5NYXRoLlBBUkVOUztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaWN0LWxlZ2FjeSc6XG4gICAgICAgICAgICAgICAgICAgIG9wdHMubWF0aCA9IENvbnN0YW50cy5NYXRoLlNUUklDVF9MRUdBQ1k7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRzLnJld3JpdGVVcmxzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgc3dpdGNoIChvcHRzLnJld3JpdGVVcmxzLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdvZmYnOlxuICAgICAgICAgICAgICAgICAgICBvcHRzLnJld3JpdGVVcmxzID0gQ29uc3RhbnRzLlJld3JpdGVVcmxzLk9GRjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnbG9jYWwnOlxuICAgICAgICAgICAgICAgICAgICBvcHRzLnJld3JpdGVVcmxzID0gQ29uc3RhbnRzLlJld3JpdGVVcmxzLkxPQ0FMO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdhbGwnOlxuICAgICAgICAgICAgICAgICAgICBvcHRzLnJld3JpdGVVcmxzID0gQ29uc3RhbnRzLlJld3JpdGVVcmxzLkFMTDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9wdHM7XG4gICAgfSxcbiAgICBkZWZhdWx0czogZnVuY3Rpb24ob2JqMSwgb2JqMikge1xuICAgICAgICB2YXIgbmV3T2JqID0gb2JqMiB8fCB7fTtcbiAgICAgICAgaWYgKCFvYmoyLl9kZWZhdWx0cykge1xuICAgICAgICAgICAgbmV3T2JqID0ge307XG4gICAgICAgICAgICB2YXIgZGVmYXVsdHMgPSBjbG9uZShvYmoxKTtcbiAgICAgICAgICAgIG5ld09iai5fZGVmYXVsdHMgPSBkZWZhdWx0cztcbiAgICAgICAgICAgIHZhciBjbG9uZWQgPSBvYmoyID8gY2xvbmUob2JqMikgOiB7fTtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24obmV3T2JqLCBkZWZhdWx0cywgY2xvbmVkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3T2JqO1xuICAgIH0sXG4gICAgbWVyZ2U6IGZ1bmN0aW9uKG9iajEsIG9iajIpIHtcbiAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBvYmoyKSB7XG4gICAgICAgICAgICBpZiAob2JqMi5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAgICAgICAgIG9iajFbcHJvcF0gPSBvYmoyW3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmoxO1xuICAgIH0sXG4gICAgZmxhdHRlbkFycmF5OiBmdW5jdGlvbihhcnIsIHJlc3VsdCkge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQgfHwgW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBhcnIubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGFycltpXTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHV0aWxzLmZsYXR0ZW5BcnJheSh2YWx1ZSwgcmVzdWx0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gdXRpbHM7XG59LHtcIi4vY29uc3RhbnRzXCI6MTIsXCJjbG9uZVwiOjEwMH1dLDkwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciB0cmVlID0gcmVxdWlyZSgnLi4vdHJlZScpLFxuICAgIFZpc2l0b3IgPSByZXF1aXJlKCcuL3Zpc2l0b3InKSxcbiAgICBsb2dnZXIgPSByZXF1aXJlKCcuLi9sb2dnZXInKSxcbiAgICB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbi8qIGpzaGludCBsb29wZnVuYzp0cnVlICovXG5cbnZhciBFeHRlbmRGaW5kZXJWaXNpdG9yID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fdmlzaXRvciA9IG5ldyBWaXNpdG9yKHRoaXMpO1xuICAgIHRoaXMuY29udGV4dHMgPSBbXTtcbiAgICB0aGlzLmFsbEV4dGVuZHNTdGFjayA9IFtbXV07XG59O1xuXG5FeHRlbmRGaW5kZXJWaXNpdG9yLnByb3RvdHlwZSA9IHtcbiAgICBydW46IGZ1bmN0aW9uIChyb290KSB7XG4gICAgICAgIHJvb3QgPSB0aGlzLl92aXNpdG9yLnZpc2l0KHJvb3QpO1xuICAgICAgICByb290LmFsbEV4dGVuZHMgPSB0aGlzLmFsbEV4dGVuZHNTdGFja1swXTtcbiAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgfSxcbiAgICB2aXNpdERlY2xhcmF0aW9uOiBmdW5jdGlvbiAoZGVjbE5vZGUsIHZpc2l0QXJncykge1xuICAgICAgICB2aXNpdEFyZ3MudmlzaXREZWVwZXIgPSBmYWxzZTtcbiAgICB9LFxuICAgIHZpc2l0TWl4aW5EZWZpbml0aW9uOiBmdW5jdGlvbiAobWl4aW5EZWZpbml0aW9uTm9kZSwgdmlzaXRBcmdzKSB7XG4gICAgICAgIHZpc2l0QXJncy52aXNpdERlZXBlciA9IGZhbHNlO1xuICAgIH0sXG4gICAgdmlzaXRSdWxlc2V0OiBmdW5jdGlvbiAocnVsZXNldE5vZGUsIHZpc2l0QXJncykge1xuICAgICAgICBpZiAocnVsZXNldE5vZGUucm9vdCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGksIGosIGV4dGVuZCwgYWxsU2VsZWN0b3JzRXh0ZW5kTGlzdCA9IFtdLCBleHRlbmRMaXN0O1xuXG4gICAgICAgIC8vIGdldCAmOmV4dGVuZCguYSk7IHJ1bGVzIHdoaWNoIGFwcGx5IHRvIGFsbCBzZWxlY3RvcnMgaW4gdGhpcyBydWxlc2V0XG4gICAgICAgIHZhciBydWxlcyA9IHJ1bGVzZXROb2RlLnJ1bGVzLCBydWxlQ250ID0gcnVsZXMgPyBydWxlcy5sZW5ndGggOiAwO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcnVsZUNudDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAocnVsZXNldE5vZGUucnVsZXNbaV0gaW5zdGFuY2VvZiB0cmVlLkV4dGVuZCkge1xuICAgICAgICAgICAgICAgIGFsbFNlbGVjdG9yc0V4dGVuZExpc3QucHVzaChydWxlc1tpXSk7XG4gICAgICAgICAgICAgICAgcnVsZXNldE5vZGUuZXh0ZW5kT25FdmVyeVBhdGggPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gbm93IGZpbmQgZXZlcnkgc2VsZWN0b3IgYW5kIGFwcGx5IHRoZSBleHRlbmRzIHRoYXQgYXBwbHkgdG8gYWxsIGV4dGVuZHNcbiAgICAgICAgLy8gYW5kIHRoZSBvbmVzIHdoaWNoIGFwcGx5IHRvIGFuIGluZGl2aWR1YWwgZXh0ZW5kXG4gICAgICAgIHZhciBwYXRocyA9IHJ1bGVzZXROb2RlLnBhdGhzO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGF0aHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3RvclBhdGggPSBwYXRoc1tpXSxcbiAgICAgICAgICAgICAgICBzZWxlY3RvciA9IHNlbGVjdG9yUGF0aFtzZWxlY3RvclBhdGgubGVuZ3RoIC0gMV0sXG4gICAgICAgICAgICAgICAgc2VsRXh0ZW5kTGlzdCA9IHNlbGVjdG9yLmV4dGVuZExpc3Q7XG5cbiAgICAgICAgICAgIGV4dGVuZExpc3QgPSBzZWxFeHRlbmRMaXN0ID8gdXRpbHMuY29weUFycmF5KHNlbEV4dGVuZExpc3QpLmNvbmNhdChhbGxTZWxlY3RvcnNFeHRlbmRMaXN0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBhbGxTZWxlY3RvcnNFeHRlbmRMaXN0O1xuXG4gICAgICAgICAgICBpZiAoZXh0ZW5kTGlzdCkge1xuICAgICAgICAgICAgICAgIGV4dGVuZExpc3QgPSBleHRlbmRMaXN0Lm1hcChmdW5jdGlvbihhbGxTZWxlY3RvcnNFeHRlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFsbFNlbGVjdG9yc0V4dGVuZC5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgZXh0ZW5kTGlzdC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHRoaXMuZm91bmRFeHRlbmRzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBleHRlbmQgPSBleHRlbmRMaXN0W2pdO1xuICAgICAgICAgICAgICAgIGV4dGVuZC5maW5kU2VsZlNlbGVjdG9ycyhzZWxlY3RvclBhdGgpO1xuICAgICAgICAgICAgICAgIGV4dGVuZC5ydWxlc2V0ID0gcnVsZXNldE5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKGogPT09IDApIHsgZXh0ZW5kLmZpcnN0RXh0ZW5kT25UaGlzU2VsZWN0b3JQYXRoID0gdHJ1ZTsgfVxuICAgICAgICAgICAgICAgIHRoaXMuYWxsRXh0ZW5kc1N0YWNrW3RoaXMuYWxsRXh0ZW5kc1N0YWNrLmxlbmd0aCAtIDFdLnB1c2goZXh0ZW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY29udGV4dHMucHVzaChydWxlc2V0Tm9kZS5zZWxlY3RvcnMpO1xuICAgIH0sXG4gICAgdmlzaXRSdWxlc2V0T3V0OiBmdW5jdGlvbiAocnVsZXNldE5vZGUpIHtcbiAgICAgICAgaWYgKCFydWxlc2V0Tm9kZS5yb290KSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHRzLmxlbmd0aCA9IHRoaXMuY29udGV4dHMubGVuZ3RoIC0gMTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgdmlzaXRNZWRpYTogZnVuY3Rpb24gKG1lZGlhTm9kZSwgdmlzaXRBcmdzKSB7XG4gICAgICAgIG1lZGlhTm9kZS5hbGxFeHRlbmRzID0gW107XG4gICAgICAgIHRoaXMuYWxsRXh0ZW5kc1N0YWNrLnB1c2gobWVkaWFOb2RlLmFsbEV4dGVuZHMpO1xuICAgIH0sXG4gICAgdmlzaXRNZWRpYU91dDogZnVuY3Rpb24gKG1lZGlhTm9kZSkge1xuICAgICAgICB0aGlzLmFsbEV4dGVuZHNTdGFjay5sZW5ndGggPSB0aGlzLmFsbEV4dGVuZHNTdGFjay5sZW5ndGggLSAxO1xuICAgIH0sXG4gICAgdmlzaXRBdFJ1bGU6IGZ1bmN0aW9uIChhdFJ1bGVOb2RlLCB2aXNpdEFyZ3MpIHtcbiAgICAgICAgYXRSdWxlTm9kZS5hbGxFeHRlbmRzID0gW107XG4gICAgICAgIHRoaXMuYWxsRXh0ZW5kc1N0YWNrLnB1c2goYXRSdWxlTm9kZS5hbGxFeHRlbmRzKTtcbiAgICB9LFxuICAgIHZpc2l0QXRSdWxlT3V0OiBmdW5jdGlvbiAoYXRSdWxlTm9kZSkge1xuICAgICAgICB0aGlzLmFsbEV4dGVuZHNTdGFjay5sZW5ndGggPSB0aGlzLmFsbEV4dGVuZHNTdGFjay5sZW5ndGggLSAxO1xuICAgIH1cbn07XG5cbnZhciBQcm9jZXNzRXh0ZW5kc1Zpc2l0b3IgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl92aXNpdG9yID0gbmV3IFZpc2l0b3IodGhpcyk7XG59O1xuXG5Qcm9jZXNzRXh0ZW5kc1Zpc2l0b3IucHJvdG90eXBlID0ge1xuICAgIHJ1bjogZnVuY3Rpb24ocm9vdCkge1xuICAgICAgICB2YXIgZXh0ZW5kRmluZGVyID0gbmV3IEV4dGVuZEZpbmRlclZpc2l0b3IoKTtcbiAgICAgICAgdGhpcy5leHRlbmRJbmRpY2VzID0ge307XG4gICAgICAgIGV4dGVuZEZpbmRlci5ydW4ocm9vdCk7XG4gICAgICAgIGlmICghZXh0ZW5kRmluZGVyLmZvdW5kRXh0ZW5kcykgeyByZXR1cm4gcm9vdDsgfVxuICAgICAgICByb290LmFsbEV4dGVuZHMgPSByb290LmFsbEV4dGVuZHMuY29uY2F0KHRoaXMuZG9FeHRlbmRDaGFpbmluZyhyb290LmFsbEV4dGVuZHMsIHJvb3QuYWxsRXh0ZW5kcykpO1xuICAgICAgICB0aGlzLmFsbEV4dGVuZHNTdGFjayA9IFtyb290LmFsbEV4dGVuZHNdO1xuICAgICAgICB2YXIgbmV3Um9vdCA9IHRoaXMuX3Zpc2l0b3IudmlzaXQocm9vdCk7XG4gICAgICAgIHRoaXMuY2hlY2tFeHRlbmRzRm9yTm9uTWF0Y2hlZChyb290LmFsbEV4dGVuZHMpO1xuICAgICAgICByZXR1cm4gbmV3Um9vdDtcbiAgICB9LFxuICAgIGNoZWNrRXh0ZW5kc0Zvck5vbk1hdGNoZWQ6IGZ1bmN0aW9uKGV4dGVuZExpc3QpIHtcbiAgICAgICAgdmFyIGluZGljZXMgPSB0aGlzLmV4dGVuZEluZGljZXM7XG4gICAgICAgIGV4dGVuZExpc3QuZmlsdGVyKGZ1bmN0aW9uKGV4dGVuZCkge1xuICAgICAgICAgICAgcmV0dXJuICFleHRlbmQuaGFzRm91bmRNYXRjaGVzICYmIGV4dGVuZC5wYXJlbnRfaWRzLmxlbmd0aCA9PSAxO1xuICAgICAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uKGV4dGVuZCkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdG9yID0gJ191bmtub3duXyc7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yID0gZXh0ZW5kLnNlbGVjdG9yLnRvQ1NTKHt9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChfKSB7fVxuXG4gICAgICAgICAgICBpZiAoIWluZGljZXNbZXh0ZW5kLmluZGV4ICsgJyAnICsgc2VsZWN0b3JdKSB7XG4gICAgICAgICAgICAgICAgaW5kaWNlc1tleHRlbmQuaW5kZXggKyAnICcgKyBzZWxlY3Rvcl0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKCdleHRlbmQgXFwnJyArIHNlbGVjdG9yICsgJ1xcJyBoYXMgbm8gbWF0Y2hlcycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LFxuICAgIGRvRXh0ZW5kQ2hhaW5pbmc6IGZ1bmN0aW9uIChleHRlbmRzTGlzdCwgZXh0ZW5kc0xpc3RUYXJnZXQsIGl0ZXJhdGlvbkNvdW50KSB7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIGNoYWluaW5nIGlzIGRpZmZlcmVudCBmcm9tIG5vcm1hbCBleHRlbnNpb24uLiBpZiB3ZSBleHRlbmQgYW4gZXh0ZW5kIHRoZW4gd2UgYXJlIG5vdCBqdXN0IGNvcHlpbmcsIGFsdGVyaW5nXG4gICAgICAgIC8vIGFuZCBwYXN0aW5nIHRoZSBzZWxlY3RvciB3ZSB3b3VsZCBkbyBub3JtYWxseSwgYnV0IHdlIGFyZSBhbHNvIGFkZGluZyBhbiBleHRlbmQgd2l0aCB0aGUgc2FtZSB0YXJnZXQgc2VsZWN0b3JcbiAgICAgICAgLy8gdGhpcyBtZWFucyB0aGlzIG5ldyBleHRlbmQgY2FuIHRoZW4gZ28gYW5kIGFsdGVyIG90aGVyIGV4dGVuZHNcbiAgICAgICAgLy9cbiAgICAgICAgLy8gdGhpcyBtZXRob2QgZGVhbHMgd2l0aCBhbGwgdGhlIGNoYWluaW5nIHdvcmsgLSB3aXRob3V0IGl0LCBleHRlbmQgaXMgZmxhdCBhbmQgZG9lc24ndCB3b3JrIG9uIG90aGVyIGV4dGVuZCBzZWxlY3RvcnNcbiAgICAgICAgLy8gdGhpcyBpcyBhbHNvIHRoZSBtb3N0IGV4cGVuc2l2ZS4uIGFuZCBhIG1hdGNoIG9uIG9uZSBzZWxlY3RvciBjYW4gY2F1c2UgYW4gZXh0ZW5zaW9uIG9mIGEgc2VsZWN0b3Igd2UgaGFkIGFscmVhZHlcbiAgICAgICAgLy8gcHJvY2Vzc2VkIGlmIHdlIGxvb2sgYXQgZWFjaCBzZWxlY3RvciBhdCBhIHRpbWUsIGFzIGlzIGRvbmUgaW4gdmlzaXRSdWxlc2V0XG5cbiAgICAgICAgdmFyIGV4dGVuZEluZGV4LCB0YXJnZXRFeHRlbmRJbmRleCwgbWF0Y2hlcywgZXh0ZW5kc1RvQWRkID0gW10sIG5ld1NlbGVjdG9yLCBleHRlbmRWaXNpdG9yID0gdGhpcywgc2VsZWN0b3JQYXRoLFxuICAgICAgICAgICAgZXh0ZW5kLCB0YXJnZXRFeHRlbmQsIG5ld0V4dGVuZDtcblxuICAgICAgICBpdGVyYXRpb25Db3VudCA9IGl0ZXJhdGlvbkNvdW50IHx8IDA7XG5cbiAgICAgICAgLy8gbG9vcCB0aHJvdWdoIGNvbXBhcmluZyBldmVyeSBleHRlbmQgd2l0aCBldmVyeSB0YXJnZXQgZXh0ZW5kLlxuICAgICAgICAvLyBhIHRhcmdldCBleHRlbmQgaXMgdGhlIG9uZSBvbiB0aGUgcnVsZXNldCB3ZSBhcmUgbG9va2luZyBhdCBjb3B5L2VkaXQvcGFzdGluZyBpbiBwbGFjZVxuICAgICAgICAvLyBlLmcuICAuYTpleHRlbmQoLmIpIHt9ICBhbmQgLmI6ZXh0ZW5kKC5jKSB7fSB0aGVuIHRoZSBmaXJzdCBleHRlbmQgZXh0ZW5kcyB0aGUgc2Vjb25kIG9uZVxuICAgICAgICAvLyBhbmQgdGhlIHNlY29uZCBpcyB0aGUgdGFyZ2V0LlxuICAgICAgICAvLyB0aGUgc2VwYXJhdGlvbiBpbnRvIHR3byBsaXN0cyBhbGxvd3MgdXMgdG8gcHJvY2VzcyBhIHN1YnNldCBvZiBjaGFpbnMgd2l0aCBhIGJpZ2dlciBzZXQsIGFzIGlzIHRoZVxuICAgICAgICAvLyBjYXNlIHdoZW4gcHJvY2Vzc2luZyBtZWRpYSBxdWVyaWVzXG4gICAgICAgIGZvciAoZXh0ZW5kSW5kZXggPSAwOyBleHRlbmRJbmRleCA8IGV4dGVuZHNMaXN0Lmxlbmd0aDsgZXh0ZW5kSW5kZXgrKykge1xuICAgICAgICAgICAgZm9yICh0YXJnZXRFeHRlbmRJbmRleCA9IDA7IHRhcmdldEV4dGVuZEluZGV4IDwgZXh0ZW5kc0xpc3RUYXJnZXQubGVuZ3RoOyB0YXJnZXRFeHRlbmRJbmRleCsrKSB7XG5cbiAgICAgICAgICAgICAgICBleHRlbmQgPSBleHRlbmRzTGlzdFtleHRlbmRJbmRleF07XG4gICAgICAgICAgICAgICAgdGFyZ2V0RXh0ZW5kID0gZXh0ZW5kc0xpc3RUYXJnZXRbdGFyZ2V0RXh0ZW5kSW5kZXhdO1xuXG4gICAgICAgICAgICAgICAgLy8gbG9vayBmb3IgY2lyY3VsYXIgcmVmZXJlbmNlc1xuICAgICAgICAgICAgICAgIGlmICggZXh0ZW5kLnBhcmVudF9pZHMuaW5kZXhPZiggdGFyZ2V0RXh0ZW5kLm9iamVjdF9pZCApID49IDAgKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgICAgICAgICAvLyBmaW5kIGEgbWF0Y2ggaW4gdGhlIHRhcmdldCBleHRlbmRzIHNlbGYgc2VsZWN0b3IgKHRoZSBiaXQgYmVmb3JlIDpleHRlbmQpXG4gICAgICAgICAgICAgICAgc2VsZWN0b3JQYXRoID0gW3RhcmdldEV4dGVuZC5zZWxmU2VsZWN0b3JzWzBdXTtcbiAgICAgICAgICAgICAgICBtYXRjaGVzID0gZXh0ZW5kVmlzaXRvci5maW5kTWF0Y2goZXh0ZW5kLCBzZWxlY3RvclBhdGgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4dGVuZC5oYXNGb3VuZE1hdGNoZXMgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIGZvdW5kIGEgbWF0Y2gsIHNvIGZvciBlYWNoIHNlbGYgc2VsZWN0b3IuLlxuICAgICAgICAgICAgICAgICAgICBleHRlbmQuc2VsZlNlbGVjdG9ycy5mb3JFYWNoKGZ1bmN0aW9uKHNlbGZTZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZm8gPSB0YXJnZXRFeHRlbmQudmlzaWJpbGl0eUluZm8oKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJvY2VzcyB0aGUgZXh0ZW5kIGFzIHVzdWFsXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdTZWxlY3RvciA9IGV4dGVuZFZpc2l0b3IuZXh0ZW5kU2VsZWN0b3IobWF0Y2hlcywgc2VsZWN0b3JQYXRoLCBzZWxmU2VsZWN0b3IsIGV4dGVuZC5pc1Zpc2libGUoKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJ1dCBub3cgd2UgY3JlYXRlIGEgbmV3IGV4dGVuZCBmcm9tIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdFeHRlbmQgPSBuZXcodHJlZS5FeHRlbmQpKHRhcmdldEV4dGVuZC5zZWxlY3RvciwgdGFyZ2V0RXh0ZW5kLm9wdGlvbiwgMCwgdGFyZ2V0RXh0ZW5kLmZpbGVJbmZvKCksIGluZm8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3RXh0ZW5kLnNlbGZTZWxlY3RvcnMgPSBuZXdTZWxlY3RvcjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkIHRoZSBleHRlbmQgb250byB0aGUgbGlzdCBvZiBleHRlbmRzIGZvciB0aGF0IHNlbGVjdG9yXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdTZWxlY3RvcltuZXdTZWxlY3Rvci5sZW5ndGggLSAxXS5leHRlbmRMaXN0ID0gW25ld0V4dGVuZF07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlY29yZCB0aGF0IHdlIG5lZWQgdG8gYWRkIGl0LlxuICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5kc1RvQWRkLnB1c2gobmV3RXh0ZW5kKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0V4dGVuZC5ydWxlc2V0ID0gdGFyZ2V0RXh0ZW5kLnJ1bGVzZXQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbWVtYmVyIGl0cyBwYXJlbnRzIGZvciBjaXJjdWxhciByZWZlcmVuY2VzXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdFeHRlbmQucGFyZW50X2lkcyA9IG5ld0V4dGVuZC5wYXJlbnRfaWRzLmNvbmNhdCh0YXJnZXRFeHRlbmQucGFyZW50X2lkcywgZXh0ZW5kLnBhcmVudF9pZHMpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvbmx5IHByb2Nlc3MgdGhlIHNlbGVjdG9yIG9uY2UuLiBpZiB3ZSBoYXZlIDpleHRlbmQoLmEsLmIpIHRoZW4gbXVsdGlwbGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV4dGVuZHMgd2lsbCBsb29rIGF0IHRoZSBzYW1lIHNlbGVjdG9yIHBhdGgsIHNvIHdoZW4gZXh0ZW5kaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBrbm93IHRoYXQgYW55IG90aGVycyB3aWxsIGJlIGR1cGxpY2F0ZXMgaW4gdGVybXMgb2Ygd2hhdCBpcyBhZGRlZCB0byB0aGUgY3NzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0RXh0ZW5kLmZpcnN0RXh0ZW5kT25UaGlzU2VsZWN0b3JQYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3RXh0ZW5kLmZpcnN0RXh0ZW5kT25UaGlzU2VsZWN0b3JQYXRoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRFeHRlbmQucnVsZXNldC5wYXRocy5wdXNoKG5ld1NlbGVjdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV4dGVuZHNUb0FkZC5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIHRyeSB0byBkZXRlY3QgY2lyY3VsYXIgcmVmZXJlbmNlcyB0byBzdG9wIGEgc3RhY2sgb3ZlcmZsb3cuXG4gICAgICAgICAgICAvLyBtYXkgbm8gbG9uZ2VyIGJlIG5lZWRlZC5cbiAgICAgICAgICAgIHRoaXMuZXh0ZW5kQ2hhaW5Db3VudCsrO1xuICAgICAgICAgICAgaWYgKGl0ZXJhdGlvbkNvdW50ID4gMTAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGVjdG9yT25lID0gJ3t1bmFibGUgdG8gY2FsY3VsYXRlfSc7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGVjdG9yVHdvID0gJ3t1bmFibGUgdG8gY2FsY3VsYXRlfSc7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3JPbmUgPSBleHRlbmRzVG9BZGRbMF0uc2VsZlNlbGVjdG9yc1swXS50b0NTUygpO1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvclR3byA9IGV4dGVuZHNUb0FkZFswXS5zZWxlY3Rvci50b0NTUygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge31cbiAgICAgICAgICAgICAgICB0aHJvdyB7IG1lc3NhZ2U6ICdleHRlbmQgY2lyY3VsYXIgcmVmZXJlbmNlIGRldGVjdGVkLiBPbmUgb2YgdGhlIGNpcmN1bGFyIGV4dGVuZHMgaXMgY3VycmVudGx5OicgK1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rvck9uZSArICc6ZXh0ZW5kKCcgKyBzZWxlY3RvclR3byArICcpJ307XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIG5vdyBwcm9jZXNzIHRoZSBuZXcgZXh0ZW5kcyBvbiB0aGUgZXhpc3RpbmcgcnVsZXMgc28gdGhhdCB3ZSBjYW4gaGFuZGxlIGEgZXh0ZW5kaW5nIGIgZXh0ZW5kaW5nIGMgZXh0ZW5kaW5nXG4gICAgICAgICAgICAvLyBkIGV4dGVuZGluZyBlLi4uXG4gICAgICAgICAgICByZXR1cm4gZXh0ZW5kc1RvQWRkLmNvbmNhdChleHRlbmRWaXNpdG9yLmRvRXh0ZW5kQ2hhaW5pbmcoZXh0ZW5kc1RvQWRkLCBleHRlbmRzTGlzdFRhcmdldCwgaXRlcmF0aW9uQ291bnQgKyAxKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZXh0ZW5kc1RvQWRkO1xuICAgICAgICB9XG4gICAgfSxcbiAgICB2aXNpdERlY2xhcmF0aW9uOiBmdW5jdGlvbiAocnVsZU5vZGUsIHZpc2l0QXJncykge1xuICAgICAgICB2aXNpdEFyZ3MudmlzaXREZWVwZXIgPSBmYWxzZTtcbiAgICB9LFxuICAgIHZpc2l0TWl4aW5EZWZpbml0aW9uOiBmdW5jdGlvbiAobWl4aW5EZWZpbml0aW9uTm9kZSwgdmlzaXRBcmdzKSB7XG4gICAgICAgIHZpc2l0QXJncy52aXNpdERlZXBlciA9IGZhbHNlO1xuICAgIH0sXG4gICAgdmlzaXRTZWxlY3RvcjogZnVuY3Rpb24gKHNlbGVjdG9yTm9kZSwgdmlzaXRBcmdzKSB7XG4gICAgICAgIHZpc2l0QXJncy52aXNpdERlZXBlciA9IGZhbHNlO1xuICAgIH0sXG4gICAgdmlzaXRSdWxlc2V0OiBmdW5jdGlvbiAocnVsZXNldE5vZGUsIHZpc2l0QXJncykge1xuICAgICAgICBpZiAocnVsZXNldE5vZGUucm9vdCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtYXRjaGVzLCBwYXRoSW5kZXgsIGV4dGVuZEluZGV4LCBhbGxFeHRlbmRzID0gdGhpcy5hbGxFeHRlbmRzU3RhY2tbdGhpcy5hbGxFeHRlbmRzU3RhY2subGVuZ3RoIC0gMV0sXG4gICAgICAgICAgICBzZWxlY3RvcnNUb0FkZCA9IFtdLCBleHRlbmRWaXNpdG9yID0gdGhpcywgc2VsZWN0b3JQYXRoO1xuXG4gICAgICAgIC8vIGxvb2sgYXQgZWFjaCBzZWxlY3RvciBwYXRoIGluIHRoZSBydWxlc2V0LCBmaW5kIGFueSBleHRlbmQgbWF0Y2hlcyBhbmQgdGhlbiBjb3B5LCBmaW5kIGFuZCByZXBsYWNlXG5cbiAgICAgICAgZm9yIChleHRlbmRJbmRleCA9IDA7IGV4dGVuZEluZGV4IDwgYWxsRXh0ZW5kcy5sZW5ndGg7IGV4dGVuZEluZGV4KyspIHtcbiAgICAgICAgICAgIGZvciAocGF0aEluZGV4ID0gMDsgcGF0aEluZGV4IDwgcnVsZXNldE5vZGUucGF0aHMubGVuZ3RoOyBwYXRoSW5kZXgrKykge1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yUGF0aCA9IHJ1bGVzZXROb2RlLnBhdGhzW3BhdGhJbmRleF07XG5cbiAgICAgICAgICAgICAgICAvLyBleHRlbmRpbmcgZXh0ZW5kcyBoYXBwZW5zIGluaXRpYWxseSwgYmVmb3JlIHRoZSBtYWluIHBhc3NcbiAgICAgICAgICAgICAgICBpZiAocnVsZXNldE5vZGUuZXh0ZW5kT25FdmVyeVBhdGgpIHsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICB2YXIgZXh0ZW5kTGlzdCA9IHNlbGVjdG9yUGF0aFtzZWxlY3RvclBhdGgubGVuZ3RoIC0gMV0uZXh0ZW5kTGlzdDtcbiAgICAgICAgICAgICAgICBpZiAoZXh0ZW5kTGlzdCAmJiBleHRlbmRMaXN0Lmxlbmd0aCkgeyBjb250aW51ZTsgfVxuXG4gICAgICAgICAgICAgICAgbWF0Y2hlcyA9IHRoaXMuZmluZE1hdGNoKGFsbEV4dGVuZHNbZXh0ZW5kSW5kZXhdLCBzZWxlY3RvclBhdGgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGFsbEV4dGVuZHNbZXh0ZW5kSW5kZXhdLmhhc0ZvdW5kTWF0Y2hlcyA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgYWxsRXh0ZW5kc1tleHRlbmRJbmRleF0uc2VsZlNlbGVjdG9ycy5mb3JFYWNoKGZ1bmN0aW9uKHNlbGZTZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV4dGVuZGVkU2VsZWN0b3JzO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5kZWRTZWxlY3RvcnMgPSBleHRlbmRWaXNpdG9yLmV4dGVuZFNlbGVjdG9yKG1hdGNoZXMsIHNlbGVjdG9yUGF0aCwgc2VsZlNlbGVjdG9yLCBhbGxFeHRlbmRzW2V4dGVuZEluZGV4XS5pc1Zpc2libGUoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcnNUb0FkZC5wdXNoKGV4dGVuZGVkU2VsZWN0b3JzKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJ1bGVzZXROb2RlLnBhdGhzID0gcnVsZXNldE5vZGUucGF0aHMuY29uY2F0KHNlbGVjdG9yc1RvQWRkKTtcbiAgICB9LFxuICAgIGZpbmRNYXRjaDogZnVuY3Rpb24gKGV4dGVuZCwgaGF5c3RhY2tTZWxlY3RvclBhdGgpIHtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gbG9vayB0aHJvdWdoIHRoZSBoYXlzdGFjayBzZWxlY3RvciBwYXRoIHRvIHRyeSBhbmQgZmluZCB0aGUgbmVlZGxlIC0gZXh0ZW5kLnNlbGVjdG9yXG4gICAgICAgIC8vIHJldHVybnMgYW4gYXJyYXkgb2Ygc2VsZWN0b3IgbWF0Y2hlcyB0aGF0IGNhbiB0aGVuIGJlIHJlcGxhY2VkXG4gICAgICAgIC8vXG4gICAgICAgIHZhciBoYXlzdGFja1NlbGVjdG9ySW5kZXgsIGhhY2tzdGFja1NlbGVjdG9yLCBoYWNrc3RhY2tFbGVtZW50SW5kZXgsIGhheXN0YWNrRWxlbWVudCxcbiAgICAgICAgICAgIHRhcmdldENvbWJpbmF0b3IsIGksXG4gICAgICAgICAgICBleHRlbmRWaXNpdG9yID0gdGhpcyxcbiAgICAgICAgICAgIG5lZWRsZUVsZW1lbnRzID0gZXh0ZW5kLnNlbGVjdG9yLmVsZW1lbnRzLFxuICAgICAgICAgICAgcG90ZW50aWFsTWF0Y2hlcyA9IFtdLCBwb3RlbnRpYWxNYXRjaCwgbWF0Y2hlcyA9IFtdO1xuXG4gICAgICAgIC8vIGxvb3AgdGhyb3VnaCB0aGUgaGF5c3RhY2sgZWxlbWVudHNcbiAgICAgICAgZm9yIChoYXlzdGFja1NlbGVjdG9ySW5kZXggPSAwOyBoYXlzdGFja1NlbGVjdG9ySW5kZXggPCBoYXlzdGFja1NlbGVjdG9yUGF0aC5sZW5ndGg7IGhheXN0YWNrU2VsZWN0b3JJbmRleCsrKSB7XG4gICAgICAgICAgICBoYWNrc3RhY2tTZWxlY3RvciA9IGhheXN0YWNrU2VsZWN0b3JQYXRoW2hheXN0YWNrU2VsZWN0b3JJbmRleF07XG5cbiAgICAgICAgICAgIGZvciAoaGFja3N0YWNrRWxlbWVudEluZGV4ID0gMDsgaGFja3N0YWNrRWxlbWVudEluZGV4IDwgaGFja3N0YWNrU2VsZWN0b3IuZWxlbWVudHMubGVuZ3RoOyBoYWNrc3RhY2tFbGVtZW50SW5kZXgrKykge1xuXG4gICAgICAgICAgICAgICAgaGF5c3RhY2tFbGVtZW50ID0gaGFja3N0YWNrU2VsZWN0b3IuZWxlbWVudHNbaGFja3N0YWNrRWxlbWVudEluZGV4XTtcblxuICAgICAgICAgICAgICAgIC8vIGlmIHdlIGFsbG93IGVsZW1lbnRzIGJlZm9yZSBvdXIgbWF0Y2ggd2UgY2FuIGFkZCBhIHBvdGVudGlhbCBtYXRjaCBldmVyeSB0aW1lLiBvdGhlcndpc2Ugb25seSBhdCB0aGUgZmlyc3QgZWxlbWVudC5cbiAgICAgICAgICAgICAgICBpZiAoZXh0ZW5kLmFsbG93QmVmb3JlIHx8IChoYXlzdGFja1NlbGVjdG9ySW5kZXggPT09IDAgJiYgaGFja3N0YWNrRWxlbWVudEluZGV4ID09PSAwKSkge1xuICAgICAgICAgICAgICAgICAgICBwb3RlbnRpYWxNYXRjaGVzLnB1c2goe3BhdGhJbmRleDogaGF5c3RhY2tTZWxlY3RvckluZGV4LCBpbmRleDogaGFja3N0YWNrRWxlbWVudEluZGV4LCBtYXRjaGVkOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbENvbWJpbmF0b3I6IGhheXN0YWNrRWxlbWVudC5jb21iaW5hdG9yfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHBvdGVudGlhbE1hdGNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcG90ZW50aWFsTWF0Y2ggPSBwb3RlbnRpYWxNYXRjaGVzW2ldO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHNlbGVjdG9ycyBhZGQgXCIgXCIgb250byB0aGUgZmlyc3QgZWxlbWVudC4gV2hlbiB3ZSB1c2UgJiBpdCBqb2lucyB0aGUgc2VsZWN0b3JzIHRvZ2V0aGVyLCBidXQgaWYgd2UgZG9uJ3RcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlbiBlYWNoIHNlbGVjdG9yIGluIGhheXN0YWNrU2VsZWN0b3JQYXRoIGhhcyBhIHNwYWNlIGJlZm9yZSBpdCBhZGRlZCBpbiB0aGUgdG9DU1MgcGhhc2UuIHNvIHdlIG5lZWQgdG9cbiAgICAgICAgICAgICAgICAgICAgLy8gd29yayBvdXQgd2hhdCB0aGUgcmVzdWx0aW5nIGNvbWJpbmF0b3Igd2lsbCBiZVxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRDb21iaW5hdG9yID0gaGF5c3RhY2tFbGVtZW50LmNvbWJpbmF0b3IudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRDb21iaW5hdG9yID09PSAnJyAmJiBoYWNrc3RhY2tFbGVtZW50SW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldENvbWJpbmF0b3IgPSAnICc7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBkb24ndCBtYXRjaCwgbnVsbCBvdXIgbWF0Y2ggdG8gaW5kaWNhdGUgZmFpbHVyZVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWV4dGVuZFZpc2l0b3IuaXNFbGVtZW50VmFsdWVzRXF1YWwobmVlZGxlRWxlbWVudHNbcG90ZW50aWFsTWF0Y2gubWF0Y2hlZF0udmFsdWUsIGhheXN0YWNrRWxlbWVudC52YWx1ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChwb3RlbnRpYWxNYXRjaC5tYXRjaGVkID4gMCAmJiBuZWVkbGVFbGVtZW50c1twb3RlbnRpYWxNYXRjaC5tYXRjaGVkXS5jb21iaW5hdG9yLnZhbHVlICE9PSB0YXJnZXRDb21iaW5hdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG90ZW50aWFsTWF0Y2ggPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG90ZW50aWFsTWF0Y2gubWF0Y2hlZCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgd2UgYXJlIHN0aWxsIHZhbGlkIGFuZCBoYXZlIGZpbmlzaGVkLCB0ZXN0IHdoZXRoZXIgd2UgaGF2ZSBlbGVtZW50cyBhZnRlciBhbmQgd2hldGhlciB0aGVzZSBhcmUgYWxsb3dlZFxuICAgICAgICAgICAgICAgICAgICBpZiAocG90ZW50aWFsTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvdGVudGlhbE1hdGNoLmZpbmlzaGVkID0gcG90ZW50aWFsTWF0Y2gubWF0Y2hlZCA9PT0gbmVlZGxlRWxlbWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvdGVudGlhbE1hdGNoLmZpbmlzaGVkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCFleHRlbmQuYWxsb3dBZnRlciAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoaGFja3N0YWNrRWxlbWVudEluZGV4ICsgMSA8IGhhY2tzdGFja1NlbGVjdG9yLmVsZW1lbnRzLmxlbmd0aCB8fCBoYXlzdGFja1NlbGVjdG9ySW5kZXggKyAxIDwgaGF5c3RhY2tTZWxlY3RvclBhdGgubGVuZ3RoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3RlbnRpYWxNYXRjaCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgbnVsbCB3ZSByZW1vdmUsIGlmIG5vdCwgd2UgYXJlIHN0aWxsIHZhbGlkLCBzbyBlaXRoZXIgcHVzaCBhcyBhIHZhbGlkIG1hdGNoIG9yIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3RlbnRpYWxNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvdGVudGlhbE1hdGNoLmZpbmlzaGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG90ZW50aWFsTWF0Y2gubGVuZ3RoID0gbmVlZGxlRWxlbWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvdGVudGlhbE1hdGNoLmVuZFBhdGhJbmRleCA9IGhheXN0YWNrU2VsZWN0b3JJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3RlbnRpYWxNYXRjaC5lbmRQYXRoRWxlbWVudEluZGV4ID0gaGFja3N0YWNrRWxlbWVudEluZGV4ICsgMTsgLy8gaW5kZXggYWZ0ZXIgZW5kIG9mIG1hdGNoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG90ZW50aWFsTWF0Y2hlcy5sZW5ndGggPSAwOyAvLyB3ZSBkb24ndCBhbGxvdyBtYXRjaGVzIHRvIG92ZXJsYXAsIHNvIHN0YXJ0IG1hdGNoaW5nIGFnYWluXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlcy5wdXNoKHBvdGVudGlhbE1hdGNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvdGVudGlhbE1hdGNoZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXRjaGVzO1xuICAgIH0sXG4gICAgaXNFbGVtZW50VmFsdWVzRXF1YWw6IGZ1bmN0aW9uKGVsZW1lbnRWYWx1ZTEsIGVsZW1lbnRWYWx1ZTIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlbGVtZW50VmFsdWUxID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgZWxlbWVudFZhbHVlMiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50VmFsdWUxID09PSBlbGVtZW50VmFsdWUyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbGVtZW50VmFsdWUxIGluc3RhbmNlb2YgdHJlZS5BdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgIGlmIChlbGVtZW50VmFsdWUxLm9wICE9PSBlbGVtZW50VmFsdWUyLm9wIHx8IGVsZW1lbnRWYWx1ZTEua2V5ICE9PSBlbGVtZW50VmFsdWUyLmtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZWxlbWVudFZhbHVlMS52YWx1ZSB8fCAhZWxlbWVudFZhbHVlMi52YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50VmFsdWUxLnZhbHVlIHx8IGVsZW1lbnRWYWx1ZTIudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsZW1lbnRWYWx1ZTEgPSBlbGVtZW50VmFsdWUxLnZhbHVlLnZhbHVlIHx8IGVsZW1lbnRWYWx1ZTEudmFsdWU7XG4gICAgICAgICAgICBlbGVtZW50VmFsdWUyID0gZWxlbWVudFZhbHVlMi52YWx1ZS52YWx1ZSB8fCBlbGVtZW50VmFsdWUyLnZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnRWYWx1ZTEgPT09IGVsZW1lbnRWYWx1ZTI7XG4gICAgICAgIH1cbiAgICAgICAgZWxlbWVudFZhbHVlMSA9IGVsZW1lbnRWYWx1ZTEudmFsdWU7XG4gICAgICAgIGVsZW1lbnRWYWx1ZTIgPSBlbGVtZW50VmFsdWUyLnZhbHVlO1xuICAgICAgICBpZiAoZWxlbWVudFZhbHVlMSBpbnN0YW5jZW9mIHRyZWUuU2VsZWN0b3IpIHtcbiAgICAgICAgICAgIGlmICghKGVsZW1lbnRWYWx1ZTIgaW5zdGFuY2VvZiB0cmVlLlNlbGVjdG9yKSB8fCBlbGVtZW50VmFsdWUxLmVsZW1lbnRzLmxlbmd0aCAhPT0gZWxlbWVudFZhbHVlMi5lbGVtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSAgPCBlbGVtZW50VmFsdWUxLmVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRWYWx1ZTEuZWxlbWVudHNbaV0uY29tYmluYXRvci52YWx1ZSAhPT0gZWxlbWVudFZhbHVlMi5lbGVtZW50c1tpXS5jb21iaW5hdG9yLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpICE9PSAwIHx8IChlbGVtZW50VmFsdWUxLmVsZW1lbnRzW2ldLmNvbWJpbmF0b3IudmFsdWUgfHwgJyAnKSAhPT0gKGVsZW1lbnRWYWx1ZTIuZWxlbWVudHNbaV0uY29tYmluYXRvci52YWx1ZSB8fCAnICcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzRWxlbWVudFZhbHVlc0VxdWFsKGVsZW1lbnRWYWx1ZTEuZWxlbWVudHNbaV0udmFsdWUsIGVsZW1lbnRWYWx1ZTIuZWxlbWVudHNbaV0udmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBleHRlbmRTZWxlY3RvcjpmdW5jdGlvbiAobWF0Y2hlcywgc2VsZWN0b3JQYXRoLCByZXBsYWNlbWVudFNlbGVjdG9yLCBpc1Zpc2libGUpIHtcblxuICAgICAgICAvLyBmb3IgYSBzZXQgb2YgbWF0Y2hlcywgcmVwbGFjZSBlYWNoIG1hdGNoIHdpdGggdGhlIHJlcGxhY2VtZW50IHNlbGVjdG9yXG5cbiAgICAgICAgdmFyIGN1cnJlbnRTZWxlY3RvclBhdGhJbmRleCA9IDAsXG4gICAgICAgICAgICBjdXJyZW50U2VsZWN0b3JQYXRoRWxlbWVudEluZGV4ID0gMCxcbiAgICAgICAgICAgIHBhdGggPSBbXSxcbiAgICAgICAgICAgIG1hdGNoSW5kZXgsXG4gICAgICAgICAgICBzZWxlY3RvcixcbiAgICAgICAgICAgIGZpcnN0RWxlbWVudCxcbiAgICAgICAgICAgIG1hdGNoLFxuICAgICAgICAgICAgbmV3RWxlbWVudHM7XG5cbiAgICAgICAgZm9yIChtYXRjaEluZGV4ID0gMDsgbWF0Y2hJbmRleCA8IG1hdGNoZXMubGVuZ3RoOyBtYXRjaEluZGV4KyspIHtcbiAgICAgICAgICAgIG1hdGNoID0gbWF0Y2hlc1ttYXRjaEluZGV4XTtcbiAgICAgICAgICAgIHNlbGVjdG9yID0gc2VsZWN0b3JQYXRoW21hdGNoLnBhdGhJbmRleF07XG4gICAgICAgICAgICBmaXJzdEVsZW1lbnQgPSBuZXcgdHJlZS5FbGVtZW50KFxuICAgICAgICAgICAgICAgIG1hdGNoLmluaXRpYWxDb21iaW5hdG9yLFxuICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50U2VsZWN0b3IuZWxlbWVudHNbMF0udmFsdWUsXG4gICAgICAgICAgICAgICAgcmVwbGFjZW1lbnRTZWxlY3Rvci5lbGVtZW50c1swXS5pc1ZhcmlhYmxlLFxuICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50U2VsZWN0b3IuZWxlbWVudHNbMF0uZ2V0SW5kZXgoKSxcbiAgICAgICAgICAgICAgICByZXBsYWNlbWVudFNlbGVjdG9yLmVsZW1lbnRzWzBdLmZpbGVJbmZvKClcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGlmIChtYXRjaC5wYXRoSW5kZXggPiBjdXJyZW50U2VsZWN0b3JQYXRoSW5kZXggJiYgY3VycmVudFNlbGVjdG9yUGF0aEVsZW1lbnRJbmRleCA+IDApIHtcbiAgICAgICAgICAgICAgICBwYXRoW3BhdGgubGVuZ3RoIC0gMV0uZWxlbWVudHMgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV1cbiAgICAgICAgICAgICAgICAgICAgLmVsZW1lbnRzLmNvbmNhdChzZWxlY3RvclBhdGhbY3VycmVudFNlbGVjdG9yUGF0aEluZGV4XS5lbGVtZW50cy5zbGljZShjdXJyZW50U2VsZWN0b3JQYXRoRWxlbWVudEluZGV4KSk7XG4gICAgICAgICAgICAgICAgY3VycmVudFNlbGVjdG9yUGF0aEVsZW1lbnRJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgY3VycmVudFNlbGVjdG9yUGF0aEluZGV4Kys7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5ld0VsZW1lbnRzID0gc2VsZWN0b3IuZWxlbWVudHNcbiAgICAgICAgICAgICAgICAuc2xpY2UoY3VycmVudFNlbGVjdG9yUGF0aEVsZW1lbnRJbmRleCwgbWF0Y2guaW5kZXgpXG4gICAgICAgICAgICAgICAgLmNvbmNhdChbZmlyc3RFbGVtZW50XSlcbiAgICAgICAgICAgICAgICAuY29uY2F0KHJlcGxhY2VtZW50U2VsZWN0b3IuZWxlbWVudHMuc2xpY2UoMSkpO1xuXG4gICAgICAgICAgICBpZiAoY3VycmVudFNlbGVjdG9yUGF0aEluZGV4ID09PSBtYXRjaC5wYXRoSW5kZXggJiYgbWF0Y2hJbmRleCA+IDApIHtcbiAgICAgICAgICAgICAgICBwYXRoW3BhdGgubGVuZ3RoIC0gMV0uZWxlbWVudHMgPVxuICAgICAgICAgICAgICAgICAgICBwYXRoW3BhdGgubGVuZ3RoIC0gMV0uZWxlbWVudHMuY29uY2F0KG5ld0VsZW1lbnRzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGF0aCA9IHBhdGguY29uY2F0KHNlbGVjdG9yUGF0aC5zbGljZShjdXJyZW50U2VsZWN0b3JQYXRoSW5kZXgsIG1hdGNoLnBhdGhJbmRleCkpO1xuXG4gICAgICAgICAgICAgICAgcGF0aC5wdXNoKG5ldyB0cmVlLlNlbGVjdG9yKFxuICAgICAgICAgICAgICAgICAgICBuZXdFbGVtZW50c1xuICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudFNlbGVjdG9yUGF0aEluZGV4ID0gbWF0Y2guZW5kUGF0aEluZGV4O1xuICAgICAgICAgICAgY3VycmVudFNlbGVjdG9yUGF0aEVsZW1lbnRJbmRleCA9IG1hdGNoLmVuZFBhdGhFbGVtZW50SW5kZXg7XG4gICAgICAgICAgICBpZiAoY3VycmVudFNlbGVjdG9yUGF0aEVsZW1lbnRJbmRleCA+PSBzZWxlY3RvclBhdGhbY3VycmVudFNlbGVjdG9yUGF0aEluZGV4XS5lbGVtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50U2VsZWN0b3JQYXRoRWxlbWVudEluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICBjdXJyZW50U2VsZWN0b3JQYXRoSW5kZXgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjdXJyZW50U2VsZWN0b3JQYXRoSW5kZXggPCBzZWxlY3RvclBhdGgubGVuZ3RoICYmIGN1cnJlbnRTZWxlY3RvclBhdGhFbGVtZW50SW5kZXggPiAwKSB7XG4gICAgICAgICAgICBwYXRoW3BhdGgubGVuZ3RoIC0gMV0uZWxlbWVudHMgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV1cbiAgICAgICAgICAgICAgICAuZWxlbWVudHMuY29uY2F0KHNlbGVjdG9yUGF0aFtjdXJyZW50U2VsZWN0b3JQYXRoSW5kZXhdLmVsZW1lbnRzLnNsaWNlKGN1cnJlbnRTZWxlY3RvclBhdGhFbGVtZW50SW5kZXgpKTtcbiAgICAgICAgICAgIGN1cnJlbnRTZWxlY3RvclBhdGhJbmRleCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgcGF0aCA9IHBhdGguY29uY2F0KHNlbGVjdG9yUGF0aC5zbGljZShjdXJyZW50U2VsZWN0b3JQYXRoSW5kZXgsIHNlbGVjdG9yUGF0aC5sZW5ndGgpKTtcbiAgICAgICAgcGF0aCA9IHBhdGgubWFwKGZ1bmN0aW9uIChjdXJyZW50VmFsdWUpIHtcbiAgICAgICAgICAgIC8vIHdlIGNhbiByZS11c2UgZWxlbWVudHMgaGVyZSwgYmVjYXVzZSB0aGUgdmlzaWJpbGl0eSBwcm9wZXJ0eSBtYXR0ZXJzIG9ubHkgZm9yIHNlbGVjdG9yc1xuICAgICAgICAgICAgdmFyIGRlcml2ZWQgPSBjdXJyZW50VmFsdWUuY3JlYXRlRGVyaXZlZChjdXJyZW50VmFsdWUuZWxlbWVudHMpO1xuICAgICAgICAgICAgaWYgKGlzVmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIGRlcml2ZWQuZW5zdXJlVmlzaWJpbGl0eSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZXJpdmVkLmVuc3VyZUludmlzaWJpbGl0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRlcml2ZWQ7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICB9LFxuICAgIHZpc2l0TWVkaWE6IGZ1bmN0aW9uIChtZWRpYU5vZGUsIHZpc2l0QXJncykge1xuICAgICAgICB2YXIgbmV3QWxsRXh0ZW5kcyA9IG1lZGlhTm9kZS5hbGxFeHRlbmRzLmNvbmNhdCh0aGlzLmFsbEV4dGVuZHNTdGFja1t0aGlzLmFsbEV4dGVuZHNTdGFjay5sZW5ndGggLSAxXSk7XG4gICAgICAgIG5ld0FsbEV4dGVuZHMgPSBuZXdBbGxFeHRlbmRzLmNvbmNhdCh0aGlzLmRvRXh0ZW5kQ2hhaW5pbmcobmV3QWxsRXh0ZW5kcywgbWVkaWFOb2RlLmFsbEV4dGVuZHMpKTtcbiAgICAgICAgdGhpcy5hbGxFeHRlbmRzU3RhY2sucHVzaChuZXdBbGxFeHRlbmRzKTtcbiAgICB9LFxuICAgIHZpc2l0TWVkaWFPdXQ6IGZ1bmN0aW9uIChtZWRpYU5vZGUpIHtcbiAgICAgICAgdmFyIGxhc3RJbmRleCA9IHRoaXMuYWxsRXh0ZW5kc1N0YWNrLmxlbmd0aCAtIDE7XG4gICAgICAgIHRoaXMuYWxsRXh0ZW5kc1N0YWNrLmxlbmd0aCA9IGxhc3RJbmRleDtcbiAgICB9LFxuICAgIHZpc2l0QXRSdWxlOiBmdW5jdGlvbiAoYXRSdWxlTm9kZSwgdmlzaXRBcmdzKSB7XG4gICAgICAgIHZhciBuZXdBbGxFeHRlbmRzID0gYXRSdWxlTm9kZS5hbGxFeHRlbmRzLmNvbmNhdCh0aGlzLmFsbEV4dGVuZHNTdGFja1t0aGlzLmFsbEV4dGVuZHNTdGFjay5sZW5ndGggLSAxXSk7XG4gICAgICAgIG5ld0FsbEV4dGVuZHMgPSBuZXdBbGxFeHRlbmRzLmNvbmNhdCh0aGlzLmRvRXh0ZW5kQ2hhaW5pbmcobmV3QWxsRXh0ZW5kcywgYXRSdWxlTm9kZS5hbGxFeHRlbmRzKSk7XG4gICAgICAgIHRoaXMuYWxsRXh0ZW5kc1N0YWNrLnB1c2gobmV3QWxsRXh0ZW5kcyk7XG4gICAgfSxcbiAgICB2aXNpdEF0UnVsZU91dDogZnVuY3Rpb24gKGF0UnVsZU5vZGUpIHtcbiAgICAgICAgdmFyIGxhc3RJbmRleCA9IHRoaXMuYWxsRXh0ZW5kc1N0YWNrLmxlbmd0aCAtIDE7XG4gICAgICAgIHRoaXMuYWxsRXh0ZW5kc1N0YWNrLmxlbmd0aCA9IGxhc3RJbmRleDtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFByb2Nlc3NFeHRlbmRzVmlzaXRvcjtcblxufSx7XCIuLi9sb2dnZXJcIjozOSxcIi4uL3RyZWVcIjo2NyxcIi4uL3V0aWxzXCI6ODksXCIuL3Zpc2l0b3JcIjo5N31dLDkxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmZ1bmN0aW9uIEltcG9ydFNlcXVlbmNlcihvblNlcXVlbmNlckVtcHR5KSB7XG4gICAgdGhpcy5pbXBvcnRzID0gW107XG4gICAgdGhpcy52YXJpYWJsZUltcG9ydHMgPSBbXTtcbiAgICB0aGlzLl9vblNlcXVlbmNlckVtcHR5ID0gb25TZXF1ZW5jZXJFbXB0eTtcbiAgICB0aGlzLl9jdXJyZW50RGVwdGggPSAwO1xufVxuXG5JbXBvcnRTZXF1ZW5jZXIucHJvdG90eXBlLmFkZEltcG9ydCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgdmFyIGltcG9ydFNlcXVlbmNlciA9IHRoaXMsXG4gICAgICAgIGltcG9ydEl0ZW0gPSB7XG4gICAgICAgICAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgICAgICAgICBhcmdzOiBudWxsLFxuICAgICAgICAgICAgaXNSZWFkeTogZmFsc2VcbiAgICAgICAgfTtcbiAgICB0aGlzLmltcG9ydHMucHVzaChpbXBvcnRJdGVtKTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIGltcG9ydEl0ZW0uYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gICAgICAgIGltcG9ydEl0ZW0uaXNSZWFkeSA9IHRydWU7XG4gICAgICAgIGltcG9ydFNlcXVlbmNlci50cnlSdW4oKTtcbiAgICB9O1xufTtcblxuSW1wb3J0U2VxdWVuY2VyLnByb3RvdHlwZS5hZGRWYXJpYWJsZUltcG9ydCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgdGhpcy52YXJpYWJsZUltcG9ydHMucHVzaChjYWxsYmFjayk7XG59O1xuXG5JbXBvcnRTZXF1ZW5jZXIucHJvdG90eXBlLnRyeVJ1biA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2N1cnJlbnREZXB0aCsrO1xuICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICB3aGlsZSAodGhpcy5pbXBvcnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgaW1wb3J0SXRlbSA9IHRoaXMuaW1wb3J0c1swXTtcbiAgICAgICAgICAgICAgICBpZiAoIWltcG9ydEl0ZW0uaXNSZWFkeSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuaW1wb3J0cyA9IHRoaXMuaW1wb3J0cy5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICBpbXBvcnRJdGVtLmNhbGxiYWNrLmFwcGx5KG51bGwsIGltcG9ydEl0ZW0uYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy52YXJpYWJsZUltcG9ydHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdmFyaWFibGVJbXBvcnQgPSB0aGlzLnZhcmlhYmxlSW1wb3J0c1swXTtcbiAgICAgICAgICAgIHRoaXMudmFyaWFibGVJbXBvcnRzID0gdGhpcy52YXJpYWJsZUltcG9ydHMuc2xpY2UoMSk7XG4gICAgICAgICAgICB2YXJpYWJsZUltcG9ydCgpO1xuICAgICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhpcy5fY3VycmVudERlcHRoLS07XG4gICAgfVxuICAgIGlmICh0aGlzLl9jdXJyZW50RGVwdGggPT09IDAgJiYgdGhpcy5fb25TZXF1ZW5jZXJFbXB0eSkge1xuICAgICAgICB0aGlzLl9vblNlcXVlbmNlckVtcHR5KCk7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbXBvcnRTZXF1ZW5jZXI7XG5cbn0se31dLDkyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBjb250ZXh0cyA9IHJlcXVpcmUoJy4uL2NvbnRleHRzJyksXG4gICAgVmlzaXRvciA9IHJlcXVpcmUoJy4vdmlzaXRvcicpLFxuICAgIEltcG9ydFNlcXVlbmNlciA9IHJlcXVpcmUoJy4vaW1wb3J0LXNlcXVlbmNlcicpLFxuICAgIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxudmFyIEltcG9ydFZpc2l0b3IgPSBmdW5jdGlvbihpbXBvcnRlciwgZmluaXNoKSB7XG5cbiAgICB0aGlzLl92aXNpdG9yID0gbmV3IFZpc2l0b3IodGhpcyk7XG4gICAgdGhpcy5faW1wb3J0ZXIgPSBpbXBvcnRlcjtcbiAgICB0aGlzLl9maW5pc2ggPSBmaW5pc2g7XG4gICAgdGhpcy5jb250ZXh0ID0gbmV3IGNvbnRleHRzLkV2YWwoKTtcbiAgICB0aGlzLmltcG9ydENvdW50ID0gMDtcbiAgICB0aGlzLm9uY2VGaWxlRGV0ZWN0aW9uTWFwID0ge307XG4gICAgdGhpcy5yZWN1cnNpb25EZXRlY3RvciA9IHt9O1xuICAgIHRoaXMuX3NlcXVlbmNlciA9IG5ldyBJbXBvcnRTZXF1ZW5jZXIodGhpcy5fb25TZXF1ZW5jZXJFbXB0eS5iaW5kKHRoaXMpKTtcbn07XG5cbkltcG9ydFZpc2l0b3IucHJvdG90eXBlID0ge1xuICAgIGlzUmVwbGFjaW5nOiBmYWxzZSxcbiAgICBydW46IGZ1bmN0aW9uIChyb290KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBwcm9jZXNzIHRoZSBjb250ZW50c1xuICAgICAgICAgICAgdGhpcy5fdmlzaXRvci52aXNpdChyb290KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5lcnJvciA9IGU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmlzRmluaXNoZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9zZXF1ZW5jZXIudHJ5UnVuKCk7XG4gICAgfSxcbiAgICBfb25TZXF1ZW5jZXJFbXB0eTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0ZpbmlzaGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZmluaXNoKHRoaXMuZXJyb3IpO1xuICAgIH0sXG4gICAgdmlzaXRJbXBvcnQ6IGZ1bmN0aW9uIChpbXBvcnROb2RlLCB2aXNpdEFyZ3MpIHtcbiAgICAgICAgdmFyIGlubGluZUNTUyA9IGltcG9ydE5vZGUub3B0aW9ucy5pbmxpbmU7XG5cbiAgICAgICAgaWYgKCFpbXBvcnROb2RlLmNzcyB8fCBpbmxpbmVDU1MpIHtcblxuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBuZXcgY29udGV4dHMuRXZhbCh0aGlzLmNvbnRleHQsIHV0aWxzLmNvcHlBcnJheSh0aGlzLmNvbnRleHQuZnJhbWVzKSk7XG4gICAgICAgICAgICB2YXIgaW1wb3J0UGFyZW50ID0gY29udGV4dC5mcmFtZXNbMF07XG5cbiAgICAgICAgICAgIHRoaXMuaW1wb3J0Q291bnQrKztcbiAgICAgICAgICAgIGlmIChpbXBvcnROb2RlLmlzVmFyaWFibGVJbXBvcnQoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NlcXVlbmNlci5hZGRWYXJpYWJsZUltcG9ydCh0aGlzLnByb2Nlc3NJbXBvcnROb2RlLmJpbmQodGhpcywgaW1wb3J0Tm9kZSwgY29udGV4dCwgaW1wb3J0UGFyZW50KSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc0ltcG9ydE5vZGUoaW1wb3J0Tm9kZSwgY29udGV4dCwgaW1wb3J0UGFyZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2aXNpdEFyZ3MudmlzaXREZWVwZXIgPSBmYWxzZTtcbiAgICB9LFxuICAgIHByb2Nlc3NJbXBvcnROb2RlOiBmdW5jdGlvbihpbXBvcnROb2RlLCBjb250ZXh0LCBpbXBvcnRQYXJlbnQpIHtcbiAgICAgICAgdmFyIGV2YWxkSW1wb3J0Tm9kZSxcbiAgICAgICAgICAgIGlubGluZUNTUyA9IGltcG9ydE5vZGUub3B0aW9ucy5pbmxpbmU7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGV2YWxkSW1wb3J0Tm9kZSA9IGltcG9ydE5vZGUuZXZhbEZvckltcG9ydChjb250ZXh0KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKCFlLmZpbGVuYW1lKSB7IGUuaW5kZXggPSBpbXBvcnROb2RlLmdldEluZGV4KCk7IGUuZmlsZW5hbWUgPSBpbXBvcnROb2RlLmZpbGVJbmZvKCkuZmlsZW5hbWU7IH1cbiAgICAgICAgICAgIC8vIGF0dGVtcHQgdG8gZXZhbCBwcm9wZXJseSBhbmQgdHJlYXQgYXMgY3NzXG4gICAgICAgICAgICBpbXBvcnROb2RlLmNzcyA9IHRydWU7XG4gICAgICAgICAgICAvLyBpZiB0aGF0IGZhaWxzLCB0aGlzIGVycm9yIHdpbGwgYmUgdGhyb3duXG4gICAgICAgICAgICBpbXBvcnROb2RlLmVycm9yID0gZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChldmFsZEltcG9ydE5vZGUgJiYgKCFldmFsZEltcG9ydE5vZGUuY3NzIHx8IGlubGluZUNTUykpIHtcblxuICAgICAgICAgICAgaWYgKGV2YWxkSW1wb3J0Tm9kZS5vcHRpb25zLm11bHRpcGxlKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5pbXBvcnRNdWx0aXBsZSA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHRyeSBhcHBlbmRpbmcgaWYgd2UgaGF2ZW4ndCBkZXRlcm1pbmVkIGlmIGl0IGlzIGNzcyBvciBub3RcbiAgICAgICAgICAgIHZhciB0cnlBcHBlbmRMZXNzRXh0ZW5zaW9uID0gZXZhbGRJbXBvcnROb2RlLmNzcyA9PT0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGltcG9ydFBhcmVudC5ydWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpbXBvcnRQYXJlbnQucnVsZXNbaV0gPT09IGltcG9ydE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaW1wb3J0UGFyZW50LnJ1bGVzW2ldID0gZXZhbGRJbXBvcnROb2RlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBvbkltcG9ydGVkID0gdGhpcy5vbkltcG9ydGVkLmJpbmQodGhpcywgZXZhbGRJbXBvcnROb2RlLCBjb250ZXh0KSxcbiAgICAgICAgICAgICAgICBzZXF1ZW5jZWRPbkltcG9ydGVkID0gdGhpcy5fc2VxdWVuY2VyLmFkZEltcG9ydChvbkltcG9ydGVkKTtcblxuICAgICAgICAgICAgdGhpcy5faW1wb3J0ZXIucHVzaChldmFsZEltcG9ydE5vZGUuZ2V0UGF0aCgpLCB0cnlBcHBlbmRMZXNzRXh0ZW5zaW9uLCBldmFsZEltcG9ydE5vZGUuZmlsZUluZm8oKSxcbiAgICAgICAgICAgICAgICBldmFsZEltcG9ydE5vZGUub3B0aW9ucywgc2VxdWVuY2VkT25JbXBvcnRlZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmltcG9ydENvdW50LS07XG4gICAgICAgICAgICBpZiAodGhpcy5pc0ZpbmlzaGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2VxdWVuY2VyLnRyeVJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBvbkltcG9ydGVkOiBmdW5jdGlvbiAoaW1wb3J0Tm9kZSwgY29udGV4dCwgZSwgcm9vdCwgaW1wb3J0ZWRBdFJvb3QsIGZ1bGxQYXRoKSB7XG4gICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICBpZiAoIWUuZmlsZW5hbWUpIHtcbiAgICAgICAgICAgICAgICBlLmluZGV4ID0gaW1wb3J0Tm9kZS5nZXRJbmRleCgpOyBlLmZpbGVuYW1lID0gaW1wb3J0Tm9kZS5maWxlSW5mbygpLmZpbGVuYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5lcnJvciA9IGU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaW1wb3J0VmlzaXRvciA9IHRoaXMsXG4gICAgICAgICAgICBpbmxpbmVDU1MgPSBpbXBvcnROb2RlLm9wdGlvbnMuaW5saW5lLFxuICAgICAgICAgICAgaXNQbHVnaW4gPSBpbXBvcnROb2RlLm9wdGlvbnMuaXNQbHVnaW4sXG4gICAgICAgICAgICBpc09wdGlvbmFsID0gaW1wb3J0Tm9kZS5vcHRpb25zLm9wdGlvbmFsLFxuICAgICAgICAgICAgZHVwbGljYXRlSW1wb3J0ID0gaW1wb3J0ZWRBdFJvb3QgfHwgZnVsbFBhdGggaW4gaW1wb3J0VmlzaXRvci5yZWN1cnNpb25EZXRlY3RvcjtcblxuICAgICAgICBpZiAoIWNvbnRleHQuaW1wb3J0TXVsdGlwbGUpIHtcbiAgICAgICAgICAgIGlmIChkdXBsaWNhdGVJbXBvcnQpIHtcbiAgICAgICAgICAgICAgICBpbXBvcnROb2RlLnNraXAgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbXBvcnROb2RlLnNraXAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZ1bGxQYXRoIGluIGltcG9ydFZpc2l0b3Iub25jZUZpbGVEZXRlY3Rpb25NYXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGltcG9ydFZpc2l0b3Iub25jZUZpbGVEZXRlY3Rpb25NYXBbZnVsbFBhdGhdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWZ1bGxQYXRoICYmIGlzT3B0aW9uYWwpIHtcbiAgICAgICAgICAgIGltcG9ydE5vZGUuc2tpcCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocm9vdCkge1xuICAgICAgICAgICAgaW1wb3J0Tm9kZS5yb290ID0gcm9vdDtcbiAgICAgICAgICAgIGltcG9ydE5vZGUuaW1wb3J0ZWRGaWxlbmFtZSA9IGZ1bGxQYXRoO1xuXG4gICAgICAgICAgICBpZiAoIWlubGluZUNTUyAmJiAhaXNQbHVnaW4gJiYgKGNvbnRleHQuaW1wb3J0TXVsdGlwbGUgfHwgIWR1cGxpY2F0ZUltcG9ydCkpIHtcbiAgICAgICAgICAgICAgICBpbXBvcnRWaXNpdG9yLnJlY3Vyc2lvbkRldGVjdG9yW2Z1bGxQYXRoXSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICB2YXIgb2xkQ29udGV4dCA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Zpc2l0b3IudmlzaXQocm9vdCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yID0gZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0ID0gb2xkQ29udGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGltcG9ydFZpc2l0b3IuaW1wb3J0Q291bnQtLTtcblxuICAgICAgICBpZiAoaW1wb3J0VmlzaXRvci5pc0ZpbmlzaGVkKSB7XG4gICAgICAgICAgICBpbXBvcnRWaXNpdG9yLl9zZXF1ZW5jZXIudHJ5UnVuKCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHZpc2l0RGVjbGFyYXRpb246IGZ1bmN0aW9uIChkZWNsTm9kZSwgdmlzaXRBcmdzKSB7XG4gICAgICAgIGlmIChkZWNsTm9kZS52YWx1ZS50eXBlID09PSAnRGV0YWNoZWRSdWxlc2V0Jykge1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmZyYW1lcy51bnNoaWZ0KGRlY2xOb2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZpc2l0QXJncy52aXNpdERlZXBlciA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfSxcbiAgICB2aXNpdERlY2xhcmF0aW9uT3V0OiBmdW5jdGlvbihkZWNsTm9kZSkge1xuICAgICAgICBpZiAoZGVjbE5vZGUudmFsdWUudHlwZSA9PT0gJ0RldGFjaGVkUnVsZXNldCcpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5mcmFtZXMuc2hpZnQoKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgdmlzaXRBdFJ1bGU6IGZ1bmN0aW9uIChhdFJ1bGVOb2RlLCB2aXNpdEFyZ3MpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0LmZyYW1lcy51bnNoaWZ0KGF0UnVsZU5vZGUpO1xuICAgIH0sXG4gICAgdmlzaXRBdFJ1bGVPdXQ6IGZ1bmN0aW9uIChhdFJ1bGVOb2RlKSB7XG4gICAgICAgIHRoaXMuY29udGV4dC5mcmFtZXMuc2hpZnQoKTtcbiAgICB9LFxuICAgIHZpc2l0TWl4aW5EZWZpbml0aW9uOiBmdW5jdGlvbiAobWl4aW5EZWZpbml0aW9uTm9kZSwgdmlzaXRBcmdzKSB7XG4gICAgICAgIHRoaXMuY29udGV4dC5mcmFtZXMudW5zaGlmdChtaXhpbkRlZmluaXRpb25Ob2RlKTtcbiAgICB9LFxuICAgIHZpc2l0TWl4aW5EZWZpbml0aW9uT3V0OiBmdW5jdGlvbiAobWl4aW5EZWZpbml0aW9uTm9kZSkge1xuICAgICAgICB0aGlzLmNvbnRleHQuZnJhbWVzLnNoaWZ0KCk7XG4gICAgfSxcbiAgICB2aXNpdFJ1bGVzZXQ6IGZ1bmN0aW9uIChydWxlc2V0Tm9kZSwgdmlzaXRBcmdzKSB7XG4gICAgICAgIHRoaXMuY29udGV4dC5mcmFtZXMudW5zaGlmdChydWxlc2V0Tm9kZSk7XG4gICAgfSxcbiAgICB2aXNpdFJ1bGVzZXRPdXQ6IGZ1bmN0aW9uIChydWxlc2V0Tm9kZSkge1xuICAgICAgICB0aGlzLmNvbnRleHQuZnJhbWVzLnNoaWZ0KCk7XG4gICAgfSxcbiAgICB2aXNpdE1lZGlhOiBmdW5jdGlvbiAobWVkaWFOb2RlLCB2aXNpdEFyZ3MpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0LmZyYW1lcy51bnNoaWZ0KG1lZGlhTm9kZS5ydWxlc1swXSk7XG4gICAgfSxcbiAgICB2aXNpdE1lZGlhT3V0OiBmdW5jdGlvbiAobWVkaWFOb2RlKSB7XG4gICAgICAgIHRoaXMuY29udGV4dC5mcmFtZXMuc2hpZnQoKTtcbiAgICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBJbXBvcnRWaXNpdG9yO1xuXG59LHtcIi4uL2NvbnRleHRzXCI6MTMsXCIuLi91dGlsc1wiOjg5LFwiLi9pbXBvcnQtc2VxdWVuY2VyXCI6OTEsXCIuL3Zpc2l0b3JcIjo5N31dLDkzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciB2aXNpdG9ycyA9IHtcbiAgICBWaXNpdG9yOiByZXF1aXJlKCcuL3Zpc2l0b3InKSxcbiAgICBJbXBvcnRWaXNpdG9yOiByZXF1aXJlKCcuL2ltcG9ydC12aXNpdG9yJyksXG4gICAgTWFya1Zpc2libGVTZWxlY3RvcnNWaXNpdG9yOiByZXF1aXJlKCcuL3NldC10cmVlLXZpc2liaWxpdHktdmlzaXRvcicpLFxuICAgIEV4dGVuZFZpc2l0b3I6IHJlcXVpcmUoJy4vZXh0ZW5kLXZpc2l0b3InKSxcbiAgICBKb2luU2VsZWN0b3JWaXNpdG9yOiByZXF1aXJlKCcuL2pvaW4tc2VsZWN0b3ItdmlzaXRvcicpLFxuICAgIFRvQ1NTVmlzaXRvcjogcmVxdWlyZSgnLi90by1jc3MtdmlzaXRvcicpXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHZpc2l0b3JzO1xuXG59LHtcIi4vZXh0ZW5kLXZpc2l0b3JcIjo5MCxcIi4vaW1wb3J0LXZpc2l0b3JcIjo5MixcIi4vam9pbi1zZWxlY3Rvci12aXNpdG9yXCI6OTQsXCIuL3NldC10cmVlLXZpc2liaWxpdHktdmlzaXRvclwiOjk1LFwiLi90by1jc3MtdmlzaXRvclwiOjk2LFwiLi92aXNpdG9yXCI6OTd9XSw5NDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgVmlzaXRvciA9IHJlcXVpcmUoJy4vdmlzaXRvcicpO1xuXG52YXIgSm9pblNlbGVjdG9yVmlzaXRvciA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY29udGV4dHMgPSBbW11dO1xuICAgIHRoaXMuX3Zpc2l0b3IgPSBuZXcgVmlzaXRvcih0aGlzKTtcbn07XG5cbkpvaW5TZWxlY3RvclZpc2l0b3IucHJvdG90eXBlID0ge1xuICAgIHJ1bjogZnVuY3Rpb24gKHJvb3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2l0b3IudmlzaXQocm9vdCk7XG4gICAgfSxcbiAgICB2aXNpdERlY2xhcmF0aW9uOiBmdW5jdGlvbiAoZGVjbE5vZGUsIHZpc2l0QXJncykge1xuICAgICAgICB2aXNpdEFyZ3MudmlzaXREZWVwZXIgPSBmYWxzZTtcbiAgICB9LFxuICAgIHZpc2l0TWl4aW5EZWZpbml0aW9uOiBmdW5jdGlvbiAobWl4aW5EZWZpbml0aW9uTm9kZSwgdmlzaXRBcmdzKSB7XG4gICAgICAgIHZpc2l0QXJncy52aXNpdERlZXBlciA9IGZhbHNlO1xuICAgIH0sXG5cbiAgICB2aXNpdFJ1bGVzZXQ6IGZ1bmN0aW9uIChydWxlc2V0Tm9kZSwgdmlzaXRBcmdzKSB7XG4gICAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0c1t0aGlzLmNvbnRleHRzLmxlbmd0aCAtIDFdLFxuICAgICAgICAgICAgcGF0aHMgPSBbXSwgc2VsZWN0b3JzO1xuXG4gICAgICAgIHRoaXMuY29udGV4dHMucHVzaChwYXRocyk7XG5cbiAgICAgICAgaWYgKCFydWxlc2V0Tm9kZS5yb290KSB7XG4gICAgICAgICAgICBzZWxlY3RvcnMgPSBydWxlc2V0Tm9kZS5zZWxlY3RvcnM7XG4gICAgICAgICAgICBpZiAoc2VsZWN0b3JzKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3JzID0gc2VsZWN0b3JzLmZpbHRlcihmdW5jdGlvbihzZWxlY3RvcikgeyByZXR1cm4gc2VsZWN0b3IuZ2V0SXNPdXRwdXQoKTsgfSk7XG4gICAgICAgICAgICAgICAgcnVsZXNldE5vZGUuc2VsZWN0b3JzID0gc2VsZWN0b3JzLmxlbmd0aCA/IHNlbGVjdG9ycyA6IChzZWxlY3RvcnMgPSBudWxsKTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0b3JzKSB7IHJ1bGVzZXROb2RlLmpvaW5TZWxlY3RvcnMocGF0aHMsIGNvbnRleHQsIHNlbGVjdG9ycyk7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc2VsZWN0b3JzKSB7IHJ1bGVzZXROb2RlLnJ1bGVzID0gbnVsbDsgfVxuICAgICAgICAgICAgcnVsZXNldE5vZGUucGF0aHMgPSBwYXRocztcbiAgICAgICAgfVxuICAgIH0sXG4gICAgdmlzaXRSdWxlc2V0T3V0OiBmdW5jdGlvbiAocnVsZXNldE5vZGUpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0cy5sZW5ndGggPSB0aGlzLmNvbnRleHRzLmxlbmd0aCAtIDE7XG4gICAgfSxcbiAgICB2aXNpdE1lZGlhOiBmdW5jdGlvbiAobWVkaWFOb2RlLCB2aXNpdEFyZ3MpIHtcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHRzW3RoaXMuY29udGV4dHMubGVuZ3RoIC0gMV07XG4gICAgICAgIG1lZGlhTm9kZS5ydWxlc1swXS5yb290ID0gKGNvbnRleHQubGVuZ3RoID09PSAwIHx8IGNvbnRleHRbMF0ubXVsdGlNZWRpYSk7XG4gICAgfSxcbiAgICB2aXNpdEF0UnVsZTogZnVuY3Rpb24gKGF0UnVsZU5vZGUsIHZpc2l0QXJncykge1xuICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dHNbdGhpcy5jb250ZXh0cy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKGF0UnVsZU5vZGUucnVsZXMgJiYgYXRSdWxlTm9kZS5ydWxlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGF0UnVsZU5vZGUucnVsZXNbMF0ucm9vdCA9IChhdFJ1bGVOb2RlLmlzUm9vdGVkIHx8IGNvbnRleHQubGVuZ3RoID09PSAwIHx8IG51bGwpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBKb2luU2VsZWN0b3JWaXNpdG9yO1xuXG59LHtcIi4vdmlzaXRvclwiOjk3fV0sOTU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIFNldFRyZWVWaXNpYmlsaXR5VmlzaXRvciA9IGZ1bmN0aW9uKHZpc2libGUpIHtcbiAgICB0aGlzLnZpc2libGUgPSB2aXNpYmxlO1xufTtcblNldFRyZWVWaXNpYmlsaXR5VmlzaXRvci5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24ocm9vdCkge1xuICAgIHRoaXMudmlzaXQocm9vdCk7XG59O1xuU2V0VHJlZVZpc2liaWxpdHlWaXNpdG9yLnByb3RvdHlwZS52aXNpdEFycmF5ID0gZnVuY3Rpb24obm9kZXMpIHtcbiAgICBpZiAoIW5vZGVzKSB7XG4gICAgICAgIHJldHVybiBub2RlcztcbiAgICB9XG5cbiAgICB2YXIgY250ID0gbm9kZXMubGVuZ3RoLCBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBjbnQ7IGkrKykge1xuICAgICAgICB0aGlzLnZpc2l0KG5vZGVzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGVzO1xufTtcblNldFRyZWVWaXNpYmlsaXR5VmlzaXRvci5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgaWYgKCFub2RlKSB7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICBpZiAobm9kZS5jb25zdHJ1Y3RvciA9PT0gQXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRBcnJheShub2RlKTtcbiAgICB9XG5cbiAgICBpZiAoIW5vZGUuYmxvY2tzVmlzaWJpbGl0eSB8fCBub2RlLmJsb2Nrc1Zpc2liaWxpdHkoKSkge1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgaWYgKHRoaXMudmlzaWJsZSkge1xuICAgICAgICBub2RlLmVuc3VyZVZpc2liaWxpdHkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLmVuc3VyZUludmlzaWJpbGl0eSgpO1xuICAgIH1cblxuICAgIG5vZGUuYWNjZXB0KHRoaXMpO1xuICAgIHJldHVybiBub2RlO1xufTtcbm1vZHVsZS5leHBvcnRzID0gU2V0VHJlZVZpc2liaWxpdHlWaXNpdG9yO1xufSx7fV0sOTY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIHRyZWUgPSByZXF1aXJlKCcuLi90cmVlJyksXG4gICAgVmlzaXRvciA9IHJlcXVpcmUoJy4vdmlzaXRvcicpO1xuXG52YXIgQ1NTVmlzaXRvclV0aWxzID0gZnVuY3Rpb24oY29udGV4dCkge1xuICAgIHRoaXMuX3Zpc2l0b3IgPSBuZXcgVmlzaXRvcih0aGlzKTtcbiAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbn07XG5cbkNTU1Zpc2l0b3JVdGlscy5wcm90b3R5cGUgPSB7XG4gICAgY29udGFpbnNTaWxlbnROb25CbG9ja2VkQ2hpbGQ6IGZ1bmN0aW9uKGJvZHlSdWxlcykge1xuICAgICAgICB2YXIgcnVsZTtcbiAgICAgICAgaWYgKCFib2R5UnVsZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciByID0gMDsgciA8IGJvZHlSdWxlcy5sZW5ndGg7IHIrKykge1xuICAgICAgICAgICAgcnVsZSA9IGJvZHlSdWxlc1tyXTtcbiAgICAgICAgICAgIGlmIChydWxlLmlzU2lsZW50ICYmIHJ1bGUuaXNTaWxlbnQodGhpcy5fY29udGV4dCkgJiYgIXJ1bGUuYmxvY2tzVmlzaWJpbGl0eSgpKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhlIGF0cnVsZSBjb250YWlucyBzb21ldGhpbmcgdGhhdCB3YXMgcmVmZXJlbmNlZCAobGlrZWx5IGJ5IGV4dGVuZClcbiAgICAgICAgICAgICAgICAvLyB0aGVyZWZvcmUgaXQgbmVlZHMgdG8gYmUgc2hvd24gaW4gb3V0cHV0IHRvb1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAga2VlcE9ubHlWaXNpYmxlQ2hpbGRzOiBmdW5jdGlvbihvd25lcikge1xuICAgICAgICBpZiAob3duZXIgJiYgb3duZXIucnVsZXMpIHtcbiAgICAgICAgICAgIG93bmVyLnJ1bGVzID0gb3duZXIucnVsZXMuZmlsdGVyKGZ1bmN0aW9uKHRoaW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaW5nLmlzVmlzaWJsZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgaXNFbXB0eTogZnVuY3Rpb24ob3duZXIpIHtcbiAgICAgICAgcmV0dXJuIChvd25lciAmJiBvd25lci5ydWxlcykgXG4gICAgICAgICAgICA/IChvd25lci5ydWxlcy5sZW5ndGggPT09IDApIDogdHJ1ZTtcbiAgICB9LFxuXG4gICAgaGFzVmlzaWJsZVNlbGVjdG9yOiBmdW5jdGlvbihydWxlc2V0Tm9kZSkge1xuICAgICAgICByZXR1cm4gKHJ1bGVzZXROb2RlICYmIHJ1bGVzZXROb2RlLnBhdGhzKVxuICAgICAgICAgICAgPyAocnVsZXNldE5vZGUucGF0aHMubGVuZ3RoID4gMCkgOiBmYWxzZTtcbiAgICB9LFxuXG4gICAgcmVzb2x2ZVZpc2liaWxpdHk6IGZ1bmN0aW9uIChub2RlLCBvcmlnaW5hbFJ1bGVzKSB7XG4gICAgICAgIGlmICghbm9kZS5ibG9ja3NWaXNpYmlsaXR5KCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzRW1wdHkobm9kZSkgJiYgIXRoaXMuY29udGFpbnNTaWxlbnROb25CbG9ja2VkQ2hpbGQob3JpZ2luYWxSdWxlcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb21waWxlZFJ1bGVzQm9keSA9IG5vZGUucnVsZXNbMF07XG4gICAgICAgIHRoaXMua2VlcE9ubHlWaXNpYmxlQ2hpbGRzKGNvbXBpbGVkUnVsZXNCb2R5KTtcblxuICAgICAgICBpZiAodGhpcy5pc0VtcHR5KGNvbXBpbGVkUnVsZXNCb2R5KSkge1xuICAgICAgICAgICAgcmV0dXJuIDtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUuZW5zdXJlVmlzaWJpbGl0eSgpO1xuICAgICAgICBub2RlLnJlbW92ZVZpc2liaWxpdHlCbG9jaygpO1xuXG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH0sXG5cbiAgICBpc1Zpc2libGVSdWxlc2V0OiBmdW5jdGlvbihydWxlc2V0Tm9kZSkge1xuICAgICAgICBpZiAocnVsZXNldE5vZGUuZmlyc3RSb290KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmlzRW1wdHkocnVsZXNldE5vZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXJ1bGVzZXROb2RlLnJvb3QgJiYgIXRoaXMuaGFzVmlzaWJsZVNlbGVjdG9yKHJ1bGVzZXROb2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG59O1xuXG52YXIgVG9DU1NWaXNpdG9yID0gZnVuY3Rpb24oY29udGV4dCkge1xuICAgIHRoaXMuX3Zpc2l0b3IgPSBuZXcgVmlzaXRvcih0aGlzKTtcbiAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLnV0aWxzID0gbmV3IENTU1Zpc2l0b3JVdGlscyhjb250ZXh0KTtcbn07XG5cblRvQ1NTVmlzaXRvci5wcm90b3R5cGUgPSB7XG4gICAgaXNSZXBsYWNpbmc6IHRydWUsXG4gICAgcnVuOiBmdW5jdGlvbiAocm9vdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmlzaXRvci52aXNpdChyb290KTtcbiAgICB9LFxuXG4gICAgdmlzaXREZWNsYXJhdGlvbjogZnVuY3Rpb24gKGRlY2xOb2RlLCB2aXNpdEFyZ3MpIHtcbiAgICAgICAgaWYgKGRlY2xOb2RlLmJsb2Nrc1Zpc2liaWxpdHkoKSB8fCBkZWNsTm9kZS52YXJpYWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWNsTm9kZTtcbiAgICB9LFxuXG4gICAgdmlzaXRNaXhpbkRlZmluaXRpb246IGZ1bmN0aW9uIChtaXhpbk5vZGUsIHZpc2l0QXJncykge1xuICAgICAgICAvLyBtaXhpbiBkZWZpbml0aW9ucyBkbyBub3QgZ2V0IGV2YWwnZCAtIHRoaXMgbWVhbnMgdGhleSBrZWVwIHN0YXRlXG4gICAgICAgIC8vIHNvIHdlIGhhdmUgdG8gY2xlYXIgdGhhdCBzdGF0ZSBoZXJlIHNvIGl0IGlzbid0IHVzZWQgaWYgdG9DU1MgaXMgY2FsbGVkIHR3aWNlXG4gICAgICAgIG1peGluTm9kZS5mcmFtZXMgPSBbXTtcbiAgICB9LFxuXG4gICAgdmlzaXRFeHRlbmQ6IGZ1bmN0aW9uIChleHRlbmROb2RlLCB2aXNpdEFyZ3MpIHtcbiAgICB9LFxuXG4gICAgdmlzaXRDb21tZW50OiBmdW5jdGlvbiAoY29tbWVudE5vZGUsIHZpc2l0QXJncykge1xuICAgICAgICBpZiAoY29tbWVudE5vZGUuYmxvY2tzVmlzaWJpbGl0eSgpIHx8IGNvbW1lbnROb2RlLmlzU2lsZW50KHRoaXMuX2NvbnRleHQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbW1lbnROb2RlO1xuICAgIH0sXG5cbiAgICB2aXNpdE1lZGlhOiBmdW5jdGlvbihtZWRpYU5vZGUsIHZpc2l0QXJncykge1xuICAgICAgICB2YXIgb3JpZ2luYWxSdWxlcyA9IG1lZGlhTm9kZS5ydWxlc1swXS5ydWxlcztcbiAgICAgICAgbWVkaWFOb2RlLmFjY2VwdCh0aGlzLl92aXNpdG9yKTtcbiAgICAgICAgdmlzaXRBcmdzLnZpc2l0RGVlcGVyID0gZmFsc2U7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMudXRpbHMucmVzb2x2ZVZpc2liaWxpdHkobWVkaWFOb2RlLCBvcmlnaW5hbFJ1bGVzKTtcbiAgICB9LFxuXG4gICAgdmlzaXRJbXBvcnQ6IGZ1bmN0aW9uIChpbXBvcnROb2RlLCB2aXNpdEFyZ3MpIHtcbiAgICAgICAgaWYgKGltcG9ydE5vZGUuYmxvY2tzVmlzaWJpbGl0eSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbXBvcnROb2RlO1xuICAgIH0sXG5cbiAgICB2aXNpdEF0UnVsZTogZnVuY3Rpb24oYXRSdWxlTm9kZSwgdmlzaXRBcmdzKSB7XG4gICAgICAgIGlmIChhdFJ1bGVOb2RlLnJ1bGVzICYmIGF0UnVsZU5vZGUucnVsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52aXNpdEF0UnVsZVdpdGhCb2R5KGF0UnVsZU5vZGUsIHZpc2l0QXJncyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52aXNpdEF0UnVsZVdpdGhvdXRCb2R5KGF0UnVsZU5vZGUsIHZpc2l0QXJncyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgdmlzaXRBbm9ueW1vdXM6IGZ1bmN0aW9uKGFub255bW91c05vZGUsIHZpc2l0QXJncykge1xuICAgICAgICBpZiAoIWFub255bW91c05vZGUuYmxvY2tzVmlzaWJpbGl0eSgpKSB7XG4gICAgICAgICAgICBhbm9ueW1vdXNOb2RlLmFjY2VwdCh0aGlzLl92aXNpdG9yKTtcbiAgICAgICAgICAgIHJldHVybiBhbm9ueW1vdXNOb2RlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHZpc2l0QXRSdWxlV2l0aEJvZHk6IGZ1bmN0aW9uKGF0UnVsZU5vZGUsIHZpc2l0QXJncykge1xuICAgICAgICAvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSBuZXN0ZWQgcnVsZXNldCBhbmQgdGhhdCBvbmUgaGFzIG5vIHBhdGgsIHRoZW4gaXQgaXNcbiAgICAgICAgLy8ganVzdCBmYWtlIHJ1bGVzZXRcbiAgICAgICAgZnVuY3Rpb24gaGFzRmFrZVJ1bGVzZXQoYXRSdWxlTm9kZSkge1xuICAgICAgICAgICAgdmFyIGJvZHlSdWxlcyA9IGF0UnVsZU5vZGUucnVsZXM7XG4gICAgICAgICAgICByZXR1cm4gYm9keVJ1bGVzLmxlbmd0aCA9PT0gMSAmJiAoIWJvZHlSdWxlc1swXS5wYXRocyB8fCBib2R5UnVsZXNbMF0ucGF0aHMubGVuZ3RoID09PSAwKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXRCb2R5UnVsZXMoYXRSdWxlTm9kZSkge1xuICAgICAgICAgICAgdmFyIG5vZGVSdWxlcyA9IGF0UnVsZU5vZGUucnVsZXM7XG4gICAgICAgICAgICBpZiAoaGFzRmFrZVJ1bGVzZXQoYXRSdWxlTm9kZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZVJ1bGVzWzBdLnJ1bGVzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbm9kZVJ1bGVzO1xuICAgICAgICB9XG4gICAgICAgIC8vIGl0IGlzIHN0aWxsIHRydWUgdGhhdCBpdCBpcyBvbmx5IG9uZSBydWxlc2V0IGluIGFycmF5XG4gICAgICAgIC8vIHRoaXMgaXMgbGFzdCBzdWNoIG1vbWVudFxuICAgICAgICAvLyBwcm9jZXNzIGNoaWxkc1xuICAgICAgICB2YXIgb3JpZ2luYWxSdWxlcyA9IGdldEJvZHlSdWxlcyhhdFJ1bGVOb2RlKTtcbiAgICAgICAgYXRSdWxlTm9kZS5hY2NlcHQodGhpcy5fdmlzaXRvcik7XG4gICAgICAgIHZpc2l0QXJncy52aXNpdERlZXBlciA9IGZhbHNlO1xuXG4gICAgICAgIGlmICghdGhpcy51dGlscy5pc0VtcHR5KGF0UnVsZU5vZGUpKSB7XG4gICAgICAgICAgICB0aGlzLl9tZXJnZVJ1bGVzKGF0UnVsZU5vZGUucnVsZXNbMF0ucnVsZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMudXRpbHMucmVzb2x2ZVZpc2liaWxpdHkoYXRSdWxlTm9kZSwgb3JpZ2luYWxSdWxlcyk7XG4gICAgfSxcblxuICAgIHZpc2l0QXRSdWxlV2l0aG91dEJvZHk6IGZ1bmN0aW9uKGF0UnVsZU5vZGUsIHZpc2l0QXJncykge1xuICAgICAgICBpZiAoYXRSdWxlTm9kZS5ibG9ja3NWaXNpYmlsaXR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhdFJ1bGVOb2RlLm5hbWUgPT09ICdAY2hhcnNldCcpIHtcbiAgICAgICAgICAgIC8vIE9ubHkgb3V0cHV0IHRoZSBkZWJ1ZyBpbmZvIHRvZ2V0aGVyIHdpdGggc3Vic2VxdWVudCBAY2hhcnNldCBkZWZpbml0aW9uc1xuICAgICAgICAgICAgLy8gYSBjb21tZW50IChvciBAbWVkaWEgc3RhdGVtZW50KSBiZWZvcmUgdGhlIGFjdHVhbCBAY2hhcnNldCBhdHJ1bGUgd291bGRcbiAgICAgICAgICAgIC8vIGJlIGNvbnNpZGVyZWQgaWxsZWdhbCBjc3MgYXMgaXQgaGFzIHRvIGJlIG9uIHRoZSBmaXJzdCBsaW5lXG4gICAgICAgICAgICBpZiAodGhpcy5jaGFyc2V0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGF0UnVsZU5vZGUuZGVidWdJbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb21tZW50ID0gbmV3IHRyZWUuQ29tbWVudCgnLyogJyArIGF0UnVsZU5vZGUudG9DU1ModGhpcy5fY29udGV4dCkucmVwbGFjZSgvXFxuL2csICcnKSArICcgKi9cXG4nKTtcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudC5kZWJ1Z0luZm8gPSBhdFJ1bGVOb2RlLmRlYnVnSW5mbztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2l0b3IudmlzaXQoY29tbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2hhcnNldCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXRSdWxlTm9kZTtcbiAgICB9LFxuXG4gICAgY2hlY2tWYWxpZE5vZGVzOiBmdW5jdGlvbihydWxlcywgaXNSb290KSB7XG4gICAgICAgIGlmICghcnVsZXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBydWxlTm9kZSA9IHJ1bGVzW2ldO1xuICAgICAgICAgICAgaWYgKGlzUm9vdCAmJiBydWxlTm9kZSBpbnN0YW5jZW9mIHRyZWUuRGVjbGFyYXRpb24gJiYgIXJ1bGVOb2RlLnZhcmlhYmxlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgeyBtZXNzYWdlOiAnUHJvcGVydGllcyBtdXN0IGJlIGluc2lkZSBzZWxlY3RvciBibG9ja3MuIFRoZXkgY2Fubm90IGJlIGluIHRoZSByb290JyxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IHJ1bGVOb2RlLmdldEluZGV4KCksIGZpbGVuYW1lOiBydWxlTm9kZS5maWxlSW5mbygpICYmIHJ1bGVOb2RlLmZpbGVJbmZvKCkuZmlsZW5hbWV9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJ1bGVOb2RlIGluc3RhbmNlb2YgdHJlZS5DYWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgeyBtZXNzYWdlOiAnRnVuY3Rpb24gXFwnJyArIHJ1bGVOb2RlLm5hbWUgKyAnXFwnIGlzIHVuZGVmaW5lZCcsXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBydWxlTm9kZS5nZXRJbmRleCgpLCBmaWxlbmFtZTogcnVsZU5vZGUuZmlsZUluZm8oKSAmJiBydWxlTm9kZS5maWxlSW5mbygpLmZpbGVuYW1lfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChydWxlTm9kZS50eXBlICYmICFydWxlTm9kZS5hbGxvd1Jvb3QpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB7IG1lc3NhZ2U6IHJ1bGVOb2RlLnR5cGUgKyAnIG5vZGUgcmV0dXJuZWQgYnkgYSBmdW5jdGlvbiBpcyBub3QgdmFsaWQgaGVyZScsXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBydWxlTm9kZS5nZXRJbmRleCgpLCBmaWxlbmFtZTogcnVsZU5vZGUuZmlsZUluZm8oKSAmJiBydWxlTm9kZS5maWxlSW5mbygpLmZpbGVuYW1lfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB2aXNpdFJ1bGVzZXQ6IGZ1bmN0aW9uIChydWxlc2V0Tm9kZSwgdmlzaXRBcmdzKSB7XG4gICAgICAgIC8vIGF0IHRoaXMgcG9pbnQgcnVsZXNldHMgYXJlIG5lc3RlZCBpbnRvIGVhY2ggb3RoZXJcbiAgICAgICAgdmFyIHJ1bGUsIHJ1bGVzZXRzID0gW107XG5cbiAgICAgICAgdGhpcy5jaGVja1ZhbGlkTm9kZXMocnVsZXNldE5vZGUucnVsZXMsIHJ1bGVzZXROb2RlLmZpcnN0Um9vdCk7XG5cbiAgICAgICAgaWYgKCFydWxlc2V0Tm9kZS5yb290KSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgaW52aXNpYmxlIHBhdGhzXG4gICAgICAgICAgICB0aGlzLl9jb21waWxlUnVsZXNldFBhdGhzKHJ1bGVzZXROb2RlKTtcblxuICAgICAgICAgICAgLy8gcmVtb3ZlIHJ1bGVzZXRzIGZyb20gdGhpcyBydWxlc2V0IGJvZHkgYW5kIGNvbXBpbGUgdGhlbSBzZXBhcmF0ZWx5XG4gICAgICAgICAgICB2YXIgbm9kZVJ1bGVzID0gcnVsZXNldE5vZGUucnVsZXMsIG5vZGVSdWxlQ250ID0gbm9kZVJ1bGVzID8gbm9kZVJ1bGVzLmxlbmd0aCA6IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVSdWxlQ250OyApIHtcbiAgICAgICAgICAgICAgICBydWxlID0gbm9kZVJ1bGVzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChydWxlICYmIHJ1bGUucnVsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdmlzaXQgYmVjYXVzZSB3ZSBhcmUgbW92aW5nIHRoZW0gb3V0IGZyb20gYmVpbmcgYSBjaGlsZFxuICAgICAgICAgICAgICAgICAgICBydWxlc2V0cy5wdXNoKHRoaXMuX3Zpc2l0b3IudmlzaXQocnVsZSkpO1xuICAgICAgICAgICAgICAgICAgICBub2RlUnVsZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICBub2RlUnVsZUNudC0tO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYWNjZXB0IHRoZSB2aXNpdG9yIHRvIHJlbW92ZSBydWxlcyBhbmQgcmVmYWN0b3IgaXRzZWxmXG4gICAgICAgICAgICAvLyB0aGVuIHdlIGNhbiBkZWNpZGUgbm9ndyB3aGV0aGVyIHdlIHdhbnQgaXQgb3Igbm90XG4gICAgICAgICAgICAvLyBjb21waWxlIGJvZHlcbiAgICAgICAgICAgIGlmIChub2RlUnVsZUNudCA+IDApIHtcbiAgICAgICAgICAgICAgICBydWxlc2V0Tm9kZS5hY2NlcHQodGhpcy5fdmlzaXRvcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJ1bGVzZXROb2RlLnJ1bGVzID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZpc2l0QXJncy52aXNpdERlZXBlciA9IGZhbHNlO1xuXG4gICAgICAgIH0gZWxzZSB7IC8vIGlmICghIHJ1bGVzZXROb2RlLnJvb3QpIHtcbiAgICAgICAgICAgIHJ1bGVzZXROb2RlLmFjY2VwdCh0aGlzLl92aXNpdG9yKTtcbiAgICAgICAgICAgIHZpc2l0QXJncy52aXNpdERlZXBlciA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJ1bGVzZXROb2RlLnJ1bGVzKSB7XG4gICAgICAgICAgICB0aGlzLl9tZXJnZVJ1bGVzKHJ1bGVzZXROb2RlLnJ1bGVzKTtcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZUR1cGxpY2F0ZVJ1bGVzKHJ1bGVzZXROb2RlLnJ1bGVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG5vdyBkZWNpZGUgd2hldGhlciB3ZSBrZWVwIHRoZSBydWxlc2V0XG4gICAgICAgIGlmICh0aGlzLnV0aWxzLmlzVmlzaWJsZVJ1bGVzZXQocnVsZXNldE5vZGUpKSB7XG4gICAgICAgICAgICBydWxlc2V0Tm9kZS5lbnN1cmVWaXNpYmlsaXR5KCk7XG4gICAgICAgICAgICBydWxlc2V0cy5zcGxpY2UoMCwgMCwgcnVsZXNldE5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJ1bGVzZXRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHJ1bGVzZXRzWzBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBydWxlc2V0cztcbiAgICB9LFxuXG4gICAgX2NvbXBpbGVSdWxlc2V0UGF0aHM6IGZ1bmN0aW9uKHJ1bGVzZXROb2RlKSB7XG4gICAgICAgIGlmIChydWxlc2V0Tm9kZS5wYXRocykge1xuICAgICAgICAgICAgcnVsZXNldE5vZGUucGF0aHMgPSBydWxlc2V0Tm9kZS5wYXRoc1xuICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBbMF0uZWxlbWVudHNbMF0uY29tYmluYXRvci52YWx1ZSA9PT0gJyAnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwWzBdLmVsZW1lbnRzWzBdLmNvbWJpbmF0b3IgPSBuZXcodHJlZS5Db21iaW5hdG9yKSgnJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwW2ldLmlzVmlzaWJsZSgpICYmIHBbaV0uZ2V0SXNPdXRwdXQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfcmVtb3ZlRHVwbGljYXRlUnVsZXM6IGZ1bmN0aW9uKHJ1bGVzKSB7XG4gICAgICAgIGlmICghcnVsZXMpIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgLy8gcmVtb3ZlIGR1cGxpY2F0ZXNcbiAgICAgICAgdmFyIHJ1bGVDYWNoZSA9IHt9LFxuICAgICAgICAgICAgcnVsZUxpc3QsIHJ1bGUsIGk7XG5cbiAgICAgICAgZm9yIChpID0gcnVsZXMubGVuZ3RoIC0gMTsgaSA+PSAwIDsgaS0tKSB7XG4gICAgICAgICAgICBydWxlID0gcnVsZXNbaV07XG4gICAgICAgICAgICBpZiAocnVsZSBpbnN0YW5jZW9mIHRyZWUuRGVjbGFyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJ1bGVDYWNoZVtydWxlLm5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bGVDYWNoZVtydWxlLm5hbWVdID0gcnVsZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBydWxlTGlzdCA9IHJ1bGVDYWNoZVtydWxlLm5hbWVdO1xuICAgICAgICAgICAgICAgICAgICBpZiAocnVsZUxpc3QgaW5zdGFuY2VvZiB0cmVlLkRlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlTGlzdCA9IHJ1bGVDYWNoZVtydWxlLm5hbWVdID0gW3J1bGVDYWNoZVtydWxlLm5hbWVdLnRvQ1NTKHRoaXMuX2NvbnRleHQpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgcnVsZUNTUyA9IHJ1bGUudG9DU1ModGhpcy5fY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChydWxlTGlzdC5pbmRleE9mKHJ1bGVDU1MpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZUxpc3QucHVzaChydWxlQ1NTKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfbWVyZ2VSdWxlczogZnVuY3Rpb24ocnVsZXMpIHtcbiAgICAgICAgaWYgKCFydWxlcykge1xuICAgICAgICAgICAgcmV0dXJuOyBcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBncm91cHMgICAgPSB7fSxcbiAgICAgICAgICAgIGdyb3Vwc0FyciA9IFtdO1xuICAgICAgICBcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBydWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHJ1bGUgPSBydWxlc1tpXTtcbiAgICAgICAgICAgIGlmIChydWxlLm1lcmdlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IHJ1bGUubmFtZTtcbiAgICAgICAgICAgICAgICBncm91cHNba2V5XSA/IHJ1bGVzLnNwbGljZShpLS0sIDEpIDogXG4gICAgICAgICAgICAgICAgICAgIGdyb3Vwc0Fyci5wdXNoKGdyb3Vwc1trZXldID0gW10pO1xuICAgICAgICAgICAgICAgIGdyb3Vwc1trZXldLnB1c2gocnVsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBncm91cHNBcnIuZm9yRWFjaChmdW5jdGlvbihncm91cCkge1xuICAgICAgICAgICAgaWYgKGdyb3VwLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gZ3JvdXBbMF0sXG4gICAgICAgICAgICAgICAgICAgIHNwYWNlICA9IFtdLFxuICAgICAgICAgICAgICAgICAgICBjb21tYSAgPSBbbmV3IHRyZWUuRXhwcmVzc2lvbihzcGFjZSldO1xuICAgICAgICAgICAgICAgIGdyb3VwLmZvckVhY2goZnVuY3Rpb24ocnVsZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHJ1bGUubWVyZ2UgPT09ICcrJykgJiYgKHNwYWNlLmxlbmd0aCA+IDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tYS5wdXNoKG5ldyB0cmVlLkV4cHJlc3Npb24oc3BhY2UgPSBbXSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNwYWNlLnB1c2gocnVsZS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5pbXBvcnRhbnQgPSByZXN1bHQuaW1wb3J0YW50IHx8IHJ1bGUuaW1wb3J0YW50O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IG5ldyB0cmVlLlZhbHVlKGNvbW1hKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBUb0NTU1Zpc2l0b3I7XG5cbn0se1wiLi4vdHJlZVwiOjY3LFwiLi92aXNpdG9yXCI6OTd9XSw5NzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgdHJlZSA9IHJlcXVpcmUoJy4uL3RyZWUnKTtcblxudmFyIF92aXNpdEFyZ3MgPSB7IHZpc2l0RGVlcGVyOiB0cnVlIH0sXG4gICAgX2hhc0luZGV4ZWQgPSBmYWxzZTtcblxuZnVuY3Rpb24gX25vb3Aobm9kZSkge1xuICAgIHJldHVybiBub2RlO1xufVxuXG5mdW5jdGlvbiBpbmRleE5vZGVUeXBlcyhwYXJlbnQsIHRpY2tlcikge1xuICAgIC8vIGFkZCAudHlwZUluZGV4IHRvIHRyZWUgbm9kZSB0eXBlcyBmb3IgbG9va3VwIHRhYmxlXG4gICAgdmFyIGtleSwgY2hpbGQ7XG4gICAgZm9yIChrZXkgaW4gcGFyZW50KSB7IFxuICAgICAgICAvKiBlc2xpbnQgZ3VhcmQtZm9yLWluOiAwICovXG4gICAgICAgIGNoaWxkID0gcGFyZW50W2tleV07XG4gICAgICAgIHN3aXRjaCAodHlwZW9mIGNoaWxkKSB7XG4gICAgICAgICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgICAgICAgICAgLy8gaWdub3JlIGJvdW5kIGZ1bmN0aW9ucyBkaXJlY3RseSBvbiB0cmVlIHdoaWNoIGRvIG5vdCBoYXZlIGEgcHJvdG90eXBlXG4gICAgICAgICAgICAgICAgLy8gb3IgYXJlbid0IG5vZGVzXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLnByb3RvdHlwZSAmJiBjaGlsZC5wcm90b3R5cGUudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZC5wcm90b3R5cGUudHlwZUluZGV4ID0gdGlja2VyKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICB0aWNrZXIgPSBpbmRleE5vZGVUeXBlcyhjaGlsZCwgdGlja2VyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgXG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRpY2tlcjtcbn1cblxudmFyIFZpc2l0b3IgPSBmdW5jdGlvbihpbXBsZW1lbnRhdGlvbikge1xuICAgIHRoaXMuX2ltcGxlbWVudGF0aW9uID0gaW1wbGVtZW50YXRpb247XG4gICAgdGhpcy5fdmlzaXRJbkNhY2hlID0ge307XG4gICAgdGhpcy5fdmlzaXRPdXRDYWNoZSA9IHt9O1xuXG4gICAgaWYgKCFfaGFzSW5kZXhlZCkge1xuICAgICAgICBpbmRleE5vZGVUeXBlcyh0cmVlLCAxKTtcbiAgICAgICAgX2hhc0luZGV4ZWQgPSB0cnVlO1xuICAgIH1cbn07XG5cblZpc2l0b3IucHJvdG90eXBlID0ge1xuICAgIHZpc2l0OiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbm9kZVR5cGVJbmRleCA9IG5vZGUudHlwZUluZGV4O1xuICAgICAgICBpZiAoIW5vZGVUeXBlSW5kZXgpIHtcbiAgICAgICAgICAgIC8vIE1peGluQ2FsbCBhcmdzIGFyZW4ndCBhIG5vZGUgdHlwZT9cbiAgICAgICAgICAgIGlmIChub2RlLnZhbHVlICYmIG5vZGUudmFsdWUudHlwZUluZGV4KSB7XG4gICAgICAgICAgICAgICAgdGhpcy52aXNpdChub2RlLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGltcGwgPSB0aGlzLl9pbXBsZW1lbnRhdGlvbixcbiAgICAgICAgICAgIGZ1bmMgPSB0aGlzLl92aXNpdEluQ2FjaGVbbm9kZVR5cGVJbmRleF0sXG4gICAgICAgICAgICBmdW5jT3V0ID0gdGhpcy5fdmlzaXRPdXRDYWNoZVtub2RlVHlwZUluZGV4XSxcbiAgICAgICAgICAgIHZpc2l0QXJncyA9IF92aXNpdEFyZ3MsXG4gICAgICAgICAgICBmbk5hbWU7XG5cbiAgICAgICAgdmlzaXRBcmdzLnZpc2l0RGVlcGVyID0gdHJ1ZTtcblxuICAgICAgICBpZiAoIWZ1bmMpIHtcbiAgICAgICAgICAgIGZuTmFtZSA9ICd2aXNpdCcgKyBub2RlLnR5cGU7XG4gICAgICAgICAgICBmdW5jID0gaW1wbFtmbk5hbWVdIHx8IF9ub29wO1xuICAgICAgICAgICAgZnVuY091dCA9IGltcGxbZm5OYW1lICsgJ091dCddIHx8IF9ub29wO1xuICAgICAgICAgICAgdGhpcy5fdmlzaXRJbkNhY2hlW25vZGVUeXBlSW5kZXhdID0gZnVuYztcbiAgICAgICAgICAgIHRoaXMuX3Zpc2l0T3V0Q2FjaGVbbm9kZVR5cGVJbmRleF0gPSBmdW5jT3V0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZ1bmMgIT09IF9ub29wKSB7XG4gICAgICAgICAgICB2YXIgbmV3Tm9kZSA9IGZ1bmMuY2FsbChpbXBsLCBub2RlLCB2aXNpdEFyZ3MpO1xuICAgICAgICAgICAgaWYgKG5vZGUgJiYgaW1wbC5pc1JlcGxhY2luZykge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBuZXdOb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZpc2l0QXJncy52aXNpdERlZXBlciAmJiBub2RlICYmIG5vZGUuYWNjZXB0KSB7XG4gICAgICAgICAgICBub2RlLmFjY2VwdCh0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmdW5jT3V0ICE9IF9ub29wKSB7XG4gICAgICAgICAgICBmdW5jT3V0LmNhbGwoaW1wbCwgbm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9LFxuICAgIHZpc2l0QXJyYXk6IGZ1bmN0aW9uKG5vZGVzLCBub25SZXBsYWNpbmcpIHtcbiAgICAgICAgaWYgKCFub2Rlcykge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNudCA9IG5vZGVzLmxlbmd0aCwgaTtcblxuICAgICAgICAvLyBOb24tcmVwbGFjaW5nXG4gICAgICAgIGlmIChub25SZXBsYWNpbmcgfHwgIXRoaXMuX2ltcGxlbWVudGF0aW9uLmlzUmVwbGFjaW5nKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY250OyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZpc2l0KG5vZGVzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBub2RlcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlcGxhY2luZ1xuICAgICAgICB2YXIgb3V0ID0gW107XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjbnQ7IGkrKykge1xuICAgICAgICAgICAgdmFyIGV2YWxkID0gdGhpcy52aXNpdChub2Rlc1tpXSk7XG4gICAgICAgICAgICBpZiAoZXZhbGQgPT09IHVuZGVmaW5lZCkgeyBjb250aW51ZTsgfVxuICAgICAgICAgICAgaWYgKCFldmFsZC5zcGxpY2UpIHtcbiAgICAgICAgICAgICAgICBvdXQucHVzaChldmFsZCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGV2YWxkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmxhdHRlbihldmFsZCwgb3V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH0sXG4gICAgZmxhdHRlbjogZnVuY3Rpb24oYXJyLCBvdXQpIHtcbiAgICAgICAgaWYgKCFvdXQpIHtcbiAgICAgICAgICAgIG91dCA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNudCwgaSwgaXRlbSxcbiAgICAgICAgICAgIG5lc3RlZENudCwgaiwgbmVzdGVkSXRlbTtcblxuICAgICAgICBmb3IgKGkgPSAwLCBjbnQgPSBhcnIubGVuZ3RoOyBpIDwgY250OyBpKyspIHtcbiAgICAgICAgICAgIGl0ZW0gPSBhcnJbaV07XG4gICAgICAgICAgICBpZiAoaXRlbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWl0ZW0uc3BsaWNlKSB7XG4gICAgICAgICAgICAgICAgb3V0LnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoaiA9IDAsIG5lc3RlZENudCA9IGl0ZW0ubGVuZ3RoOyBqIDwgbmVzdGVkQ250OyBqKyspIHtcbiAgICAgICAgICAgICAgICBuZXN0ZWRJdGVtID0gaXRlbVtqXTtcbiAgICAgICAgICAgICAgICBpZiAobmVzdGVkSXRlbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIW5lc3RlZEl0ZW0uc3BsaWNlKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dC5wdXNoKG5lc3RlZEl0ZW0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobmVzdGVkSXRlbS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mbGF0dGVuKG5lc3RlZEl0ZW0sIG91dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBWaXNpdG9yO1xuXG59LHtcIi4uL3RyZWVcIjo2N31dLDk4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuXG4vLyByYXdBc2FwIHByb3ZpZGVzIGV2ZXJ5dGhpbmcgd2UgbmVlZCBleGNlcHQgZXhjZXB0aW9uIG1hbmFnZW1lbnQuXG52YXIgcmF3QXNhcCA9IHJlcXVpcmUoXCIuL3Jhd1wiKTtcbi8vIFJhd1Rhc2tzIGFyZSByZWN5Y2xlZCB0byByZWR1Y2UgR0MgY2h1cm4uXG52YXIgZnJlZVRhc2tzID0gW107XG4vLyBXZSBxdWV1ZSBlcnJvcnMgdG8gZW5zdXJlIHRoZXkgYXJlIHRocm93biBpbiByaWdodCBvcmRlciAoRklGTykuXG4vLyBBcnJheS1hcy1xdWV1ZSBpcyBnb29kIGVub3VnaCBoZXJlLCBzaW5jZSB3ZSBhcmUganVzdCBkZWFsaW5nIHdpdGggZXhjZXB0aW9ucy5cbnZhciBwZW5kaW5nRXJyb3JzID0gW107XG52YXIgcmVxdWVzdEVycm9yVGhyb3cgPSByYXdBc2FwLm1ha2VSZXF1ZXN0Q2FsbEZyb21UaW1lcih0aHJvd0ZpcnN0RXJyb3IpO1xuXG5mdW5jdGlvbiB0aHJvd0ZpcnN0RXJyb3IoKSB7XG4gICAgaWYgKHBlbmRpbmdFcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IHBlbmRpbmdFcnJvcnMuc2hpZnQoKTtcbiAgICB9XG59XG5cbi8qKlxuICogQ2FsbHMgYSB0YXNrIGFzIHNvb24gYXMgcG9zc2libGUgYWZ0ZXIgcmV0dXJuaW5nLCBpbiBpdHMgb3duIGV2ZW50LCB3aXRoIHByaW9yaXR5XG4gKiBvdmVyIG90aGVyIGV2ZW50cyBsaWtlIGFuaW1hdGlvbiwgcmVmbG93LCBhbmQgcmVwYWludC4gQW4gZXJyb3IgdGhyb3duIGZyb20gYW5cbiAqIGV2ZW50IHdpbGwgbm90IGludGVycnVwdCwgbm9yIGV2ZW4gc3Vic3RhbnRpYWxseSBzbG93IGRvd24gdGhlIHByb2Nlc3Npbmcgb2ZcbiAqIG90aGVyIGV2ZW50cywgYnV0IHdpbGwgYmUgcmF0aGVyIHBvc3Rwb25lZCB0byBhIGxvd2VyIHByaW9yaXR5IGV2ZW50LlxuICogQHBhcmFtIHt7Y2FsbH19IHRhc2sgQSBjYWxsYWJsZSBvYmplY3QsIHR5cGljYWxseSBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgbm9cbiAqIGFyZ3VtZW50cy5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBhc2FwO1xuZnVuY3Rpb24gYXNhcCh0YXNrKSB7XG4gICAgdmFyIHJhd1Rhc2s7XG4gICAgaWYgKGZyZWVUYXNrcy5sZW5ndGgpIHtcbiAgICAgICAgcmF3VGFzayA9IGZyZWVUYXNrcy5wb3AoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByYXdUYXNrID0gbmV3IFJhd1Rhc2soKTtcbiAgICB9XG4gICAgcmF3VGFzay50YXNrID0gdGFzaztcbiAgICByYXdBc2FwKHJhd1Rhc2spO1xufVxuXG4vLyBXZSB3cmFwIHRhc2tzIHdpdGggcmVjeWNsYWJsZSB0YXNrIG9iamVjdHMuICBBIHRhc2sgb2JqZWN0IGltcGxlbWVudHNcbi8vIGBjYWxsYCwganVzdCBsaWtlIGEgZnVuY3Rpb24uXG5mdW5jdGlvbiBSYXdUYXNrKCkge1xuICAgIHRoaXMudGFzayA9IG51bGw7XG59XG5cbi8vIFRoZSBzb2xlIHB1cnBvc2Ugb2Ygd3JhcHBpbmcgdGhlIHRhc2sgaXMgdG8gY2F0Y2ggdGhlIGV4Y2VwdGlvbiBhbmQgcmVjeWNsZVxuLy8gdGhlIHRhc2sgb2JqZWN0IGFmdGVyIGl0cyBzaW5nbGUgdXNlLlxuUmF3VGFzay5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICB0aGlzLnRhc2suY2FsbCgpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChhc2FwLm9uZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaG9vayBleGlzdHMgcHVyZWx5IGZvciB0ZXN0aW5nIHB1cnBvc2VzLlxuICAgICAgICAgICAgLy8gSXRzIG5hbWUgd2lsbCBiZSBwZXJpb2RpY2FsbHkgcmFuZG9taXplZCB0byBicmVhayBhbnkgY29kZSB0aGF0XG4gICAgICAgICAgICAvLyBkZXBlbmRzIG9uIGl0cyBleGlzdGVuY2UuXG4gICAgICAgICAgICBhc2FwLm9uZXJyb3IoZXJyb3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSW4gYSB3ZWIgYnJvd3NlciwgZXhjZXB0aW9ucyBhcmUgbm90IGZhdGFsLiBIb3dldmVyLCB0byBhdm9pZFxuICAgICAgICAgICAgLy8gc2xvd2luZyBkb3duIHRoZSBxdWV1ZSBvZiBwZW5kaW5nIHRhc2tzLCB3ZSByZXRocm93IHRoZSBlcnJvciBpbiBhXG4gICAgICAgICAgICAvLyBsb3dlciBwcmlvcml0eSB0dXJuLlxuICAgICAgICAgICAgcGVuZGluZ0Vycm9ycy5wdXNoKGVycm9yKTtcbiAgICAgICAgICAgIHJlcXVlc3RFcnJvclRocm93KCk7XG4gICAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgICB0aGlzLnRhc2sgPSBudWxsO1xuICAgICAgICBmcmVlVGFza3NbZnJlZVRhc2tzLmxlbmd0aF0gPSB0aGlzO1xuICAgIH1cbn07XG5cbn0se1wiLi9yYXdcIjo5OX1dLDk5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcblwidXNlIHN0cmljdFwiO1xuXG4vLyBVc2UgdGhlIGZhc3Rlc3QgbWVhbnMgcG9zc2libGUgdG8gZXhlY3V0ZSBhIHRhc2sgaW4gaXRzIG93biB0dXJuLCB3aXRoXG4vLyBwcmlvcml0eSBvdmVyIG90aGVyIGV2ZW50cyBpbmNsdWRpbmcgSU8sIGFuaW1hdGlvbiwgcmVmbG93LCBhbmQgcmVkcmF3XG4vLyBldmVudHMgaW4gYnJvd3NlcnMuXG4vL1xuLy8gQW4gZXhjZXB0aW9uIHRocm93biBieSBhIHRhc2sgd2lsbCBwZXJtYW5lbnRseSBpbnRlcnJ1cHQgdGhlIHByb2Nlc3Npbmcgb2Zcbi8vIHN1YnNlcXVlbnQgdGFza3MuIFRoZSBoaWdoZXIgbGV2ZWwgYGFzYXBgIGZ1bmN0aW9uIGVuc3VyZXMgdGhhdCBpZiBhblxuLy8gZXhjZXB0aW9uIGlzIHRocm93biBieSBhIHRhc2ssIHRoYXQgdGhlIHRhc2sgcXVldWUgd2lsbCBjb250aW51ZSBmbHVzaGluZyBhc1xuLy8gc29vbiBhcyBwb3NzaWJsZSwgYnV0IGlmIHlvdSB1c2UgYHJhd0FzYXBgIGRpcmVjdGx5LCB5b3UgYXJlIHJlc3BvbnNpYmxlIHRvXG4vLyBlaXRoZXIgZW5zdXJlIHRoYXQgbm8gZXhjZXB0aW9ucyBhcmUgdGhyb3duIGZyb20geW91ciB0YXNrLCBvciB0byBtYW51YWxseVxuLy8gY2FsbCBgcmF3QXNhcC5yZXF1ZXN0Rmx1c2hgIGlmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24uXG5tb2R1bGUuZXhwb3J0cyA9IHJhd0FzYXA7XG5mdW5jdGlvbiByYXdBc2FwKHRhc2spIHtcbiAgICBpZiAoIXF1ZXVlLmxlbmd0aCkge1xuICAgICAgICByZXF1ZXN0Rmx1c2goKTtcbiAgICAgICAgZmx1c2hpbmcgPSB0cnVlO1xuICAgIH1cbiAgICAvLyBFcXVpdmFsZW50IHRvIHB1c2gsIGJ1dCBhdm9pZHMgYSBmdW5jdGlvbiBjYWxsLlxuICAgIHF1ZXVlW3F1ZXVlLmxlbmd0aF0gPSB0YXNrO1xufVxuXG52YXIgcXVldWUgPSBbXTtcbi8vIE9uY2UgYSBmbHVzaCBoYXMgYmVlbiByZXF1ZXN0ZWQsIG5vIGZ1cnRoZXIgY2FsbHMgdG8gYHJlcXVlc3RGbHVzaGAgYXJlXG4vLyBuZWNlc3NhcnkgdW50aWwgdGhlIG5leHQgYGZsdXNoYCBjb21wbGV0ZXMuXG52YXIgZmx1c2hpbmcgPSBmYWxzZTtcbi8vIGByZXF1ZXN0Rmx1c2hgIGlzIGFuIGltcGxlbWVudGF0aW9uLXNwZWNpZmljIG1ldGhvZCB0aGF0IGF0dGVtcHRzIHRvIGtpY2tcbi8vIG9mZiBhIGBmbHVzaGAgZXZlbnQgYXMgcXVpY2tseSBhcyBwb3NzaWJsZS4gYGZsdXNoYCB3aWxsIGF0dGVtcHQgdG8gZXhoYXVzdFxuLy8gdGhlIGV2ZW50IHF1ZXVlIGJlZm9yZSB5aWVsZGluZyB0byB0aGUgYnJvd3NlcidzIG93biBldmVudCBsb29wLlxudmFyIHJlcXVlc3RGbHVzaDtcbi8vIFRoZSBwb3NpdGlvbiBvZiB0aGUgbmV4dCB0YXNrIHRvIGV4ZWN1dGUgaW4gdGhlIHRhc2sgcXVldWUuIFRoaXMgaXNcbi8vIHByZXNlcnZlZCBiZXR3ZWVuIGNhbGxzIHRvIGBmbHVzaGAgc28gdGhhdCBpdCBjYW4gYmUgcmVzdW1lZCBpZlxuLy8gYSB0YXNrIHRocm93cyBhbiBleGNlcHRpb24uXG52YXIgaW5kZXggPSAwO1xuLy8gSWYgYSB0YXNrIHNjaGVkdWxlcyBhZGRpdGlvbmFsIHRhc2tzIHJlY3Vyc2l2ZWx5LCB0aGUgdGFzayBxdWV1ZSBjYW4gZ3Jvd1xuLy8gdW5ib3VuZGVkLiBUbyBwcmV2ZW50IG1lbW9yeSBleGhhdXN0aW9uLCB0aGUgdGFzayBxdWV1ZSB3aWxsIHBlcmlvZGljYWxseVxuLy8gdHJ1bmNhdGUgYWxyZWFkeS1jb21wbGV0ZWQgdGFza3MuXG52YXIgY2FwYWNpdHkgPSAxMDI0O1xuXG4vLyBUaGUgZmx1c2ggZnVuY3Rpb24gcHJvY2Vzc2VzIGFsbCB0YXNrcyB0aGF0IGhhdmUgYmVlbiBzY2hlZHVsZWQgd2l0aFxuLy8gYHJhd0FzYXBgIHVubGVzcyBhbmQgdW50aWwgb25lIG9mIHRob3NlIHRhc2tzIHRocm93cyBhbiBleGNlcHRpb24uXG4vLyBJZiBhIHRhc2sgdGhyb3dzIGFuIGV4Y2VwdGlvbiwgYGZsdXNoYCBlbnN1cmVzIHRoYXQgaXRzIHN0YXRlIHdpbGwgcmVtYWluXG4vLyBjb25zaXN0ZW50IGFuZCB3aWxsIHJlc3VtZSB3aGVyZSBpdCBsZWZ0IG9mZiB3aGVuIGNhbGxlZCBhZ2Fpbi5cbi8vIEhvd2V2ZXIsIGBmbHVzaGAgZG9lcyBub3QgbWFrZSBhbnkgYXJyYW5nZW1lbnRzIHRvIGJlIGNhbGxlZCBhZ2FpbiBpZiBhblxuLy8gZXhjZXB0aW9uIGlzIHRocm93bi5cbmZ1bmN0aW9uIGZsdXNoKCkge1xuICAgIHdoaWxlIChpbmRleCA8IHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICB2YXIgY3VycmVudEluZGV4ID0gaW5kZXg7XG4gICAgICAgIC8vIEFkdmFuY2UgdGhlIGluZGV4IGJlZm9yZSBjYWxsaW5nIHRoZSB0YXNrLiBUaGlzIGVuc3VyZXMgdGhhdCB3ZSB3aWxsXG4gICAgICAgIC8vIGJlZ2luIGZsdXNoaW5nIG9uIHRoZSBuZXh0IHRhc2sgdGhlIHRhc2sgdGhyb3dzIGFuIGVycm9yLlxuICAgICAgICBpbmRleCA9IGluZGV4ICsgMTtcbiAgICAgICAgcXVldWVbY3VycmVudEluZGV4XS5jYWxsKCk7XG4gICAgICAgIC8vIFByZXZlbnQgbGVha2luZyBtZW1vcnkgZm9yIGxvbmcgY2hhaW5zIG9mIHJlY3Vyc2l2ZSBjYWxscyB0byBgYXNhcGAuXG4gICAgICAgIC8vIElmIHdlIGNhbGwgYGFzYXBgIHdpdGhpbiB0YXNrcyBzY2hlZHVsZWQgYnkgYGFzYXBgLCB0aGUgcXVldWUgd2lsbFxuICAgICAgICAvLyBncm93LCBidXQgdG8gYXZvaWQgYW4gTyhuKSB3YWxrIGZvciBldmVyeSB0YXNrIHdlIGV4ZWN1dGUsIHdlIGRvbid0XG4gICAgICAgIC8vIHNoaWZ0IHRhc2tzIG9mZiB0aGUgcXVldWUgYWZ0ZXIgdGhleSBoYXZlIGJlZW4gZXhlY3V0ZWQuXG4gICAgICAgIC8vIEluc3RlYWQsIHdlIHBlcmlvZGljYWxseSBzaGlmdCAxMDI0IHRhc2tzIG9mZiB0aGUgcXVldWUuXG4gICAgICAgIGlmIChpbmRleCA+IGNhcGFjaXR5KSB7XG4gICAgICAgICAgICAvLyBNYW51YWxseSBzaGlmdCBhbGwgdmFsdWVzIHN0YXJ0aW5nIGF0IHRoZSBpbmRleCBiYWNrIHRvIHRoZVxuICAgICAgICAgICAgLy8gYmVnaW5uaW5nIG9mIHRoZSBxdWV1ZS5cbiAgICAgICAgICAgIGZvciAodmFyIHNjYW4gPSAwLCBuZXdMZW5ndGggPSBxdWV1ZS5sZW5ndGggLSBpbmRleDsgc2NhbiA8IG5ld0xlbmd0aDsgc2NhbisrKSB7XG4gICAgICAgICAgICAgICAgcXVldWVbc2Nhbl0gPSBxdWV1ZVtzY2FuICsgaW5kZXhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcXVldWUubGVuZ3RoIC09IGluZGV4O1xuICAgICAgICAgICAgaW5kZXggPSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLmxlbmd0aCA9IDA7XG4gICAgaW5kZXggPSAwO1xuICAgIGZsdXNoaW5nID0gZmFsc2U7XG59XG5cbi8vIGByZXF1ZXN0Rmx1c2hgIGlzIGltcGxlbWVudGVkIHVzaW5nIGEgc3RyYXRlZ3kgYmFzZWQgb24gZGF0YSBjb2xsZWN0ZWQgZnJvbVxuLy8gZXZlcnkgYXZhaWxhYmxlIFNhdWNlTGFicyBTZWxlbml1bSB3ZWIgZHJpdmVyIHdvcmtlciBhdCB0aW1lIG9mIHdyaXRpbmcuXG4vLyBodHRwczovL2RvY3MuZ29vZ2xlLmNvbS9zcHJlYWRzaGVldHMvZC8xbUctNVVZR3VwNXF4R2RFTVdraFA2QldDejA1M05VYjJFMVFvVVRVMTZ1QS9lZGl0I2dpZD03ODM3MjQ1OTNcblxuLy8gU2FmYXJpIDYgYW5kIDYuMSBmb3IgZGVza3RvcCwgaVBhZCwgYW5kIGlQaG9uZSBhcmUgdGhlIG9ubHkgYnJvd3NlcnMgdGhhdFxuLy8gaGF2ZSBXZWJLaXRNdXRhdGlvbk9ic2VydmVyIGJ1dCBub3QgdW4tcHJlZml4ZWQgTXV0YXRpb25PYnNlcnZlci5cbi8vIE11c3QgdXNlIGBnbG9iYWxgIG9yIGBzZWxmYCBpbnN0ZWFkIG9mIGB3aW5kb3dgIHRvIHdvcmsgaW4gYm90aCBmcmFtZXMgYW5kIHdlYlxuLy8gd29ya2Vycy4gYGdsb2JhbGAgaXMgYSBwcm92aXNpb24gb2YgQnJvd3NlcmlmeSwgTXIsIE1ycywgb3IgTW9wLlxuXG4vKiBnbG9iYWxzIHNlbGYgKi9cbnZhciBzY29wZSA9IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiBzZWxmO1xudmFyIEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyID0gc2NvcGUuTXV0YXRpb25PYnNlcnZlciB8fCBzY29wZS5XZWJLaXRNdXRhdGlvbk9ic2VydmVyO1xuXG4vLyBNdXRhdGlvbk9ic2VydmVycyBhcmUgZGVzaXJhYmxlIGJlY2F1c2UgdGhleSBoYXZlIGhpZ2ggcHJpb3JpdHkgYW5kIHdvcmtcbi8vIHJlbGlhYmx5IGV2ZXJ5d2hlcmUgdGhleSBhcmUgaW1wbGVtZW50ZWQuXG4vLyBUaGV5IGFyZSBpbXBsZW1lbnRlZCBpbiBhbGwgbW9kZXJuIGJyb3dzZXJzLlxuLy9cbi8vIC0gQW5kcm9pZCA0LTQuM1xuLy8gLSBDaHJvbWUgMjYtMzRcbi8vIC0gRmlyZWZveCAxNC0yOVxuLy8gLSBJbnRlcm5ldCBFeHBsb3JlciAxMVxuLy8gLSBpUGFkIFNhZmFyaSA2LTcuMVxuLy8gLSBpUGhvbmUgU2FmYXJpIDctNy4xXG4vLyAtIFNhZmFyaSA2LTdcbmlmICh0eXBlb2YgQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJlcXVlc3RGbHVzaCA9IG1ha2VSZXF1ZXN0Q2FsbEZyb21NdXRhdGlvbk9ic2VydmVyKGZsdXNoKTtcblxuLy8gTWVzc2FnZUNoYW5uZWxzIGFyZSBkZXNpcmFibGUgYmVjYXVzZSB0aGV5IGdpdmUgZGlyZWN0IGFjY2VzcyB0byB0aGUgSFRNTFxuLy8gdGFzayBxdWV1ZSwgYXJlIGltcGxlbWVudGVkIGluIEludGVybmV0IEV4cGxvcmVyIDEwLCBTYWZhcmkgNS4wLTEsIGFuZCBPcGVyYVxuLy8gMTEtMTIsIGFuZCBpbiB3ZWIgd29ya2VycyBpbiBtYW55IGVuZ2luZXMuXG4vLyBBbHRob3VnaCBtZXNzYWdlIGNoYW5uZWxzIHlpZWxkIHRvIGFueSBxdWV1ZWQgcmVuZGVyaW5nIGFuZCBJTyB0YXNrcywgdGhleVxuLy8gd291bGQgYmUgYmV0dGVyIHRoYW4gaW1wb3NpbmcgdGhlIDRtcyBkZWxheSBvZiB0aW1lcnMuXG4vLyBIb3dldmVyLCB0aGV5IGRvIG5vdCB3b3JrIHJlbGlhYmx5IGluIEludGVybmV0IEV4cGxvcmVyIG9yIFNhZmFyaS5cblxuLy8gSW50ZXJuZXQgRXhwbG9yZXIgMTAgaXMgdGhlIG9ubHkgYnJvd3NlciB0aGF0IGhhcyBzZXRJbW1lZGlhdGUgYnV0IGRvZXNcbi8vIG5vdCBoYXZlIE11dGF0aW9uT2JzZXJ2ZXJzLlxuLy8gQWx0aG91Z2ggc2V0SW1tZWRpYXRlIHlpZWxkcyB0byB0aGUgYnJvd3NlcidzIHJlbmRlcmVyLCBpdCB3b3VsZCBiZVxuLy8gcHJlZmVycmFibGUgdG8gZmFsbGluZyBiYWNrIHRvIHNldFRpbWVvdXQgc2luY2UgaXQgZG9lcyBub3QgaGF2ZVxuLy8gdGhlIG1pbmltdW0gNG1zIHBlbmFsdHkuXG4vLyBVbmZvcnR1bmF0ZWx5IHRoZXJlIGFwcGVhcnMgdG8gYmUgYSBidWcgaW4gSW50ZXJuZXQgRXhwbG9yZXIgMTAgTW9iaWxlIChhbmRcbi8vIERlc2t0b3AgdG8gYSBsZXNzZXIgZXh0ZW50KSB0aGF0IHJlbmRlcnMgYm90aCBzZXRJbW1lZGlhdGUgYW5kXG4vLyBNZXNzYWdlQ2hhbm5lbCB1c2VsZXNzIGZvciB0aGUgcHVycG9zZXMgb2YgQVNBUC5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9rcmlza293YWwvcS9pc3N1ZXMvMzk2XG5cbi8vIFRpbWVycyBhcmUgaW1wbGVtZW50ZWQgdW5pdmVyc2FsbHkuXG4vLyBXZSBmYWxsIGJhY2sgdG8gdGltZXJzIGluIHdvcmtlcnMgaW4gbW9zdCBlbmdpbmVzLCBhbmQgaW4gZm9yZWdyb3VuZFxuLy8gY29udGV4dHMgaW4gdGhlIGZvbGxvd2luZyBicm93c2Vycy5cbi8vIEhvd2V2ZXIsIG5vdGUgdGhhdCBldmVuIHRoaXMgc2ltcGxlIGNhc2UgcmVxdWlyZXMgbnVhbmNlcyB0byBvcGVyYXRlIGluIGFcbi8vIGJyb2FkIHNwZWN0cnVtIG9mIGJyb3dzZXJzLlxuLy9cbi8vIC0gRmlyZWZveCAzLTEzXG4vLyAtIEludGVybmV0IEV4cGxvcmVyIDYtOVxuLy8gLSBpUGFkIFNhZmFyaSA0LjNcbi8vIC0gTHlueCAyLjguN1xufSBlbHNlIHtcbiAgICByZXF1ZXN0Rmx1c2ggPSBtYWtlUmVxdWVzdENhbGxGcm9tVGltZXIoZmx1c2gpO1xufVxuXG4vLyBgcmVxdWVzdEZsdXNoYCByZXF1ZXN0cyB0aGF0IHRoZSBoaWdoIHByaW9yaXR5IGV2ZW50IHF1ZXVlIGJlIGZsdXNoZWQgYXNcbi8vIHNvb24gYXMgcG9zc2libGUuXG4vLyBUaGlzIGlzIHVzZWZ1bCB0byBwcmV2ZW50IGFuIGVycm9yIHRocm93biBpbiBhIHRhc2sgZnJvbSBzdGFsbGluZyB0aGUgZXZlbnRcbi8vIHF1ZXVlIGlmIHRoZSBleGNlcHRpb24gaGFuZGxlZCBieSBOb2RlLmpz4oCZc1xuLy8gYHByb2Nlc3Mub24oXCJ1bmNhdWdodEV4Y2VwdGlvblwiKWAgb3IgYnkgYSBkb21haW4uXG5yYXdBc2FwLnJlcXVlc3RGbHVzaCA9IHJlcXVlc3RGbHVzaDtcblxuLy8gVG8gcmVxdWVzdCBhIGhpZ2ggcHJpb3JpdHkgZXZlbnQsIHdlIGluZHVjZSBhIG11dGF0aW9uIG9ic2VydmVyIGJ5IHRvZ2dsaW5nXG4vLyB0aGUgdGV4dCBvZiBhIHRleHQgbm9kZSBiZXR3ZWVuIFwiMVwiIGFuZCBcIi0xXCIuXG5mdW5jdGlvbiBtYWtlUmVxdWVzdENhbGxGcm9tTXV0YXRpb25PYnNlcnZlcihjYWxsYmFjaykge1xuICAgIHZhciB0b2dnbGUgPSAxO1xuICAgIHZhciBvYnNlcnZlciA9IG5ldyBCcm93c2VyTXV0YXRpb25PYnNlcnZlcihjYWxsYmFjayk7XG4gICAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlwiKTtcbiAgICBvYnNlcnZlci5vYnNlcnZlKG5vZGUsIHtjaGFyYWN0ZXJEYXRhOiB0cnVlfSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHJlcXVlc3RDYWxsKCkge1xuICAgICAgICB0b2dnbGUgPSAtdG9nZ2xlO1xuICAgICAgICBub2RlLmRhdGEgPSB0b2dnbGU7XG4gICAgfTtcbn1cblxuLy8gVGhlIG1lc3NhZ2UgY2hhbm5lbCB0ZWNobmlxdWUgd2FzIGRpc2NvdmVyZWQgYnkgTWFsdGUgVWJsIGFuZCB3YXMgdGhlXG4vLyBvcmlnaW5hbCBmb3VuZGF0aW9uIGZvciB0aGlzIGxpYnJhcnkuXG4vLyBodHRwOi8vd3d3Lm5vbmJsb2NraW5nLmlvLzIwMTEvMDYvd2luZG93bmV4dHRpY2suaHRtbFxuXG4vLyBTYWZhcmkgNi4wLjUgKGF0IGxlYXN0KSBpbnRlcm1pdHRlbnRseSBmYWlscyB0byBjcmVhdGUgbWVzc2FnZSBwb3J0cyBvbiBhXG4vLyBwYWdlJ3MgZmlyc3QgbG9hZC4gVGhhbmtmdWxseSwgdGhpcyB2ZXJzaW9uIG9mIFNhZmFyaSBzdXBwb3J0c1xuLy8gTXV0YXRpb25PYnNlcnZlcnMsIHNvIHdlIGRvbid0IG5lZWQgdG8gZmFsbCBiYWNrIGluIHRoYXQgY2FzZS5cblxuLy8gZnVuY3Rpb24gbWFrZVJlcXVlc3RDYWxsRnJvbU1lc3NhZ2VDaGFubmVsKGNhbGxiYWNrKSB7XG4vLyAgICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbi8vICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGNhbGxiYWNrO1xuLy8gICAgIHJldHVybiBmdW5jdGlvbiByZXF1ZXN0Q2FsbCgpIHtcbi8vICAgICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZSgwKTtcbi8vICAgICB9O1xuLy8gfVxuXG4vLyBGb3IgcmVhc29ucyBleHBsYWluZWQgYWJvdmUsIHdlIGFyZSBhbHNvIHVuYWJsZSB0byB1c2UgYHNldEltbWVkaWF0ZWBcbi8vIHVuZGVyIGFueSBjaXJjdW1zdGFuY2VzLlxuLy8gRXZlbiBpZiB3ZSB3ZXJlLCB0aGVyZSBpcyBhbm90aGVyIGJ1ZyBpbiBJbnRlcm5ldCBFeHBsb3JlciAxMC5cbi8vIEl0IGlzIG5vdCBzdWZmaWNpZW50IHRvIGFzc2lnbiBgc2V0SW1tZWRpYXRlYCB0byBgcmVxdWVzdEZsdXNoYCBiZWNhdXNlXG4vLyBgc2V0SW1tZWRpYXRlYCBtdXN0IGJlIGNhbGxlZCAqYnkgbmFtZSogYW5kIHRoZXJlZm9yZSBtdXN0IGJlIHdyYXBwZWQgaW4gYVxuLy8gY2xvc3VyZS5cbi8vIE5ldmVyIGZvcmdldC5cblxuLy8gZnVuY3Rpb24gbWFrZVJlcXVlc3RDYWxsRnJvbVNldEltbWVkaWF0ZShjYWxsYmFjaykge1xuLy8gICAgIHJldHVybiBmdW5jdGlvbiByZXF1ZXN0Q2FsbCgpIHtcbi8vICAgICAgICAgc2V0SW1tZWRpYXRlKGNhbGxiYWNrKTtcbi8vICAgICB9O1xuLy8gfVxuXG4vLyBTYWZhcmkgNi4wIGhhcyBhIHByb2JsZW0gd2hlcmUgdGltZXJzIHdpbGwgZ2V0IGxvc3Qgd2hpbGUgdGhlIHVzZXIgaXNcbi8vIHNjcm9sbGluZy4gVGhpcyBwcm9ibGVtIGRvZXMgbm90IGltcGFjdCBBU0FQIGJlY2F1c2UgU2FmYXJpIDYuMCBzdXBwb3J0c1xuLy8gbXV0YXRpb24gb2JzZXJ2ZXJzLCBzbyB0aGF0IGltcGxlbWVudGF0aW9uIGlzIHVzZWQgaW5zdGVhZC5cbi8vIEhvd2V2ZXIsIGlmIHdlIGV2ZXIgZWxlY3QgdG8gdXNlIHRpbWVycyBpbiBTYWZhcmksIHRoZSBwcmV2YWxlbnQgd29yay1hcm91bmRcbi8vIGlzIHRvIGFkZCBhIHNjcm9sbCBldmVudCBsaXN0ZW5lciB0aGF0IGNhbGxzIGZvciBhIGZsdXNoLlxuXG4vLyBgc2V0VGltZW91dGAgZG9lcyBub3QgY2FsbCB0aGUgcGFzc2VkIGNhbGxiYWNrIGlmIHRoZSBkZWxheSBpcyBsZXNzIHRoYW5cbi8vIGFwcHJveGltYXRlbHkgNyBpbiB3ZWIgd29ya2VycyBpbiBGaXJlZm94IDggdGhyb3VnaCAxOCwgYW5kIHNvbWV0aW1lcyBub3Rcbi8vIGV2ZW4gdGhlbi5cblxuZnVuY3Rpb24gbWFrZVJlcXVlc3RDYWxsRnJvbVRpbWVyKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHJlcXVlc3RDYWxsKCkge1xuICAgICAgICAvLyBXZSBkaXNwYXRjaCBhIHRpbWVvdXQgd2l0aCBhIHNwZWNpZmllZCBkZWxheSBvZiAwIGZvciBlbmdpbmVzIHRoYXRcbiAgICAgICAgLy8gY2FuIHJlbGlhYmx5IGFjY29tbW9kYXRlIHRoYXQgcmVxdWVzdC4gVGhpcyB3aWxsIHVzdWFsbHkgYmUgc25hcHBlZFxuICAgICAgICAvLyB0byBhIDQgbWlsaXNlY29uZCBkZWxheSwgYnV0IG9uY2Ugd2UncmUgZmx1c2hpbmcsIHRoZXJlJ3Mgbm8gZGVsYXlcbiAgICAgICAgLy8gYmV0d2VlbiBldmVudHMuXG4gICAgICAgIHZhciB0aW1lb3V0SGFuZGxlID0gc2V0VGltZW91dChoYW5kbGVUaW1lciwgMCk7XG4gICAgICAgIC8vIEhvd2V2ZXIsIHNpbmNlIHRoaXMgdGltZXIgZ2V0cyBmcmVxdWVudGx5IGRyb3BwZWQgaW4gRmlyZWZveFxuICAgICAgICAvLyB3b3JrZXJzLCB3ZSBlbmxpc3QgYW4gaW50ZXJ2YWwgaGFuZGxlIHRoYXQgd2lsbCB0cnkgdG8gZmlyZVxuICAgICAgICAvLyBhbiBldmVudCAyMCB0aW1lcyBwZXIgc2Vjb25kIHVudGlsIGl0IHN1Y2NlZWRzLlxuICAgICAgICB2YXIgaW50ZXJ2YWxIYW5kbGUgPSBzZXRJbnRlcnZhbChoYW5kbGVUaW1lciwgNTApO1xuXG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZVRpbWVyKCkge1xuICAgICAgICAgICAgLy8gV2hpY2hldmVyIHRpbWVyIHN1Y2NlZWRzIHdpbGwgY2FuY2VsIGJvdGggdGltZXJzIGFuZFxuICAgICAgICAgICAgLy8gZXhlY3V0ZSB0aGUgY2FsbGJhY2suXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dEhhbmRsZSk7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsSGFuZGxlKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG4vLyBUaGlzIGlzIGZvciBgYXNhcC5qc2Agb25seS5cbi8vIEl0cyBuYW1lIHdpbGwgYmUgcGVyaW9kaWNhbGx5IHJhbmRvbWl6ZWQgdG8gYnJlYWsgYW55IGNvZGUgdGhhdCBkZXBlbmRzIG9uXG4vLyBpdHMgZXhpc3RlbmNlLlxucmF3QXNhcC5tYWtlUmVxdWVzdENhbGxGcm9tVGltZXIgPSBtYWtlUmVxdWVzdENhbGxGcm9tVGltZXI7XG5cbi8vIEFTQVAgd2FzIG9yaWdpbmFsbHkgYSBuZXh0VGljayBzaGltIGluY2x1ZGVkIGluIFEuIFRoaXMgd2FzIGZhY3RvcmVkIG91dFxuLy8gaW50byB0aGlzIEFTQVAgcGFja2FnZS4gSXQgd2FzIGxhdGVyIGFkYXB0ZWQgdG8gUlNWUCB3aGljaCBtYWRlIGZ1cnRoZXJcbi8vIGFtZW5kbWVudHMuIFRoZXNlIGRlY2lzaW9ucywgcGFydGljdWxhcmx5IHRvIG1hcmdpbmFsaXplIE1lc3NhZ2VDaGFubmVsIGFuZFxuLy8gdG8gY2FwdHVyZSB0aGUgTXV0YXRpb25PYnNlcnZlciBpbXBsZW1lbnRhdGlvbiBpbiBhIGNsb3N1cmUsIHdlcmUgaW50ZWdyYXRlZFxuLy8gYmFjayBpbnRvIEFTQVAgcHJvcGVyLlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RpbGRlaW8vcnN2cC5qcy9ibG9iL2NkZGY3MjMyNTQ2YTljZjg1ODUyNGI3NWNkZTZmOWVkZjcyNjIwYTcvbGliL3JzdnAvYXNhcC5qc1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcbn0se31dLDEwMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgY2xvbmUgPSAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9pbnN0YW5jZW9mKG9iaiwgdHlwZSkge1xuICByZXR1cm4gdHlwZSAhPSBudWxsICYmIG9iaiBpbnN0YW5jZW9mIHR5cGU7XG59XG5cbnZhciBuYXRpdmVNYXA7XG50cnkge1xuICBuYXRpdmVNYXAgPSBNYXA7XG59IGNhdGNoKF8pIHtcbiAgLy8gbWF5YmUgYSByZWZlcmVuY2UgZXJyb3IgYmVjYXVzZSBubyBgTWFwYC4gR2l2ZSBpdCBhIGR1bW15IHZhbHVlIHRoYXQgbm9cbiAgLy8gdmFsdWUgd2lsbCBldmVyIGJlIGFuIGluc3RhbmNlb2YuXG4gIG5hdGl2ZU1hcCA9IGZ1bmN0aW9uKCkge307XG59XG5cbnZhciBuYXRpdmVTZXQ7XG50cnkge1xuICBuYXRpdmVTZXQgPSBTZXQ7XG59IGNhdGNoKF8pIHtcbiAgbmF0aXZlU2V0ID0gZnVuY3Rpb24oKSB7fTtcbn1cblxudmFyIG5hdGl2ZVByb21pc2U7XG50cnkge1xuICBuYXRpdmVQcm9taXNlID0gUHJvbWlzZTtcbn0gY2F0Y2goXykge1xuICBuYXRpdmVQcm9taXNlID0gZnVuY3Rpb24oKSB7fTtcbn1cblxuLyoqXG4gKiBDbG9uZXMgKGNvcGllcykgYW4gT2JqZWN0IHVzaW5nIGRlZXAgY29weWluZy5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHN1cHBvcnRzIGNpcmN1bGFyIHJlZmVyZW5jZXMgYnkgZGVmYXVsdCwgYnV0IGlmIHlvdSBhcmUgY2VydGFpblxuICogdGhlcmUgYXJlIG5vIGNpcmN1bGFyIHJlZmVyZW5jZXMgaW4geW91ciBvYmplY3QsIHlvdSBjYW4gc2F2ZSBzb21lIENQVSB0aW1lXG4gKiBieSBjYWxsaW5nIGNsb25lKG9iaiwgZmFsc2UpLlxuICpcbiAqIENhdXRpb246IGlmIGBjaXJjdWxhcmAgaXMgZmFsc2UgYW5kIGBwYXJlbnRgIGNvbnRhaW5zIGNpcmN1bGFyIHJlZmVyZW5jZXMsXG4gKiB5b3VyIHByb2dyYW0gbWF5IGVudGVyIGFuIGluZmluaXRlIGxvb3AgYW5kIGNyYXNoLlxuICpcbiAqIEBwYXJhbSBgcGFyZW50YCAtIHRoZSBvYmplY3QgdG8gYmUgY2xvbmVkXG4gKiBAcGFyYW0gYGNpcmN1bGFyYCAtIHNldCB0byB0cnVlIGlmIHRoZSBvYmplY3QgdG8gYmUgY2xvbmVkIG1heSBjb250YWluXG4gKiAgICBjaXJjdWxhciByZWZlcmVuY2VzLiAob3B0aW9uYWwgLSB0cnVlIGJ5IGRlZmF1bHQpXG4gKiBAcGFyYW0gYGRlcHRoYCAtIHNldCB0byBhIG51bWJlciBpZiB0aGUgb2JqZWN0IGlzIG9ubHkgdG8gYmUgY2xvbmVkIHRvXG4gKiAgICBhIHBhcnRpY3VsYXIgZGVwdGguIChvcHRpb25hbCAtIGRlZmF1bHRzIHRvIEluZmluaXR5KVxuICogQHBhcmFtIGBwcm90b3R5cGVgIC0gc2V0cyB0aGUgcHJvdG90eXBlIHRvIGJlIHVzZWQgd2hlbiBjbG9uaW5nIGFuIG9iamVjdC5cbiAqICAgIChvcHRpb25hbCAtIGRlZmF1bHRzIHRvIHBhcmVudCBwcm90b3R5cGUpLlxuICogQHBhcmFtIGBpbmNsdWRlTm9uRW51bWVyYWJsZWAgLSBzZXQgdG8gdHJ1ZSBpZiB0aGUgbm9uLWVudW1lcmFibGUgcHJvcGVydGllc1xuICogICAgc2hvdWxkIGJlIGNsb25lZCBhcyB3ZWxsLiBOb24tZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9uIHRoZSBwcm90b3R5cGVcbiAqICAgIGNoYWluIHdpbGwgYmUgaWdub3JlZC4gKG9wdGlvbmFsIC0gZmFsc2UgYnkgZGVmYXVsdClcbiovXG5mdW5jdGlvbiBjbG9uZShwYXJlbnQsIGNpcmN1bGFyLCBkZXB0aCwgcHJvdG90eXBlLCBpbmNsdWRlTm9uRW51bWVyYWJsZSkge1xuICBpZiAodHlwZW9mIGNpcmN1bGFyID09PSAnb2JqZWN0Jykge1xuICAgIGRlcHRoID0gY2lyY3VsYXIuZGVwdGg7XG4gICAgcHJvdG90eXBlID0gY2lyY3VsYXIucHJvdG90eXBlO1xuICAgIGluY2x1ZGVOb25FbnVtZXJhYmxlID0gY2lyY3VsYXIuaW5jbHVkZU5vbkVudW1lcmFibGU7XG4gICAgY2lyY3VsYXIgPSBjaXJjdWxhci5jaXJjdWxhcjtcbiAgfVxuICAvLyBtYWludGFpbiB0d28gYXJyYXlzIGZvciBjaXJjdWxhciByZWZlcmVuY2VzLCB3aGVyZSBjb3JyZXNwb25kaW5nIHBhcmVudHNcbiAgLy8gYW5kIGNoaWxkcmVuIGhhdmUgdGhlIHNhbWUgaW5kZXhcbiAgdmFyIGFsbFBhcmVudHMgPSBbXTtcbiAgdmFyIGFsbENoaWxkcmVuID0gW107XG5cbiAgdmFyIHVzZUJ1ZmZlciA9IHR5cGVvZiBCdWZmZXIgIT0gJ3VuZGVmaW5lZCc7XG5cbiAgaWYgKHR5cGVvZiBjaXJjdWxhciA9PSAndW5kZWZpbmVkJylcbiAgICBjaXJjdWxhciA9IHRydWU7XG5cbiAgaWYgKHR5cGVvZiBkZXB0aCA9PSAndW5kZWZpbmVkJylcbiAgICBkZXB0aCA9IEluZmluaXR5O1xuXG4gIC8vIHJlY3Vyc2UgdGhpcyBmdW5jdGlvbiBzbyB3ZSBkb24ndCByZXNldCBhbGxQYXJlbnRzIGFuZCBhbGxDaGlsZHJlblxuICBmdW5jdGlvbiBfY2xvbmUocGFyZW50LCBkZXB0aCkge1xuICAgIC8vIGNsb25pbmcgbnVsbCBhbHdheXMgcmV0dXJucyBudWxsXG4gICAgaWYgKHBhcmVudCA9PT0gbnVsbClcbiAgICAgIHJldHVybiBudWxsO1xuXG4gICAgaWYgKGRlcHRoID09PSAwKVxuICAgICAgcmV0dXJuIHBhcmVudDtcblxuICAgIHZhciBjaGlsZDtcbiAgICB2YXIgcHJvdG87XG4gICAgaWYgKHR5cGVvZiBwYXJlbnQgIT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgfVxuXG4gICAgaWYgKF9pbnN0YW5jZW9mKHBhcmVudCwgbmF0aXZlTWFwKSkge1xuICAgICAgY2hpbGQgPSBuZXcgbmF0aXZlTWFwKCk7XG4gICAgfSBlbHNlIGlmIChfaW5zdGFuY2VvZihwYXJlbnQsIG5hdGl2ZVNldCkpIHtcbiAgICAgIGNoaWxkID0gbmV3IG5hdGl2ZVNldCgpO1xuICAgIH0gZWxzZSBpZiAoX2luc3RhbmNlb2YocGFyZW50LCBuYXRpdmVQcm9taXNlKSkge1xuICAgICAgY2hpbGQgPSBuZXcgbmF0aXZlUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHBhcmVudC50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgcmVzb2x2ZShfY2xvbmUodmFsdWUsIGRlcHRoIC0gMSkpO1xuICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICByZWplY3QoX2Nsb25lKGVyciwgZGVwdGggLSAxKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChjbG9uZS5fX2lzQXJyYXkocGFyZW50KSkge1xuICAgICAgY2hpbGQgPSBbXTtcbiAgICB9IGVsc2UgaWYgKGNsb25lLl9faXNSZWdFeHAocGFyZW50KSkge1xuICAgICAgY2hpbGQgPSBuZXcgUmVnRXhwKHBhcmVudC5zb3VyY2UsIF9fZ2V0UmVnRXhwRmxhZ3MocGFyZW50KSk7XG4gICAgICBpZiAocGFyZW50Lmxhc3RJbmRleCkgY2hpbGQubGFzdEluZGV4ID0gcGFyZW50Lmxhc3RJbmRleDtcbiAgICB9IGVsc2UgaWYgKGNsb25lLl9faXNEYXRlKHBhcmVudCkpIHtcbiAgICAgIGNoaWxkID0gbmV3IERhdGUocGFyZW50LmdldFRpbWUoKSk7XG4gICAgfSBlbHNlIGlmICh1c2VCdWZmZXIgJiYgQnVmZmVyLmlzQnVmZmVyKHBhcmVudCkpIHtcbiAgICAgIGlmIChCdWZmZXIuYWxsb2NVbnNhZmUpIHtcbiAgICAgICAgLy8gTm9kZS5qcyA+PSA0LjUuMFxuICAgICAgICBjaGlsZCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShwYXJlbnQubGVuZ3RoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE9sZGVyIE5vZGUuanMgdmVyc2lvbnNcbiAgICAgICAgY2hpbGQgPSBuZXcgQnVmZmVyKHBhcmVudC5sZW5ndGgpO1xuICAgICAgfVxuICAgICAgcGFyZW50LmNvcHkoY2hpbGQpO1xuICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH0gZWxzZSBpZiAoX2luc3RhbmNlb2YocGFyZW50LCBFcnJvcikpIHtcbiAgICAgIGNoaWxkID0gT2JqZWN0LmNyZWF0ZShwYXJlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZW9mIHByb3RvdHlwZSA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihwYXJlbnQpO1xuICAgICAgICBjaGlsZCA9IE9iamVjdC5jcmVhdGUocHJvdG8pO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGNoaWxkID0gT2JqZWN0LmNyZWF0ZShwcm90b3R5cGUpO1xuICAgICAgICBwcm90byA9IHByb3RvdHlwZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY2lyY3VsYXIpIHtcbiAgICAgIHZhciBpbmRleCA9IGFsbFBhcmVudHMuaW5kZXhPZihwYXJlbnQpO1xuXG4gICAgICBpZiAoaW5kZXggIT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIGFsbENoaWxkcmVuW2luZGV4XTtcbiAgICAgIH1cbiAgICAgIGFsbFBhcmVudHMucHVzaChwYXJlbnQpO1xuICAgICAgYWxsQ2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgfVxuXG4gICAgaWYgKF9pbnN0YW5jZW9mKHBhcmVudCwgbmF0aXZlTWFwKSkge1xuICAgICAgcGFyZW50LmZvckVhY2goZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICB2YXIga2V5Q2hpbGQgPSBfY2xvbmUoa2V5LCBkZXB0aCAtIDEpO1xuICAgICAgICB2YXIgdmFsdWVDaGlsZCA9IF9jbG9uZSh2YWx1ZSwgZGVwdGggLSAxKTtcbiAgICAgICAgY2hpbGQuc2V0KGtleUNoaWxkLCB2YWx1ZUNoaWxkKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoX2luc3RhbmNlb2YocGFyZW50LCBuYXRpdmVTZXQpKSB7XG4gICAgICBwYXJlbnQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB2YXIgZW50cnlDaGlsZCA9IF9jbG9uZSh2YWx1ZSwgZGVwdGggLSAxKTtcbiAgICAgICAgY2hpbGQuYWRkKGVudHJ5Q2hpbGQpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSBpbiBwYXJlbnQpIHtcbiAgICAgIHZhciBhdHRycztcbiAgICAgIGlmIChwcm90bykge1xuICAgICAgICBhdHRycyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocHJvdG8sIGkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoYXR0cnMgJiYgYXR0cnMuc2V0ID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjaGlsZFtpXSA9IF9jbG9uZShwYXJlbnRbaV0sIGRlcHRoIC0gMSk7XG4gICAgfVxuXG4gICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICAgIHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhwYXJlbnQpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzeW1ib2xzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIERvbid0IG5lZWQgdG8gd29ycnkgYWJvdXQgY2xvbmluZyBhIHN5bWJvbCBiZWNhdXNlIGl0IGlzIGEgcHJpbWl0aXZlLFxuICAgICAgICAvLyBsaWtlIGEgbnVtYmVyIG9yIHN0cmluZy5cbiAgICAgICAgdmFyIHN5bWJvbCA9IHN5bWJvbHNbaV07XG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwYXJlbnQsIHN5bWJvbCk7XG4gICAgICAgIGlmIChkZXNjcmlwdG9yICYmICFkZXNjcmlwdG9yLmVudW1lcmFibGUgJiYgIWluY2x1ZGVOb25FbnVtZXJhYmxlKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGRbc3ltYm9sXSA9IF9jbG9uZShwYXJlbnRbc3ltYm9sXSwgZGVwdGggLSAxKTtcbiAgICAgICAgaWYgKCFkZXNjcmlwdG9yLmVudW1lcmFibGUpIHtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2hpbGQsIHN5bWJvbCwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpbmNsdWRlTm9uRW51bWVyYWJsZSkge1xuICAgICAgdmFyIGFsbFByb3BlcnR5TmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwYXJlbnQpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGxQcm9wZXJ0eU5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwcm9wZXJ0eU5hbWUgPSBhbGxQcm9wZXJ0eU5hbWVzW2ldO1xuICAgICAgICB2YXIgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocGFyZW50LCBwcm9wZXJ0eU5hbWUpO1xuICAgICAgICBpZiAoZGVzY3JpcHRvciAmJiBkZXNjcmlwdG9yLmVudW1lcmFibGUpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjaGlsZFtwcm9wZXJ0eU5hbWVdID0gX2Nsb25lKHBhcmVudFtwcm9wZXJ0eU5hbWVdLCBkZXB0aCAtIDEpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2hpbGQsIHByb3BlcnR5TmFtZSwge1xuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjaGlsZDtcbiAgfVxuXG4gIHJldHVybiBfY2xvbmUocGFyZW50LCBkZXB0aCk7XG59XG5cbi8qKlxuICogU2ltcGxlIGZsYXQgY2xvbmUgdXNpbmcgcHJvdG90eXBlLCBhY2NlcHRzIG9ubHkgb2JqZWN0cywgdXNlZnVsbCBmb3IgcHJvcGVydHlcbiAqIG92ZXJyaWRlIG9uIEZMQVQgY29uZmlndXJhdGlvbiBvYmplY3QgKG5vIG5lc3RlZCBwcm9wcykuXG4gKlxuICogVVNFIFdJVEggQ0FVVElPTiEgVGhpcyBtYXkgbm90IGJlaGF2ZSBhcyB5b3Ugd2lzaCBpZiB5b3UgZG8gbm90IGtub3cgaG93IHRoaXNcbiAqIHdvcmtzLlxuICovXG5jbG9uZS5jbG9uZVByb3RvdHlwZSA9IGZ1bmN0aW9uIGNsb25lUHJvdG90eXBlKHBhcmVudCkge1xuICBpZiAocGFyZW50ID09PSBudWxsKVxuICAgIHJldHVybiBudWxsO1xuXG4gIHZhciBjID0gZnVuY3Rpb24gKCkge307XG4gIGMucHJvdG90eXBlID0gcGFyZW50O1xuICByZXR1cm4gbmV3IGMoKTtcbn07XG5cbi8vIHByaXZhdGUgdXRpbGl0eSBmdW5jdGlvbnNcblxuZnVuY3Rpb24gX19vYmpUb1N0cihvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG5jbG9uZS5fX29ialRvU3RyID0gX19vYmpUb1N0cjtcblxuZnVuY3Rpb24gX19pc0RhdGUobykge1xuICByZXR1cm4gdHlwZW9mIG8gPT09ICdvYmplY3QnICYmIF9fb2JqVG9TdHIobykgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmNsb25lLl9faXNEYXRlID0gX19pc0RhdGU7XG5cbmZ1bmN0aW9uIF9faXNBcnJheShvKSB7XG4gIHJldHVybiB0eXBlb2YgbyA9PT0gJ29iamVjdCcgJiYgX19vYmpUb1N0cihvKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn1cbmNsb25lLl9faXNBcnJheSA9IF9faXNBcnJheTtcblxuZnVuY3Rpb24gX19pc1JlZ0V4cChvKSB7XG4gIHJldHVybiB0eXBlb2YgbyA9PT0gJ29iamVjdCcgJiYgX19vYmpUb1N0cihvKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5jbG9uZS5fX2lzUmVnRXhwID0gX19pc1JlZ0V4cDtcblxuZnVuY3Rpb24gX19nZXRSZWdFeHBGbGFncyhyZSkge1xuICB2YXIgZmxhZ3MgPSAnJztcbiAgaWYgKHJlLmdsb2JhbCkgZmxhZ3MgKz0gJ2cnO1xuICBpZiAocmUuaWdub3JlQ2FzZSkgZmxhZ3MgKz0gJ2knO1xuICBpZiAocmUubXVsdGlsaW5lKSBmbGFncyArPSAnbSc7XG4gIHJldHVybiBmbGFncztcbn1cbmNsb25lLl9fZ2V0UmVnRXhwRmxhZ3MgPSBfX2dldFJlZ0V4cEZsYWdzO1xuXG5yZXR1cm4gY2xvbmU7XG59KSgpO1xuXG5pZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBjbG9uZTtcbn1cblxufSx7fV0sMTAxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGFzYXAgPSByZXF1aXJlKCdhc2FwL3JhdycpO1xuXG5mdW5jdGlvbiBub29wKCkge31cblxuLy8gU3RhdGVzOlxuLy9cbi8vIDAgLSBwZW5kaW5nXG4vLyAxIC0gZnVsZmlsbGVkIHdpdGggX3ZhbHVlXG4vLyAyIC0gcmVqZWN0ZWQgd2l0aCBfdmFsdWVcbi8vIDMgLSBhZG9wdGVkIHRoZSBzdGF0ZSBvZiBhbm90aGVyIHByb21pc2UsIF92YWx1ZVxuLy9cbi8vIG9uY2UgdGhlIHN0YXRlIGlzIG5vIGxvbmdlciBwZW5kaW5nICgwKSBpdCBpcyBpbW11dGFibGVcblxuLy8gQWxsIGBfYCBwcmVmaXhlZCBwcm9wZXJ0aWVzIHdpbGwgYmUgcmVkdWNlZCB0byBgX3tyYW5kb20gbnVtYmVyfWBcbi8vIGF0IGJ1aWxkIHRpbWUgdG8gb2JmdXNjYXRlIHRoZW0gYW5kIGRpc2NvdXJhZ2UgdGhlaXIgdXNlLlxuLy8gV2UgZG9uJ3QgdXNlIHN5bWJvbHMgb3IgT2JqZWN0LmRlZmluZVByb3BlcnR5IHRvIGZ1bGx5IGhpZGUgdGhlbVxuLy8gYmVjYXVzZSB0aGUgcGVyZm9ybWFuY2UgaXNuJ3QgZ29vZCBlbm91Z2guXG5cblxuLy8gdG8gYXZvaWQgdXNpbmcgdHJ5L2NhdGNoIGluc2lkZSBjcml0aWNhbCBmdW5jdGlvbnMsIHdlXG4vLyBleHRyYWN0IHRoZW0gdG8gaGVyZS5cbnZhciBMQVNUX0VSUk9SID0gbnVsbDtcbnZhciBJU19FUlJPUiA9IHt9O1xuZnVuY3Rpb24gZ2V0VGhlbihvYmopIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gb2JqLnRoZW47XG4gIH0gY2F0Y2ggKGV4KSB7XG4gICAgTEFTVF9FUlJPUiA9IGV4O1xuICAgIHJldHVybiBJU19FUlJPUjtcbiAgfVxufVxuXG5mdW5jdGlvbiB0cnlDYWxsT25lKGZuLCBhKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGZuKGEpO1xuICB9IGNhdGNoIChleCkge1xuICAgIExBU1RfRVJST1IgPSBleDtcbiAgICByZXR1cm4gSVNfRVJST1I7XG4gIH1cbn1cbmZ1bmN0aW9uIHRyeUNhbGxUd28oZm4sIGEsIGIpIHtcbiAgdHJ5IHtcbiAgICBmbihhLCBiKTtcbiAgfSBjYXRjaCAoZXgpIHtcbiAgICBMQVNUX0VSUk9SID0gZXg7XG4gICAgcmV0dXJuIElTX0VSUk9SO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvbWlzZTtcblxuZnVuY3Rpb24gUHJvbWlzZShmbikge1xuICBpZiAodHlwZW9mIHRoaXMgIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUHJvbWlzZXMgbXVzdCBiZSBjb25zdHJ1Y3RlZCB2aWEgbmV3Jyk7XG4gIH1cbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Byb21pc2UgY29uc3RydWN0b3JcXCdzIGFyZ3VtZW50IGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG4gIH1cbiAgdGhpcy5fNDAgPSAwO1xuICB0aGlzLl82NSA9IDA7XG4gIHRoaXMuXzU1ID0gbnVsbDtcbiAgdGhpcy5fNzIgPSBudWxsO1xuICBpZiAoZm4gPT09IG5vb3ApIHJldHVybjtcbiAgZG9SZXNvbHZlKGZuLCB0aGlzKTtcbn1cblByb21pc2UuXzM3ID0gbnVsbDtcblByb21pc2UuXzg3ID0gbnVsbDtcblByb21pc2UuXzYxID0gbm9vcDtcblxuUHJvbWlzZS5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gIGlmICh0aGlzLmNvbnN0cnVjdG9yICE9PSBQcm9taXNlKSB7XG4gICAgcmV0dXJuIHNhZmVUaGVuKHRoaXMsIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKTtcbiAgfVxuICB2YXIgcmVzID0gbmV3IFByb21pc2Uobm9vcCk7XG4gIGhhbmRsZSh0aGlzLCBuZXcgSGFuZGxlcihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgcmVzKSk7XG4gIHJldHVybiByZXM7XG59O1xuXG5mdW5jdGlvbiBzYWZlVGhlbihzZWxmLCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICByZXR1cm4gbmV3IHNlbGYuY29uc3RydWN0b3IoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciByZXMgPSBuZXcgUHJvbWlzZShub29wKTtcbiAgICByZXMudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgIGhhbmRsZShzZWxmLCBuZXcgSGFuZGxlcihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgcmVzKSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gaGFuZGxlKHNlbGYsIGRlZmVycmVkKSB7XG4gIHdoaWxlIChzZWxmLl82NSA9PT0gMykge1xuICAgIHNlbGYgPSBzZWxmLl81NTtcbiAgfVxuICBpZiAoUHJvbWlzZS5fMzcpIHtcbiAgICBQcm9taXNlLl8zNyhzZWxmKTtcbiAgfVxuICBpZiAoc2VsZi5fNjUgPT09IDApIHtcbiAgICBpZiAoc2VsZi5fNDAgPT09IDApIHtcbiAgICAgIHNlbGYuXzQwID0gMTtcbiAgICAgIHNlbGYuXzcyID0gZGVmZXJyZWQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChzZWxmLl80MCA9PT0gMSkge1xuICAgICAgc2VsZi5fNDAgPSAyO1xuICAgICAgc2VsZi5fNzIgPSBbc2VsZi5fNzIsIGRlZmVycmVkXTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2VsZi5fNzIucHVzaChkZWZlcnJlZCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGhhbmRsZVJlc29sdmVkKHNlbGYsIGRlZmVycmVkKTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlUmVzb2x2ZWQoc2VsZiwgZGVmZXJyZWQpIHtcbiAgYXNhcChmdW5jdGlvbigpIHtcbiAgICB2YXIgY2IgPSBzZWxmLl82NSA9PT0gMSA/IGRlZmVycmVkLm9uRnVsZmlsbGVkIDogZGVmZXJyZWQub25SZWplY3RlZDtcbiAgICBpZiAoY2IgPT09IG51bGwpIHtcbiAgICAgIGlmIChzZWxmLl82NSA9PT0gMSkge1xuICAgICAgICByZXNvbHZlKGRlZmVycmVkLnByb21pc2UsIHNlbGYuXzU1KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlamVjdChkZWZlcnJlZC5wcm9taXNlLCBzZWxmLl81NSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciByZXQgPSB0cnlDYWxsT25lKGNiLCBzZWxmLl81NSk7XG4gICAgaWYgKHJldCA9PT0gSVNfRVJST1IpIHtcbiAgICAgIHJlamVjdChkZWZlcnJlZC5wcm9taXNlLCBMQVNUX0VSUk9SKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzb2x2ZShkZWZlcnJlZC5wcm9taXNlLCByZXQpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiByZXNvbHZlKHNlbGYsIG5ld1ZhbHVlKSB7XG4gIC8vIFByb21pc2UgUmVzb2x1dGlvbiBQcm9jZWR1cmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9wcm9taXNlcy1hcGx1cy9wcm9taXNlcy1zcGVjI3RoZS1wcm9taXNlLXJlc29sdXRpb24tcHJvY2VkdXJlXG4gIGlmIChuZXdWYWx1ZSA9PT0gc2VsZikge1xuICAgIHJldHVybiByZWplY3QoXG4gICAgICBzZWxmLFxuICAgICAgbmV3IFR5cGVFcnJvcignQSBwcm9taXNlIGNhbm5vdCBiZSByZXNvbHZlZCB3aXRoIGl0c2VsZi4nKVxuICAgICk7XG4gIH1cbiAgaWYgKFxuICAgIG5ld1ZhbHVlICYmXG4gICAgKHR5cGVvZiBuZXdWYWx1ZSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIG5ld1ZhbHVlID09PSAnZnVuY3Rpb24nKVxuICApIHtcbiAgICB2YXIgdGhlbiA9IGdldFRoZW4obmV3VmFsdWUpO1xuICAgIGlmICh0aGVuID09PSBJU19FUlJPUikge1xuICAgICAgcmV0dXJuIHJlamVjdChzZWxmLCBMQVNUX0VSUk9SKTtcbiAgICB9XG4gICAgaWYgKFxuICAgICAgdGhlbiA9PT0gc2VsZi50aGVuICYmXG4gICAgICBuZXdWYWx1ZSBpbnN0YW5jZW9mIFByb21pc2VcbiAgICApIHtcbiAgICAgIHNlbGYuXzY1ID0gMztcbiAgICAgIHNlbGYuXzU1ID0gbmV3VmFsdWU7XG4gICAgICBmaW5hbGUoc2VsZik7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZG9SZXNvbHZlKHRoZW4uYmluZChuZXdWYWx1ZSksIHNlbGYpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBzZWxmLl82NSA9IDE7XG4gIHNlbGYuXzU1ID0gbmV3VmFsdWU7XG4gIGZpbmFsZShzZWxmKTtcbn1cblxuZnVuY3Rpb24gcmVqZWN0KHNlbGYsIG5ld1ZhbHVlKSB7XG4gIHNlbGYuXzY1ID0gMjtcbiAgc2VsZi5fNTUgPSBuZXdWYWx1ZTtcbiAgaWYgKFByb21pc2UuXzg3KSB7XG4gICAgUHJvbWlzZS5fODcoc2VsZiwgbmV3VmFsdWUpO1xuICB9XG4gIGZpbmFsZShzZWxmKTtcbn1cbmZ1bmN0aW9uIGZpbmFsZShzZWxmKSB7XG4gIGlmIChzZWxmLl80MCA9PT0gMSkge1xuICAgIGhhbmRsZShzZWxmLCBzZWxmLl83Mik7XG4gICAgc2VsZi5fNzIgPSBudWxsO1xuICB9XG4gIGlmIChzZWxmLl80MCA9PT0gMikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5fNzIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGhhbmRsZShzZWxmLCBzZWxmLl83MltpXSk7XG4gICAgfVxuICAgIHNlbGYuXzcyID0gbnVsbDtcbiAgfVxufVxuXG5mdW5jdGlvbiBIYW5kbGVyKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBwcm9taXNlKXtcbiAgdGhpcy5vbkZ1bGZpbGxlZCA9IHR5cGVvZiBvbkZ1bGZpbGxlZCA9PT0gJ2Z1bmN0aW9uJyA/IG9uRnVsZmlsbGVkIDogbnVsbDtcbiAgdGhpcy5vblJlamVjdGVkID0gdHlwZW9mIG9uUmVqZWN0ZWQgPT09ICdmdW5jdGlvbicgPyBvblJlamVjdGVkIDogbnVsbDtcbiAgdGhpcy5wcm9taXNlID0gcHJvbWlzZTtcbn1cblxuLyoqXG4gKiBUYWtlIGEgcG90ZW50aWFsbHkgbWlzYmVoYXZpbmcgcmVzb2x2ZXIgZnVuY3Rpb24gYW5kIG1ha2Ugc3VyZVxuICogb25GdWxmaWxsZWQgYW5kIG9uUmVqZWN0ZWQgYXJlIG9ubHkgY2FsbGVkIG9uY2UuXG4gKlxuICogTWFrZXMgbm8gZ3VhcmFudGVlcyBhYm91dCBhc3luY2hyb255LlxuICovXG5mdW5jdGlvbiBkb1Jlc29sdmUoZm4sIHByb21pc2UpIHtcbiAgdmFyIGRvbmUgPSBmYWxzZTtcbiAgdmFyIHJlcyA9IHRyeUNhbGxUd28oZm4sIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmIChkb25lKSByZXR1cm47XG4gICAgZG9uZSA9IHRydWU7XG4gICAgcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgIGRvbmUgPSB0cnVlO1xuICAgIHJlamVjdChwcm9taXNlLCByZWFzb24pO1xuICB9KTtcbiAgaWYgKCFkb25lICYmIHJlcyA9PT0gSVNfRVJST1IpIHtcbiAgICBkb25lID0gdHJ1ZTtcbiAgICByZWplY3QocHJvbWlzZSwgTEFTVF9FUlJPUik7XG4gIH1cbn1cblxufSx7XCJhc2FwL3Jhd1wiOjk5fV0sMTAyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuLy9UaGlzIGZpbGUgY29udGFpbnMgdGhlIEVTNiBleHRlbnNpb25zIHRvIHRoZSBjb3JlIFByb21pc2VzL0ErIEFQSVxuXG52YXIgUHJvbWlzZSA9IHJlcXVpcmUoJy4vY29yZS5qcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFByb21pc2U7XG5cbi8qIFN0YXRpYyBGdW5jdGlvbnMgKi9cblxudmFyIFRSVUUgPSB2YWx1ZVByb21pc2UodHJ1ZSk7XG52YXIgRkFMU0UgPSB2YWx1ZVByb21pc2UoZmFsc2UpO1xudmFyIE5VTEwgPSB2YWx1ZVByb21pc2UobnVsbCk7XG52YXIgVU5ERUZJTkVEID0gdmFsdWVQcm9taXNlKHVuZGVmaW5lZCk7XG52YXIgWkVSTyA9IHZhbHVlUHJvbWlzZSgwKTtcbnZhciBFTVBUWVNUUklORyA9IHZhbHVlUHJvbWlzZSgnJyk7XG5cbmZ1bmN0aW9uIHZhbHVlUHJvbWlzZSh2YWx1ZSkge1xuICB2YXIgcCA9IG5ldyBQcm9taXNlKFByb21pc2UuXzYxKTtcbiAgcC5fNjUgPSAxO1xuICBwLl81NSA9IHZhbHVlO1xuICByZXR1cm4gcDtcbn1cblByb21pc2UucmVzb2x2ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlKSByZXR1cm4gdmFsdWU7XG5cbiAgaWYgKHZhbHVlID09PSBudWxsKSByZXR1cm4gTlVMTDtcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybiBVTkRFRklORUQ7XG4gIGlmICh2YWx1ZSA9PT0gdHJ1ZSkgcmV0dXJuIFRSVUU7XG4gIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHJldHVybiBGQUxTRTtcbiAgaWYgKHZhbHVlID09PSAwKSByZXR1cm4gWkVSTztcbiAgaWYgKHZhbHVlID09PSAnJykgcmV0dXJuIEVNUFRZU1RSSU5HO1xuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRyeSB7XG4gICAgICB2YXIgdGhlbiA9IHZhbHVlLnRoZW47XG4gICAgICBpZiAodHlwZW9mIHRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHRoZW4uYmluZCh2YWx1ZSkpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICByZWplY3QoZXgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZVByb21pc2UodmFsdWUpO1xufTtcblxuUHJvbWlzZS5hbGwgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJyKTtcblxuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHJlc29sdmUoW10pO1xuICAgIHZhciByZW1haW5pbmcgPSBhcmdzLmxlbmd0aDtcbiAgICBmdW5jdGlvbiByZXMoaSwgdmFsKSB7XG4gICAgICBpZiAodmFsICYmICh0eXBlb2YgdmFsID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKSkge1xuICAgICAgICBpZiAodmFsIGluc3RhbmNlb2YgUHJvbWlzZSAmJiB2YWwudGhlbiA9PT0gUHJvbWlzZS5wcm90b3R5cGUudGhlbikge1xuICAgICAgICAgIHdoaWxlICh2YWwuXzY1ID09PSAzKSB7XG4gICAgICAgICAgICB2YWwgPSB2YWwuXzU1O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmFsLl82NSA9PT0gMSkgcmV0dXJuIHJlcyhpLCB2YWwuXzU1KTtcbiAgICAgICAgICBpZiAodmFsLl82NSA9PT0gMikgcmVqZWN0KHZhbC5fNTUpO1xuICAgICAgICAgIHZhbC50aGVuKGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHJlcyhpLCB2YWwpO1xuICAgICAgICAgIH0sIHJlamVjdCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciB0aGVuID0gdmFsLnRoZW47XG4gICAgICAgICAgaWYgKHR5cGVvZiB0aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YXIgcCA9IG5ldyBQcm9taXNlKHRoZW4uYmluZCh2YWwpKTtcbiAgICAgICAgICAgIHAudGhlbihmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICAgIHJlcyhpLCB2YWwpO1xuICAgICAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGFyZ3NbaV0gPSB2YWw7XG4gICAgICBpZiAoLS1yZW1haW5pbmcgPT09IDApIHtcbiAgICAgICAgcmVzb2x2ZShhcmdzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXMoaSwgYXJnc1tpXSk7XG4gICAgfVxuICB9KTtcbn07XG5cblByb21pc2UucmVqZWN0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgcmVqZWN0KHZhbHVlKTtcbiAgfSk7XG59O1xuXG5Qcm9taXNlLnJhY2UgPSBmdW5jdGlvbiAodmFsdWVzKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFsdWVzLmZvckVhY2goZnVuY3Rpb24odmFsdWUpe1xuICAgICAgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgfSk7XG4gIH0pO1xufTtcblxuLyogUHJvdG90eXBlIE1ldGhvZHMgKi9cblxuUHJvbWlzZS5wcm90b3R5cGVbJ2NhdGNoJ10gPSBmdW5jdGlvbiAob25SZWplY3RlZCkge1xuICByZXR1cm4gdGhpcy50aGVuKG51bGwsIG9uUmVqZWN0ZWQpO1xufTtcblxufSx7XCIuL2NvcmUuanNcIjoxMDF9XSwxMDM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLy8gc2hvdWxkIHdvcmsgaW4gYW55IGJyb3dzZXIgd2l0aG91dCBicm93c2VyaWZ5XG5cbmlmICh0eXBlb2YgUHJvbWlzZS5wcm90b3R5cGUuZG9uZSAhPT0gJ2Z1bmN0aW9uJykge1xuICBQcm9taXNlLnByb3RvdHlwZS5kb25lID0gZnVuY3Rpb24gKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgdmFyIHNlbGYgPSBhcmd1bWVudHMubGVuZ3RoID8gdGhpcy50aGVuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiB0aGlzXG4gICAgc2VsZi50aGVuKG51bGwsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBlcnJcbiAgICAgIH0sIDApXG4gICAgfSlcbiAgfVxufVxufSx7fV0sMTA0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8vIG5vdCBcInVzZSBzdHJpY3RcIiBzbyB3ZSBjYW4gZGVjbGFyZSBnbG9iYWwgXCJQcm9taXNlXCJcblxudmFyIGFzYXAgPSByZXF1aXJlKCdhc2FwJyk7XG5cbmlmICh0eXBlb2YgUHJvbWlzZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgUHJvbWlzZSA9IHJlcXVpcmUoJy4vbGliL2NvcmUuanMnKVxuICByZXF1aXJlKCcuL2xpYi9lczYtZXh0ZW5zaW9ucy5qcycpXG59XG5cbnJlcXVpcmUoJy4vcG9seWZpbGwtZG9uZS5qcycpO1xuXG59LHtcIi4vbGliL2NvcmUuanNcIjoxMDEsXCIuL2xpYi9lczYtZXh0ZW5zaW9ucy5qc1wiOjEwMixcIi4vcG9seWZpbGwtZG9uZS5qc1wiOjEwMyxcImFzYXBcIjo5OH1dfSx7fSxbMl0pKDIpXG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sZXNzL2Rpc3QvbGVzcy5qc1xuLy8gbW9kdWxlIGlkID0gMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///13\n");

/***/ }),
/* 14 */
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  for (var i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(\n      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\n    ))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzPzEwYWIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxuLy8gU3VwcG9ydCBkZWNvZGluZyBVUkwtc2FmZSBiYXNlNjQgc3RyaW5ncywgYXMgTm9kZS5qcyBkb2VzLlxuLy8gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXNlNjQjVVJMX2FwcGxpY2F0aW9uc1xucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gZ2V0TGVucyAoYjY0KSB7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIFRyaW0gb2ZmIGV4dHJhIGJ5dGVzIGFmdGVyIHBsYWNlaG9sZGVyIGJ5dGVzIGFyZSBmb3VuZFxuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9iZWF0Z2FtbWl0L2Jhc2U2NC1qcy9pc3N1ZXMvNDJcbiAgdmFyIHZhbGlkTGVuID0gYjY0LmluZGV4T2YoJz0nKVxuICBpZiAodmFsaWRMZW4gPT09IC0xKSB2YWxpZExlbiA9IGxlblxuXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSB2YWxpZExlbiA9PT0gbGVuXG4gICAgPyAwXG4gICAgOiA0IC0gKHZhbGlkTGVuICUgNClcblxuICByZXR1cm4gW3ZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW5dXG59XG5cbi8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIF9ieXRlTGVuZ3RoIChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pIHtcbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG5cbiAgdmFyIGFyciA9IG5ldyBBcnIoX2J5dGVMZW5ndGgoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSlcblxuICB2YXIgY3VyQnl0ZSA9IDBcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIHZhciBsZW4gPSBwbGFjZUhvbGRlcnNMZW4gPiAwXG4gICAgPyB2YWxpZExlbiAtIDRcbiAgICA6IHZhbGlkTGVuXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfFxuICAgICAgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV1cbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDIpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAxKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID1cbiAgICAgICgodWludDhbaV0gPDwgMTYpICYgMHhGRjAwMDApICtcbiAgICAgICgodWludDhbaSArIDFdIDw8IDgpICYgMHhGRjAwKSArXG4gICAgICAodWludDhbaSArIDJdICYgMHhGRilcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSlcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aFxuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDMgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayhcbiAgICAgIHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aClcbiAgICApKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXSArXG4gICAgICAnPT0nXG4gICAgKVxuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDEwXSArXG4gICAgICBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl0gK1xuICAgICAgJz0nXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///14\n");

/***/ }),
/* 15 */
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports) {

eval("exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcz9iYTM3Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gKGUgKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gKG0gKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcbiAgICBlID0gZSAtIGVCaWFzXG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgY1xuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAoKHZhbHVlICogYykgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///15\n");

/***/ }),
/* 16 */
/*!***************************************!*\
  !*** ./node_modules/isarray/index.js ***!
  \***************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports) {

eval("var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaXNhcnJheS9pbmRleC5qcz9iMGU0Il0sInNvdXJjZXNDb250ZW50IjpbInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvaXNhcnJheS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///16\n");

/***/ }),
/* 17 */
/*!********************************************************!*\
  !*** ./src/components/raw-textarea/raw-js-textarea.js ***!
  \********************************************************/
/*! exports provided: default */
/*! exports used: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_js_base64__ = __webpack_require__(/*! js-base64 */ 0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_js_base64___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_js_base64__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_classnames__ = __webpack_require__(/*! classnames */ 5);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_classnames___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_classnames__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_uglifyjs_browser__ = __webpack_require__(/*! uglifyjs-browser */ 18);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_uglifyjs_browser___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_uglifyjs_browser__);\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n// Import Base64\n\n// Import classnames\n\n// Import Uglify\n\n\nvar _wp$element = wp.element,\n    Component = _wp$element.Component,\n    Fragment = _wp$element.Fragment;\nvar _wp$components = wp.components,\n    TextareaControl = _wp$components.TextareaControl,\n    ButtonGroup = _wp$components.ButtonGroup,\n    Button = _wp$components.Button;\n\nvar RawJSTextareaControl = function (_Component) {\n  _inherits(RawJSTextareaControl, _Component);\n\n  function RawJSTextareaControl() {\n    _classCallCheck(this, RawJSTextareaControl);\n\n    var _this = _possibleConstructorReturn(this, (RawJSTextareaControl.__proto__ || Object.getPrototypeOf(RawJSTextareaControl)).apply(this, arguments));\n\n    _this.state = {\n      err: false\n    };\n    return _this;\n  }\n\n  _createClass(RawJSTextareaControl, [{\n    key: 'render',\n    value: function render() {\n      var _this2 = this;\n\n      var jsStyleTypes = {\n        js: 'JS',\n        babel: 'Babel'\n      };\n\n      var setError = function setError(err) {\n        return _this2.setState({ err: err });\n      };\n\n      var minify = function minify(js) {\n        if (!js) return js;\n\n        var result = __WEBPACK_IMPORTED_MODULE_2_uglifyjs_browser___default.a.minify(js);\n\n        if (result.error) {\n          setError(true);\n          // console.error( 'uglify error', result.error );\n          return js;\n        }\n\n        return result.code;\n      };\n\n      var onParamUpdate = function onParamUpdate(js) {\n        _this2.props.params.min = __WEBPACK_IMPORTED_MODULE_0_js_base64__[\"Base64\"].encode(_this2.props.params.minEnabled ? minify(js) : js);\n\n        _this2.props.onParamsChange(_this2.props.params);\n      };\n\n      var onParamChange = function onParamChange(js) {\n        if (!js) {\n          onParamUpdate(js);\n          return;\n        }\n\n        if (_this2.props.params.type === 'babel') {\n          try {\n            setError(false);\n            onParamUpdate(Babel.transform(js, { presets: [['es2015', { modules: false }]] }).code);\n          } catch (ex) {\n            // console.error('babel error: ' + ex.message);\n            setError(true);\n            onParamUpdate(js);\n          }\n        } else {\n          setError(false);\n          onParamUpdate(js);\n        }\n      };\n\n      var onJSChange = function onJSChange(js) {\n        _this2.props.onJSChange(__WEBPACK_IMPORTED_MODULE_0_js_base64__[\"Base64\"].encode(js));\n\n        onParamChange(js);\n      };\n\n      var onMinifyToggle = function onMinifyToggle() {\n        _this2.props.params.minEnabled = !_this2.props.params.minEnabled;\n        onParamChange(__WEBPACK_IMPORTED_MODULE_0_js_base64__[\"Base64\"].decode(_this2.props.js));\n      };\n\n      var onTypeChange = function onTypeChange(type) {\n        _this2.props.params.type = type;\n        onParamChange(__WEBPACK_IMPORTED_MODULE_0_js_base64__[\"Base64\"].decode(_this2.props.js));\n      };\n\n      var styleType = Object.keys(jsStyleTypes).indexOf(this.props.params.type) > -1 ? this.props.params.type : 'js';\n\n      return wp.element.createElement(\n        Fragment,\n        null,\n        wp.element.createElement(\n          'div',\n          { className: 'components-base-control mcw-textarea-comp' },\n          wp.element.createElement(\n            'label',\n            null,\n            this.props.label\n          ),\n          wp.element.createElement(\n            ButtonGroup,\n            { className: 'mcw-textarea-button-group' },\n            wp.element.createElement(\n              Button,\n              {\n                className: 'mcw-textarea-btn mcw-textarea-btn-margright',\n                isSmall: true,\n                isPrimary: this.props.params.minEnabled,\n                'aria-pressed': this.props.params.minEnabled,\n                onClick: function onClick() {\n                  return onMinifyToggle();\n                }\n              },\n              this.props.minifyLabel\n            ),\n            Object.keys(jsStyleTypes).map(function (key) {\n              return wp.element.createElement(\n                Button,\n                {\n                  key: key,\n                  className: 'mcw-textarea-btn',\n                  isSmall: true,\n                  isPrimary: styleType === key,\n                  'aria-pressed': styleType === key,\n                  onClick: function onClick() {\n                    return onTypeChange(key);\n                  }\n                },\n                jsStyleTypes[key]\n              );\n            })\n          ),\n          wp.element.createElement(\n            'div',\n            { className: __WEBPACK_IMPORTED_MODULE_1_classnames___default()('mcw-textarea-comp-inner', { 'mcw-textarea-comp-error': this.state.err }) },\n            wp.element.createElement(\n              'p',\n              { className: 'mcw-textarea-def' },\n              '<script type=\"text/javascript\">'\n            ),\n            wp.element.createElement(TextareaControl, {\n              rows: 12,\n              value: __WEBPACK_IMPORTED_MODULE_0_js_base64__[\"Base64\"].decode(this.props.js),\n              onChange: function onChange(value) {\n                return onJSChange(value);\n              }\n            }),\n            wp.element.createElement(\n              'p',\n              { className: 'mcw-textarea-def' },\n              '</script>'\n            )\n          )\n        )\n      );\n    }\n  }]);\n\n  return RawJSTextareaControl;\n}(Component);\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (RawJSTextareaControl);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9yYXctdGV4dGFyZWEvcmF3LWpzLXRleHRhcmVhLmpzP2RhMjQiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4vLyBJbXBvcnQgQmFzZTY0XG5pbXBvcnQgeyBCYXNlNjQgfSBmcm9tICdqcy1iYXNlNjQnO1xuLy8gSW1wb3J0IGNsYXNzbmFtZXNcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuLy8gSW1wb3J0IFVnbGlmeVxuaW1wb3J0IHVnbGlmeSBmcm9tICd1Z2xpZnlqcy1icm93c2VyJztcblxudmFyIF93cCRlbGVtZW50ID0gd3AuZWxlbWVudCxcbiAgICBDb21wb25lbnQgPSBfd3AkZWxlbWVudC5Db21wb25lbnQsXG4gICAgRnJhZ21lbnQgPSBfd3AkZWxlbWVudC5GcmFnbWVudDtcbnZhciBfd3AkY29tcG9uZW50cyA9IHdwLmNvbXBvbmVudHMsXG4gICAgVGV4dGFyZWFDb250cm9sID0gX3dwJGNvbXBvbmVudHMuVGV4dGFyZWFDb250cm9sLFxuICAgIEJ1dHRvbkdyb3VwID0gX3dwJGNvbXBvbmVudHMuQnV0dG9uR3JvdXAsXG4gICAgQnV0dG9uID0gX3dwJGNvbXBvbmVudHMuQnV0dG9uO1xuXG52YXIgUmF3SlNUZXh0YXJlYUNvbnRyb2wgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoUmF3SlNUZXh0YXJlYUNvbnRyb2wsIF9Db21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFJhd0pTVGV4dGFyZWFDb250cm9sKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSYXdKU1RleHRhcmVhQ29udHJvbCk7XG5cbiAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoUmF3SlNUZXh0YXJlYUNvbnRyb2wuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihSYXdKU1RleHRhcmVhQ29udHJvbCkpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuXG4gICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICBlcnI6IGZhbHNlXG4gICAgfTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUmF3SlNUZXh0YXJlYUNvbnRyb2wsIFt7XG4gICAga2V5OiAncmVuZGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBqc1N0eWxlVHlwZXMgPSB7XG4gICAgICAgIGpzOiAnSlMnLFxuICAgICAgICBiYWJlbDogJ0JhYmVsJ1xuICAgICAgfTtcblxuICAgICAgdmFyIHNldEVycm9yID0gZnVuY3Rpb24gc2V0RXJyb3IoZXJyKSB7XG4gICAgICAgIHJldHVybiBfdGhpczIuc2V0U3RhdGUoeyBlcnI6IGVyciB9KTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBtaW5pZnkgPSBmdW5jdGlvbiBtaW5pZnkoanMpIHtcbiAgICAgICAgaWYgKCFqcykgcmV0dXJuIGpzO1xuXG4gICAgICAgIHZhciByZXN1bHQgPSB1Z2xpZnkubWluaWZ5KGpzKTtcblxuICAgICAgICBpZiAocmVzdWx0LmVycm9yKSB7XG4gICAgICAgICAgc2V0RXJyb3IodHJ1ZSk7XG4gICAgICAgICAgLy8gY29uc29sZS5lcnJvciggJ3VnbGlmeSBlcnJvcicsIHJlc3VsdC5lcnJvciApO1xuICAgICAgICAgIHJldHVybiBqcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQuY29kZTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBvblBhcmFtVXBkYXRlID0gZnVuY3Rpb24gb25QYXJhbVVwZGF0ZShqcykge1xuICAgICAgICBfdGhpczIucHJvcHMucGFyYW1zLm1pbiA9IEJhc2U2NC5lbmNvZGUoX3RoaXMyLnByb3BzLnBhcmFtcy5taW5FbmFibGVkID8gbWluaWZ5KGpzKSA6IGpzKTtcblxuICAgICAgICBfdGhpczIucHJvcHMub25QYXJhbXNDaGFuZ2UoX3RoaXMyLnByb3BzLnBhcmFtcyk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgb25QYXJhbUNoYW5nZSA9IGZ1bmN0aW9uIG9uUGFyYW1DaGFuZ2UoanMpIHtcbiAgICAgICAgaWYgKCFqcykge1xuICAgICAgICAgIG9uUGFyYW1VcGRhdGUoanMpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfdGhpczIucHJvcHMucGFyYW1zLnR5cGUgPT09ICdiYWJlbCcpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgc2V0RXJyb3IoZmFsc2UpO1xuICAgICAgICAgICAgb25QYXJhbVVwZGF0ZShCYWJlbC50cmFuc2Zvcm0oanMsIHsgcHJlc2V0czogW1snZXMyMDE1JywgeyBtb2R1bGVzOiBmYWxzZSB9XV0gfSkuY29kZSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJ2JhYmVsIGVycm9yOiAnICsgZXgubWVzc2FnZSk7XG4gICAgICAgICAgICBzZXRFcnJvcih0cnVlKTtcbiAgICAgICAgICAgIG9uUGFyYW1VcGRhdGUoanMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXRFcnJvcihmYWxzZSk7XG4gICAgICAgICAgb25QYXJhbVVwZGF0ZShqcyk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHZhciBvbkpTQ2hhbmdlID0gZnVuY3Rpb24gb25KU0NoYW5nZShqcykge1xuICAgICAgICBfdGhpczIucHJvcHMub25KU0NoYW5nZShCYXNlNjQuZW5jb2RlKGpzKSk7XG5cbiAgICAgICAgb25QYXJhbUNoYW5nZShqcyk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgb25NaW5pZnlUb2dnbGUgPSBmdW5jdGlvbiBvbk1pbmlmeVRvZ2dsZSgpIHtcbiAgICAgICAgX3RoaXMyLnByb3BzLnBhcmFtcy5taW5FbmFibGVkID0gIV90aGlzMi5wcm9wcy5wYXJhbXMubWluRW5hYmxlZDtcbiAgICAgICAgb25QYXJhbUNoYW5nZShCYXNlNjQuZGVjb2RlKF90aGlzMi5wcm9wcy5qcykpO1xuICAgICAgfTtcblxuICAgICAgdmFyIG9uVHlwZUNoYW5nZSA9IGZ1bmN0aW9uIG9uVHlwZUNoYW5nZSh0eXBlKSB7XG4gICAgICAgIF90aGlzMi5wcm9wcy5wYXJhbXMudHlwZSA9IHR5cGU7XG4gICAgICAgIG9uUGFyYW1DaGFuZ2UoQmFzZTY0LmRlY29kZShfdGhpczIucHJvcHMuanMpKTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBzdHlsZVR5cGUgPSBPYmplY3Qua2V5cyhqc1N0eWxlVHlwZXMpLmluZGV4T2YodGhpcy5wcm9wcy5wYXJhbXMudHlwZSkgPiAtMSA/IHRoaXMucHJvcHMucGFyYW1zLnR5cGUgOiAnanMnO1xuXG4gICAgICByZXR1cm4gd3AuZWxlbWVudC5jcmVhdGVFbGVtZW50KFxuICAgICAgICBGcmFnbWVudCxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgd3AuZWxlbWVudC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICdkaXYnLFxuICAgICAgICAgIHsgY2xhc3NOYW1lOiAnY29tcG9uZW50cy1iYXNlLWNvbnRyb2wgbWN3LXRleHRhcmVhLWNvbXAnIH0sXG4gICAgICAgICAgd3AuZWxlbWVudC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgJ2xhYmVsJyxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICB0aGlzLnByb3BzLmxhYmVsXG4gICAgICAgICAgKSxcbiAgICAgICAgICB3cC5lbGVtZW50LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICBCdXR0b25Hcm91cCxcbiAgICAgICAgICAgIHsgY2xhc3NOYW1lOiAnbWN3LXRleHRhcmVhLWJ1dHRvbi1ncm91cCcgfSxcbiAgICAgICAgICAgIHdwLmVsZW1lbnQuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgQnV0dG9uLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnbWN3LXRleHRhcmVhLWJ0biBtY3ctdGV4dGFyZWEtYnRuLW1hcmdyaWdodCcsXG4gICAgICAgICAgICAgICAgaXNTbWFsbDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpc1ByaW1hcnk6IHRoaXMucHJvcHMucGFyYW1zLm1pbkVuYWJsZWQsXG4gICAgICAgICAgICAgICAgJ2FyaWEtcHJlc3NlZCc6IHRoaXMucHJvcHMucGFyYW1zLm1pbkVuYWJsZWQsXG4gICAgICAgICAgICAgICAgb25DbGljazogZnVuY3Rpb24gb25DbGljaygpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBvbk1pbmlmeVRvZ2dsZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgdGhpcy5wcm9wcy5taW5pZnlMYWJlbFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGpzU3R5bGVUeXBlcykubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHdwLmVsZW1lbnQuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICBCdXR0b24sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdtY3ctdGV4dGFyZWEtYnRuJyxcbiAgICAgICAgICAgICAgICAgIGlzU21hbGw6IHRydWUsXG4gICAgICAgICAgICAgICAgICBpc1ByaW1hcnk6IHN0eWxlVHlwZSA9PT0ga2V5LFxuICAgICAgICAgICAgICAgICAgJ2FyaWEtcHJlc3NlZCc6IHN0eWxlVHlwZSA9PT0ga2V5LFxuICAgICAgICAgICAgICAgICAgb25DbGljazogZnVuY3Rpb24gb25DbGljaygpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9uVHlwZUNoYW5nZShrZXkpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAganNTdHlsZVR5cGVzW2tleV1cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKSxcbiAgICAgICAgICB3cC5lbGVtZW50LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICAgIHsgY2xhc3NOYW1lOiBjbGFzc25hbWVzKCdtY3ctdGV4dGFyZWEtY29tcC1pbm5lcicsIHsgJ21jdy10ZXh0YXJlYS1jb21wLWVycm9yJzogdGhpcy5zdGF0ZS5lcnIgfSkgfSxcbiAgICAgICAgICAgIHdwLmVsZW1lbnQuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgJ3AnLFxuICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogJ21jdy10ZXh0YXJlYS1kZWYnIH0sXG4gICAgICAgICAgICAgICc8c2NyaXB0IHR5cGU9XCJ0ZXh0L2phdmFzY3JpcHRcIj4nXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgd3AuZWxlbWVudC5jcmVhdGVFbGVtZW50KFRleHRhcmVhQ29udHJvbCwge1xuICAgICAgICAgICAgICByb3dzOiAxMixcbiAgICAgICAgICAgICAgdmFsdWU6IEJhc2U2NC5kZWNvZGUodGhpcy5wcm9wcy5qcyksXG4gICAgICAgICAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiBvbkNoYW5nZSh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvbkpTQ2hhbmdlKHZhbHVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB3cC5lbGVtZW50LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICdwJyxcbiAgICAgICAgICAgICAgeyBjbGFzc05hbWU6ICdtY3ctdGV4dGFyZWEtZGVmJyB9LFxuICAgICAgICAgICAgICAnPC9zY3JpcHQ+J1xuICAgICAgICAgICAgKVxuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUmF3SlNUZXh0YXJlYUNvbnRyb2w7XG59KENvbXBvbmVudCk7XG5cbmV4cG9ydCBkZWZhdWx0IFJhd0pTVGV4dGFyZWFDb250cm9sO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2NvbXBvbmVudHMvcmF3LXRleHRhcmVhL3Jhdy1qcy10ZXh0YXJlYS5qc1xuLy8gbW9kdWxlIGlkID0gMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///17\n");

/***/ }),
/* 18 */
/*!************************************************!*\
  !*** ./node_modules/uglifyjs-browser/build.js ***!
  \************************************************/
/*! dynamic exports provided */
/*! exports used: default */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(Buffer, global) {!function(h){\"use strict\";function e(e){return e.split(\"\")}function te(e,n){return 0<=n.indexOf(e)}function V(e,n){for(var t=0,i=n.length;t<i;++t)if(e(n[t]))return n[t]}function n(e){Object.defineProperty(e.prototype,\"stack\",{get:function(){var e=new Error(this.message);e.name=this.name;try{throw e}catch(e){return e.stack}}})}function o(e,n){this.message=e,this.defs=n}function Y(e,n,t){!0===e&&(e={});var i=e||{};if(t)for(var r in i)ae(i,r)&&!ae(n,r)&&o.croak(\"`\"+r+\"` is not a supported option\",n);for(var r in n)ae(n,r)&&(i[r]=e&&ae(e,r)?e[r]:n[r]);return i}function t(e,n){var t=0;for(var i in n)ae(n,i)&&(e[i]=n[i],t++);return t}function L(){}function ie(){return!1}function J(){return!0}function C(){return this}function B(){return null}((o.prototype=Object.create(Error.prototype)).constructor=o).prototype.name=\"DefaultsError\",n(o),o.croak=function(e,n){throw new o(e,n)};var re=function(){function e(t,i,r){var o,a=[],s=[];function e(){var e=i(t[o],o),n=e instanceof l;return n&&(e=e.v),e instanceof c?(e=e.v)instanceof f?s.push.apply(s,r?e.v.slice().reverse():e.v):s.push(e):e!==u&&(e instanceof f?a.push.apply(a,r?e.v.slice().reverse():e.v):a.push(e)),n}if(t instanceof Array)if(r){for(o=t.length;0<=--o&&!e(););a.reverse(),s.reverse()}else for(o=0;o<t.length&&!e();++o);else for(o in t)if(ae(t,o)&&e())break;return s.concat(a)}e.at_top=function(e){return new c(e)},e.splice=function(e){return new f(e)},e.last=function(e){return new l(e)};var u=e.skip={};function c(e){this.v=e}function f(e){this.v=e}function l(e){this.v=e}return e}();function v(e,n){e.indexOf(n)<0&&e.push(n)}function S(e,t){return e.replace(/\\{(.+?)\\}/g,function(e,n){return t&&t[n]})}function T(e,n){for(var t=e.length;0<=--t;)e[t]===n&&e.splice(t,1)}function s(e,a){if(e.length<2)return e.slice();return function e(n){if(n.length<=1)return n;var t=Math.floor(n.length/2),i=n.slice(0,t),r=n.slice(t);return function(e,n){for(var t=[],i=0,r=0,o=0;i<e.length&&r<n.length;)a(e[i],n[r])<=0?t[o++]=e[i++]:t[o++]=n[r++];return i<e.length&&t.push.apply(t,e.slice(i)),r<n.length&&t.push.apply(t,n.slice(r)),t}(i=e(i),r=e(r))}(e)}function W(e){e instanceof Array||(e=e.split(\" \"));var t=\"\",n=[];e:for(var i=0;i<e.length;++i){for(var r=0;r<n.length;++r)if(n[r][0].length==e[i].length){n[r].push(e[i]);continue e}n.push([e[i]])}function o(e){return JSON.stringify(e).replace(/[\\u2028\\u2029]/g,function(e){switch(e){case\"\\u2028\":return\"\\\\u2028\";case\"\\u2029\":return\"\\\\u2029\"}return e})}function a(e){if(1==e.length)return t+=\"return str === \"+o(e[0])+\";\";t+=\"switch(str){\";for(var n=0;n<e.length;++n)t+=\"case \"+o(e[n])+\":\";t+=\"return true}return false;\"}if(3<n.length){n.sort(function(e,n){return n.length-e.length}),t+=\"switch(str.length){\";for(i=0;i<n.length;++i){var s=n[i];t+=\"case \"+s[0].length+\":\",a(s)}t+=\"}\"}else a(e);return new Function(\"str\",t)}function oe(e,n){for(var t=e.length;0<=--t;)if(!n(e[t]))return!1;return!0}function O(){this._values=Object.create(null),this._size=0}function ae(e,n){return Object.prototype.hasOwnProperty.call(e,n)}function $(e){for(var n,t=e.parent(-1),i=0;n=e.parent(i);i++){if(n instanceof ue&&n.body===t)return!0;if(!(n instanceof We&&n.expressions[0]===t||\"Call\"==n.TYPE&&n.expression===t||n instanceof Xe&&n.expression===t||n instanceof Ze&&n.expression===t||n instanceof tn&&n.condition===t||n instanceof nn&&n.left===t||n instanceof en&&n.expression===t))return!1;t=n}}function i(e,n,t,i){arguments.length<4&&(i=se);var r=n=n?n.split(/\\s+/):[];i&&i.PROPS&&(n=n.concat(i.PROPS));for(var o=\"return function AST_\"+e+\"(props){ if (props) { \",a=n.length;0<=--a;)o+=\"this.\"+n[a]+\" = props.\"+n[a]+\";\";var s=i&&new i;(s&&s.initialize||t&&t.initialize)&&(o+=\"this.initialize();\"),o+=\"}}\";var u=new Function(o)();if(s&&(u.prototype=s,u.BASE=i),i&&i.SUBCLASSES.push(u),(u.prototype.CTOR=u).PROPS=n||null,u.SELF_PROPS=r,u.SUBCLASSES=[],e&&(u.prototype.TYPE=u.TYPE=e),t)for(a in t)ae(t,a)&&(/^\\$/.test(a)?u[a.substr(1)]=t[a]:u.prototype[a]=t[a]);return u.DEFMETHOD=function(e,n){this.prototype[e]=n},void 0!==h&&(h[\"AST_\"+e]=u),u}O.prototype={set:function(e,n){return this.has(e)||++this._size,this._values[\"$\"+e]=n,this},add:function(e,n){return this.has(e)?this.get(e).push(n):this.set(e,[n]),this},get:function(e){return this._values[\"$\"+e]},del:function(e){return this.has(e)&&(--this._size,delete this._values[\"$\"+e]),this},has:function(e){return\"$\"+e in this._values},each:function(e){for(var n in this._values)e(this._values[n],n.substr(1))},size:function(){return this._size},map:function(e){var n=[];for(var t in this._values)n.push(e(this._values[t],t.substr(1)));return n},clone:function(){var e=new O;for(var n in this._values)e._values[n]=this._values[n];return e._size=this._size,e},toObject:function(){return this._values}},O.fromObject=function(e){var n=new O;return n._size=t(n._values,e),n};var F=i(\"Token\",\"type value line col pos endline endcol endpos nlb comments_before comments_after file raw\",{},null),se=i(\"Node\",\"start end\",{_clone:function(e){if(e){var n=this.clone();return n.transform(new Xn(function(e){if(e!==n)return e.clone(!0)}))}return new this.CTOR(this)},clone:function(e){return this._clone(e)},$documentation:\"Base class of all AST nodes\",$propdoc:{start:\"[AST_Token] The first token of this node\",end:\"[AST_Token] The last token of this node\"},_walk:function(e){return e._visit(this)},walk:function(e){return this._walk(e)}},null);se.warn_function=null,se.warn=function(e,n){se.warn_function&&se.warn_function(S(e,n))};var ue=i(\"Statement\",null,{$documentation:\"Base class of all statements\"}),ce=i(\"Debugger\",null,{$documentation:\"Represents a debugger statement\"},ue),fe=i(\"Directive\",\"value quote\",{$documentation:'Represents a directive, like \"use strict\";',$propdoc:{value:\"[string] The value of this directive as a plain string (it's not an AST_String!)\",quote:\"[string] the original quote character\"}},ue),le=i(\"SimpleStatement\",\"body\",{$documentation:\"A statement consisting of an expression, i.e. a = 1 + 2\",$propdoc:{body:\"[AST_Node] an expression node (should not be instanceof AST_Statement)\"},_walk:function(e){return e._visit(this,function(){this.body._walk(e)})}},ue);function z(e,n){var t=e.body;if(t instanceof ue)t._walk(n);else for(var i=0,r=t.length;i<r;i++)t[i]._walk(n)}var pe=i(\"Block\",\"body\",{$documentation:\"A body of statements (usually braced)\",$propdoc:{body:\"[AST_Statement*] an array of statements\"},_walk:function(e){return e._visit(this,function(){z(this,e)})}},ue),de=i(\"BlockStatement\",null,{$documentation:\"A block statement\"},pe),he=i(\"EmptyStatement\",null,{$documentation:\"The empty statement (empty block or simply a semicolon)\"},ue),_=i(\"StatementWithBody\",\"body\",{$documentation:\"Base class for all statements that contain one nested body: `For`, `ForIn`, `Do`, `While`, `With`\",$propdoc:{body:\"[AST_Statement] the body; this should always be present, even if it's an AST_EmptyStatement\"}},ue),ve=i(\"LabeledStatement\",\"label\",{$documentation:\"Statement with a label\",$propdoc:{label:\"[AST_Label] a label definition\"},_walk:function(e){return e._visit(this,function(){this.label._walk(e),this.body._walk(e)})},clone:function(e){var n=this._clone(e);if(e){var t=n.label,i=this.label;n.walk(new Sn(function(e){e instanceof Oe&&e.label&&e.label.thedef===i&&(e.label.thedef=t).references.push(e)}))}return n}},_),_e=i(\"IterationStatement\",null,{$documentation:\"Internal class.  All loops inherit from it.\"},_),me=i(\"DWLoop\",\"condition\",{$documentation:\"Base class for do/while statements\",$propdoc:{condition:\"[AST_Node] the loop condition.  Should not be instanceof AST_Statement\"}},_e),ge=i(\"Do\",null,{$documentation:\"A `do` statement\",_walk:function(e){return e._visit(this,function(){this.body._walk(e),this.condition._walk(e)})}},me),be=i(\"While\",null,{$documentation:\"A `while` statement\",_walk:function(e){return e._visit(this,function(){this.condition._walk(e),this.body._walk(e)})}},me),ye=i(\"For\",\"init condition step\",{$documentation:\"A `for` statement\",$propdoc:{init:\"[AST_Node?] the `for` initialization code, or null if empty\",condition:\"[AST_Node?] the `for` termination clause, or null if empty\",step:\"[AST_Node?] the `for` update clause, or null if empty\"},_walk:function(e){return e._visit(this,function(){this.init&&this.init._walk(e),this.condition&&this.condition._walk(e),this.step&&this.step._walk(e),this.body._walk(e)})}},_e),we=i(\"ForIn\",\"init object\",{$documentation:\"A `for ... in` statement\",$propdoc:{init:\"[AST_Node] the `for/in` initialization code\",object:\"[AST_Node] the object that we're looping through\"},_walk:function(e){return e._visit(this,function(){this.init._walk(e),this.object._walk(e),this.body._walk(e)})}},_e),xe=i(\"With\",\"expression\",{$documentation:\"A `with` statement\",$propdoc:{expression:\"[AST_Node] the `with` expression\"},_walk:function(e){return e._visit(this,function(){this.expression._walk(e),this.body._walk(e)})}},_),Ae=i(\"Scope\",\"variables functions uses_with uses_eval parent_scope enclosed cname\",{$documentation:\"Base class for all statements introducing a lexical scope\",$propdoc:{variables:\"[Object/S] a map of name -> SymbolDef for all variables/functions defined in this scope\",functions:\"[Object/S] like `variables`, but only lists function declarations\",uses_with:\"[boolean/S] tells whether this scope uses the `with` statement\",uses_eval:\"[boolean/S] tells whether this scope contains a direct call to the global `eval`\",parent_scope:\"[AST_Scope?/S] link to the parent scope\",enclosed:\"[SymbolDef*/S] a list of all symbol definitions that are accessed from this scope or any subscopes\",cname:\"[integer/S] current index for mangling variables (used internally by the mangler)\"},clone:function(e){var n=this._clone(e);return this.variables&&(n.variables=this.variables.clone()),this.functions&&(n.functions=this.functions.clone()),this.enclosed&&(n.enclosed=this.enclosed.slice()),n}},pe),Ee=i(\"Toplevel\",\"globals\",{$documentation:\"The toplevel scope\",$propdoc:{globals:\"[Object/S] a map of name -> SymbolDef for all undeclared names\"},wrap_commonjs:function(e){var n=this.body,t=\"(function(exports){'$ORIG';})(typeof \"+e+\"=='undefined'?(\"+e+\"={}):\"+e+\");\";return t=(t=Gn(t)).transform(new Xn(function(e){if(e instanceof fe&&\"$ORIG\"==e.value)return re.splice(n)}))}},Ae),ke=i(\"Lambda\",\"name argnames uses_arguments\",{$documentation:\"Base class for functions\",$propdoc:{name:\"[AST_SymbolDeclaration?] the name of this function\",argnames:\"[AST_SymbolFunarg*] array of function arguments\",uses_arguments:\"[boolean/S] tells whether this function accesses the arguments array\"},_walk:function(i){return i._visit(this,function(){this.name&&this.name._walk(i);for(var e=this.argnames,n=0,t=e.length;n<t;n++)e[n]._walk(i);z(this,i)})}},Ae),De=i(\"Accessor\",null,{$documentation:\"A setter/getter function.  The `name` property is always null.\"},ke),Fe=i(\"Function\",\"inlined\",{$documentation:\"A function expression\"},ke),Ce=i(\"Defun\",\"inlined\",{$documentation:\"A function definition\"},ke),Be=i(\"Jump\",null,{$documentation:\"Base class for jumps (for now that's `return`, `throw`, `break` and `continue`)\"},ue),Se=i(\"Exit\",\"value\",{$documentation:\"Base class for exits (`return` and `throw`)\",$propdoc:{value:\"[AST_Node?] the value returned or thrown by this statement; could be null for AST_Return\"},_walk:function(e){return e._visit(this,this.value&&function(){this.value._walk(e)})}},Be),Te=i(\"Return\",null,{$documentation:\"A `return` statement\"},Se),G=i(\"Throw\",null,{$documentation:\"A `throw` statement\"},Se),Oe=i(\"LoopControl\",\"label\",{$documentation:\"Base class for loop control statements (`break` and `continue`)\",$propdoc:{label:\"[AST_LabelRef?] the label, or null if none\"},_walk:function(e){return e._visit(this,this.label&&function(){this.label._walk(e)})}},Be),$e=i(\"Break\",null,{$documentation:\"A `break` statement\"},Oe),ze=i(\"Continue\",null,{$documentation:\"A `continue` statement\"},Oe),Me=i(\"If\",\"condition alternative\",{$documentation:\"A `if` statement\",$propdoc:{condition:\"[AST_Node] the `if` condition\",alternative:\"[AST_Statement?] the `else` part, or null if not present\"},_walk:function(e){return e._visit(this,function(){this.condition._walk(e),this.body._walk(e),this.alternative&&this.alternative._walk(e)})}},_),qe=i(\"Switch\",\"expression\",{$documentation:\"A `switch` statement\",$propdoc:{expression:\"[AST_Node] the `switch` discriminant\"},_walk:function(e){return e._visit(this,function(){this.expression._walk(e),z(this,e)})}},pe),je=i(\"SwitchBranch\",null,{$documentation:\"Base class for `switch` branches\"},pe),Ne=i(\"Default\",null,{$documentation:\"A `default` switch branch\"},je),He=i(\"Case\",\"expression\",{$documentation:\"A `case` switch branch\",$propdoc:{expression:\"[AST_Node] the `case` expression\"},_walk:function(e){return e._visit(this,function(){this.expression._walk(e),z(this,e)})}},je),Re=i(\"Try\",\"bcatch bfinally\",{$documentation:\"A `try` statement\",$propdoc:{bcatch:\"[AST_Catch?] the catch block, or null if not present\",bfinally:\"[AST_Finally?] the finally block, or null if not present\"},_walk:function(e){return e._visit(this,function(){z(this,e),this.bcatch&&this.bcatch._walk(e),this.bfinally&&this.bfinally._walk(e)})}},pe),Ie=i(\"Catch\",\"argname\",{$documentation:\"A `catch` node; only makes sense as part of a `try` statement\",$propdoc:{argname:\"[AST_SymbolCatch] symbol for the exception\"},_walk:function(e){return e._visit(this,function(){this.argname._walk(e),z(this,e)})}},pe),Pe=i(\"Finally\",null,{$documentation:\"A `finally` node; only makes sense as part of a `try` statement\"},pe),Ue=i(\"Definitions\",\"definitions\",{$documentation:\"Base class for `var` nodes (variable declarations/initializations)\",$propdoc:{definitions:\"[AST_VarDef*] array of variable definitions\"},_walk:function(i){return i._visit(this,function(){for(var e=this.definitions,n=0,t=e.length;n<t;n++)e[n]._walk(i)})}},ue),Le=i(\"Var\",null,{$documentation:\"A `var` statement\"},Ue),Ve=i(\"VarDef\",\"name value\",{$documentation:\"A variable declaration; only appears in a AST_Definitions node\",$propdoc:{name:\"[AST_SymbolVar] name of the variable\",value:\"[AST_Node?] initializer, or null of there's no initializer\"},_walk:function(e){return e._visit(this,function(){this.name._walk(e),this.value&&this.value._walk(e)})}}),Ye=i(\"Call\",\"expression args\",{$documentation:\"A function call expression\",$propdoc:{expression:\"[AST_Node] expression to invoke as function\",args:\"[AST_Node*] array of arguments\"},_walk:function(i){return i._visit(this,function(){for(var e=this.args,n=0,t=e.length;n<t;n++)e[n]._walk(i);this.expression._walk(i)})}}),Je=i(\"New\",null,{$documentation:\"An object instantiation.  Derives from a function call since it has exactly the same properties\"},Ye),We=i(\"Sequence\",\"expressions\",{$documentation:\"A sequence expression (comma-separated expressions)\",$propdoc:{expressions:\"[AST_Node*] array of expressions (at least two)\"},_walk:function(n){return n._visit(this,function(){this.expressions.forEach(function(e){e._walk(n)})})}}),Ge=i(\"PropAccess\",\"expression property\",{$documentation:'Base class for property access expressions, i.e. `a.foo` or `a[\"foo\"]`',$propdoc:{expression:\"[AST_Node] the container expression\",property:\"[AST_Node|string] the property to access.  For AST_Dot this is always a plain string, while for AST_Sub it's an arbitrary AST_Node\"}}),Xe=i(\"Dot\",null,{$documentation:\"A dotted property access expression\",_walk:function(e){return e._visit(this,function(){this.expression._walk(e)})}},Ge),Ze=i(\"Sub\",null,{$documentation:'Index-style property access, i.e. `a[\"foo\"]`',_walk:function(e){return e._visit(this,function(){this.expression._walk(e),this.property._walk(e)})}},Ge),Ke=i(\"Unary\",\"operator expression\",{$documentation:\"Base class for unary expressions\",$propdoc:{operator:\"[string] the operator\",expression:\"[AST_Node] expression that this unary operator applies to\"},_walk:function(e){return e._visit(this,function(){this.expression._walk(e)})}}),Qe=i(\"UnaryPrefix\",null,{$documentation:\"Unary prefix expression, i.e. `typeof i` or `++i`\"},Ke),en=i(\"UnaryPostfix\",null,{$documentation:\"Unary postfix expression, i.e. `i++`\"},Ke),nn=i(\"Binary\",\"operator left right\",{$documentation:\"Binary expression, i.e. `a + b`\",$propdoc:{left:\"[AST_Node] left-hand side expression\",operator:\"[string] the operator\",right:\"[AST_Node] right-hand side expression\"},_walk:function(e){return e._visit(this,function(){this.left._walk(e),this.right._walk(e)})}}),tn=i(\"Conditional\",\"condition consequent alternative\",{$documentation:\"Conditional expression using the ternary operator, i.e. `a ? b : c`\",$propdoc:{condition:\"[AST_Node]\",consequent:\"[AST_Node]\",alternative:\"[AST_Node]\"},_walk:function(e){return e._visit(this,function(){this.condition._walk(e),this.consequent._walk(e),this.alternative._walk(e)})}}),rn=i(\"Assign\",null,{$documentation:\"An assignment expression  `a = b + 5`\"},nn),on=i(\"Array\",\"elements\",{$documentation:\"An array literal\",$propdoc:{elements:\"[AST_Node*] array of elements\"},_walk:function(i){return i._visit(this,function(){for(var e=this.elements,n=0,t=e.length;n<t;n++)e[n]._walk(i)})}}),an=i(\"Object\",\"properties\",{$documentation:\"An object literal\",$propdoc:{properties:\"[AST_ObjectProperty*] array of properties\"},_walk:function(i){return i._visit(this,function(){for(var e=this.properties,n=0,t=e.length;n<t;n++)e[n]._walk(i)})}}),sn=i(\"ObjectProperty\",\"key value\",{$documentation:\"Base class for literal object properties\",$propdoc:{key:\"[string|AST_SymbolAccessor] property name. For ObjectKeyVal this is a string. For getters and setters this is an AST_SymbolAccessor.\",value:\"[AST_Node] property value.  For getters and setters this is an AST_Accessor.\"},_walk:function(e){return e._visit(this,function(){this.value._walk(e)})}}),un=i(\"ObjectKeyVal\",\"quote\",{$documentation:\"A key: value object property\",$propdoc:{quote:\"[string] the original quote character\"}},sn),X=i(\"ObjectSetter\",null,{$documentation:\"An object setter property\"},sn),Z=i(\"ObjectGetter\",null,{$documentation:\"An object getter property\"},sn),cn=i(\"Symbol\",\"scope name thedef\",{$propdoc:{name:\"[string] name of this symbol\",scope:\"[AST_Scope/S] the current scope (not necessarily the definition scope)\",thedef:\"[SymbolDef/S] the definition of this symbol\"},$documentation:\"Base class for all symbols\"}),K=i(\"SymbolAccessor\",null,{$documentation:\"The name of a property accessor (setter/getter function)\"},cn),fn=i(\"SymbolDeclaration\",\"init\",{$documentation:\"A declaration symbol (symbol in var, function name or argument, symbol in catch)\"},cn),ln=i(\"SymbolVar\",null,{$documentation:\"Symbol defining a variable\"},fn),pn=i(\"SymbolFunarg\",null,{$documentation:\"Symbol naming a function argument\"},ln),dn=i(\"SymbolDefun\",null,{$documentation:\"Symbol defining a function\"},fn),hn=i(\"SymbolLambda\",null,{$documentation:\"Symbol naming a function expression\"},fn),vn=i(\"SymbolCatch\",null,{$documentation:\"Symbol naming the exception in catch\"},fn),Q=i(\"Label\",\"references\",{$documentation:\"Symbol naming a label (declaration)\",$propdoc:{references:\"[AST_LoopControl*] a list of nodes referring to this label\"},initialize:function(){this.references=[],this.thedef=this}},cn),_n=i(\"SymbolRef\",null,{$documentation:\"Reference to some symbol (not definition/declaration)\"},cn),ee=i(\"LabelRef\",null,{$documentation:\"Reference to a label symbol\"},cn),mn=i(\"This\",null,{$documentation:\"The `this` symbol\"},cn),gn=i(\"Constant\",null,{$documentation:\"Base class for all constants\",getValue:function(){return this.value}}),bn=i(\"String\",\"value quote\",{$documentation:\"A string literal\",$propdoc:{value:\"[string] the contents of this string\",quote:\"[string] the original quote character\"}},gn),yn=i(\"Number\",\"value literal\",{$documentation:\"A number literal\",$propdoc:{value:\"[number] the numeric value\",literal:\"[string] numeric value as string (optional)\"}},gn),wn=i(\"RegExp\",\"value\",{$documentation:\"A regexp literal\",$propdoc:{value:\"[RegExp] the actual regexp\"}},gn),a=i(\"Atom\",null,{$documentation:\"Base class for atoms\"},gn),xn=i(\"Null\",null,{$documentation:\"The `null` atom\",value:null},a),An=i(\"NaN\",null,{$documentation:\"The impossible value\",value:NaN},a),En=i(\"Undefined\",null,{$documentation:\"The `undefined` value\",value:void 0},a),kn=i(\"Hole\",null,{$documentation:\"A hole in an array\",value:void 0},a),Dn=i(\"Infinity\",null,{$documentation:\"The `Infinity` value\",value:1/0},a),Fn=i(\"Boolean\",null,{$documentation:\"Base class for booleans\"},a),Cn=i(\"False\",null,{$documentation:\"The `false` atom\",value:!1},Fn),Bn=i(\"True\",null,{$documentation:\"The `true` atom\",value:!0},Fn);function Sn(e){this.visit=e,this.stack=[],this.directives=Object.create(null)}Sn.prototype={_visit:function(e,n){this.push(e);var t=this.visit(e,n?function(){n.call(e)}:L);return!t&&n&&n.call(e),this.pop(),t},parent:function(e){return this.stack[this.stack.length-2-(e||0)]},push:function(e){e instanceof ke?this.directives=Object.create(this.directives):e instanceof fe&&!this.directives[e.value]&&(this.directives[e.value]=e),this.stack.push(e)},pop:function(){this.stack.pop()instanceof ke&&(this.directives=Object.getPrototypeOf(this.directives))},self:function(){return this.stack[this.stack.length-1]},find_parent:function(e){for(var n=this.stack,t=n.length;0<=--t;){var i=n[t];if(i instanceof e)return i}},has_directive:function(e){var n=this.directives[e];if(n)return n;var t=this.stack[this.stack.length-1];if(t instanceof Ae)for(var i=0;i<t.body.length;++i){var r=t.body[i];if(!(r instanceof fe))break;if(r.value==e)return r}},loopcontrol_target:function(e){var n=this.stack;if(e.label)for(var t=n.length;0<=--t;){if((i=n[t])instanceof ve&&i.label.name==e.label.name)return i.body}else for(t=n.length;0<=--t;){var i;if((i=n[t])instanceof _e||e instanceof $e&&i instanceof qe)return i}},in_boolean_context:function(){for(var e,n=this.self(),t=0;e=this.parent(t);t++){if(e instanceof le||e instanceof tn&&e.condition===n||e instanceof me&&e.condition===n||e instanceof ye&&e.condition===n||e instanceof Me&&e.condition===n||e instanceof Qe&&\"!\"==e.operator&&e.expression===n)return!0;if(!(e instanceof nn&&(\"&&\"==e.operator||\"||\"==e.operator)||e instanceof tn||e.tail_node()===n))return!1;n=e}}};var ne=\"break case catch const continue debugger default delete do else finally for function if in instanceof new return switch throw try typeof var void while with\",M=\"false null true\",m=\"abstract boolean byte char class double enum export extends final float goto implements import int interface let long native package private protected public short static super synchronized this throws transient volatile yield \"+M+\" \"+ne,q=\"return new delete throw else case\";ne=W(ne),m=W(m),q=W(q),M=W(M);var j=W(e(\"+-*&%=<>!?|~^\")),N=/^0x[0-9a-f]+$/i,H=/^0[0-7]+$/,R=W([\"in\",\"instanceof\",\"typeof\",\"new\",\"void\",\"delete\",\"++\",\"--\",\"+\",\"-\",\"!\",\"~\",\"&\",\"|\",\"^\",\"*\",\"/\",\"%\",\">>\",\"<<\",\">>>\",\"<\",\">\",\"<=\",\">=\",\"==\",\"===\",\"!=\",\"!==\",\"?\",\"=\",\"+=\",\"-=\",\"/=\",\"*=\",\"%=\",\">>=\",\"<<=\",\">>>=\",\"|=\",\"^=\",\"&=\",\"&&\",\"||\"]),I=W(e(\" \\n\\r\\t\\f\\v\\u2028\\u2029\\ufeff\")),P=W(e(\"\\n\\r\\u2028\\u2029\")),U=W(e(\"[{(,;:\")),Tn=W(e(\"[]{}(),;:\")),u={letter:new RegExp(\"[\\\\u0041-\\\\u005A\\\\u0061-\\\\u007A\\\\u00AA\\\\u00B5\\\\u00BA\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02C1\\\\u02C6-\\\\u02D1\\\\u02E0-\\\\u02E4\\\\u02EC\\\\u02EE\\\\u0370-\\\\u0374\\\\u0376\\\\u0377\\\\u037A-\\\\u037D\\\\u037F\\\\u0386\\\\u0388-\\\\u038A\\\\u038C\\\\u038E-\\\\u03A1\\\\u03A3-\\\\u03F5\\\\u03F7-\\\\u0481\\\\u048A-\\\\u052F\\\\u0531-\\\\u0556\\\\u0559\\\\u0561-\\\\u0587\\\\u05D0-\\\\u05EA\\\\u05F0-\\\\u05F2\\\\u0620-\\\\u064A\\\\u066E\\\\u066F\\\\u0671-\\\\u06D3\\\\u06D5\\\\u06E5\\\\u06E6\\\\u06EE\\\\u06EF\\\\u06FA-\\\\u06FC\\\\u06FF\\\\u0710\\\\u0712-\\\\u072F\\\\u074D-\\\\u07A5\\\\u07B1\\\\u07CA-\\\\u07EA\\\\u07F4\\\\u07F5\\\\u07FA\\\\u0800-\\\\u0815\\\\u081A\\\\u0824\\\\u0828\\\\u0840-\\\\u0858\\\\u08A0-\\\\u08B2\\\\u0904-\\\\u0939\\\\u093D\\\\u0950\\\\u0958-\\\\u0961\\\\u0971-\\\\u0980\\\\u0985-\\\\u098C\\\\u098F\\\\u0990\\\\u0993-\\\\u09A8\\\\u09AA-\\\\u09B0\\\\u09B2\\\\u09B6-\\\\u09B9\\\\u09BD\\\\u09CE\\\\u09DC\\\\u09DD\\\\u09DF-\\\\u09E1\\\\u09F0\\\\u09F1\\\\u0A05-\\\\u0A0A\\\\u0A0F\\\\u0A10\\\\u0A13-\\\\u0A28\\\\u0A2A-\\\\u0A30\\\\u0A32\\\\u0A33\\\\u0A35\\\\u0A36\\\\u0A38\\\\u0A39\\\\u0A59-\\\\u0A5C\\\\u0A5E\\\\u0A72-\\\\u0A74\\\\u0A85-\\\\u0A8D\\\\u0A8F-\\\\u0A91\\\\u0A93-\\\\u0AA8\\\\u0AAA-\\\\u0AB0\\\\u0AB2\\\\u0AB3\\\\u0AB5-\\\\u0AB9\\\\u0ABD\\\\u0AD0\\\\u0AE0\\\\u0AE1\\\\u0B05-\\\\u0B0C\\\\u0B0F\\\\u0B10\\\\u0B13-\\\\u0B28\\\\u0B2A-\\\\u0B30\\\\u0B32\\\\u0B33\\\\u0B35-\\\\u0B39\\\\u0B3D\\\\u0B5C\\\\u0B5D\\\\u0B5F-\\\\u0B61\\\\u0B71\\\\u0B83\\\\u0B85-\\\\u0B8A\\\\u0B8E-\\\\u0B90\\\\u0B92-\\\\u0B95\\\\u0B99\\\\u0B9A\\\\u0B9C\\\\u0B9E\\\\u0B9F\\\\u0BA3\\\\u0BA4\\\\u0BA8-\\\\u0BAA\\\\u0BAE-\\\\u0BB9\\\\u0BD0\\\\u0C05-\\\\u0C0C\\\\u0C0E-\\\\u0C10\\\\u0C12-\\\\u0C28\\\\u0C2A-\\\\u0C39\\\\u0C3D\\\\u0C58\\\\u0C59\\\\u0C60\\\\u0C61\\\\u0C85-\\\\u0C8C\\\\u0C8E-\\\\u0C90\\\\u0C92-\\\\u0CA8\\\\u0CAA-\\\\u0CB3\\\\u0CB5-\\\\u0CB9\\\\u0CBD\\\\u0CDE\\\\u0CE0\\\\u0CE1\\\\u0CF1\\\\u0CF2\\\\u0D05-\\\\u0D0C\\\\u0D0E-\\\\u0D10\\\\u0D12-\\\\u0D3A\\\\u0D3D\\\\u0D4E\\\\u0D60\\\\u0D61\\\\u0D7A-\\\\u0D7F\\\\u0D85-\\\\u0D96\\\\u0D9A-\\\\u0DB1\\\\u0DB3-\\\\u0DBB\\\\u0DBD\\\\u0DC0-\\\\u0DC6\\\\u0E01-\\\\u0E30\\\\u0E32\\\\u0E33\\\\u0E40-\\\\u0E46\\\\u0E81\\\\u0E82\\\\u0E84\\\\u0E87\\\\u0E88\\\\u0E8A\\\\u0E8D\\\\u0E94-\\\\u0E97\\\\u0E99-\\\\u0E9F\\\\u0EA1-\\\\u0EA3\\\\u0EA5\\\\u0EA7\\\\u0EAA\\\\u0EAB\\\\u0EAD-\\\\u0EB0\\\\u0EB2\\\\u0EB3\\\\u0EBD\\\\u0EC0-\\\\u0EC4\\\\u0EC6\\\\u0EDC-\\\\u0EDF\\\\u0F00\\\\u0F40-\\\\u0F47\\\\u0F49-\\\\u0F6C\\\\u0F88-\\\\u0F8C\\\\u1000-\\\\u102A\\\\u103F\\\\u1050-\\\\u1055\\\\u105A-\\\\u105D\\\\u1061\\\\u1065\\\\u1066\\\\u106E-\\\\u1070\\\\u1075-\\\\u1081\\\\u108E\\\\u10A0-\\\\u10C5\\\\u10C7\\\\u10CD\\\\u10D0-\\\\u10FA\\\\u10FC-\\\\u1248\\\\u124A-\\\\u124D\\\\u1250-\\\\u1256\\\\u1258\\\\u125A-\\\\u125D\\\\u1260-\\\\u1288\\\\u128A-\\\\u128D\\\\u1290-\\\\u12B0\\\\u12B2-\\\\u12B5\\\\u12B8-\\\\u12BE\\\\u12C0\\\\u12C2-\\\\u12C5\\\\u12C8-\\\\u12D6\\\\u12D8-\\\\u1310\\\\u1312-\\\\u1315\\\\u1318-\\\\u135A\\\\u1380-\\\\u138F\\\\u13A0-\\\\u13F4\\\\u1401-\\\\u166C\\\\u166F-\\\\u167F\\\\u1681-\\\\u169A\\\\u16A0-\\\\u16EA\\\\u16EE-\\\\u16F8\\\\u1700-\\\\u170C\\\\u170E-\\\\u1711\\\\u1720-\\\\u1731\\\\u1740-\\\\u1751\\\\u1760-\\\\u176C\\\\u176E-\\\\u1770\\\\u1780-\\\\u17B3\\\\u17D7\\\\u17DC\\\\u1820-\\\\u1877\\\\u1880-\\\\u18A8\\\\u18AA\\\\u18B0-\\\\u18F5\\\\u1900-\\\\u191E\\\\u1950-\\\\u196D\\\\u1970-\\\\u1974\\\\u1980-\\\\u19AB\\\\u19C1-\\\\u19C7\\\\u1A00-\\\\u1A16\\\\u1A20-\\\\u1A54\\\\u1AA7\\\\u1B05-\\\\u1B33\\\\u1B45-\\\\u1B4B\\\\u1B83-\\\\u1BA0\\\\u1BAE\\\\u1BAF\\\\u1BBA-\\\\u1BE5\\\\u1C00-\\\\u1C23\\\\u1C4D-\\\\u1C4F\\\\u1C5A-\\\\u1C7D\\\\u1CE9-\\\\u1CEC\\\\u1CEE-\\\\u1CF1\\\\u1CF5\\\\u1CF6\\\\u1D00-\\\\u1DBF\\\\u1E00-\\\\u1F15\\\\u1F18-\\\\u1F1D\\\\u1F20-\\\\u1F45\\\\u1F48-\\\\u1F4D\\\\u1F50-\\\\u1F57\\\\u1F59\\\\u1F5B\\\\u1F5D\\\\u1F5F-\\\\u1F7D\\\\u1F80-\\\\u1FB4\\\\u1FB6-\\\\u1FBC\\\\u1FBE\\\\u1FC2-\\\\u1FC4\\\\u1FC6-\\\\u1FCC\\\\u1FD0-\\\\u1FD3\\\\u1FD6-\\\\u1FDB\\\\u1FE0-\\\\u1FEC\\\\u1FF2-\\\\u1FF4\\\\u1FF6-\\\\u1FFC\\\\u2071\\\\u207F\\\\u2090-\\\\u209C\\\\u2102\\\\u2107\\\\u210A-\\\\u2113\\\\u2115\\\\u2119-\\\\u211D\\\\u2124\\\\u2126\\\\u2128\\\\u212A-\\\\u212D\\\\u212F-\\\\u2139\\\\u213C-\\\\u213F\\\\u2145-\\\\u2149\\\\u214E\\\\u2160-\\\\u2188\\\\u2C00-\\\\u2C2E\\\\u2C30-\\\\u2C5E\\\\u2C60-\\\\u2CE4\\\\u2CEB-\\\\u2CEE\\\\u2CF2\\\\u2CF3\\\\u2D00-\\\\u2D25\\\\u2D27\\\\u2D2D\\\\u2D30-\\\\u2D67\\\\u2D6F\\\\u2D80-\\\\u2D96\\\\u2DA0-\\\\u2DA6\\\\u2DA8-\\\\u2DAE\\\\u2DB0-\\\\u2DB6\\\\u2DB8-\\\\u2DBE\\\\u2DC0-\\\\u2DC6\\\\u2DC8-\\\\u2DCE\\\\u2DD0-\\\\u2DD6\\\\u2DD8-\\\\u2DDE\\\\u2E2F\\\\u3005-\\\\u3007\\\\u3021-\\\\u3029\\\\u3031-\\\\u3035\\\\u3038-\\\\u303C\\\\u3041-\\\\u3096\\\\u309D-\\\\u309F\\\\u30A1-\\\\u30FA\\\\u30FC-\\\\u30FF\\\\u3105-\\\\u312D\\\\u3131-\\\\u318E\\\\u31A0-\\\\u31BA\\\\u31F0-\\\\u31FF\\\\u3400-\\\\u4DB5\\\\u4E00-\\\\u9FCC\\\\uA000-\\\\uA48C\\\\uA4D0-\\\\uA4FD\\\\uA500-\\\\uA60C\\\\uA610-\\\\uA61F\\\\uA62A\\\\uA62B\\\\uA640-\\\\uA66E\\\\uA67F-\\\\uA69D\\\\uA6A0-\\\\uA6EF\\\\uA717-\\\\uA71F\\\\uA722-\\\\uA788\\\\uA78B-\\\\uA78E\\\\uA790-\\\\uA7AD\\\\uA7B0\\\\uA7B1\\\\uA7F7-\\\\uA801\\\\uA803-\\\\uA805\\\\uA807-\\\\uA80A\\\\uA80C-\\\\uA822\\\\uA840-\\\\uA873\\\\uA882-\\\\uA8B3\\\\uA8F2-\\\\uA8F7\\\\uA8FB\\\\uA90A-\\\\uA925\\\\uA930-\\\\uA946\\\\uA960-\\\\uA97C\\\\uA984-\\\\uA9B2\\\\uA9CF\\\\uA9E0-\\\\uA9E4\\\\uA9E6-\\\\uA9EF\\\\uA9FA-\\\\uA9FE\\\\uAA00-\\\\uAA28\\\\uAA40-\\\\uAA42\\\\uAA44-\\\\uAA4B\\\\uAA60-\\\\uAA76\\\\uAA7A\\\\uAA7E-\\\\uAAAF\\\\uAAB1\\\\uAAB5\\\\uAAB6\\\\uAAB9-\\\\uAABD\\\\uAAC0\\\\uAAC2\\\\uAADB-\\\\uAADD\\\\uAAE0-\\\\uAAEA\\\\uAAF2-\\\\uAAF4\\\\uAB01-\\\\uAB06\\\\uAB09-\\\\uAB0E\\\\uAB11-\\\\uAB16\\\\uAB20-\\\\uAB26\\\\uAB28-\\\\uAB2E\\\\uAB30-\\\\uAB5A\\\\uAB5C-\\\\uAB5F\\\\uAB64\\\\uAB65\\\\uABC0-\\\\uABE2\\\\uAC00-\\\\uD7A3\\\\uD7B0-\\\\uD7C6\\\\uD7CB-\\\\uD7FB\\\\uF900-\\\\uFA6D\\\\uFA70-\\\\uFAD9\\\\uFB00-\\\\uFB06\\\\uFB13-\\\\uFB17\\\\uFB1D\\\\uFB1F-\\\\uFB28\\\\uFB2A-\\\\uFB36\\\\uFB38-\\\\uFB3C\\\\uFB3E\\\\uFB40\\\\uFB41\\\\uFB43\\\\uFB44\\\\uFB46-\\\\uFBB1\\\\uFBD3-\\\\uFD3D\\\\uFD50-\\\\uFD8F\\\\uFD92-\\\\uFDC7\\\\uFDF0-\\\\uFDFB\\\\uFE70-\\\\uFE74\\\\uFE76-\\\\uFEFC\\\\uFF21-\\\\uFF3A\\\\uFF41-\\\\uFF5A\\\\uFF66-\\\\uFFBE\\\\uFFC2-\\\\uFFC7\\\\uFFCA-\\\\uFFCF\\\\uFFD2-\\\\uFFD7\\\\uFFDA-\\\\uFFDC]\"),digit:new RegExp(\"[\\\\u0030-\\\\u0039\\\\u0660-\\\\u0669\\\\u06F0-\\\\u06F9\\\\u07C0-\\\\u07C9\\\\u0966-\\\\u096F\\\\u09E6-\\\\u09EF\\\\u0A66-\\\\u0A6F\\\\u0AE6-\\\\u0AEF\\\\u0B66-\\\\u0B6F\\\\u0BE6-\\\\u0BEF\\\\u0C66-\\\\u0C6F\\\\u0CE6-\\\\u0CEF\\\\u0D66-\\\\u0D6F\\\\u0DE6-\\\\u0DEF\\\\u0E50-\\\\u0E59\\\\u0ED0-\\\\u0ED9\\\\u0F20-\\\\u0F29\\\\u1040-\\\\u1049\\\\u1090-\\\\u1099\\\\u17E0-\\\\u17E9\\\\u1810-\\\\u1819\\\\u1946-\\\\u194F\\\\u19D0-\\\\u19D9\\\\u1A80-\\\\u1A89\\\\u1A90-\\\\u1A99\\\\u1B50-\\\\u1B59\\\\u1BB0-\\\\u1BB9\\\\u1C40-\\\\u1C49\\\\u1C50-\\\\u1C59\\\\uA620-\\\\uA629\\\\uA8D0-\\\\uA8D9\\\\uA900-\\\\uA909\\\\uA9D0-\\\\uA9D9\\\\uA9F0-\\\\uA9F9\\\\uAA50-\\\\uAA59\\\\uABF0-\\\\uABF9\\\\uFF10-\\\\uFF19]\"),non_spacing_mark:new RegExp(\"[\\\\u0300-\\\\u036F\\\\u0483-\\\\u0487\\\\u0591-\\\\u05BD\\\\u05BF\\\\u05C1\\\\u05C2\\\\u05C4\\\\u05C5\\\\u05C7\\\\u0610-\\\\u061A\\\\u064B-\\\\u065E\\\\u0670\\\\u06D6-\\\\u06DC\\\\u06DF-\\\\u06E4\\\\u06E7\\\\u06E8\\\\u06EA-\\\\u06ED\\\\u0711\\\\u0730-\\\\u074A\\\\u07A6-\\\\u07B0\\\\u07EB-\\\\u07F3\\\\u0816-\\\\u0819\\\\u081B-\\\\u0823\\\\u0825-\\\\u0827\\\\u0829-\\\\u082D\\\\u0900-\\\\u0902\\\\u093C\\\\u0941-\\\\u0948\\\\u094D\\\\u0951-\\\\u0955\\\\u0962\\\\u0963\\\\u0981\\\\u09BC\\\\u09C1-\\\\u09C4\\\\u09CD\\\\u09E2\\\\u09E3\\\\u0A01\\\\u0A02\\\\u0A3C\\\\u0A41\\\\u0A42\\\\u0A47\\\\u0A48\\\\u0A4B-\\\\u0A4D\\\\u0A51\\\\u0A70\\\\u0A71\\\\u0A75\\\\u0A81\\\\u0A82\\\\u0ABC\\\\u0AC1-\\\\u0AC5\\\\u0AC7\\\\u0AC8\\\\u0ACD\\\\u0AE2\\\\u0AE3\\\\u0B01\\\\u0B3C\\\\u0B3F\\\\u0B41-\\\\u0B44\\\\u0B4D\\\\u0B56\\\\u0B62\\\\u0B63\\\\u0B82\\\\u0BC0\\\\u0BCD\\\\u0C3E-\\\\u0C40\\\\u0C46-\\\\u0C48\\\\u0C4A-\\\\u0C4D\\\\u0C55\\\\u0C56\\\\u0C62\\\\u0C63\\\\u0CBC\\\\u0CBF\\\\u0CC6\\\\u0CCC\\\\u0CCD\\\\u0CE2\\\\u0CE3\\\\u0D41-\\\\u0D44\\\\u0D4D\\\\u0D62\\\\u0D63\\\\u0DCA\\\\u0DD2-\\\\u0DD4\\\\u0DD6\\\\u0E31\\\\u0E34-\\\\u0E3A\\\\u0E47-\\\\u0E4E\\\\u0EB1\\\\u0EB4-\\\\u0EB9\\\\u0EBB\\\\u0EBC\\\\u0EC8-\\\\u0ECD\\\\u0F18\\\\u0F19\\\\u0F35\\\\u0F37\\\\u0F39\\\\u0F71-\\\\u0F7E\\\\u0F80-\\\\u0F84\\\\u0F86\\\\u0F87\\\\u0F90-\\\\u0F97\\\\u0F99-\\\\u0FBC\\\\u0FC6\\\\u102D-\\\\u1030\\\\u1032-\\\\u1037\\\\u1039\\\\u103A\\\\u103D\\\\u103E\\\\u1058\\\\u1059\\\\u105E-\\\\u1060\\\\u1071-\\\\u1074\\\\u1082\\\\u1085\\\\u1086\\\\u108D\\\\u109D\\\\u135F\\\\u1712-\\\\u1714\\\\u1732-\\\\u1734\\\\u1752\\\\u1753\\\\u1772\\\\u1773\\\\u17B7-\\\\u17BD\\\\u17C6\\\\u17C9-\\\\u17D3\\\\u17DD\\\\u180B-\\\\u180D\\\\u18A9\\\\u1920-\\\\u1922\\\\u1927\\\\u1928\\\\u1932\\\\u1939-\\\\u193B\\\\u1A17\\\\u1A18\\\\u1A56\\\\u1A58-\\\\u1A5E\\\\u1A60\\\\u1A62\\\\u1A65-\\\\u1A6C\\\\u1A73-\\\\u1A7C\\\\u1A7F\\\\u1B00-\\\\u1B03\\\\u1B34\\\\u1B36-\\\\u1B3A\\\\u1B3C\\\\u1B42\\\\u1B6B-\\\\u1B73\\\\u1B80\\\\u1B81\\\\u1BA2-\\\\u1BA5\\\\u1BA8\\\\u1BA9\\\\u1C2C-\\\\u1C33\\\\u1C36\\\\u1C37\\\\u1CD0-\\\\u1CD2\\\\u1CD4-\\\\u1CE0\\\\u1CE2-\\\\u1CE8\\\\u1CED\\\\u1DC0-\\\\u1DE6\\\\u1DFD-\\\\u1DFF\\\\u20D0-\\\\u20DC\\\\u20E1\\\\u20E5-\\\\u20F0\\\\u2CEF-\\\\u2CF1\\\\u2DE0-\\\\u2DFF\\\\u302A-\\\\u302F\\\\u3099\\\\u309A\\\\uA66F\\\\uA67C\\\\uA67D\\\\uA6F0\\\\uA6F1\\\\uA802\\\\uA806\\\\uA80B\\\\uA825\\\\uA826\\\\uA8C4\\\\uA8E0-\\\\uA8F1\\\\uA926-\\\\uA92D\\\\uA947-\\\\uA951\\\\uA980-\\\\uA982\\\\uA9B3\\\\uA9B6-\\\\uA9B9\\\\uA9BC\\\\uAA29-\\\\uAA2E\\\\uAA31\\\\uAA32\\\\uAA35\\\\uAA36\\\\uAA43\\\\uAA4C\\\\uAAB0\\\\uAAB2-\\\\uAAB4\\\\uAAB7\\\\uAAB8\\\\uAABE\\\\uAABF\\\\uAAC1\\\\uABE5\\\\uABE8\\\\uABED\\\\uFB1E\\\\uFE00-\\\\uFE0F\\\\uFE20-\\\\uFE26]\"),space_combining_mark:new RegExp(\"[\\\\u0903\\\\u093E-\\\\u0940\\\\u0949-\\\\u094C\\\\u094E\\\\u0982\\\\u0983\\\\u09BE-\\\\u09C0\\\\u09C7\\\\u09C8\\\\u09CB\\\\u09CC\\\\u09D7\\\\u0A03\\\\u0A3E-\\\\u0A40\\\\u0A83\\\\u0ABE-\\\\u0AC0\\\\u0AC9\\\\u0ACB\\\\u0ACC\\\\u0B02\\\\u0B03\\\\u0B3E\\\\u0B40\\\\u0B47\\\\u0B48\\\\u0B4B\\\\u0B4C\\\\u0B57\\\\u0BBE\\\\u0BBF\\\\u0BC1\\\\u0BC2\\\\u0BC6-\\\\u0BC8\\\\u0BCA-\\\\u0BCC\\\\u0BD7\\\\u0C01-\\\\u0C03\\\\u0C41-\\\\u0C44\\\\u0C82\\\\u0C83\\\\u0CBE\\\\u0CC0-\\\\u0CC4\\\\u0CC7\\\\u0CC8\\\\u0CCA\\\\u0CCB\\\\u0CD5\\\\u0CD6\\\\u0D02\\\\u0D03\\\\u0D3E-\\\\u0D40\\\\u0D46-\\\\u0D48\\\\u0D4A-\\\\u0D4C\\\\u0D57\\\\u0D82\\\\u0D83\\\\u0DCF-\\\\u0DD1\\\\u0DD8-\\\\u0DDF\\\\u0DF2\\\\u0DF3\\\\u0F3E\\\\u0F3F\\\\u0F7F\\\\u102B\\\\u102C\\\\u1031\\\\u1038\\\\u103B\\\\u103C\\\\u1056\\\\u1057\\\\u1062-\\\\u1064\\\\u1067-\\\\u106D\\\\u1083\\\\u1084\\\\u1087-\\\\u108C\\\\u108F\\\\u109A-\\\\u109C\\\\u17B6\\\\u17BE-\\\\u17C5\\\\u17C7\\\\u17C8\\\\u1923-\\\\u1926\\\\u1929-\\\\u192B\\\\u1930\\\\u1931\\\\u1933-\\\\u1938\\\\u19B0-\\\\u19C0\\\\u19C8\\\\u19C9\\\\u1A19-\\\\u1A1B\\\\u1A55\\\\u1A57\\\\u1A61\\\\u1A63\\\\u1A64\\\\u1A6D-\\\\u1A72\\\\u1B04\\\\u1B35\\\\u1B3B\\\\u1B3D-\\\\u1B41\\\\u1B43\\\\u1B44\\\\u1B82\\\\u1BA1\\\\u1BA6\\\\u1BA7\\\\u1BAA\\\\u1C24-\\\\u1C2B\\\\u1C34\\\\u1C35\\\\u1CE1\\\\u1CF2\\\\uA823\\\\uA824\\\\uA827\\\\uA880\\\\uA881\\\\uA8B4-\\\\uA8C3\\\\uA952\\\\uA953\\\\uA983\\\\uA9B4\\\\uA9B5\\\\uA9BA\\\\uA9BB\\\\uA9BD-\\\\uA9C0\\\\uAA2F\\\\uAA30\\\\uAA33\\\\uAA34\\\\uAA4D\\\\uAA7B\\\\uABE3\\\\uABE4\\\\uABE6\\\\uABE7\\\\uABE9\\\\uABEA\\\\uABEC]\"),connector_punctuation:new RegExp(\"[\\\\u005F\\\\u203F\\\\u2040\\\\u2054\\\\uFE33\\\\uFE34\\\\uFE4D-\\\\uFE4F\\\\uFF3F]\")};function On(e){return 97<=e&&e<=122||65<=e&&e<=90||170<=e&&u.letter.test(String.fromCharCode(e))}function $n(e){return\"string\"==typeof e&&(e=e.charCodeAt(0)),55296<=e&&e<=56319}function zn(e){return\"string\"==typeof e&&(e=e.charCodeAt(0)),56320<=e&&e<=57343}function Mn(e){return 48<=e&&e<=57}function l(e){return!m(e)&&/^[a-z_$][a-z0-9_$]*$/i.test(e)}function qn(e){return 36==e||95==e||On(e)}function jn(e){var n,t,i,r=e.charCodeAt(0);return qn(r)||Mn(r)||8204==r||8205==r||(i=e,u.non_spacing_mark.test(i)||u.space_combining_mark.test(i))||(t=e,u.connector_punctuation.test(t))||(n=r,u.digit.test(String.fromCharCode(n)))}function Nn(e){return/^[a-z_$][a-z0-9_$]*$/i.test(e)}function Hn(e,n,t,i,r){this.message=e,this.filename=n,this.line=t,this.col=i,this.pos=r}function Rn(e,n,t,i,r){throw new Hn(e,n,t,i,r)}function In(e,n,t){return e.type==n&&(null==t||e.value==t)}((Hn.prototype=Object.create(Error.prototype)).constructor=Hn).prototype.name=\"SyntaxError\",n(Hn);var Pn={};function Un(r,o,a,s){var u={text:r,filename:o,pos:0,tokpos:0,line:1,tokline:0,col:0,tokcol:0,newline_before:!1,regex_allowed:!1,comments_before:[],directives:{},directive_stack:[]};function c(){return u.text.charAt(u.pos)}function f(e,n){var t=u.text.charAt(u.pos++);if(e&&!t)throw Pn;return P(t)?(u.newline_before=u.newline_before||!n,++u.line,u.col=0,n||\"\\r\"!=t||\"\\n\"!=c()||(++u.pos,t=\"\\n\")):++u.col,t}function l(e){for(;0<e--;)f()}function p(e){return u.text.substr(u.pos,e.length)==e}function d(){u.tokline=u.line,u.tokcol=u.col,u.tokpos=u.pos}var h=!1;function v(e,n,t){u.regex_allowed=\"operator\"==e&&!Vn(n)||\"keyword\"==e&&q(n)||\"punc\"==e&&U(n),\"punc\"==e&&\".\"==n?h=!0:t||(h=!1);var i={type:e,value:n,line:u.tokline,col:u.tokcol,pos:u.tokpos,endline:u.line,endcol:u.col,endpos:u.pos,nlb:u.newline_before,file:o};return/^(?:num|string|regexp)$/i.test(e)&&(i.raw=r.substring(i.pos,i.endpos)),t||(i.comments_before=u.comments_before,i.comments_after=u.comments_before=[]),u.newline_before=!1,new F(i)}function _(){for(;I(c());)f()}function m(e){Rn(e,o,u.tokline,u.tokcol,u.tokpos)}function g(r){var o=!1,a=!1,s=!1,u=\".\"==r,e=function(e){for(var n,t=\"\",i=0;(n=c())&&e(n,i++);)t+=f();return t}(function(e,n){var t,i=e.charCodeAt(0);switch(i){case 120:case 88:return!s&&(s=!0);case 101:case 69:return!!s||!o&&(o=a=!0);case 45:return a||0==n&&!r;case 43:return a;case a=!1,46:return!(u||s||o)&&(u=!0)}return Mn(t=i)||On(t)});r&&(e=r+e),H.test(e)&&D.has_directive(\"use strict\")&&m(\"Legacy octal literals are not allowed in strict mode\");var n=function(e){if(N.test(e))return parseInt(e.substr(2),16);if(H.test(e))return parseInt(e.substr(1),8);var n=parseFloat(e);return n==e?n:void 0}(e);if(!isNaN(n))return v(\"num\",n);m(\"Invalid syntax: \"+e)}function b(e){var n=f(!0,e);switch(n.charCodeAt(0)){case 110:return\"\\n\";case 114:return\"\\r\";case 116:return\"\\t\";case 98:return\"\\b\";case 118:return\"\\v\";case 102:return\"\\f\";case 120:return String.fromCharCode(t(2));case 117:return String.fromCharCode(t(4));case 10:return\"\";case 13:if(\"\\n\"==c())return f(!0,e),\"\"}return\"0\"<=n&&n<=\"7\"?function(e){var n=c();\"0\"<=n&&n<=\"7\"&&(e+=f(!0))[0]<=\"3\"&&\"0\"<=(n=c())&&n<=\"7\"&&(e+=f(!0));if(\"0\"===e)return\"\\0\";0<e.length&&D.has_directive(\"use strict\")&&m(\"Legacy octal escape sequences are not allowed in strict mode\");return String.fromCharCode(parseInt(e,8))}(n):n}function t(e){for(var n=0;0<e;--e){var t=parseInt(f(!0),16);isNaN(t)&&m(\"Invalid hex-character pattern in string\"),n=n<<4|t}return n}var y=n(\"Unterminated string constant\",function(e){for(var n=f(),t=\"\";;){var i=f(!0,!0);if(\"\\\\\"==i)i=b(!0);else if(P(i))m(\"Unterminated string constant\");else if(i==n)break;t+=i}var r=v(\"string\",t);return r.quote=e,r});function w(e){var n,t=u.regex_allowed,i=function(){for(var e=u.text,n=u.pos,t=u.text.length;n<t;++n){var i=e[n];if(P(i))return n}return-1}();return-1==i?(n=u.text.substr(u.pos),u.pos=u.text.length):(n=u.text.substring(u.pos,i),u.pos=i),u.col=u.tokcol+(u.pos-u.tokpos),u.comments_before.push(v(e,n,!0)),u.regex_allowed=t,D}var e=n(\"Unterminated multiline comment\",function(){var e=u.regex_allowed,n=function(e,n){var t=u.text.indexOf(e,u.pos);if(n&&-1==t)throw Pn;return t}(\"*/\",!0),t=u.text.substring(u.pos,n).replace(/\\r\\n|\\r|\\u2028|\\u2029/g,\"\\n\");return l(t.length+2),u.comments_before.push(v(\"comment2\",t,!0)),u.regex_allowed=e,D});function x(){for(var e,n,t=!1,i=\"\",r=!1;null!=(e=c());)if(t)\"u\"!=e&&m(\"Expecting UnicodeEscapeSequence -- uXXXX\"),jn(e=b())||m(\"Unicode char: \"+e.charCodeAt(0)+\" is not valid in identifier\"),i+=e,t=!1;else if(\"\\\\\"==e)r=t=!0,f();else{if(!jn(e))break;i+=f()}return ne(i)&&r&&(n=i.charCodeAt(0).toString(16).toUpperCase(),i=\"\\\\u\"+\"0000\".substr(n.length)+n+i.slice(1)),i}var A=n(\"Unterminated regular expression\",function(e){for(var n,t=!1,i=!1;n=f(!0);)if(P(n))m(\"Unexpected line terminator\");else if(t)e+=\"\\\\\"+n,t=!1;else if(\"[\"==n)i=!0,e+=n;else if(\"]\"==n&&i)i=!1,e+=n;else{if(\"/\"==n&&!i)break;\"\\\\\"==n?t=!0:e+=n}var r=x();try{var o=new RegExp(e,r);return o.raw_source=e,v(\"regexp\",o)}catch(e){m(e.message)}});function E(e){return v(\"operator\",function e(n){if(!c())return n;var t=n+c();return R(t)?(f(),e(t)):n}(e||f()))}function k(){switch(f(),c()){case\"/\":return f(),w(\"comment1\");case\"*\":return f(),e()}return u.regex_allowed?A(\"\"):E(\"/\")}function n(n,t){return function(e){try{return t(e)}catch(e){if(e!==Pn)throw e;m(n)}}}function D(e){if(null!=e)return A(e);for(s&&0==u.pos&&p(\"#!\")&&(d(),l(2),w(\"comment5\"));;){if(_(),d(),a){if(p(\"\\x3c!--\")){l(4),w(\"comment3\");continue}if(p(\"--\\x3e\")&&u.newline_before){l(3),w(\"comment4\");continue}}var n=c();if(!n)return v(\"eof\");var t=n.charCodeAt(0);switch(t){case 34:case 39:return y(n);case 46:return f(),Mn(c().charCodeAt(0))?g(\".\"):v(\"punc\",\".\");case 47:var i=k();if(i===D)continue;return i}if(Mn(t))return g();if(Tn(n))return v(\"punc\",f());if(j(n))return E();if(92==t||qn(t))return void 0,r=x(),h?v(\"name\",r):M(r)?v(\"atom\",r):ne(r)?R(r)?v(\"operator\",r):v(\"keyword\",r):v(\"name\",r);break}var r;m(\"Unexpected character '\"+n+\"'\")}return D.context=function(e){return e&&(u=e),u},D.add_directive=function(e){u.directive_stack[u.directive_stack.length-1].push(e),void 0===u.directives[e]?u.directives[e]=1:u.directives[e]++},D.push_directives_stack=function(){u.directive_stack.push([])},D.pop_directives_stack=function(){for(var e=u.directive_stack[u.directive_stack.length-1],n=0;n<e.length;n++)u.directives[e[n]]--;u.directive_stack.pop()},D.has_directive=function(e){return 0<u.directives[e]},D}var Ln=W([\"typeof\",\"void\",\"delete\",\"--\",\"++\",\"!\",\"~\",\"-\",\"+\"]),Vn=W([\"--\",\"++\"]),Yn=W([\"=\",\"+=\",\"-=\",\"/=\",\"*=\",\"%=\",\">>=\",\"<<=\",\">>>=\",\"|=\",\"^=\",\"&=\"]),Jn=function(e,n){for(var t=0;t<e.length;++t)for(var i=e[t],r=0;r<i.length;++r)n[i[r]]=t+1;return n}([[\"||\"],[\"&&\"],[\"|\"],[\"^\"],[\"&\"],[\"==\",\"===\",\"!=\",\"!==\"],[\"<\",\">\",\"<=\",\">=\",\"in\",\"instanceof\"],[\">>\",\"<<\",\">>>\"],[\"+\",\"-\"],[\"*\",\"/\",\"%\"]],{}),Wn=W([\"atom\",\"num\",\"string\",\"regexp\",\"name\"]);function Gn(e,u){u=Y(u,{bare_returns:!1,expression:!1,filename:null,html5_comments:!0,shebang:!0,strict:!1,toplevel:null},!0);var c={input:\"string\"==typeof e?Un(e,u.filename,u.html5_comments,u.shebang):e,token:null,prev:null,peeked:null,in_function:0,in_directives:!0,in_loop:0,labels:[]};function f(e,n){return In(c.token,e,n)}function l(){return c.peeked||(c.peeked=c.input())}function p(){return c.prev=c.token,c.peeked?(c.token=c.peeked,c.peeked=null):c.token=c.input(),c.in_directives=c.in_directives&&(\"string\"==c.token.type||f(\"punc\",\";\")),c.token}function d(){return c.prev}function h(e,n,t,i){var r=c.input.context();Rn(e,r.filename,null!=n?n:r.tokline,null!=t?t:r.tokcol,null!=i?i:r.tokpos)}function t(e,n){h(n,e.line,e.col)}function v(e){null==e&&(e=c.token),t(e,\"Unexpected token: \"+e.type+\" (\"+e.value+\")\")}function _(e,n){if(f(e,n))return p();t(c.token,\"Unexpected token \"+c.token.type+\" \"+c.token.value+\", expected \"+e+\" \"+n+\"\")}function m(e){return _(\"punc\",e)}function g(e){return e.nlb||!oe(e.comments_before,function(e){return!e.nlb})}function b(){return!u.strict&&(f(\"eof\")||f(\"punc\",\"}\")||g(c.token))}function y(e){f(\"punc\",\";\")?p():e||b()||v()}function w(){m(\"(\");var e=U(!0);return m(\")\"),e}function n(i){return function(){var e=c.token,n=i.apply(null,arguments),t=d();return n.start=e,n.end=t,n}}function x(){(f(\"operator\",\"/\")||f(\"operator\",\"/=\"))&&(c.peeked=null,c.token=c.input(c.token.value.substr(1)))}c.token=p();var A=n(function(e){switch(x(),c.token.type){case\"string\":if(c.in_directives){var n=l();-1==c.token.raw.indexOf(\"\\\\\")&&(In(n,\"punc\",\";\")||In(n,\"punc\",\"}\")||g(n)||In(n,\"eof\"))?c.input.add_directive(c.token.value):c.in_directives=!1}var t=c.in_directives,i=E();return t?new fe(i.body):i;case\"num\":case\"regexp\":case\"operator\":case\"atom\":return E();case\"name\":return In(l(),\"punc\",\":\")?function(){var n=q(Q);V(function(e){return e.name==n.name},c.labels)&&h(\"Label \"+n.name+\" defined twice\");m(\":\"),c.labels.push(n);var e=A();c.labels.pop(),e instanceof _e||n.references.forEach(function(e){e instanceof ze&&(e=e.label.start,h(\"Continue label `\"+n.name+\"` refers to non-IterationStatement.\",e.line,e.col,e.pos))});return new ve({body:e,label:n})}():E();case\"punc\":switch(c.token.value){case\"{\":return new de({start:c.token,body:F(),end:d()});case\"[\":case\"(\":return E();case\";\":return c.in_directives=!1,p(),new he;default:v()}case\"keyword\":switch(c.token.value){case\"break\":return p(),k($e);case\"continue\":return p(),k(ze);case\"debugger\":return p(),y(),new ce;case\"do\":p();var r=L(A);_(\"keyword\",\"while\");var o=w();return y(!0),new ge({body:r,condition:o});case\"while\":return p(),new be({condition:w(),body:L(A)});case\"for\":return p(),function(){m(\"(\");var e=null;if(!f(\"punc\",\";\")&&(e=f(\"keyword\",\"var\")?(p(),B(!0)):U(!0,!0),f(\"operator\",\"in\")))return e instanceof Le?1<e.definitions.length&&h(\"Only one variable declaration allowed in for..in loop\",e.start.line,e.start.col,e.start.pos):I(e)||h(\"Invalid left-hand side in for..in loop\",e.start.line,e.start.col,e.start.pos),p(),n=e,t=U(!0),m(\")\"),new we({init:n,object:t,body:L(A)});var n,t;return function(e){m(\";\");var n=f(\"punc\",\";\")?null:U(!0);m(\";\");var t=f(\"punc\",\")\")?null:U(!0);return m(\")\"),new ye({init:e,condition:n,step:t,body:L(A)})}(e)}();case\"function\":return!e&&c.input.has_directive(\"use strict\")&&h(\"In strict mode code, functions can only be declared at top level or immediately within another function.\"),p(),D(Ce);case\"if\":return p(),function(){var e=w(),n=A(),t=null;f(\"keyword\",\"else\")&&(p(),t=A());return new Me({condition:e,body:n,alternative:t})}();case\"return\":0!=c.in_function||u.bare_returns||h(\"'return' outside of function\"),p();var a=null;return f(\"punc\",\";\")?p():b()||(a=U(!0),y()),new Te({value:a});case\"switch\":return p(),new qe({expression:w(),body:L(C)});case\"throw\":p(),g(c.token)&&h(\"Illegal newline after 'throw'\");a=U(!0);return y(),new G({value:a});case\"try\":return p(),function(){var e=F(),n=null,t=null;if(f(\"keyword\",\"catch\")){var i=c.token;p(),m(\"(\");var r=q(vn);m(\")\"),n=new Ie({start:i,argname:r,body:F(),end:d()})}if(f(\"keyword\",\"finally\")){var i=c.token;p(),t=new Pe({start:i,body:F(),end:d()})}n||t||h(\"Missing catch/finally blocks\");return new Re({body:e,bcatch:n,bfinally:t})}();case\"var\":p();var s=B();return y(),s;case\"with\":return c.input.has_directive(\"use strict\")&&h(\"Strict mode may not include a with statement\"),p(),new xe({expression:w(),body:A()})}}v()});function E(e){return new le({body:(e=U(!0),y(),e)})}function k(e){var n,t=null;b()||(t=q(ee,!0)),null!=t?((n=V(function(e){return e.name==t.name},c.labels))||h(\"Undefined label \"+t.name),t.thedef=n):0==c.in_loop&&h(e.TYPE+\" not inside a loop or switch\"),y();var i=new e({label:t});return n&&n.references.push(i),i}var D=function(e){var n=e===Ce,t=f(\"name\")?q(n?dn:hn):null;n&&!t&&v(),!t||e===De||t instanceof fn||v(d()),m(\"(\");for(var i=[],r=!0;!f(\"punc\",\")\");)r?r=!1:m(\",\"),i.push(q(pn));p();var o=c.in_loop,a=c.labels;++c.in_function,c.in_directives=!0,c.input.push_directives_stack(),c.in_loop=0,c.labels=[];var s=F(!0);return c.input.has_directive(\"use strict\")&&(t&&M(t),i.forEach(M)),c.input.pop_directives_stack(),--c.in_function,c.in_loop=o,c.labels=a,new e({name:t,argnames:i,body:s})};function F(e){m(\"{\");for(var n=[];!f(\"punc\",\"}\");)f(\"eof\")&&v(),n.push(A(e));return p(),n}function C(){m(\"{\");for(var e,n=[],t=null,i=null;!f(\"punc\",\"}\");)f(\"eof\")&&v(),f(\"keyword\",\"case\")?(i&&(i.end=d()),t=[],i=new He({start:(e=c.token,p(),e),expression:U(!0),body:t}),n.push(i),m(\":\")):f(\"keyword\",\"default\")?(i&&(i.end=d()),t=[],i=new Ne({start:(e=c.token,p(),m(\":\"),e),body:t}),n.push(i)):(t||v(),t.push(A()));return i&&(i.end=d()),p(),n}var B=function(e){return new Le({start:d(),definitions:function(e){for(var n=[];n.push(new Ve({start:c.token,name:q(ln),value:f(\"operator\",\"=\")?(p(),U(!1,e)):null,end:d()})),f(\"punc\",\",\");)p();return n}(e),end:d()})};var s=function(e){if(f(\"operator\",\"new\"))return function(e){var n=c.token;_(\"operator\",\"new\");var t,i=s(!1);f(\"punc\",\"(\")?(p(),t=S(\")\")):t=[];var r=new Je({start:n,expression:i,args:t,end:d()});return j(r),N(r,e)}(e);var n=c.token;if(f(\"punc\")){switch(n.value){case\"(\":p();var t=U(!0),i=n.comments_before.length;if([].unshift.apply(t.start.comments_before,n.comments_before),n.comments_before=t.start.comments_before,0==(n.comments_before_length=i)&&0<n.comments_before.length){var r=n.comments_before[0];r.nlb||(r.nlb=n.nlb,n.nlb=!1)}n.comments_after=t.start.comments_after,t.start=n,m(\")\");var o=d();return o.comments_before=t.end.comments_before,[].push.apply(t.end.comments_after,o.comments_after),o.comments_after=t.end.comments_after,t.end=o,t instanceof Ye&&j(t),N(t,e);case\"[\":return N(T(),e);case\"{\":return N(O(),e)}v()}if(f(\"keyword\",\"function\")){p();var a=D(Fe);return a.start=n,a.end=d(),N(a,e)}if(Wn(c.token.type))return N(function(){var e,n=c.token;switch(n.type){case\"name\":e=z(_n);break;case\"num\":e=new yn({start:n,end:n,value:n.value});break;case\"string\":e=new bn({start:n,end:n,value:n.value,quote:n.quote});break;case\"regexp\":e=new wn({start:n,end:n,value:n.value});break;case\"atom\":switch(n.value){case\"false\":e=new Cn({start:n,end:n});break;case\"true\":e=new Bn({start:n,end:n});break;case\"null\":e=new xn({start:n,end:n})}}return p(),e}(),e);v()};function S(e,n,t){for(var i=!0,r=[];!f(\"punc\",e)&&(i?i=!1:m(\",\"),!n||!f(\"punc\",e));)f(\"punc\",\",\")&&t?r.push(new kn({start:c.token,end:c.token})):r.push(U(!1));return p(),r}var T=n(function(){return m(\"[\"),new on({elements:S(\"]\",!u.strict,!0)})}),a=n(function(){return D(De)}),O=n(function(){m(\"{\");for(var e=!0,n=[];!f(\"punc\",\"}\")&&(e?e=!1:m(\",\"),u.strict||!f(\"punc\",\"}\"));){var t=c.token,i=t.type,r=$();if(\"name\"==i&&!f(\"punc\",\":\")){var o=new K({start:c.token,name:\"\"+$(),end:d()});if(\"get\"==r){n.push(new Z({start:t,key:o,value:a(),end:d()}));continue}if(\"set\"==r){n.push(new X({start:t,key:o,value:a(),end:d()}));continue}}m(\":\"),n.push(new un({start:t,quote:t.quote,key:\"\"+r,value:U(!1),end:d()}))}return p(),new an({properties:n})});function $(){var e=c.token;switch(e.type){case\"operator\":ne(e.value)||v();case\"num\":case\"string\":case\"name\":case\"keyword\":case\"atom\":return p(),e.value;default:v()}}function z(e){var n=c.token.value;return new(\"this\"==n?mn:e)({name:String(n),start:c.token,end:c.token})}function M(e){\"arguments\"!=e.name&&\"eval\"!=e.name||h(\"Unexpected \"+e.name+\" in strict mode\",e.start.line,e.start.col,e.start.pos)}function q(e,n){if(!f(\"name\"))return n||h(\"Name expected\"),null;var t=z(e);return c.input.has_directive(\"use strict\")&&t instanceof fn&&M(t),p(),t}function j(e){for(var n=e.start,t=n.comments_before,i=ae(n,\"comments_before_length\")?n.comments_before_length:t.length;0<=--i;){var r=t[i];if(/[@#]__PURE__/.test(r.value)){e.pure=r;break}}}var N=function(e,n){var t,i=e.start;if(f(\"punc\",\".\"))return p(),N(new Xe({start:i,expression:e,property:(t=c.token,\"name\"!=t.type&&v(),p(),t.value),end:d()}),n);if(f(\"punc\",\"[\")){p();var r=U(!0);return m(\"]\"),N(new Ze({start:i,expression:e,property:r,end:d()}),n)}if(n&&f(\"punc\",\"(\")){p();var o=new Ye({start:i,expression:e,args:S(\")\"),end:d()});return j(o),N(o,!0)}return e},H=function(e){var n=c.token;if(f(\"operator\")&&Ln(n.value)){p(),x();var t=r(Qe,n,H(e));return t.start=n,t.end=d(),t}for(var i=s(e);f(\"operator\")&&Vn(c.token.value)&&!g(c.token);)(i=r(en,c.token,i)).start=n,i.end=c.token,p();return i};function r(e,n,t){var i=n.value;switch(i){case\"++\":case\"--\":I(t)||h(\"Invalid use of \"+i+\" operator\",n.line,n.col,n.pos);break;case\"delete\":t instanceof _n&&c.input.has_directive(\"use strict\")&&h(\"Calling delete on expression not allowed in strict mode\",t.start.line,t.start.col,t.start.pos)}return new e({operator:i,expression:t})}var R=function(e,n,t){var i=f(\"operator\")?c.token.value:null;\"in\"==i&&t&&(i=null);var r=null!=i?Jn[i]:null;if(null!=r&&n<r){p();var o=R(H(!0),r,t);return R(new nn({start:e.start,left:e,operator:i,right:o,end:o.end}),n,t)}return e};var o=function(e){var n,t=c.token,i=(n=e,R(H(!0),0,n));if(f(\"operator\",\"?\")){p();var r=U(!1);return m(\":\"),new tn({start:t,condition:i,consequent:r,alternative:U(!1,e),end:d()})}return i};function I(e){return e instanceof Ge||e instanceof _n}var P=function(e){var n=c.token,t=o(e),i=c.token.value;if(f(\"operator\")&&Yn(i)){if(I(t))return p(),new rn({start:n,left:t,operator:i,right:P(e),end:d()});h(\"Invalid assignment\")}return t},U=function(e,n){for(var t=c.token,i=[];i.push(P(n)),e&&f(\"punc\",\",\");)p(),e=!0;return 1==i.length?i[0]:new We({start:t,expressions:i,end:l()})};function L(e){++c.in_loop;var n=e();return--c.in_loop,n}return u.expression?U(!0):function(){var e=c.token,n=[];for(c.input.push_directives_stack();!f(\"eof\");)n.push(A(!0));c.input.pop_directives_stack();var t=d(),i=u.toplevel;return i?(i.body=i.body.concat(n),i.end=t):i=new Ee({start:e,body:n,end:t}),i}()}function Xn(e,n){Sn.call(this),this.before=e,this.after=n}function r(e,n,t){this.name=n.name,this.orig=[n],this.init=t,this.eliminated=0,this.scope=e,this.references=[],this.replaced=0,this.global=!1,this.mangled_name=null,this.undeclared=!1,this.id=r.next_id++}function p(e,n){var t=e.names_in_use;return t||(e.names_in_use=t=Object.create(e.mangled_names||null),e.cname_holes=[],e.enclosed.forEach(function(e){e.unmangleable(n)&&(t[e.name]=!0)})),t}function f(e){return e=Y(e,{eval:!1,ie8:!1,keep_fnames:!1,reserved:[],toplevel:!1}),Array.isArray(e.reserved)||(e.reserved=[]),v(e.reserved,\"arguments\"),e}Xn.prototype=new Sn,function(o){function e(e,r){e.DEFMETHOD(\"transform\",function(e,n){var t,i;return e.push(this),e.before&&(t=e.before(this,r,n)),t===o&&(r(t=this,e),e.after&&(i=e.after(t,n))!==o&&(t=i)),e.pop(),t})}function t(e,n){return re(e,function(e){return e.transform(n,!0)})}e(se,L),e(ve,function(e,n){e.label=e.label.transform(n),e.body=e.body.transform(n)}),e(le,function(e,n){e.body=e.body.transform(n)}),e(pe,function(e,n){e.body=t(e.body,n)}),e(me,function(e,n){e.condition=e.condition.transform(n),e.body=e.body.transform(n)}),e(ye,function(e,n){e.init&&(e.init=e.init.transform(n)),e.condition&&(e.condition=e.condition.transform(n)),e.step&&(e.step=e.step.transform(n)),e.body=e.body.transform(n)}),e(we,function(e,n){e.init=e.init.transform(n),e.object=e.object.transform(n),e.body=e.body.transform(n)}),e(xe,function(e,n){e.expression=e.expression.transform(n),e.body=e.body.transform(n)}),e(Se,function(e,n){e.value&&(e.value=e.value.transform(n))}),e(Oe,function(e,n){e.label&&(e.label=e.label.transform(n))}),e(Me,function(e,n){e.condition=e.condition.transform(n),e.body=e.body.transform(n),e.alternative&&(e.alternative=e.alternative.transform(n))}),e(qe,function(e,n){e.expression=e.expression.transform(n),e.body=t(e.body,n)}),e(He,function(e,n){e.expression=e.expression.transform(n),e.body=t(e.body,n)}),e(Re,function(e,n){e.body=t(e.body,n),e.bcatch&&(e.bcatch=e.bcatch.transform(n)),e.bfinally&&(e.bfinally=e.bfinally.transform(n))}),e(Ie,function(e,n){e.argname=e.argname.transform(n),e.body=t(e.body,n)}),e(Ue,function(e,n){e.definitions=t(e.definitions,n)}),e(Ve,function(e,n){e.name=e.name.transform(n),e.value&&(e.value=e.value.transform(n))}),e(ke,function(e,n){e.name&&(e.name=e.name.transform(n)),e.argnames=t(e.argnames,n),e.body=t(e.body,n)}),e(Ye,function(e,n){e.expression=e.expression.transform(n),e.args=t(e.args,n)}),e(We,function(e,n){e.expressions=t(e.expressions,n)}),e(Xe,function(e,n){e.expression=e.expression.transform(n)}),e(Ze,function(e,n){e.expression=e.expression.transform(n),e.property=e.property.transform(n)}),e(Ke,function(e,n){e.expression=e.expression.transform(n)}),e(nn,function(e,n){e.left=e.left.transform(n),e.right=e.right.transform(n)}),e(tn,function(e,n){e.condition=e.condition.transform(n),e.consequent=e.consequent.transform(n),e.alternative=e.alternative.transform(n)}),e(on,function(e,n){e.elements=t(e.elements,n)}),e(an,function(e,n){e.properties=t(e.properties,n)}),e(sn,function(e,n){e.value=e.value.transform(n)})}(),r.next_id=1,r.prototype={unmangleable:function(e){return e||(e={}),this.global&&!e.toplevel||this.undeclared||!e.eval&&(this.scope.uses_eval||this.scope.uses_with)||e.keep_fnames&&(this.orig[0]instanceof hn||this.orig[0]instanceof dn)},mangle:function(e){var n=e.cache&&e.cache.props;if(this.global&&n&&n.has(this.name))this.mangled_name=n.get(this.name);else if(!this.mangled_name&&!this.unmangleable(e)){var t;(t=this.redefined())?this.mangled_name=t.mangled_name||t.name:this.mangled_name=function(e,i,n){var t=p(e,i),r=e.cname_holes,o=Object.create(null);if(e instanceof Fe&&e.name&&n.orig[0]instanceof pn){var a=e.name.definition();o[a.mangled_name||a.name]=!0}var s,u=[e];n.references.forEach(function(e){var n=e.scope;do{if(!(u.indexOf(n)<0))break;for(var t in p(n,i))o[t]=!0;u.push(n)}while(n=n.parent_scope)});for(var c=0,f=r.length;c<f;c++)if(s=g(r[c]),!o[s])return r.splice(c,1),e.names_in_use[s]=!0,s;for(;;)if(s=g(++e.cname),!t[s]&&l(s)&&!te(s,i.reserved)){if(!o[s])break;r.push(e.cname)}e.names_in_use[s]=!0,i.ie8&&n.orig[0]instanceof hn&&(p(e.parent_scope,i)[s]=!0);return s}(this.scope,e,this),this.global&&n&&n.set(this.name,this.mangled_name)}},redefined:function(){return this.defun&&this.defun.variables.get(this.name)}},Ee.DEFMETHOD(\"figure_out_scope\",function(c){c=Y(c,{cache:null,ie8:!1});var a=this,f=a.parent_scope=null,l=new O,p=null,s=new Sn(function(e,n){if(e instanceof Ie){var t=f;return(f=new Ae(e)).init_scope_vars(t),n(),f=t,!0}if(e instanceof Ae){e.init_scope_vars(f);t=f;var i=p,r=l;return p=f=e,l=new O,n(),f=t,p=i,l=r,!0}if(e instanceof ve){var o=e.label;if(l.has(o.name))throw new Error(S(\"Label {name} defined twice\",o));return l.set(o.name,o),n(),l.del(o.name),!0}if(e instanceof xe)for(var a=f;a;a=a.parent_scope)a.uses_with=!0;else if(e instanceof cn&&(e.scope=f),e instanceof Q&&((e.thedef=e).references=[]),e instanceof hn)p.def_function(e,\"arguments\"==e.name?void 0:p);else if(e instanceof dn)(e.scope=p.parent_scope).def_function(e,p);else if(e instanceof ln){if(p.def_variable(e,\"SymbolVar\"==e.TYPE?null:void 0),p!==f){e.mark_enclosed(c);var s=f.find_variable(e);e.thedef!==s&&(e.thedef=s),e.reference(c)}}else if(e instanceof vn)f.def_variable(e).defun=p;else if(e instanceof ee){var u=l.get(e.name);if(!u)throw new Error(S(\"Undefined label {name} [{line},{col}]\",{name:e.name,line:e.start.line,col:e.start.col}));e.thedef=u}});a.walk(s),a.globals=new O;s=new Sn(function(e,n){if(e instanceof Oe&&e.label)return e.label.thedef.references.push(e),!0;if(e instanceof _n){var t=e.name;if(\"eval\"==t&&s.parent()instanceof Ye)for(var i=e.scope;i&&!i.uses_eval;i=i.parent_scope)i.uses_eval=!0;var r=e.scope.find_variable(t);return r?r.scope instanceof ke&&\"arguments\"==t&&(r.scope.uses_arguments=!0):r=a.def_global(e),e.thedef=r,e.reference(c),!0}var o;if(e instanceof vn&&(o=e.definition().redefined()))for(i=e.scope;i&&(v(i.enclosed,o),i!==o.scope);)i=i.parent_scope});a.walk(s),c.ie8&&a.walk(new Sn(function(e,n){if(e instanceof vn){var t=e.name,i=e.thedef.references,r=e.thedef.defun,o=r.find_variable(t)||a.globals.get(t)||r.def_variable(e);return i.forEach(function(e){e.thedef=o,e.reference(c)}),e.thedef=o,e.reference(c),!0}}))}),Ee.DEFMETHOD(\"def_global\",function(e){var n=this.globals,t=e.name;if(n.has(t))return n.get(t);var i=new r(this,e);return i.undeclared=!0,i.global=!0,n.set(t,i),i}),Ae.DEFMETHOD(\"init_scope_vars\",function(e){this.variables=new O,this.functions=new O,this.uses_with=!1,this.uses_eval=!1,this.parent_scope=e,this.enclosed=[],this.cname=-1}),ke.DEFMETHOD(\"init_scope_vars\",function(){Ae.prototype.init_scope_vars.apply(this,arguments),this.uses_arguments=!1,this.def_variable(new pn({name:\"arguments\",start:this.start,end:this.end}))}),cn.DEFMETHOD(\"mark_enclosed\",function(e){for(var n=this.definition(),t=this.scope;t&&(v(t.enclosed,n),e.keep_fnames&&t.functions.each(function(e){v(n.scope.enclosed,e)}),t!==n.scope);)t=t.parent_scope}),cn.DEFMETHOD(\"reference\",function(e){this.definition().references.push(this),this.mark_enclosed(e)}),Ae.DEFMETHOD(\"find_variable\",function(e){return e instanceof cn&&(e=e.name),this.variables.get(e)||this.parent_scope&&this.parent_scope.find_variable(e)}),Ae.DEFMETHOD(\"def_function\",function(e,n){var t=this.def_variable(e,n);return(!t.init||t.init instanceof Ce)&&(t.init=n),this.functions.set(e.name,t),t}),Ae.DEFMETHOD(\"def_variable\",function(e,n){var t=this.variables.get(e.name);return t?(t.orig.push(e),t.init&&(t.scope!==e.scope||t.init instanceof Fe)&&(t.init=n)):(t=new r(this,e,n),this.variables.set(e.name,t),t.global=!this.parent_scope),e.thedef=t}),cn.DEFMETHOD(\"unmangleable\",function(e){var n=this.definition();return!n||n.unmangleable(e)}),Q.DEFMETHOD(\"unmangleable\",ie),cn.DEFMETHOD(\"unreferenced\",function(){return 0==this.definition().references.length&&!(this.scope.uses_eval||this.scope.uses_with)}),cn.DEFMETHOD(\"definition\",function(){return this.thedef}),cn.DEFMETHOD(\"global\",function(){return this.definition().global}),Ee.DEFMETHOD(\"mangle_names\",function(a){a=f(a);var s=-1;if(a.cache&&a.cache.props){var n=this.mangled_names=Object.create(null);a.cache.props.each(function(e){n[e]=!0})}var u=[],e=new Sn(function(e,n){if(e instanceof ve){var t=s;return n(),s=t,!0}if(e instanceof Ae)return n(),a.cache&&e instanceof Ee&&e.globals.each(c),e.variables.each(c),!0;if(e instanceof Q){for(var i;!l(i=g(++s)););return e.mangled_name=i,!0}if(!a.ie8&&e instanceof Ie){var r=e.argname.definition(),o=r.redefined();return o&&(u.push(r),r.references.forEach(function(e){e.thedef=o,e.reference(a),e.thedef=r})),n(),o||c(r),!0}});function c(e){te(e.name,a.reserved)||e.mangle(a)}this.walk(e),u.forEach(c)}),Ee.DEFMETHOD(\"find_colliding_names\",function(t){var i=t.cache&&t.cache.props,n=Object.create(null);return t.reserved.forEach(r),this.globals.each(o),this.walk(new Sn(function(e){e instanceof Ae&&e.variables.each(o),e instanceof vn&&o(e.definition())})),n;function r(e){n[e]=!0}function o(e){var n=e.name;if(e.global&&i&&i.has(n))n=i.get(n);else if(!e.unmangleable(t))return;r(n)}}),Ee.DEFMETHOD(\"expand_names\",function(t){g.reset(),g.sort(),t=f(t);var i=this.find_colliding_names(t),r=0;function n(n){if(!(n.global&&t.cache||n.unmangleable(t)||te(n.name,t.reserved))){var e=n.redefined();n.name=e?e.name:function(){for(var e;e=g(r++),i[e]||!l(e););return e}(),n.orig.forEach(function(e){e.name=n.name}),n.references.forEach(function(e){e.name=n.name})}}this.globals.each(n),this.walk(new Sn(function(e){e instanceof Ae&&e.variables.each(n),e instanceof vn&&n(e.definition())}))}),se.DEFMETHOD(\"tail_node\",C),We.DEFMETHOD(\"tail_node\",function(){return this.expressions[this.expressions.length-1]}),Ee.DEFMETHOD(\"compute_char_frequency\",function(t){t=f(t),g.reset();try{se.prototype.print=function(e,n){this._print(e,n),this instanceof cn&&!this.unmangleable(t)?g.consider(this.name,-1):t.properties&&(this instanceof Xe?g.consider(this.property,-1):this instanceof Ze&&function e(n){n instanceof bn?g.consider(n.value,-1):n instanceof tn?(e(n.consequent),e(n.alternative)):n instanceof We&&e(n.tail_node())}(this.property))},g.consider(this.print_to_string(),1)}finally{se.prototype.print=se.prototype._print}g.sort()});var g=function(){var i,r,e=\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_\".split(\"\"),n=\"0123456789\".split(\"\");function t(){r=Object.create(null),e.forEach(function(e){r[e]=0}),n.forEach(function(e){r[e]=0})}function o(e,n){return r[n]-r[e]}function a(e){var n=\"\",t=54;for(e++;n+=i[--e%t],e=Math.floor(e/t),t=64,0<e;);return n}return a.consider=function(e,n){for(var t=e.length;0<=--t;)r[e[t]]+=n},a.sort=function(){i=s(e,o).concat(s(n,o))},(a.reset=t)(),a}(),Zn=/^$|[;{][\\s\\n]*$/;function Kn(e){return\"comment2\"==e.type&&/@preserve|@license|@cc_on/i.test(e.value)}function Qn(s){var e=!s;s=Y(s,{ascii_only:!1,beautify:!1,braces:!1,comments:!1,ie8:!1,indent_level:4,indent_start:0,inline_script:!0,keep_quoted_props:!1,max_line_len:!1,preamble:null,preserve_line:!1,quote_keys:!1,quote_style:0,semicolons:!0,shebang:!0,source_map:null,webkit:!1,width:80,wrap_iife:!1},!0);var u=ie;if(s.comments){var n=s.comments;if(\"string\"==typeof s.comments&&/^\\/.*\\/[a-zA-Z]*$/.test(s.comments)){var t=s.comments.lastIndexOf(\"/\");n=new RegExp(s.comments.substr(1,t-1),s.comments.substr(t+1))}u=n instanceof RegExp?function(e){return\"comment5\"!=e.type&&n.test(e.value)}:\"function\"==typeof n?function(e){return\"comment5\"!=e.type&&n(this,e)}:\"some\"===n?Kn:J}var r=0,a=0,c=1,f=0,l=\"\",p=s.ascii_only?function(e,t){return e.replace(/[\\u0000-\\u001f\\u007f-\\uffff]/g,function(e){var n=e.charCodeAt(0).toString(16);if(n.length<=2&&!t){for(;n.length<2;)n=\"0\"+n;return\"\\\\x\"+n}for(;n.length<4;)n=\"0\"+n;return\"\\\\u\"+n})}:function(e){for(var n=\"\",t=0,i=e.length;t<i;t++)$n(e[t])&&!zn(e[t+1])||zn(e[t])&&!$n(e[t-1])?n+=\"\\\\u\"+e.charCodeAt(t).toString(16):n+=e[t];return n};function o(e,n){var t=function(t,e){var i=0,r=0;function n(){return\"'\"+t.replace(/\\x27/g,\"\\\\'\")+\"'\"}function o(){return'\"'+t.replace(/\\x22/g,'\\\\\"')+'\"'}switch(t=t.replace(/[\\\\\\b\\f\\n\\r\\v\\t\\x22\\x27\\u2028\\u2029\\0\\ufeff]/g,function(e,n){switch(e){case'\"':return++i,'\"';case\"'\":return++r,\"'\";case\"\\\\\":return\"\\\\\\\\\";case\"\\n\":return\"\\\\n\";case\"\\r\":return\"\\\\r\";case\"\\t\":return\"\\\\t\";case\"\\b\":return\"\\\\b\";case\"\\f\":return\"\\\\f\";case\"\\v\":return s.ie8?\"\\\\x0B\":\"\\\\v\";case\"\\u2028\":return\"\\\\u2028\";case\"\\u2029\":return\"\\\\u2029\";case\"\\ufeff\":return\"\\\\ufeff\";case\"\\0\":return/[0-9]/.test(t.charAt(n+1))?\"\\\\x00\":\"\\\\0\"}return e}),t=p(t),s.quote_style){case 1:return n();case 2:return o();case 3:return\"'\"==e?n():o();default:return r<i?n():o()}}(e,n);return s.inline_script&&(t=(t=(t=t.replace(/<\\x2f(script)([>\\/\\t\\n\\f\\r ])/gi,\"<\\\\/$1$2\")).replace(/\\x3c!--/g,\"\\\\x3c!--\")).replace(/--\\x3e/g,\"--\\\\x3e\")),t}function i(e){return function e(n,t){if(t<=0)return\"\";if(1==t)return n;var i=e(n,t>>1);return i+=i,1&t&&(i+=n),i}(\" \",s.indent_start+r-e*s.indent_level)}var d,h,v=!1,_=!1,m=0,g=!1,b=!1,y=-1,w=\"\",x=s.source_map&&[],A=x?function(){x.forEach(function(n){try{s.source_map.add(n.token.file,n.line,n.col,n.token.line,n.token.col,n.name||\"name\"!=n.token.type?n.name:n.token.value)}catch(e){se.warn(\"Couldn't figure out mapping for {file}:{line},{col}  {cline},{ccol} [{name}]\",{file:n.token.file,line:n.token.line,col:n.token.col,cline:n.line,ccol:n.col,name:n.name||\"\"})}}),x=[]}:L,E=s.max_line_len?function(){if(a>s.max_line_len){if(m){var e=l.slice(0,m),n=l.slice(m);if(x){var t=n.length-a;x.forEach(function(e){e.line++,e.col+=t})}l=e+\"\\n\"+n,c++,f++,a=n.length}a>s.max_line_len&&se.warn(\"Output exceeds {max_line_len} characters\",s)}m&&(m=0,A())}:L,k=W(\"( [ + * / - , .\");function D(e){var n=(e=String(e)).charAt(0);g&&n&&(g=!1,\"\\n\"!=n&&(D(\"\\n\"),C())),b&&n&&(b=!1,/[\\s;})]/.test(n)||F()),y=-1;var t=w.charAt(w.length-1);if(_&&(_=!1,(\":\"==t&&\"}\"==n||(!n||\";}\".indexOf(n)<0)&&\";\"!=t)&&(s.semicolons||k(n)?(l+=\";\",a++,f++):(E(),l+=\"\\n\",f++,c++,a=0,/^\\s+$/.test(e)&&(_=!0)),s.beautify||(v=!1))),!s.beautify&&s.preserve_line&&q[q.length-1])for(var i=q[q.length-1].start.line;c<i;)E(),l+=\"\\n\",f++,c++,a=0,v=!1;v&&((jn(t)&&(jn(n)||\"\\\\\"==n)||\"/\"==n&&n==t||(\"+\"==n||\"-\"==n)&&n==w)&&(l+=\" \",a++,f++),v=!1),d&&(x.push({token:d,name:h,line:c,col:a}),d=!1,m||A()),l+=e,f+=e.length;var r=e.split(/\\r?\\n/),o=r.length-1;c+=o,a+=r[0].length,0<o&&(E(),a=r[o].length),w=e}var F=s.beautify?function(){D(\" \")}:function(){v=!0},C=s.beautify?function(e){s.beautify&&D(i(e?.5:0))}:L,B=s.beautify?function(e,n){!0===e&&(e=$());var t=r;r=e;var i=n();return r=t,i}:function(e,n){return n()},S=s.beautify?function(){if(y<0)return D(\"\\n\");\"\\n\"!=l[y]&&(l=l.slice(0,y)+\"\\n\"+l.slice(y),f++,c++),y++}:s.max_line_len?function(){E(),m=l.length}:L,T=s.beautify?function(){D(\";\")}:function(){_=!0};function O(){_=!1,D(\";\")}function $(){return r+s.indent_level}function z(){return m&&E(),l}function M(){var e=l.lastIndexOf(\"\\n\");return/^ *$/.test(l.slice(e+1))}var q=[];return{get:z,toString:z,indent:C,indentation:function(){return r},current_width:function(){return a-r},should_break:function(){return s.width&&this.current_width()>=s.width},has_parens:function(){return\"(\"==l.slice(-1)},newline:S,print:D,space:F,comma:function(){D(\",\"),F()},colon:function(){D(\":\"),F()},last:function(){return w},semicolon:T,force_semicolon:O,to_utf8:p,print_name:function(e){var n;D((n=(n=e).toString(),n=p(n,!0)))},print_string:function(e,n,t){var i=o(e,n);!0===t&&-1===i.indexOf(\"\\\\\")&&(Zn.test(l)||O(),O()),D(i)},encode_string:o,next_indent:$,with_indent:B,with_block:function(e){var n;return D(\"{\"),S(),B($(),function(){n=e()}),C(),D(\"}\"),n},with_parens:function(e){D(\"(\");var n=e();return D(\")\"),n},with_square:function(e){D(\"[\");var n=e();return D(\"]\"),n},add_mapping:x?function(e,n){d=e,h=n}:L,option:function(e){return s[e]},prepend_comments:e?L:function(e){var i=this,n=e.start;if(n&&(!n.comments_before||n.comments_before._dumped!==i)){var r=n.comments_before;if(r||(r=n.comments_before=[]),r._dumped=i,e instanceof Se&&e.value){var o=new Sn(function(e){var n=o.parent();if(!(n instanceof Se||n instanceof nn&&n.left===e||\"Call\"==n.TYPE&&n.expression===e||n instanceof tn&&n.condition===e||n instanceof Xe&&n.expression===e||n instanceof We&&n.expressions[0]===e||n instanceof Ze&&n.expression===e||n instanceof en))return!0;var t=e.start.comments_before;t&&t._dumped!==i&&(t._dumped=i,r=r.concat(t))});o.push(e),e.value.walk(o)}if(0==f){0<r.length&&s.shebang&&\"comment5\"==r[0].type&&(D(\"#!\"+r.shift().value+\"\\n\"),C());var t=s.preamble;t&&D(t.replace(/\\r\\n?|[\\n\\u2028\\u2029]|\\s*$/g,\"\\n\"))}if(0!=(r=r.filter(u,e)).length){var a=M();r.forEach(function(e,n){a||(e.nlb?(D(\"\\n\"),C(),a=!0):0<n&&F()),/comment[134]/.test(e.type)?(D(\"//\"+e.value.replace(/[@#]__PURE__/g,\" \")+\"\\n\"),C(),a=!0):\"comment2\"==e.type&&(D(\"/*\"+e.value.replace(/[@#]__PURE__/g,\" \")+\"*/\"),a=!1)}),a||(n.nlb?(D(\"\\n\"),C()):F())}}},append_comments:e||u===ie?L:function(e,t){var n=e.end;if(n){var i=n[t?\"comments_before\":\"comments_after\"];if(i&&i._dumped!==this&&(e instanceof ue||oe(i,function(e){return!/comment[134]/.test(e.type)}))){i._dumped=this;var r=l.length;i.filter(u,e).forEach(function(e,n){b=!1,g?(D(\"\\n\"),C(),g=!1):e.nlb&&(0<n||!M())?(D(\"\\n\"),C()):(0<n||!t)&&F(),/comment[134]/.test(e.type)?(D(\"//\"+e.value.replace(/[@#]__PURE__/g,\" \")),g=!0):\"comment2\"==e.type&&(D(\"/*\"+e.value.replace(/[@#]__PURE__/g,\" \")+\"*/\"),b=!0)}),l.length>r&&(y=r)}}},line:function(){return c},col:function(){return a},pos:function(){return f},push_node:function(e){q.push(e)},pop_node:function(){return q.pop()},parent:function(e){return q[q.length-2-(e||0)]}}}function et(e,n){if(!(this instanceof et))return new et(e,n);Xn.call(this,this.before,this.after),this.options=Y(e,{arguments:!n,booleans:!n,collapse_vars:!n,comparisons:!n,conditionals:!n,dead_code:!n,drop_console:!1,drop_debugger:!n,evaluate:!n,expression:!1,global_defs:{},hoist_funs:!1,hoist_props:!n,hoist_vars:!1,ie8:!1,if_return:!n,inline:!n,join_vars:!n,keep_fargs:!0,keep_fnames:!1,keep_infinity:!1,loops:!n,negate_iife:!n,passes:1,properties:!n,pure_getters:!n&&\"strict\",pure_funcs:null,reduce_funcs:!n,reduce_vars:!n,sequences:!n,side_effects:!n,switches:!n,top_retain:null,toplevel:!(!e||!e.top_retain),typeofs:!n,unsafe:!1,unsafe_comps:!1,unsafe_Function:!1,unsafe_math:!1,unsafe_proto:!1,unsafe_regexp:!1,unsafe_undefined:!1,unused:!n,warnings:!1},!0);var t=this.options.global_defs;if(\"object\"==typeof t)for(var i in t)/^@/.test(i)&&ae(t,i)&&(t[i.slice(1)]=Gn(t[i],{expression:!0}));!0===this.options.inline&&(this.options.inline=3);var r=this.options.pure_funcs;this.pure_funcs=\"function\"==typeof r?r:r?function(e){return r.indexOf(e.expression.print_to_string())<0}:J;var o=this.options.top_retain;o instanceof RegExp?this.top_retain=function(e){return o.test(e.name)}:\"function\"==typeof o?this.top_retain=o:o&&(\"string\"==typeof o&&(o=o.split(/,/)),this.top_retain=function(e){return 0<=o.indexOf(e.name)});var a=this.options.toplevel;this.toplevel=\"string\"==typeof a?{funcs:/funcs/.test(a),vars:/vars/.test(a)}:{funcs:a,vars:a};var s=this.options.sequences;this.sequences_limit=1==s?800:0|s,this.warnings_produced={}}function b(e,n){e.walk(new Sn(function(e){return e instanceof We?b(e.tail_node(),n):e instanceof bn?n(e.value):e instanceof tn&&(b(e.consequent,n),b(e.alternative,n)),!0}))}function d(e,n){var t=(n=Y(n,{builtins:!1,cache:null,debug:!1,keep_quoted:!1,only_cache:!1,regex:null,reserved:null},!0)).reserved;Array.isArray(t)||(t=[]),n.builtins||function(n){function t(e){v(n,e)}[\"null\",\"true\",\"false\",\"Infinity\",\"-Infinity\",\"undefined\"].forEach(t),[Object,Array,Function,Number,String,Boolean,Error,Math,Date,RegExp].forEach(function(e){Object.getOwnPropertyNames(e).map(t),e.prototype&&Object.getOwnPropertyNames(e.prototype).map(t)})}(t);var i,r=-1;n.cache?(i=n.cache.props).each(function(e){v(t,e)}):i=new O;var o,a=n.regex,s=!1!==n.debug;s&&(o=!0===n.debug?\"\":n.debug);var u=[],c=[];return e.walk(new Sn(function(e){e instanceof un?p(e.key):e instanceof sn?p(e.key.name):e instanceof Xe?p(e.property):e instanceof Ze&&b(e.property,p)})),e.transform(new Xn(function(e){e instanceof un?e.key=d(e.key):e instanceof sn?e.key.name=d(e.key.name):e instanceof Xe?e.property=d(e.property):!n.keep_quoted&&e instanceof Ze&&(e.property=function t(e){return e.transform(new Xn(function(e){if(e instanceof We){var n=e.expressions.length-1;e.expressions[n]=t(e.expressions[n])}else e instanceof bn?e.value=d(e.value):e instanceof tn&&(e.consequent=t(e.consequent),e.alternative=t(e.alternative));return e}))}(e.property))}));function f(e){return!(0<=c.indexOf(e))&&(!(0<=t.indexOf(e))&&(n.only_cache?i.has(e):!/^-?[0-9]+(\\.[0-9]+)?(e[+-][0-9]+)?$/.test(e)))}function l(e){return!(a&&!a.test(e))&&(!(0<=t.indexOf(e))&&(i.has(e)||0<=u.indexOf(e)))}function p(e){f(e)&&v(u,e),l(e)||v(c,e)}function d(e){if(!l(e))return e;var n=i.get(e);if(!n){if(s){var t=\"_$\"+e+\"$\"+o+\"_\";f(t)&&(n=t)}if(!n)for(;!f(n=g(++r)););i.set(e,n)}return n}}!function(){function e(e,n){e.DEFMETHOD(\"_codegen\",n)}var o=!1,a=null,s=null;function t(e,n){Array.isArray(e)?e.forEach(function(e){t(e,n)}):e.DEFMETHOD(\"needs_parens\",n)}function i(e,t,i,n){var r=e.length-1;o=n,e.forEach(function(e,n){!0!==o||e instanceof fe||e instanceof he||e instanceof le&&e.body instanceof bn||(o=!1),e instanceof he||(i.indent(),e.print(i),n==r&&t||(i.newline(),t&&i.newline())),!0===o&&e instanceof le&&e.body instanceof bn&&(o=!1)}),o=!1}function r(e,n){n.print(\"{\"),n.with_indent(n.next_indent(),function(){n.append_comments(e,!0)}),n.print(\"}\")}function u(e,n,t){0<e.body.length?n.with_block(function(){i(e.body,!1,n,t)}):r(e,n)}function c(e,n,t){var i=!1;t&&e.walk(new Sn(function(e){return!!(i||e instanceof Ae)||(e instanceof nn&&\"in\"==e.operator?i=!0:void 0)})),e.print(n,i)}function f(e,n,t){t.option(\"quote_keys\")?t.print_string(e):\"\"+ +e==e&&0<=e?t.print(d(e)):(m(e)?!t.option(\"ie8\"):Nn(e))?n&&t.option(\"keep_quoted_props\")?t.print_string(e,n):t.print_name(e):t.print_string(e,n)}function l(e,n){n.option(\"braces\")?h(e,n):!e||e instanceof he?n.force_semicolon():e.print(n)}function p(e,n){return 0<e.args.length||n.option(\"beautify\")}function d(e){var n,t=e.toString(10),i=[t.replace(/^0\\./,\".\").replace(\"e+\",\"e\")];return Math.floor(e)===e?(0<=e?i.push(\"0x\"+e.toString(16).toLowerCase(),\"0\"+e.toString(8)):i.push(\"-0x\"+(-e).toString(16).toLowerCase(),\"-0\"+(-e).toString(8)),(n=/^(.*?)(0+)$/.exec(e))&&i.push(n[1]+\"e\"+n[2].length)):(n=/^0?\\.(0+)(.*)$/.exec(e))&&i.push(n[2]+\"e-\"+(n[1].length+n[2].length),t.substr(t.indexOf(\".\"))),function(e){for(var n=e[0],t=n.length,i=1;i<e.length;++i)e[i].length<t&&(t=(n=e[i]).length);return n}(i)}function h(e,n){!e||e instanceof he?n.print(\"{}\"):e instanceof de?e.print(n):n.with_block(function(){n.indent(),e.print(n),n.newline()})}function n(e,n){e.DEFMETHOD(\"add_source_map\",function(e){n(this,e)})}function v(e,n){n.add_mapping(e.start)}se.DEFMETHOD(\"print\",function(e,n){var t=this,i=t._codegen;function r(){e.prepend_comments(t),t.add_source_map(e),i(t,e),e.append_comments(t)}t instanceof Ae?a=t:!s&&t instanceof fe&&\"use asm\"==t.value&&(s=a),e.push_node(t),n||t.needs_parens(e)?e.with_parens(r):r(),e.pop_node(),t===s&&(s=null)}),se.DEFMETHOD(\"_print\",se.prototype.print),se.DEFMETHOD(\"print_to_string\",function(e){var n=Qn(e);return this.print(n),n.get()}),t(se,ie),t(Fe,function(e){if(!e.has_parens()&&$(e))return!0;var n;if(e.option(\"webkit\")&&((n=e.parent())instanceof Ge&&n.expression===this))return!0;return!!e.option(\"wrap_iife\")&&((n=e.parent())instanceof Ye&&n.expression===this)}),t(an,function(e){return!e.has_parens()&&$(e)}),t(Ke,function(e){var n=e.parent();return n instanceof Ge&&n.expression===this||n instanceof Ye&&n.expression===this}),t(We,function(e){var n=e.parent();return n instanceof Ye||n instanceof Ke||n instanceof nn||n instanceof Ve||n instanceof Ge||n instanceof on||n instanceof sn||n instanceof tn}),t(nn,function(e){var n=e.parent();if(n instanceof Ye&&n.expression===this)return!0;if(n instanceof Ke)return!0;if(n instanceof Ge&&n.expression===this)return!0;if(n instanceof nn){var t=n.operator,i=Jn[t],r=this.operator,o=Jn[r];if(o<i||i==o&&this===n.right)return!0}}),t(Ge,function(e){var n=e.parent();if(n instanceof Je&&n.expression===this){var t=!1;return this.walk(new Sn(function(e){return!!(t||e instanceof Ae)||(e instanceof Ye?t=!0:void 0)})),t}}),t(Ye,function(e){var n,t=e.parent();return t instanceof Je&&t.expression===this||this.expression instanceof Fe&&t instanceof Ge&&t.expression===this&&(n=e.parent(1))instanceof rn&&n.left===t}),t(Je,function(e){var n=e.parent();if(!p(this,e)&&(n instanceof Ge||n instanceof Ye&&n.expression===this))return!0}),t(yn,function(e){var n=e.parent();if(n instanceof Ge&&n.expression===this){var t=this.getValue();if(t<0||/^0/.test(d(t)))return!0}}),t([rn,tn],function(e){var n=e.parent();return n instanceof Ke||(n instanceof nn&&!(n instanceof rn)||(n instanceof Ye&&n.expression===this||(n instanceof tn&&n.condition===this||(n instanceof Ge&&n.expression===this||void 0))))}),e(fe,function(e,n){n.print_string(e.value,e.quote),n.semicolon()}),e(ce,function(e,n){n.print(\"debugger\"),n.semicolon()}),_.DEFMETHOD(\"_do_print_body\",function(e){l(this.body,e)}),e(ue,function(e,n){e.body.print(n),n.semicolon()}),e(Ee,function(e,n){i(e.body,!0,n,!0),n.print(\"\")}),e(ve,function(e,n){e.label.print(n),n.colon(),e.body.print(n)}),e(le,function(e,n){e.body.print(n),n.semicolon()}),e(de,function(e,n){u(e,n)}),e(he,function(e,n){n.semicolon()}),e(ge,function(e,n){n.print(\"do\"),n.space(),h(e.body,n),n.space(),n.print(\"while\"),n.space(),n.with_parens(function(){e.condition.print(n)}),n.semicolon()}),e(be,function(e,n){n.print(\"while\"),n.space(),n.with_parens(function(){e.condition.print(n)}),n.space(),e._do_print_body(n)}),e(ye,function(e,n){n.print(\"for\"),n.space(),n.with_parens(function(){e.init?(e.init instanceof Ue?e.init.print(n):c(e.init,n,!0),n.print(\";\"),n.space()):n.print(\";\"),e.condition?(e.condition.print(n),n.print(\";\"),n.space()):n.print(\";\"),e.step&&e.step.print(n)}),n.space(),e._do_print_body(n)}),e(we,function(e,n){n.print(\"for\"),n.space(),n.with_parens(function(){e.init.print(n),n.space(),n.print(\"in\"),n.space(),e.object.print(n)}),n.space(),e._do_print_body(n)}),e(xe,function(e,n){n.print(\"with\"),n.space(),n.with_parens(function(){e.expression.print(n)}),n.space(),e._do_print_body(n)}),ke.DEFMETHOD(\"_do_print\",function(t,e){var n=this;e||t.print(\"function\"),n.name&&(t.space(),n.name.print(t)),t.with_parens(function(){n.argnames.forEach(function(e,n){n&&t.comma(),e.print(t)})}),t.space(),u(n,t,!0)}),e(ke,function(e,n){e._do_print(n)}),Se.DEFMETHOD(\"_do_print\",function(e,n){e.print(n),this.value&&(e.space(),this.value.print(e)),e.semicolon()}),e(Te,function(e,n){e._do_print(n,\"return\")}),e(G,function(e,n){e._do_print(n,\"throw\")}),Oe.DEFMETHOD(\"_do_print\",function(e,n){e.print(n),this.label&&(e.space(),this.label.print(e)),e.semicolon()}),e($e,function(e,n){e._do_print(n,\"break\")}),e(ze,function(e,n){e._do_print(n,\"continue\")}),e(Me,function(e,n){n.print(\"if\"),n.space(),n.with_parens(function(){e.condition.print(n)}),n.space(),e.alternative?(!function(e,n){var t=e.body;if(n.option(\"braces\")||n.option(\"ie8\")&&t instanceof ge)return h(t,n);if(!t)return n.force_semicolon();for(;;)if(t instanceof Me){if(!t.alternative)return h(e.body,n);t=t.alternative}else{if(!(t instanceof _))break;t=t.body}l(e.body,n)}(e,n),n.space(),n.print(\"else\"),n.space(),e.alternative instanceof Me?e.alternative.print(n):l(e.alternative,n)):e._do_print_body(n)}),e(qe,function(e,t){t.print(\"switch\"),t.space(),t.with_parens(function(){e.expression.print(t)}),t.space();var i=e.body.length-1;i<0?r(e,t):t.with_block(function(){e.body.forEach(function(e,n){t.indent(!0),e.print(t),n<i&&0<e.body.length&&t.newline()})})}),je.DEFMETHOD(\"_do_print_body\",function(n){n.newline(),this.body.forEach(function(e){n.indent(),e.print(n),n.newline()})}),e(Ne,function(e,n){n.print(\"default:\"),e._do_print_body(n)}),e(He,function(e,n){n.print(\"case\"),n.space(),e.expression.print(n),n.print(\":\"),e._do_print_body(n)}),e(Re,function(e,n){n.print(\"try\"),n.space(),u(e,n),e.bcatch&&(n.space(),e.bcatch.print(n)),e.bfinally&&(n.space(),e.bfinally.print(n))}),e(Ie,function(e,n){n.print(\"catch\"),n.space(),n.with_parens(function(){e.argname.print(n)}),n.space(),u(e,n)}),e(Pe,function(e,n){n.print(\"finally\"),n.space(),u(e,n)}),Ue.DEFMETHOD(\"_do_print\",function(t,e){t.print(e),t.space(),this.definitions.forEach(function(e,n){n&&t.comma(),e.print(t)});var n=t.parent();(n instanceof ye||n instanceof we)&&n.init===this||t.semicolon()}),e(Le,function(e,n){e._do_print(n,\"var\")}),e(Ve,function(e,n){if(e.name.print(n),e.value){n.space(),n.print(\"=\"),n.space();var t=n.parent(1),i=t instanceof ye||t instanceof we;c(e.value,n,i)}}),e(Ye,function(e,t){e.expression.print(t),e instanceof Je&&!p(e,t)||((e.expression instanceof Ye||e.expression instanceof ke)&&t.add_mapping(e.start),t.with_parens(function(){e.args.forEach(function(e,n){n&&t.comma(),e.print(t)})}))}),e(Je,function(e,n){n.print(\"new\"),n.space(),Ye.prototype._codegen(e,n)}),We.DEFMETHOD(\"_do_print\",function(t){this.expressions.forEach(function(e,n){0<n&&(t.comma(),t.should_break()&&(t.newline(),t.indent())),e.print(t)})}),e(We,function(e,n){e._do_print(n)}),e(Xe,function(e,n){var t=e.expression;t.print(n);var i=e.property;n.option(\"ie8\")&&m(i)?(n.print(\"[\"),n.add_mapping(e.end),n.print_string(i),n.print(\"]\")):(t instanceof yn&&0<=t.getValue()&&(/[xa-f.)]/i.test(n.last())||n.print(\".\")),n.print(\".\"),n.add_mapping(e.end),n.print_name(i))}),e(Ze,function(e,n){e.expression.print(n),n.print(\"[\"),e.property.print(n),n.print(\"]\")}),e(Qe,function(e,n){var t=e.operator;n.print(t),(/^[a-z]/i.test(t)||/[+-]$/.test(t)&&e.expression instanceof Qe&&/^[+-]/.test(e.expression.operator))&&n.space(),e.expression.print(n)}),e(en,function(e,n){e.expression.print(n),n.print(e.operator)}),e(nn,function(e,n){var t=e.operator;e.left.print(n),\">\"==t[0]&&e.left instanceof en&&\"--\"==e.left.operator?n.print(\" \"):n.space(),n.print(t),(\"<\"==t||\"<<\"==t)&&e.right instanceof Qe&&\"!\"==e.right.operator&&e.right.expression instanceof Qe&&\"--\"==e.right.expression.operator?n.print(\" \"):n.space(),e.right.print(n)}),e(tn,function(e,n){e.condition.print(n),n.space(),n.print(\"?\"),n.space(),e.consequent.print(n),n.space(),n.colon(),e.alternative.print(n)}),e(on,function(n,i){i.with_square(function(){var e=n.elements,t=e.length;0<t&&i.space(),e.forEach(function(e,n){n&&i.comma(),e.print(i),n===t-1&&e instanceof kn&&i.comma()}),0<t&&i.space()})}),e(an,function(e,t){0<e.properties.length?t.with_block(function(){e.properties.forEach(function(e,n){n&&(t.print(\",\"),t.newline()),t.indent(),e.print(t)}),t.newline()}):r(e,t)}),e(un,function(e,n){f(e.key,e.quote,n),n.colon(),e.value.print(n)}),sn.DEFMETHOD(\"_print_getter_setter\",function(e,n){n.print(e),n.space(),f(this.key.name,this.quote,n),this.value._do_print(n,!0)}),e(X,function(e,n){e._print_getter_setter(\"set\",n)}),e(Z,function(e,n){e._print_getter_setter(\"get\",n)}),e(cn,function(e,n){var t=e.definition();n.print_name(t?t.mangled_name||t.name:e.name)}),e(kn,L),e(mn,function(e,n){n.print(\"this\")}),e(gn,function(e,n){n.print(e.getValue())}),e(bn,function(e,n){n.print_string(e.getValue(),e.quote,o)}),e(yn,function(e,n){s&&e.start&&null!=e.start.raw?n.print(e.start.raw):n.print(d(e.getValue()))}),e(wn,function(e,n){var t=e.getValue(),i=t.toString();t.raw_source&&(i=\"/\"+t.raw_source+i.slice(i.lastIndexOf(\"/\"))),i=n.to_utf8(i),n.print(i);var r=n.parent();r instanceof nn&&/^in/.test(r.operator)&&r.left===e&&n.print(\" \")}),n(se,L),n(fe,v),n(ce,v),n(cn,v),n(Be,v),n(_,v),n(ve,L),n(ke,v),n(qe,v),n(je,v),n(de,v),n(Ee,L),n(Je,v),n(Re,v),n(Ie,v),n(Pe,v),n(Ue,v),n(gn,v),n(X,function(e,n){n.add_mapping(e.start,e.key.name)}),n(Z,function(e,n){n.add_mapping(e.start,e.key.name)}),n(sn,function(e,n){n.add_mapping(e.start,e.key)})}(),t(et.prototype=new Xn,{option:function(e){return this.options[e]},exposed:function(e){if(e.global)for(var n=0,t=e.orig.length;n<t;n++)if(!this.toplevel[e.orig[n]instanceof dn?\"funcs\":\"vars\"])return!0;return!1},compress:function(e){this.option(\"expression\")&&e.process_expression(!0);for(var n=+this.options.passes||1,t=1/0,i=!1,r={ie8:this.option(\"ie8\")},o=0;o<n;o++)if(e.figure_out_scope(r),(0<o||this.option(\"reduce_vars\"))&&e.reset_opt_flags(this),e=e.transform(this),1<n){var a=0;if(e.walk(new Sn(function(){a++})),this.info(\"pass \"+o+\": last_count: \"+t+\", count: \"+a),a<t)t=a,i=!1;else{if(i)break;i=!0}}return this.option(\"expression\")&&e.process_expression(!1),e},info:function(){\"verbose\"==this.options.warnings&&se.warn.apply(se,arguments)},warn:function(e,n){if(this.options.warnings){var t=S(e,n);t in this.warnings_produced||(this.warnings_produced[t]=!0,se.warn.apply(se,arguments))}},clear_warnings:function(){this.warnings_produced={}},before:function(e,n,t){if(e._squeezed)return e;var i=!1;e instanceof Ae&&(e=(e=e.hoist_properties(this)).hoist_declarations(this),i=!0),n(e,this),n(e,this);var r=e.optimize(this);return i&&r instanceof Ae&&(r.drop_unused(this),n(r,this)),r===e&&(r._squeezed=!0),r}}),function(){function e(e,t){e.DEFMETHOD(\"optimize\",function(e){if(this._optimized)return this;if(e.has_directive(\"use asm\"))return this;var n=t(this,e);return n._optimized=!0,n})}function G(e){if(e instanceof mn)return!0;if(e instanceof _n)return e.definition().orig[0]instanceof hn;if(e instanceof Ge){if((e=e.expression)instanceof _n){if(e.is_immutable())return!1;e=e.fixed_value()}return!e||(!!e.is_constant()||G(e))}return!1}function o(e,n){for(var t,i=0;(t=e.parent(i++))&&!(t instanceof Ae);)if(t instanceof Ie){t=t.argname.definition().scope;break}return t.find_variable(n)}function X(e,n,t){return t||(t={}),n&&(t.start||(t.start=n.start),t.end||(t.end=n.end)),new e(t)}function M(e,n){return 1==n.length?n[0]:X(We,e,{expressions:n.reduce(l,[])})}function q(e,n){switch(typeof e){case\"string\":return X(bn,n,{value:e});case\"number\":return isNaN(e)?X(An,n):isFinite(e)?1/e<0?X(Qe,n,{operator:\"-\",expression:X(yn,n,{value:-e})}):X(yn,n,{value:e}):e<0?X(Qe,n,{operator:\"-\",expression:X(Dn,n)}):X(Dn,n);case\"boolean\":return X(e?Bn:Cn,n);case\"undefined\":return X(En,n);default:if(null===e)return X(xn,n,{value:null});if(e instanceof RegExp)return X(wn,n,{value:e});throw new Error(S(\"Can't handle constant of type: {type}\",{type:typeof e}))}}function Z(e,n,t){return e instanceof Qe&&\"delete\"==e.operator||e instanceof Ye&&e.expression===n&&(t instanceof Ge||t instanceof _n&&\"eval\"==t.name)?M(n,[X(yn,n,{value:0}),t]):t}function l(e,n){return n instanceof We?e.push.apply(e,n.expressions):e.push(n),e}function b(e){if(null===e)return[];if(e instanceof de)return e.body;if(e instanceof he)return[];if(e instanceof ue)return[e];throw new Error(\"Can't convert thing to statement array\")}function j(e){return null===e||(e instanceof he||e instanceof de&&0==e.body.length)}function y(e){return e instanceof _e&&e.body instanceof de?e.body:e}function K(e){for(;e instanceof Ge;)e=e.expression;return e}function N(e){return\"Call\"==e.TYPE&&(e.expression instanceof Fe||N(e.expression))}function H(e){return e instanceof _n&&e.definition().undeclared}e(se,function(e,n){return e}),se.DEFMETHOD(\"equivalent_to\",function(e){return this.TYPE==e.TYPE&&this.print_to_string()==e.print_to_string()}),Ae.DEFMETHOD(\"process_expression\",function(i,r){var o=this,a=new Xn(function(e){if(i&&e instanceof le)return X(Te,e,{value:e.body});if(!i&&e instanceof Te){if(r){var n=e.value&&e.value.drop_side_effect_free(r,!0);return n?X(le,e,{body:n}):X(he,e)}return X(le,e,{body:e.value||X(Qe,e,{operator:\"void\",expression:X(yn,e,{value:0})})})}if(e instanceof ke&&e!==o)return e;if(e instanceof pe){var t=e.body.length-1;0<=t&&(e.body[t]=e.body[t].transform(a))}else e instanceof Me?(e.body=e.body.transform(a),e.alternative&&(e.alternative=e.alternative.transform(a))):e instanceof xe&&(e.body=e.body.transform(a));return e});o.transform(a)}),function(e){function i(e,n){n.assignments=0,n.chained=!1,n.direct_access=!1,n.escaped=!1,n.scope.uses_eval||n.scope.uses_with?n.fixed=!1:e.exposed(n)?n.fixed=!1:n.fixed=n.init,n.recursive_refs=0,n.references=[],n.should_replace=void 0,n.single_use=void 0}function a(n,t,e){e.variables.each(function(e){i(t,e),null===e.fixed?(e.safe_ids=n.safe_ids,c(n,e,!0)):e.fixed&&(n.loop_ids[e.id]=n.in_loop,c(n,e,!0))})}function s(e){e.safe_ids=Object.create(e.safe_ids)}function u(e){e.safe_ids=Object.getPrototypeOf(e.safe_ids)}function c(e,n,t){e.safe_ids[n.id]=t}function f(e,n){if(e.safe_ids[n.id]){if(null==n.fixed){var t=n.orig[0];if(t instanceof pn||\"arguments\"==t.name)return!1;n.fixed=X(En,t)}return!0}return n.fixed instanceof Ce}function o(e,n,t){return void 0===n.fixed||(null===n.fixed&&n.safe_ids?(n.safe_ids[n.id]=!1,delete n.safe_ids,!0):!!ae(e.safe_ids,n.id)&&(!!f(e,n)&&(!1!==n.fixed&&(!(null!=n.fixed&&(!t||n.references.length>n.assignments))&&oe(n.orig,function(e){return!(e instanceof dn||e instanceof hn)})))))}function l(e,n){if(!((n=p(n))instanceof se)){var t;if(e instanceof on){var i=e.elements;if(\"length\"==n)return q(i.length,e);\"number\"==typeof n&&n in i&&(t=i[n])}else if(e instanceof an){n=\"\"+n;for(var r=e.properties,o=r.length;0<=--o;){if(!(r[o]instanceof un))return;t||r[o].key!==n||(t=r[o].value)}}return t instanceof _n&&t.fixed_value()||t}}e(se,L);var t=new Sn(function(e){if(e instanceof cn){var n=e.definition();n&&(e instanceof _n&&n.references.push(e),n.fixed=!1)}});e(De,function(e,n,t){return s(e),a(e,t,this),n(),u(e),!0}),e(rn,function(e){var n=this;if(n.left instanceof _n){var t=n.left.definition(),i=t.fixed;if((i||\"=\"==n.operator)&&o(e,t,n.right))return t.references.push(n.left),t.assignments++,\"=\"!=n.operator&&(t.chained=!0),t.fixed=\"=\"==n.operator?function(){return n.right}:function(){return X(nn,n,{operator:n.operator.slice(0,-1),left:i instanceof se?i:i(),right:n.right})},c(e,t,!1),n.right.walk(e),c(e,t,!0),!0}}),e(nn,function(e){if(ee(this.operator))return this.left.walk(e),s(e),this.right.walk(e),u(e),!0}),e(He,function(e){return s(e),this.expression.walk(e),u(e),s(e),z(this,e),u(e),!0}),e(tn,function(e){return this.condition.walk(e),s(e),this.consequent.walk(e),u(e),s(e),this.alternative.walk(e),u(e),!0}),e(Ne,function(e,n){return s(e),n(),u(e),!0}),e(Ce,function(e,n,t){this.inlined=!1;var i=e.safe_ids;return e.safe_ids=Object.create(null),a(e,t,this),n(),e.safe_ids=i,!0}),e(ge,function(e){var n=e.in_loop;return e.in_loop=this,s(e),this.body.walk(e),this.condition.walk(e),u(e),e.in_loop=n,!0}),e(ye,function(e){this.init&&this.init.walk(e);var n=e.in_loop;return(e.in_loop=this).condition&&(s(e),this.condition.walk(e),u(e)),s(e),this.body.walk(e),u(e),this.step&&(s(e),this.step.walk(e),u(e)),e.in_loop=n,!0}),e(we,function(e){this.init.walk(t),this.object.walk(e);var n=e.in_loop;return e.in_loop=this,s(e),this.body.walk(e),u(e),e.in_loop=n,!0}),e(Fe,function(i,e,n){var r,o=this;return o.inlined=!1,s(i),a(i,n,o),!o.name&&(r=i.parent())instanceof Ye&&r.expression===o&&o.argnames.forEach(function(e,n){var t=e.definition();o.uses_arguments||void 0!==t.fixed?t.fixed=!1:(t.fixed=function(){return r.args[n]||X(En,r)},i.loop_ids[t.id]=i.in_loop,c(i,t,!0))}),e(),u(i),!0}),e(Me,function(e){return this.condition.walk(e),s(e),this.body.walk(e),u(e),this.alternative&&(s(e),this.alternative.walk(e),u(e)),!0}),e(ve,function(e){return s(e),this.body.walk(e),u(e),!0}),e(vn,function(){this.definition().fixed=!1}),e(_n,function(e,n,t){var i,r,o,a,s=this.definition();s.references.push(this),1==s.references.length&&!s.fixed&&s.orig[0]instanceof dn&&(e.loop_ids[s.id]=e.in_loop),void 0!==s.fixed&&f(e,s)&&\"m\"!=s.single_use?s.fixed&&((i=this.fixed_value())instanceof ke&&P(e,s)?s.recursive_refs++:i&&(o=e,a=s,t.option(\"unused\")&&!a.scope.uses_eval&&!a.scope.uses_with&&a.references.length-a.recursive_refs==1&&o.loop_ids[a.id]===o.in_loop)?s.single_use=i instanceof ke||s.scope===this.scope&&i.is_constant_expression():s.single_use=!1,function e(n,t,i,r,o){var a=n.parent(r);if(ne(t,a)||!o&&a instanceof Ye&&a.expression===t&&(!(i instanceof Fe)||!(a instanceof Je)&&i.contains_this()))return!0;if(a instanceof on)return e(n,a,a,r+1);if(a instanceof un&&t===a.value){var s=n.parent(r+1);return e(n,s,s,r+2)}return a instanceof Ge&&a.expression===t?!o&&e(n,a,l(i,a.property),r+1):void 0}(e,this,i,0,!!(r=i)&&(r.is_constant()||r instanceof ke||r instanceof mn))&&(s.single_use?s.single_use=\"m\":s.fixed=!1)):s.fixed=!1,function e(n,t,i,r,o,a,s){var u=n.parent(a);if(!o||!o.is_constant()){if(u instanceof rn&&\"=\"==u.operator&&r===u.right||u instanceof Ye&&r!==u.expression||u instanceof Se&&r===u.value&&r.scope!==t.scope||u instanceof Ve&&r===u.value)return!(1<s)||o&&o.is_constant_expression(i)||(s=1),void((!t.escaped||t.escaped>s)&&(t.escaped=s));if(u instanceof on||u instanceof nn&&ee(u.operator)||u instanceof tn&&r!==u.condition||u instanceof We&&r===u.tail_node())e(n,t,i,u,u,a+1,s);else if(u instanceof un&&r===u.value){var c=n.parent(a+1);e(n,t,i,c,c,a+2,s)}else if(u instanceof Ge&&r===u.expression&&(e(n,t,i,u,o=l(o,u.property),a+1,s+1),o))return;0==a&&(t.direct_access=!0)}}(e,s,this.scope,this,i,0,1)}),e(Ee,function(e,n,t){this.globals.each(function(e){i(t,e)}),a(e,t,this)}),e(Re,function(e){return s(e),z(this,e),u(e),this.bcatch&&(s(e),this.bcatch.walk(e),u(e)),this.bfinally&&this.bfinally.walk(e),!0}),e(Ke,function(e,n){var t=this;if((\"++\"==t.operator||\"--\"==t.operator)&&t.expression instanceof _n){var i=t.expression.definition(),r=i.fixed;if(r&&o(e,i,!0))return i.references.push(t.expression),i.assignments++,i.chained=!0,i.fixed=function(){return X(nn,t,{operator:t.operator.slice(0,-1),left:X(Qe,t,{operator:\"+\",expression:r instanceof se?r:r()}),right:X(yn,t,{value:1})})},c(e,i,!0),!0}}),e(Ve,function(e,n){var t=this,i=t.name.definition();if(t.value){if(o(e,i,t.value))return i.fixed=function(){return t.value},e.loop_ids[i.id]=e.in_loop,c(e,i,!1),n(),c(e,i,!0),!0;i.fixed=!1}}),e(be,function(e){var n=e.in_loop;return e.in_loop=this,s(e),this.condition.walk(e),this.body.walk(e),u(e),e.in_loop=n,!0})}(function(e,n){e.DEFMETHOD(\"reduce_vars\",n)}),Ee.DEFMETHOD(\"reset_opt_flags\",function(t){var i=t.option(\"reduce_vars\"),r=new Sn(function(e,n){if(e._squeezed=!1,e._optimized=!1,i)return e.reduce_vars(r,n,t)});r.safe_ids=Object.create(null),r.in_loop=null,r.loop_ids=Object.create(null),this.walk(r)}),cn.DEFMETHOD(\"fixed_value\",function(){var e=this.definition().fixed;return!e||e instanceof se?e:e()}),_n.DEFMETHOD(\"is_immutable\",function(){var e=this.definition().orig;return 1==e.length&&e[0]instanceof hn});var n=W(\"Array Boolean clearInterval clearTimeout console Date decodeURI decodeURIComponent encodeURI encodeURIComponent Error escape eval EvalError Function isFinite isNaN JSON Math Number parseFloat parseInt RangeError ReferenceError RegExp Object setInterval setTimeout String SyntaxError TypeError unescape URIError\");_n.DEFMETHOD(\"is_declared\",function(e){return!this.definition().undeclared||e.option(\"unsafe\")&&n(this.name)});var t,i,r,a,s,R=W(\"Infinity NaN undefined\");function Q(e){return e instanceof Dn||e instanceof An||e instanceof En}function u(e,c){var V,Y,J;!function(){var e=c.self(),n=0;do{if(e instanceof Ie||e instanceof Pe)n++;else if(e instanceof _e)V=!0;else{if(e instanceof Ae){J=e;break}e instanceof Re&&(Y=!0)}}while(e=c.parent(n++))}();for(var W,n=10;W=!1,r(e),c.option(\"dead_code\")&&o(e,c),c.option(\"if_return\")&&i(e,c),0<c.sequences_limit&&(a(e,c),s(e,c)),c.option(\"join_vars\")&&u(e),c.option(\"collapse_vars\")&&t(e,c),W&&0<n--;);function t(t,c){if(J.uses_eval||J.uses_with)return t;for(var f,e,n,l=[],o=t.length,a=new Xn(function(e){if(D)return e;if(!k)return e!==s[u]?e:++u<s.length?O(e):(k=!0,(h=function e(n,t,i){var r=a.parent(t);if(r instanceof rn)return i&&!(r.left instanceof Ge||r.left.name in y)?e(r,t+1,i):n;if(r instanceof nn)return!i||ee(r.operator)&&r.left!==n?n:e(r,t+1,i);if(r instanceof Ye)return n;if(r instanceof He)return n;if(r instanceof tn)return i&&r.condition===n?e(r,t+1,i):n;if(r instanceof Ue)return e(r,t+1,!0);if(r instanceof Se)return i?e(r,t+1,i):n;if(r instanceof Me)return i&&r.condition===n?e(r,t+1,i):n;if(r instanceof _e)return n;if(r instanceof We)return e(r,t+1,r.tail_node()!==n);if(r instanceof le)return e(r,t+1,!0);if(r instanceof qe)return n;if(r instanceof Ke)return n;if(r instanceof Ve)return n;return null}(e,0))===e&&(D=!0),e);var n,t,i=a.parent();if(e instanceof rn&&\"=\"!=e.operator&&_.equivalent_to(e.left)||e instanceof Ye&&_ instanceof Ge&&_.equivalent_to(e.expression)||e instanceof ce||e instanceof _e&&!(e instanceof ye)||e instanceof Oe||e instanceof Re||e instanceof xe||i instanceof ye&&e!==i.init||!x&&e instanceof _n&&!e.is_declared(c))return D=!0,e;if(!v&&(i instanceof nn&&ee(i.operator)&&i.left!==e||i instanceof tn&&i.condition!==e||i instanceof Me&&i.condition!==e)&&(v=i),C&&!(e instanceof fn)&&(g&&_.equivalent_to(e)||b&&(n=b(e,this)))){if(v&&(n||!w||!x))return D=!0,e;if(ne(e,i))return d&&F++,e;if(W=D=!0,F++,c.info(\"Collapsing {name} [{file}:{line},{col}]\",{name:e.print_to_string(),file:e.start.file,line:e.start.line,col:e.start.col}),p instanceof en)return X(Qe,p,p);if(p instanceof Ve){if(d)return D=!1,e;var r=p.name.definition(),o=p.value;return r.references.length-r.replaced!=1||c.exposed(r)?X(rn,p,{operator:\"=\",left:X(_n,p.name,p.name),right:o}):(r.replaced++,E&&Q(o)?o.transform(c):Z(i,e,o))}return p.write_only=!1,p}return(e instanceof Ye||e instanceof Se&&(m||_ instanceof Ge||L(_))||e instanceof Ge&&(m||e.expression.may_throw_on_access(c))||e instanceof _n&&(function(e){var n=y[e.name];if(!n)return;if(n!==_)return!0;b=!1}(e)||m&&L(e))||e instanceof Ve&&e.value&&(e.name.name in y||m&&L(e.name))||(t=ne(e.left,e))&&(t instanceof Ge||t.name in y)||A&&(Y?e.has_side_effects(c):function e(n,t){if(n instanceof rn)return e(n.left,!0);if(n instanceof Ke)return e(n.expression,!0);if(n instanceof Ve)return n.value&&e(n.value);if(t){if(n instanceof Xe)return e(n.expression,!0);if(n instanceof Ze)return e(n.expression,!0);if(n instanceof _n)return n.definition().scope!==J}return!1}(e)))&&(h=e)instanceof Ae&&(D=!0),O(e)},function(e){D||(h===e&&(D=!0),v===e&&(v=null))}),i=new Xn(function(e){if(D)return e;if(!k){if(e!==s[u])return e;if(++u<s.length)return;return k=!0,e}return e instanceof _n&&e.name==T.name?(--F||(D=!0),ne(e,i.parent())?e:(T.replaced++,d.replaced--,p.value)):e instanceof Ne||e instanceof Ae?e:void 0});0<=--o;){0==o&&c.option(\"unused\")&&$();var s=[];for(z(t[o]);0<l.length;){s=l.pop();var u=0,p=s[s.length-1],d=null,h=null,v=null,_=M(p),r=q(p),m=_&&_.has_side_effects(c),g=_&&!m&&!G(_),b=r&&j(r);if(g||b){var y=R(p),w=(n=void 0,(n=K(e=_))instanceof _n&&n.definition().scope===J&&!(V&&(n.name in y&&y[n.name]!==e||p instanceof Ke||p instanceof rn&&\"=\"!=p.operator)));m||(m=P(p));var x=U(),A=p.may_throw(c),E=p.name instanceof pn,k=E,D=!1,F=0,C=!f||!k;if(!C){for(var B=c.self().argnames.lastIndexOf(p.name)+1;!D&&B<f.length;B++)f[B].transform(a);C=!0}for(var S=o;!D&&S<t.length;S++)t[S].transform(a);if(d){var T=p.name.definition();if(D&&T.references.length-T.replaced>F)F=!1;else{D=!1,u=0,k=E;for(S=o;!D&&S<t.length;S++)t[S].transform(i);d.single_use=!1}}F&&!I(p)&&t.splice(o,1)}}}function O(e){if(e instanceof Ae)return e;if(e instanceof qe){e.expression=e.expression.transform(a);for(var n=0,t=e.body.length;!D&&n<t;n++){var i=e.body[n];if(i instanceof He){if(!k){if(i!==s[u])continue;u++}if(i.expression=i.expression.transform(a),!x)break}}return D=!0,e}}function $(){var e,t=c.self();if(t instanceof Fe&&!t.name&&!t.uses_arguments&&!t.uses_eval&&(e=c.parent())instanceof Ye&&e.expression===t){var i=c.has_directive(\"use strict\");i&&!te(i,t.body)&&(i=!1);var n=t.argnames.length;f=e.args.slice(n);for(var r=Object.create(null),o=n;0<=--o;){var a=t.argnames[o],s=e.args[o];if(f.unshift(X(Ve,a,{name:a,value:s})),!(a.name in r)){if(r[a.name]=!0,s){var u=new Sn(function(e){if(!s)return!0;if(e instanceof _n&&t.variables.has(e.name)){var n=e.definition().scope;if(n!==J)for(;n=n.parent_scope;)if(n===J)return!0;s=null}return e instanceof mn&&(i||!u.find_parent(Ae))?!(s=null):void 0});s.walk(u)}else s=X(En,a).transform(c);s&&l.unshift([X(Ve,a,{name:a,value:s})])}}}}function z(e){s.push(e),e instanceof rn?(l.push(s.slice()),z(e.right)):e instanceof nn?(z(e.left),z(e.right)):e instanceof Ye?(z(e.expression),e.args.forEach(z)):e instanceof He?z(e.expression):e instanceof tn?(z(e.condition),z(e.consequent),z(e.alternative)):e instanceof Ue?e.definitions.forEach(z):e instanceof me?(z(e.condition),e.body instanceof pe||z(e.body)):e instanceof Se?e.value&&z(e.value):e instanceof ye?(e.init&&z(e.init),e.condition&&z(e.condition),e.step&&z(e.step),e.body instanceof pe||z(e.body)):e instanceof we?(z(e.object),e.body instanceof pe||z(e.body)):e instanceof Me?(z(e.condition),e.body instanceof pe||z(e.body),!e.alternative||e.alternative instanceof pe||z(e.alternative)):e instanceof We?e.expressions.forEach(z):e instanceof le?z(e.body):e instanceof qe?(z(e.expression),e.body.forEach(z)):e instanceof Ke?\"++\"==e.operator||\"--\"==e.operator?l.push(s.slice()):z(e.expression):e instanceof Ve&&e.value&&(l.push(s.slice()),z(e.value)),s.pop()}function M(e){if(!(e instanceof Ve))return e[e instanceof rn?\"left\":\"expression\"];var n=e.name.definition();if(te(e.name,n.orig)){var t=n.orig.length-n.eliminated,i=n.references.length-n.replaced;return 1<t&&!(e.name instanceof pn)||(1<i?function(e){var n=e.value;if(n instanceof _n&&\"arguments\"!=n.name){var t=n.definition();if(!t.undeclared)return d=t}}(e):!c.exposed(n))?X(_n,e.name,e.name):void 0}}function q(e){if(p instanceof rn&&\"=\"==p.operator)return p.right}function j(e){if(e instanceof _n){var n=e.evaluate(c);return n===e?N:H(n,N)}if(e instanceof mn)return N;if(e.is_truthy())return H(!0,ie);if(e.is_constant())return H(e.evaluate(c),N);if(!(_ instanceof _n))return!1;if(e.has_side_effects(c))return!1;var t,i=_.definition();return e.walk(new Sn(function(e){if(t)return!0;e instanceof _n&&e.definition()===i&&(t=!0)})),!t&&N}function N(e){return r.equivalent_to(e)}function H(t,i){return function(e,n){if(n.in_boolean_context()){if(t&&e.is_truthy()&&!e.has_side_effects(c))return!0;if(e.is_constant())return!e.evaluate(c)==!t}return i(e)}}function R(e){var t=Object.create(null);p instanceof Ve&&(t[p.name.name]=_);var i=new Sn(function(e){var n=K(e);(n instanceof _n||n instanceof mn)&&(t[n.name]=t[n.name]||ne(e,i.parent()))});return e.walk(i),t}function I(i){if(i.name instanceof pn){var e=c.self().argnames.indexOf(i.name),n=c.parent().args;return n[e]&&(n[e]=X(yn,n[e],{value:0})),!0}var r=!1;return t[o].transform(new Xn(function(e,n,t){return r?e:e===i||e.body===i?(r=!0,e instanceof Ve?(e.value=null,e):t?re.skip:null):void 0},function(e){if(e instanceof We)switch(e.expressions.length){case 0:return null;case 1:return e.expressions[0]}}))}function P(e){return!(e instanceof Ke)&&(n=e,n[n instanceof rn?\"right\":\"value\"]).has_side_effects(c);var n}function U(){if(m)return!1;if(d)return!0;if(_ instanceof _n){var e=_.definition();if(e.references.length-e.replaced==(p instanceof Ve?1:2))return!0}return!1}function L(e){var n=e.definition();return!(1==n.orig.length&&n.orig[0]instanceof dn)&&(n.scope!==J||!oe(n.references,function(e){var n=e.scope;return\"Scope\"==n.TYPE&&(n=n.parent_scope),n===J}))}}function r(e){for(var n=[],t=0;t<e.length;){var i=e[t];i instanceof de?(W=!0,r(i.body),[].splice.apply(e,[t,1].concat(i.body)),t+=i.body.length):i instanceof he?(W=!0,e.splice(t,1)):i instanceof fe?n.indexOf(i.value)<0?(t++,n.push(i.value)):(W=!0,e.splice(t,1)):t++}}function i(r,i){for(var o=i.self(),e=function(e){for(var n=0,t=e.length;0<=--t;){var i=e[t];if(i instanceof Me&&i.body instanceof Te&&1<++n)return!0}return!1}(r),a=o instanceof ke,n=r.length;0<=--n;){var t=r[n],s=_(n),u=r[s];if(a&&!u&&t instanceof Te){if(!t.value){W=!0,r.splice(n,1);continue}if(t.value instanceof Qe&&\"void\"==t.value.operator){W=!0,r[n]=X(le,t,{body:t.value.expression});continue}}if(t instanceof Me){var c;if(d(c=A(t.body))){c.label&&T(c.label.thedef.references,c),W=!0,(t=t.clone()).condition=t.condition.negate(i);var f=v(t.body,c);t.body=X(de,t,{body:b(t.alternative).concat(h())}),t.alternative=X(de,t,{body:f}),r[n]=t.transform(i);continue}if(d(c=A(t.alternative))){c.label&&T(c.label.thedef.references,c),W=!0,(t=t.clone()).body=X(de,t.body,{body:b(t.body).concat(h())});f=v(t.alternative,c);t.alternative=X(de,t.alternative,{body:f}),r[n]=t.transform(i);continue}}if(t instanceof Me&&t.body instanceof Te){var l=t.body.value;if(!l&&!t.alternative&&(a&&!u||u instanceof Te&&!u.value)){W=!0,r[n]=X(le,t.condition,{body:t.condition});continue}if(l&&!t.alternative&&u instanceof Te&&u.value){W=!0,(t=t.clone()).alternative=u,r.splice(n,1,t.transform(i)),r.splice(s,1);continue}if(l&&!t.alternative&&(!u&&a&&e||u instanceof Te)){W=!0,(t=t.clone()).alternative=u||X(Te,t,{value:null}),r.splice(n,1,t.transform(i)),u&&r.splice(s,1);continue}var p=r[m(n)];if(i.option(\"sequences\")&&a&&!t.alternative&&p instanceof Me&&p.body instanceof Te&&_(s)==r.length&&u instanceof le){W=!0,(t=t.clone()).alternative=X(de,u,{body:[u,X(Te,u,{value:null})]}),r.splice(n,1,t.transform(i)),r.splice(s,1);continue}}}function d(e){if(!e)return!1;var n,t=e instanceof Oe?i.loopcontrol_target(e):null;return e instanceof Te&&a&&(!(n=e.value)||n instanceof Qe&&\"void\"==n.operator)||e instanceof ze&&o===y(t)||e instanceof $e&&t instanceof de&&o===t}function h(){var e=r.slice(n+1);return r.length=n+1,e.filter(function(e){return!(e instanceof Ce)||(r.push(e),!1)})}function v(e,n){var t=b(e).slice(0,-1);return n.value&&t.push(X(le,n.value,{body:n.value.expression})),t}function _(e){for(var n=e+1,t=r.length;n<t;n++){var i=r[n];if(!(i instanceof Le&&g(i)))break}return n}function m(e){for(var n=e;0<=--n;){var t=r[n];if(!(t instanceof Le&&g(t)))break}return n}}function o(n,t){for(var e,i=t.self(),r=0,o=0,a=n.length;r<a;r++){var s=n[r];if(s instanceof Oe){var u=t.loopcontrol_target(s);s instanceof $e&&!(u instanceof _e)&&y(u)===i||s instanceof ze&&y(u)===i?s.label&&T(s.label.thedef.references,s):n[o++]=s}else n[o++]=s;if(A(s)){e=n.slice(r+1);break}}n.length=o,W=o!=a,e&&e.forEach(function(e){w(t,e,n)})}function g(e){return oe(e.definitions,function(e){return!e.value})}function a(n,e){if(!(n.length<2)){for(var t=[],i=0,r=0,o=n.length;r<o;r++){var a=n[r];if(a instanceof le){t.length>=e.sequences_limit&&u();var s=a.body;0<t.length&&(s=s.drop_side_effect_free(e)),s&&l(t,s)}else a instanceof Ue&&g(a)||a instanceof Ce||u(),n[i++]=a}u(),(n.length=i)!=o&&(W=!0)}function u(){if(t.length){var e=M(t[0],t);n[i++]=X(le,e,{body:e}),t=[]}}}function p(e,n){if(!(e instanceof de))return e;for(var t=null,i=0,r=e.body.length;i<r;i++){var o=e.body[i];if(o instanceof Le&&g(o))n.push(o);else{if(t)return!1;t=o}}return t}function s(e,t){function n(e){r--,W=!0;var n=i.body;return M(n,[n,e]).transform(t)}for(var i,r=0,o=0;o<e.length;o++){var a=e[o];if(i)if(a instanceof Se)a.value=n(a.value||X(En,a).transform(t));else if(a instanceof ye){if(!(a.init instanceof Ue)){var s=!1;i.body.walk(new Sn(function(e){return!!(s||e instanceof Ae)||(e instanceof nn&&\"in\"==e.operator?s=!0:void 0)})),s||(a.init?a.init=n(a.init):(a.init=i.body,r--,W=!0))}}else a instanceof we?a.object=n(a.object):a instanceof Me?a.condition=n(a.condition):a instanceof qe?a.expression=n(a.expression):a instanceof xe&&(a.expression=n(a.expression));if(t.option(\"conditionals\")&&a instanceof Me){var u=[],c=p(a.body,u),f=p(a.alternative,u);if(!1!==c&&!1!==f&&0<u.length){var l=u.length;u.push(X(Me,a,{condition:a.condition,body:c||X(he,a.body),alternative:f})),u.unshift(r,1),[].splice.apply(e,u),o+=l,r+=l+1,W=!(i=null);continue}}e[r++]=a,i=a instanceof le?a:null}e.length=r}function f(e,n){if(e instanceof Ue){var t,i=e.definitions[e.definitions.length-1];if(i.value instanceof an)if(n instanceof rn?t=[n]:n instanceof We&&(t=n.expressions.slice()),t){var r=!1;do{var o=t[0];if(!(o instanceof rn))break;if(\"=\"!=o.operator)break;if(!(o.left instanceof Ge))break;var a=o.left.expression;if(!(a instanceof _n))break;if(i.name.name!=a.name)break;if(!o.right.is_constant_expression(J))break;var s=o.left.property;if(s instanceof se&&(s=s.evaluate(c)),s instanceof se)break;s=\"\"+s;var u=c.has_directive(\"use strict\")?function(e){return e.key!=s&&e.key.name!=s}:function(e){return e.key.name!=s};if(!oe(i.value.properties,u))break;i.value.properties.push(X(un,o,{key:s,value:o.right})),t.shift(),r=!0}while(t.length);return r&&t}}}function u(t){for(var e,n=0,i=-1,r=t.length;n<r;n++){var o=t[n],a=t[i];if(o instanceof Ue)a&&a.TYPE==o.TYPE?(a.definitions=a.definitions.concat(o.definitions),W=!0):e&&e.TYPE==o.TYPE&&g(o)?(e.definitions=e.definitions.concat(o.definitions),W=!0):e=t[++i]=o;else if(o instanceof Se)o.value=u(o.value);else if(o instanceof ye){(s=f(a,o.init))?(W=!0,o.init=s.length?M(o.init,s):null,t[++i]=o):a instanceof Le&&(!o.init||o.init.TYPE==a.TYPE)?(o.init&&(a.definitions=a.definitions.concat(o.init.definitions)),o.init=a,t[i]=o,W=!0):e&&o.init&&e.TYPE==o.init.TYPE&&g(o.init)?(e.definitions=e.definitions.concat(o.init.definitions),o.init=null,t[++i]=o,W=!0):t[++i]=o}else if(o instanceof we)o.object=u(o.object);else if(o instanceof Me)o.condition=u(o.condition);else if(o instanceof le){var s;if(s=f(a,o.body)){if(W=!0,!s.length)continue;o.body=M(o.body,s)}t[++i]=o}else o instanceof qe?o.expression=u(o.expression):o instanceof xe?o.expression=u(o.expression):t[++i]=o}function u(e){t[++i]=o;var n=f(a,e);return n?(W=!0,n.length?M(e,n):e instanceof We?e.tail_node().left:e.left):e}t.length=i+1}}function w(n,e,t){e instanceof Ce||n.warn(\"Dropping unreachable code [{file}:{line},{col}]\",e.start),e.walk(new Sn(function(e){return e instanceof Ue?(n.warn(\"Declarations in unreachable code! [{file}:{line},{col}]\",e.start),e.remove_initializers(),t.push(e),!0):e instanceof Ce?(t.push(e),!0):e instanceof Ae||void 0}))}function p(e){return e instanceof gn?e.getValue():e instanceof Qe&&\"void\"==e.operator&&e.expression instanceof gn?void 0:e}function g(e,n){return e.is_undefined||e instanceof En||e instanceof Qe&&\"void\"==e.operator&&!e.expression.has_side_effects(n)}(t=function(e,n){e.DEFMETHOD(\"is_truthy\",n)})(se,ie),t(on,J),t(rn,function(){return\"=\"==this.operator&&this.right.is_truthy()}),t(ke,J),t(an,J),t(wn,J),t(We,function(){return this.tail_node().is_truthy()}),t(_n,function(){var e=this.fixed_value();return e&&e.is_truthy()}),function(e){function t(e){return/strict/.test(e.option(\"pure_getters\"))}se.DEFMETHOD(\"may_throw_on_access\",function(e){return!e.option(\"pure_getters\")||this._dot_throw(e)}),e(se,t),e(xn,J),e(En,J),e(gn,ie),e(on,ie),e(an,function(e){if(!t(e))return!1;for(var n=this.properties.length;0<=--n;)if(this.properties[n].value instanceof De)return!0;return!1}),e(ke,ie),e(en,ie),e(Qe,function(){return\"void\"==this.operator}),e(nn,function(e){return(\"&&\"==this.operator||\"||\"==this.operator)&&(this.left._dot_throw(e)||this.right._dot_throw(e))}),e(rn,function(e){return\"=\"==this.operator&&this.right._dot_throw(e)}),e(tn,function(e){return this.consequent._dot_throw(e)||this.alternative._dot_throw(e)}),e(Xe,function(e){if(!t(e))return!1;var n=this.expression;return n instanceof _n&&(n=n.fixed_value()),!(n instanceof ke&&\"prototype\"==this.property)}),e(We,function(e){return this.tail_node()._dot_throw(e)}),e(_n,function(e){if(this.is_undefined)return!0;if(!t(e))return!1;if(H(this)&&this.is_declared(e))return!1;if(this.is_immutable())return!1;var n=this.fixed_value();return!n||n._dot_throw(e)})}(function(e,n){e.DEFMETHOD(\"_dot_throw\",n)}),r=[\"!\",\"delete\"],a=[\"in\",\"instanceof\",\"==\",\"!=\",\"===\",\"!==\",\"<\",\"<=\",\">=\",\">\"],(i=function(e,n){e.DEFMETHOD(\"is_boolean\",n)})(se,ie),i(Qe,function(){return te(this.operator,r)}),i(nn,function(){return te(this.operator,a)||ee(this.operator)&&this.left.is_boolean()&&this.right.is_boolean()}),i(tn,function(){return this.consequent.is_boolean()&&this.alternative.is_boolean()}),i(rn,function(){return\"=\"==this.operator&&this.right.is_boolean()}),i(We,function(){return this.tail_node().is_boolean()}),i(Bn,J),i(Cn,J),function(e){e(se,ie),e(yn,J);var n=W(\"+ - ~ ++ --\");e(Ke,function(){return n(this.operator)});var t=W(\"- * / % & | ^ << >> >>>\");e(nn,function(e){return t(this.operator)||\"+\"==this.operator&&this.left.is_number(e)&&this.right.is_number(e)}),e(rn,function(e){return t(this.operator.slice(0,-1))||\"=\"==this.operator&&this.right.is_number(e)}),e(We,function(e){return this.tail_node().is_number(e)}),e(tn,function(e){return this.consequent.is_number(e)&&this.alternative.is_number(e)})}(function(e,n){e.DEFMETHOD(\"is_number\",n)}),(s=function(e,n){e.DEFMETHOD(\"is_string\",n)})(se,ie),s(bn,J),s(Qe,function(){return\"typeof\"==this.operator}),s(nn,function(e){return\"+\"==this.operator&&(this.left.is_string(e)||this.right.is_string(e))}),s(rn,function(e){return(\"=\"==this.operator||\"+=\"==this.operator)&&this.right.is_string(e)}),s(We,function(e){return this.tail_node().is_string(e)}),s(tn,function(e){return this.consequent.is_string(e)&&this.alternative.is_string(e)});var c,ee=W(\"&& ||\"),f=W(\"delete ++ --\");function ne(e,n){return n instanceof Ke&&f(n.operator)?n.expression:n instanceof rn&&n.left===e?e:void 0}function x(e,n){return e.print_to_string().length>n.print_to_string().length?n:e}function I(e,n,t){return($(e)?function(e,n){return x(X(le,e,{body:e}),X(le,n,{body:n})).body}:x)(n,t)}function d(e){for(var n in e)e[n]=W(e[n])}c=function(e,n){e.DEFMETHOD(\"_find_defs\",n)},se.DEFMETHOD(\"resolve_defines\",function(e){if(e.option(\"global_defs\")){var n=this._find_defs(e,\"\");if(n){for(var t,i=this,r=0;t=i,(i=e.parent(r++))instanceof Ge&&i.expression===t;);if(!ne(t,i))return n;e.warn(\"global_defs \"+this.print_to_string()+\" redefined [{file}:{line},{col}]\",this.start)}}}),c(se,L),c(Xe,function(e,n){return this.expression._find_defs(e,\".\"+this.property+n)}),c(_n,function(e,n){if(this.global()){var t,i=e.option(\"global_defs\");if(i&&ae(i,t=this.name+n)){var r=function n(e,t){if(e instanceof se)return X(e.CTOR,t,e);if(Array.isArray(e))return X(on,t,{elements:e.map(function(e){return n(e,t)})});if(e&&\"object\"==typeof e){var i=[];for(var r in e)ae(e,r)&&i.push(X(un,t,{key:r,value:n(e[r],t)}));return X(an,t,{properties:i})}return q(e,t)}(i[t],this),o=e.find_parent(Ee);return r.walk(new Sn(function(e){e instanceof _n&&(e.scope=o,e.thedef=o.def_global(e))})),r}}});var h=[\"constructor\",\"toString\",\"valueOf\"],v={Array:[\"indexOf\",\"join\",\"lastIndexOf\",\"slice\"].concat(h),Boolean:h,Function:h,Number:[\"toExponential\",\"toFixed\",\"toPrecision\"].concat(h),Object:h,RegExp:[\"test\"].concat(h),String:[\"charAt\",\"charCodeAt\",\"concat\",\"indexOf\",\"italics\",\"lastIndexOf\",\"match\",\"replace\",\"search\",\"slice\",\"split\",\"substr\",\"substring\",\"toLowerCase\",\"toUpperCase\",\"trim\"].concat(h)};d(v);var _={Array:[\"isArray\"],Math:[\"abs\",\"acos\",\"asin\",\"atan\",\"ceil\",\"cos\",\"exp\",\"floor\",\"log\",\"round\",\"sin\",\"sqrt\",\"tan\",\"atan2\",\"pow\",\"max\",\"min\"],Number:[\"isFinite\",\"isNaN\"],Object:[\"create\",\"getOwnPropertyDescriptor\",\"getOwnPropertyNames\",\"getPrototypeOf\",\"isExtensible\",\"isFrozen\",\"isSealed\",\"keys\"],String:[\"fromCharCode\"]};d(_),function(e){se.DEFMETHOD(\"evaluate\",function(e){if(!e.option(\"evaluate\"))return this;var n=[],t=this._eval(e,n,1);return n.forEach(function(e){delete e._eval}),!t||t instanceof RegExp?t:\"function\"==typeof t||\"object\"==typeof t?this:t});var n=W(\"! ~ - + void\");se.DEFMETHOD(\"is_constant\",function(){return this instanceof gn?!(this instanceof wn):this instanceof Qe&&this.expression instanceof gn&&n(this.operator)}),e(ue,function(){throw new Error(S(\"Cannot evaluate a statement [{file}:{line},{col}]\",this.start))}),e(ke,C),e(se,C),e(gn,function(){return this.getValue()}),e(Fe,function(e){if(e.option(\"unsafe\")){var n=function(){};return n.node=this,n.toString=function(){return\"function(){}\"},n}return this}),e(on,function(e,n,t){if(e.option(\"unsafe\")){for(var i=[],r=0,o=this.elements.length;r<o;r++){var a=this.elements[r],s=a._eval(e,n,t);if(a===s)return this;i.push(s)}return i}return this}),e(an,function(e,n,t){if(e.option(\"unsafe\")){for(var i={},r=0,o=this.properties.length;r<o;r++){var a=this.properties[r],s=a.key;if(s instanceof cn)s=s.name;else if(s instanceof se&&(s=s._eval(e,n,t))===a.key)return this;if(\"function\"==typeof Object.prototype[s])return this;if(!(a.value instanceof Fe)&&(i[s]=a.value._eval(e,n,t),i[s]===a.value))return this}return i}return this});var r=W(\"! typeof void\");e(Qe,function(e,n,t){var i=this.expression;if(e.option(\"typeofs\")&&\"typeof\"==this.operator&&(i instanceof ke||i instanceof _n&&i.fixed_value()instanceof ke))return\"function\";if(r(this.operator)||t++,(i=i._eval(e,n,t))===this.expression)return this;switch(this.operator){case\"!\":return!i;case\"typeof\":return i instanceof RegExp?this:typeof i;case\"void\":return;case\"~\":return~i;case\"-\":return-i;case\"+\":return+i}return this});var a=W(\"&& || === !==\");e(nn,function(e,n,t){a(this.operator)||t++;var i=this.left._eval(e,n,t);if(i===this.left)return this;var r,o=this.right._eval(e,n,t);if(o===this.right)return this;switch(this.operator){case\"&&\":r=i&&o;break;case\"||\":r=i||o;break;case\"|\":r=i|o;break;case\"&\":r=i&o;break;case\"^\":r=i^o;break;case\"+\":r=i+o;break;case\"*\":r=i*o;break;case\"/\":r=i/o;break;case\"%\":r=i%o;break;case\"-\":r=i-o;break;case\"<<\":r=i<<o;break;case\">>\":r=i>>o;break;case\">>>\":r=i>>>o;break;case\"==\":r=i==o;break;case\"===\":r=i===o;break;case\"!=\":r=i!=o;break;case\"!==\":r=i!==o;break;case\"<\":r=i<o;break;case\"<=\":r=i<=o;break;case\">\":r=o<i;break;case\">=\":r=o<=i;break;default:return this}return isNaN(r)&&e.find_parent(xe)?this:r}),e(tn,function(e,n,t){var i=this.condition._eval(e,n,t);if(i===this.condition)return this;var r=i?this.consequent:this.alternative,o=r._eval(e,n,t);return o===r?this:o}),e(_n,function(e,n,t){var i,r=this.fixed_value();if(!r)return this;if(0<=n.indexOf(r))i=r._eval();else{if(this._eval=C,i=r._eval(e,n,t),delete this._eval,i===r)return this;r._eval=function(){return i},n.push(r)}if(i&&\"object\"==typeof i){var o=this.definition().escaped;if(o&&o<t)return this}return i});var p={Array:Array,Math:Math,Number:Number,Object:Object,String:String},s={Math:[\"E\",\"LN10\",\"LN2\",\"LOG2E\",\"LOG10E\",\"PI\",\"SQRT1_2\",\"SQRT2\"],Number:[\"MAX_VALUE\",\"MIN_VALUE\",\"NaN\",\"NEGATIVE_INFINITY\",\"POSITIVE_INFINITY\"]};d(s),e(Ge,function(e,n,t){if(e.option(\"unsafe\")){var i=this.property;if(i instanceof se&&(i=i._eval(e,n,t))===this.property)return this;var r,o=this.expression;if(H(o)){if(!(s[o.name]||ie)(i))return this;r=p[o.name]}else{if(!(r=o._eval(e,n,t+1))||r===o||!ae(r,i))return this;if(\"function\"==typeof r)switch(i){case\"name\":return r.node.name?r.node.name.name:\"\";case\"length\":return r.node.argnames.length;default:return this}}return r[i]}return this}),e(Ye,function(n,e,t){var i=this.expression;if(n.option(\"unsafe\")&&i instanceof Ge){var r,o=i.property;if(o instanceof se&&(o=o._eval(n,e,t))===i.property)return this;var a=i.expression;if(H(a)){if(!(_[a.name]||ie)(o))return this;r=p[a.name]}else if((r=a._eval(n,e,t+1))===a||!(r&&v[r.constructor.name]||ie)(o))return this;for(var s=[],u=0,c=this.args.length;u<c;u++){var f=this.args[u],l=f._eval(n,e,t);if(f===l)return this;s.push(l)}try{return r[o].apply(r,s)}catch(e){n.warn(\"Error evaluating {code} [{file}:{line},{col}]\",{code:this.print_to_string(),file:this.start.file,line:this.start.line,col:this.start.col})}}return this}),e(Je,C)}(function(e,n){e.DEFMETHOD(\"_eval\",n)}),function(e){function o(e){return X(Qe,e,{operator:\"!\",expression:e})}function r(e,n,t){var i=o(e);if(t){var r=X(le,n,{body:n});return x(i,r)===r?n:i}return x(i,n)}e(se,function(){return o(this)}),e(ue,function(){throw new Error(\"Cannot negate a statement\")}),e(Fe,function(){return o(this)}),e(Qe,function(){return\"!\"==this.operator?this.expression:o(this)}),e(We,function(e){var n=this.expressions.slice();return n.push(n.pop().negate(e)),M(this,n)}),e(tn,function(e,n){var t=this.clone();return t.consequent=t.consequent.negate(e),t.alternative=t.alternative.negate(e),r(this,t,n)}),e(nn,function(e,n){var t=this.clone(),i=this.operator;if(e.option(\"unsafe_comps\"))switch(i){case\"<=\":return t.operator=\">\",t;case\"<\":return t.operator=\">=\",t;case\">=\":return t.operator=\"<\",t;case\">\":return t.operator=\"<=\",t}switch(i){case\"==\":return t.operator=\"!=\",t;case\"!=\":return t.operator=\"==\",t;case\"===\":return t.operator=\"!==\",t;case\"!==\":return t.operator=\"===\",t;case\"&&\":return t.operator=\"||\",t.left=t.left.negate(e,n),t.right=t.right.negate(e),r(this,t,n);case\"||\":return t.operator=\"&&\",t.left=t.left.negate(e,n),t.right=t.right.negate(e),r(this,t,n)}return o(this)})}(function(e,t){e.DEFMETHOD(\"negate\",function(e,n){return t.call(this,e,n)})});var m=W(\"Boolean decodeURI decodeURIComponent Date encodeURI encodeURIComponent Error escape EvalError isFinite isNaN Number Object parseFloat parseInt RangeError ReferenceError String SyntaxError TypeError unescape URIError\");function A(e){return e&&e.aborts()}Ye.DEFMETHOD(\"is_expr_pure\",function(e){if(e.option(\"unsafe\")){var n=this.expression;if(H(n)&&m(n.name))return!0;if(n instanceof Xe&&H(n.expression)&&(_[n.expression.name]||ie)(n.property))return!0}return this.pure||!e.pure_funcs(this)}),se.DEFMETHOD(\"is_call_pure\",ie),Xe.DEFMETHOD(\"is_call_pure\",function(e){if(e.option(\"unsafe\")){var n=this.expression,t=ie;return n instanceof on?t=v.Array:n.is_boolean()?t=v.Boolean:n.is_number(e)?t=v.Number:n instanceof wn?t=v.RegExp:n.is_string(e)?t=v.String:this.may_throw_on_access(e)||(t=v.Object),t(this.property)}}),function(e){function n(e,n){for(var t=e.length;0<=--t;)if(e[t].has_side_effects(n))return!0;return!1}e(se,J),e(he,ie),e(gn,ie),e(mn,ie),e(pe,function(e){return n(this.body,e)}),e(Ye,function(e){return!(this.is_expr_pure(e)||this.expression.is_call_pure(e)&&!this.expression.has_side_effects(e))||n(this.args,e)}),e(qe,function(e){return this.expression.has_side_effects(e)||n(this.body,e)}),e(He,function(e){return this.expression.has_side_effects(e)||n(this.body,e)}),e(Re,function(e){return n(this.body,e)||this.bcatch&&this.bcatch.has_side_effects(e)||this.bfinally&&this.bfinally.has_side_effects(e)}),e(Me,function(e){return this.condition.has_side_effects(e)||this.body&&this.body.has_side_effects(e)||this.alternative&&this.alternative.has_side_effects(e)}),e(ve,function(e){return this.body.has_side_effects(e)}),e(le,function(e){return this.body.has_side_effects(e)}),e(ke,ie),e(nn,function(e){return this.left.has_side_effects(e)||this.right.has_side_effects(e)}),e(rn,J),e(tn,function(e){return this.condition.has_side_effects(e)||this.consequent.has_side_effects(e)||this.alternative.has_side_effects(e)}),e(Ke,function(e){return f(this.operator)||this.expression.has_side_effects(e)}),e(_n,function(e){return!this.is_declared(e)}),e(fn,ie),e(an,function(e){return n(this.properties,e)}),e(sn,function(e){return this.value.has_side_effects(e)}),e(on,function(e){return n(this.elements,e)}),e(Xe,function(e){return this.expression.may_throw_on_access(e)||this.expression.has_side_effects(e)}),e(Ze,function(e){return this.expression.may_throw_on_access(e)||this.expression.has_side_effects(e)||this.property.has_side_effects(e)}),e(We,function(e){return n(this.expressions,e)}),e(Ue,function(e){return n(this.definitions,e)}),e(Ve,function(e){return this.value})}(function(e,n){e.DEFMETHOD(\"has_side_effects\",n)}),function(e){function n(e,n){for(var t=e.length;0<=--t;)if(e[t].may_throw(n))return!0;return!1}e(se,J),e(gn,ie),e(he,ie),e(ke,ie),e(fn,ie),e(mn,ie),e(on,function(e){return n(this.elements,e)}),e(rn,function(e){return!!this.right.may_throw(e)||!(!e.has_directive(\"use strict\")&&\"=\"==this.operator&&this.left instanceof _n)&&this.left.may_throw(e)}),e(nn,function(e){return this.left.may_throw(e)||this.right.may_throw(e)}),e(pe,function(e){return n(this.body,e)}),e(Ye,function(e){return!!n(this.args,e)||!this.is_expr_pure(e)&&(!!this.expression.may_throw(e)||(!(this.expression instanceof ke)||n(this.expression.body,e)))}),e(He,function(e){return this.expression.may_throw(e)||n(this.body,e)}),e(tn,function(e){return this.condition.may_throw(e)||this.consequent.may_throw(e)||this.alternative.may_throw(e)}),e(Ue,function(e){return n(this.definitions,e)}),e(Xe,function(e){return this.expression.may_throw_on_access(e)||this.expression.may_throw(e)}),e(Me,function(e){return this.condition.may_throw(e)||this.body&&this.body.may_throw(e)||this.alternative&&this.alternative.may_throw(e)}),e(ve,function(e){return this.body.may_throw(e)}),e(an,function(e){return n(this.properties,e)}),e(sn,function(e){return this.value.may_throw(e)}),e(Te,function(e){return this.value&&this.value.may_throw(e)}),e(We,function(e){return n(this.expressions,e)}),e(le,function(e){return this.body.may_throw(e)}),e(Ze,function(e){return this.expression.may_throw_on_access(e)||this.expression.may_throw(e)||this.property.may_throw(e)}),e(qe,function(e){return this.expression.may_throw(e)||n(this.body,e)}),e(_n,function(e){return!this.is_declared(e)}),e(Re,function(e){return this.bcatch?this.bcatch.may_throw(e):n(this.body,e)||this.bfinally&&this.bfinally.may_throw(e)}),e(Ke,function(e){return!(\"typeof\"==this.operator&&this.expression instanceof _n)&&this.expression.may_throw(e)}),e(Ve,function(e){return!!this.value&&this.value.may_throw(e)})}(function(e,n){e.DEFMETHOD(\"may_throw\",n)}),function(e){function n(e){for(var n=e.length;0<=--n;)if(!e[n].is_constant_expression())return!1;return!0}e(se,ie),e(gn,J),e(ke,function(i){var r=this,o=!0;return r.walk(new Sn(function(e){if(!o)return!0;if(e instanceof _n){if(r.inlined)return!(o=!1);var n=e.definition();if(te(n,r.enclosed)&&!r.variables.has(n.name)){if(i){var t=i.find_variable(e);if(n.undeclared?!t:t===n)return o=\"f\",!0}o=!1}return!0}})),o}),e(Ke,function(){return this.expression.is_constant_expression()}),e(nn,function(){return this.left.is_constant_expression()&&this.right.is_constant_expression()}),e(on,function(){return n(this.elements)}),e(an,function(){return n(this.properties)}),e(sn,function(){return this.value.is_constant_expression()})}(function(e,n){e.DEFMETHOD(\"is_constant_expression\",n)}),function(e){function n(){var e=this.body.length;return 0<e&&A(this.body[e-1])}e(ue,B),e(Be,C),e(de,n),e(je,n),e(Me,function(){return this.alternative&&A(this.body)&&A(this.alternative)&&this})}(function(e,n){e.DEFMETHOD(\"aborts\",n)}),e(fe,function(e,n){return n.has_directive(e.value)!==e?X(he,e):e}),e(ce,function(e,n){return n.option(\"drop_debugger\")?X(he,e):e}),e(ve,function(e,n){return e.body instanceof $e&&n.loopcontrol_target(e.body)===e.body?X(he,e):0==e.label.references.length?e.body:e}),e(pe,function(e,n){return u(e.body,n),e}),e(de,function(e,n){switch(u(e.body,n),e.body.length){case 1:return e.body[0];case 0:return X(he,e)}return e}),e(ke,function(e,n){return u(e.body,n),n.option(\"side_effects\")&&1==e.body.length&&e.body[0]===n.has_directive(\"use strict\")&&(e.body.length=0),e}),Ae.DEFMETHOD(\"drop_unused\",function(b){if(b.option(\"unused\")&&!b.has_directive(\"use asm\")){var y=this;if(!y.uses_eval&&!y.uses_with){var w=!(y instanceof Ee)||b.toplevel.funcs,x=!(y instanceof Ee)||b.toplevel.vars,A=/keep_assign/.test(b.option(\"unused\"))?ie:function(e,n){var t;if(e instanceof rn&&(e.write_only||\"=\"==e.operator)?t=e.left:e instanceof Ke&&e.write_only&&(t=e.expression),/strict/.test(b.option(\"pure_getters\")))for(;t instanceof Ge&&!t.expression.may_throw_on_access(b);)t instanceof Ze&&n.unshift(t.property),t=t.expression;return t},s=[],E=Object.create(null),k=Object.create(null),u=Object.create(null),c=Object.create(null);y instanceof Ee&&b.top_retain&&y.variables.each(function(e){!b.top_retain(e)||e.id in E||(E[e.id]=!0,s.push(e))});var D=new O,i=new O,F=this,f=new Sn(function(e,n){if(e!==y){if(e instanceof Ce){var t=e.name.definition();return w||F!==y||t.id in E||(E[t.id]=!0,s.push(t)),i.add(t.id,e),!0}return e instanceof pn&&F===y&&D.add(e.definition().id,e),e instanceof Ue&&F===y?(e.definitions.forEach(function(e){var n=e.name.definition();e.name instanceof ln&&D.add(n.id,e),x||n.id in E||(E[n.id]=!0,s.push(n)),e.value&&(i.add(n.id,e.value),e.value.has_side_effects(b)&&e.value.walk(f),n.chained||e.name.fixed_value()!==e.value||(k[n.id]=e))}),!0):r(e,n)}});y.walk(f),f=new Sn(r);for(var e=0;e<s.length;e++){var n=i.get(s[e].id);n&&n.forEach(function(e){e.walk(f)})}var C=new Xn(function(a,e,n){var t=C.parent();if(x){var i=[];if((l=A(a,i))instanceof _n){var r=(s=l.definition()).id in E,o=null;if(a instanceof rn?(!r||a.left===l&&s.id in k&&k[s.id]!==a)&&(o=a.right):r||(o=X(yn,a,{value:0})),o)return i.push(o),Z(t,a,M(a,i.map(function(e){return e.transform(C)})))}}if(F===y){var s;if(a instanceof Fe&&a.name&&!b.option(\"keep_fnames\"))(s=a.name.definition()).id in E&&!(1<s.orig.length)||(a.name=null);if(a instanceof ke&&!(a instanceof De))for(var u=!b.option(\"keep_fargs\"),c=a.argnames,f=c.length;0<=--f;){var l;(l=c[f]).definition().id in E?u=!1:(l.__unused=!0,u&&(c.pop(),b[l.unreferenced()?\"warn\":\"info\"](\"Dropping unused function argument {name} [{file}:{line},{col}]\",g(l))))}if(w&&a instanceof Ce&&a!==y)if(!((s=a.name.definition()).id in E))return b[a.name.unreferenced()?\"warn\":\"info\"](\"Dropping unused function {name} [{file}:{line},{col}]\",g(a.name)),s.eliminated++,X(he,a);if(a instanceof Ue&&!(t instanceof we&&t.init===a)){var p=[],d=[],h=[],v=[];switch(a.definitions.forEach(function(e){e.value&&(e.value=e.value.transform(C));var n=e.name.definition();if(!x||n.id in E){if(e.value&&n.id in k&&k[n.id]!==e&&(e.value=e.value.drop_side_effect_free(b)),e.name instanceof ln){var t=D.get(n.id);if(1<t.length&&(!e.value||n.orig.indexOf(e.name)>n.eliminated)){if(b.warn(\"Dropping duplicated definition of variable {name} [{file}:{line},{col}]\",g(e.name)),e.value){var i=X(_n,e.name,e.name);n.references.push(i);var r=X(rn,e,{operator:\"=\",left:i,right:e.value});k[n.id]===e&&(k[n.id]=r),v.push(r.transform(C))}return T(t,e),void n.eliminated++}}e.value?(0<v.length&&(0<h.length?(v.push(e.value),e.value=M(e.value,v)):p.push(X(le,a,{body:M(a,v)})),v=[]),h.push(e)):d.push(e)}else if(n.orig[0]instanceof vn){(o=e.value&&e.value.drop_side_effect_free(b))&&v.push(o),e.value=null,d.push(e)}else{var o;(o=e.value&&e.value.drop_side_effect_free(b))?(b.warn(\"Side effects in initialization of unused variable {name} [{file}:{line},{col}]\",g(e.name)),v.push(o)):b[e.name.unreferenced()?\"warn\":\"info\"](\"Dropping unused variable {name} [{file}:{line},{col}]\",g(e.name)),n.eliminated++}}),(0<d.length||0<h.length)&&(a.definitions=d.concat(h),p.push(a)),0<v.length&&p.push(X(le,a,{body:M(a,v)})),p.length){case 0:return n?re.skip:X(he,a);case 1:return p[0];default:return n?re.splice(p):X(de,a,{body:p})}}if(a instanceof ye)return e(a,this),a.init instanceof de&&(_=a.init,a.init=_.body.pop(),_.body.push(a)),a.init instanceof le?a.init=a.init.body:j(a.init)&&(a.init=null),_?n?re.splice(_.body):_:a;if(a instanceof ve&&a.body instanceof ye){if(e(a,this),a.body instanceof de){var _=a.body;return a.body=_.body.pop(),_.body.push(a),n?re.splice(_.body):_}return a}if(a instanceof Ae){var m=F;return e(F=a,this),F=m,a}}function g(e){return{name:e.name,file:e.start.file,line:e.start.line,col:e.start.col}}});y.transform(C)}}function l(e,n,t){e.id in E||(n&&t?(E[e.id]=!0,s.push(e)):(u[e.id]=n,c[e.id]=t))}function r(e,n){var t,i=[],r=A(e,i);if(r instanceof _n&&y.variables.get(r.name)===(t=r.definition())){if(i.forEach(function(e){e.walk(f)}),e instanceof rn)if(e.right.walk(f),e.left===r)t.chained||r.fixed_value()!==e.right||(k[t.id]=e),e.write_only||l(t,!0,c[t.id]);else{var o=r.fixed_value();o&&o.is_constant()||l(t,u[t.id],!0)}return!0}if(e instanceof _n)return(t=e.definition()).id in E||(E[t.id]=!0,s.push(t)),!0;if(e instanceof Ae){var a=F;return F=e,n(),F=a,!0}}}),Ae.DEFMETHOD(\"hoist_declarations\",function(r){var o=this;if(r.has_directive(\"use asm\"))return o;var a=r.option(\"hoist_funs\"),s=r.option(\"hoist_vars\");if(a||s){var u=[],c=[],f=new O,l=0,n=0;o.walk(new Sn(function(e){return e instanceof Ae&&e!==o||(e instanceof Le?(++n,!0):void 0)})),s=s&&1<n;var p=new Xn(function(e){if(e!==o){if(e instanceof fe)return u.push(e),X(he,e);if(a&&e instanceof Ce&&(p.parent()===o||!r.has_directive(\"use strict\")))return c.push(e),X(he,e);if(s&&e instanceof Le){e.definitions.forEach(function(e){f.set(e.name.name,e),++l});var n=e.to_assignments(r),t=p.parent();if(t instanceof we&&t.init===e){if(null==n){var i=e.definitions[0].name;return X(_n,i,i)}return n}return t instanceof ye&&t.init===e?n:n?X(le,e,{body:n}):X(he,e)}if(e instanceof Ae)return e}});if(o=o.transform(p),0<l){var t=[];if(f.each(function(n,e){o instanceof ke&&V(function(e){return e.name==n.name.name},o.argnames)?f.del(e):((n=n.clone()).value=null,t.push(n),f.set(e,n))}),0<t.length){for(var e=0;e<o.body.length;){if(o.body[e]instanceof le){var i,d,h=o.body[e].body;if(h instanceof rn&&\"=\"==h.operator&&(i=h.left)instanceof cn&&f.has(i.name)){if((v=f.get(i.name)).value)break;v.value=h.right,T(t,v),t.push(v),o.body.splice(e,1);continue}if(h instanceof We&&(d=h.expressions[0])instanceof rn&&\"=\"==d.operator&&(i=d.left)instanceof cn&&f.has(i.name)){var v;if((v=f.get(i.name)).value)break;v.value=d.right,T(t,v),t.push(v),o.body[e].body=M(h,h.expressions.slice(1));continue}}if(o.body[e]instanceof he)o.body.splice(e,1);else{if(!(o.body[e]instanceof de))break;var _=[e,1].concat(o.body[e].body);o.body.splice.apply(o.body,_)}}t=X(Le,o,{definitions:t}),c.push(t)}}o.body=u.concat(c,o.body)}return o}),Ae.DEFMETHOD(\"var_names\",function(){var t=this._var_names;return t||(this._var_names=t=Object.create(null),this.enclosed.forEach(function(e){t[e.name]=!0}),this.variables.each(function(e,n){t[n]=!0})),t}),Ae.DEFMETHOD(\"make_var_name\",function(e){for(var n=this.var_names(),t=e=e.replace(/(?:^[^a-z_$]|[^a-z0-9_$])/gi,\"_\"),i=0;n[t];i++)t=e+\"$\"+i;return n[t]=!0,t}),Ae.DEFMETHOD(\"hoist_properties\",function(e){var u=this;if(!e.option(\"hoist_props\")||e.has_directive(\"use asm\"))return u;var i=u instanceof Ee&&e.top_retain||ie,c=Object.create(null);return u.transform(new Xn(function(r,e){var n;if(r instanceof Ve&&((s=r.name).scope===u&&1!=(t=s.definition()).escaped&&!t.single_use&&!t.direct_access&&!i(t)&&(n=s.fixed_value())===r.value&&n instanceof an)){e(r,this);var o=new O,a=[];return n.properties.forEach(function(e){var n,t,i;a.push(X(Ve,r,{name:(n=e.key,t=X(s.CTOR,s,{name:u.make_var_name(s.name+\"_\"+n),scope:u}),i=u.def_variable(t),o.set(n,i),u.enclosed.push(i),t),value:e.value}))}),c[t.id]=o,re.splice(a)}if(r instanceof Ge&&r.expression instanceof _n&&(o=c[r.expression.definition().id])){var s,t=o.get(p(r.property));return(s=X(_n,r,{name:t.name,scope:r.expression.scope,thedef:t})).reference({}),s}}))}),function(e){function a(e,n,t){var i=e.length;if(!i)return null;for(var r=[],o=!1,a=0;a<i;a++){var s=e[a].drop_side_effect_free(n,t);o|=s!==e[a],s&&(r.push(s),t=!1)}return o?r.length?r:null:e}e(se,C),e(gn,B),e(mn,B),e(Ye,function(n,e){if(!this.is_expr_pure(n)){if(this.expression.is_call_pure(n)){var t=this.args.slice();return t.unshift(this.expression.expression),(t=a(t,n,e))&&M(this,t)}if(this.expression instanceof Fe&&(!this.expression.name||!this.expression.name.definition().references.length)){var i=this.clone(),r=i.expression;return r.process_expression(!1,n),r.walk(new Sn(function(e){return e instanceof Te&&e.value?(e.value=e.value.drop_side_effect_free(n),!0):e instanceof Ae&&e!==r||void 0})),i}return this}this.pure&&n.warn(\"Dropping __PURE__ call [{file}:{line},{col}]\",this.start);var o=a(this.args,n,e);return o&&M(this,o)}),e(De,B),e(Fe,B),e(nn,function(e,n){var t=this.right.drop_side_effect_free(e);if(!t)return this.left.drop_side_effect_free(e,n);if(ee(this.operator)){if(t===this.right)return this;var i=this.clone();return i.right=t,i}var r=this.left.drop_side_effect_free(e,n);return r?M(this,[r,t]):this.right.drop_side_effect_free(e,n)}),e(rn,function(e){var n=this.left;return n.has_side_effects(e)||e.has_directive(\"use strict\")&&n instanceof Ge&&n.expression.is_constant()?this:(this.write_only=!0,K(n).is_constant_expression(e.find_parent(Ae))?this.right.drop_side_effect_free(e):this)}),e(tn,function(e){var n=this.consequent.drop_side_effect_free(e),t=this.alternative.drop_side_effect_free(e);if(n===this.consequent&&t===this.alternative)return this;if(!n)return t?X(nn,this,{operator:\"||\",left:this.condition,right:t}):this.condition.drop_side_effect_free(e);if(!t)return X(nn,this,{operator:\"&&\",left:this.condition,right:n});var i=this.clone();return i.consequent=n,i.alternative=t,i}),e(Ke,function(e,n){if(f(this.operator))return this.write_only=!this.expression.has_side_effects(e),this;if(\"typeof\"==this.operator&&this.expression instanceof _n)return null;var t=this.expression.drop_side_effect_free(e,n);return n&&t&&N(t)?t===this.expression&&\"!\"==this.operator?this:t.negate(e,n):t}),e(_n,function(e){return this.is_declared(e)?null:this}),e(an,function(e,n){var t=a(this.properties,e,n);return t&&M(this,t)}),e(sn,function(e,n){return this.value.drop_side_effect_free(e,n)}),e(on,function(e,n){var t=a(this.elements,e,n);return t&&M(this,t)}),e(Xe,function(e,n){return this.expression.may_throw_on_access(e)?this:this.expression.drop_side_effect_free(e,n)}),e(Ze,function(e,n){if(this.expression.may_throw_on_access(e))return this;var t=this.expression.drop_side_effect_free(e,n);if(!t)return this.property.drop_side_effect_free(e,n);var i=this.property.drop_side_effect_free(e);return i?M(this,[t,i]):t}),e(We,function(e){var n=this.tail_node(),t=n.drop_side_effect_free(e);if(t===n)return this;var i=this.expressions.slice(0,-1);return t&&i.push(t),M(this,i)})}(function(e,n){e.DEFMETHOD(\"drop_side_effect_free\",n)}),e(le,function(e,n){if(n.option(\"side_effects\")){var t=e.body,i=t.drop_side_effect_free(n,!0);if(!i)return n.warn(\"Dropping side-effect-free statement [{file}:{line},{col}]\",e.start),X(he,e);if(i!==t)return X(le,e,{body:i})}return e}),e(be,function(e,n){return n.option(\"loops\")?X(ye,e,e).optimize(n):e}),e(ge,function(n,e){if(!e.option(\"loops\"))return n;var t=n.condition.is_truthy()||n.condition.tail_node().evaluate(e);if(!(t instanceof se)){if(t)return X(ye,n,{body:X(de,n.body,{body:[n.body,X(le,n.condition,{body:n.condition})]})}).optimize(e);var i=!1,r=new Sn(function(e){return!!(e instanceof Ae||i)||(e instanceof Oe&&r.loopcontrol_target(e)===n?i=!0:void 0)}),o=e.parent();if((o instanceof ve?o:n).walk(r),!i)return X(de,n.body,{body:[n.body,X(le,n.condition,{body:n.condition})]}).optimize(e)}return n.body instanceof le?X(ye,n,{condition:M(n.condition,[n.body.body,n.condition]),body:X(he,n)}).optimize(e):n}),e(ye,function(e,n){if(!n.option(\"loops\"))return e;if(n.option(\"side_effects\")&&e.init&&(e.init=e.init.drop_side_effect_free(n)),e.condition){var t=e.condition.evaluate(n);if(!(t instanceof se))if(t)e.condition=null;else if(!n.option(\"dead_code\")){var i=e.condition;e.condition=q(t,e.condition),e.condition=x(e.condition.transform(n),i)}if(t instanceof se&&(t=e.condition.is_truthy()||e.condition.tail_node().evaluate(n)),t)!e.condition||t instanceof se||(e.body=X(de,e.body,{body:[X(le,e.condition,{body:e.condition}),e.body]}),e.condition=null);else if(n.option(\"dead_code\")){var r=[];return w(n,e.body,r),e.init instanceof ue?r.push(e.init):e.init&&r.push(X(le,e.init,{body:e.init})),r.push(X(le,e.condition,{body:e.condition})),X(de,e,{body:r}).optimize(n)}}return function n(t,i){var e=t.body instanceof de?t.body.body[0]:t.body;if(i.option(\"dead_code\")&&o(e)){var r=[];return t.init instanceof ue?r.push(t.init):t.init&&r.push(X(le,t.init,{body:t.init})),t.condition&&r.push(X(le,t.condition,{body:t.condition})),w(i,t.body,r),X(de,t,{body:r})}return e instanceof Me&&(o(e.body)?(t.condition?t.condition=X(nn,t.condition,{left:t.condition,operator:\"&&\",right:e.condition.negate(i)}):t.condition=e.condition.negate(i),a(e.alternative)):o(e.alternative)&&(t.condition?t.condition=X(nn,t.condition,{left:t.condition,operator:\"&&\",right:e.condition}):t.condition=e.condition,a(e.body))),t;function o(e){return e instanceof $e&&i.loopcontrol_target(e)===i.self()}function a(e){e=b(e),t.body instanceof de?(t.body=t.body.clone(),t.body.body=e.concat(t.body.body.slice(1)),t.body=t.body.transform(i)):t.body=X(de,t.body,{body:e}).transform(i),t=n(t,i)}}(e,n)}),e(Me,function(e,n){if(j(e.alternative)&&(e.alternative=null),!n.option(\"conditionals\"))return e;var t=e.condition.evaluate(n);if(!(n.option(\"dead_code\")||t instanceof se)){var i=e.condition;e.condition=q(t,i),e.condition=x(e.condition.transform(n),i)}if(n.option(\"dead_code\")){if(t instanceof se&&(t=e.condition.is_truthy()||e.condition.tail_node().evaluate(n)),!t){n.warn(\"Condition always false [{file}:{line},{col}]\",e.condition.start);var r=[];return w(n,e.body,r),r.push(X(le,e.condition,{body:e.condition})),e.alternative&&r.push(e.alternative),X(de,e,{body:r}).optimize(n)}if(!(t instanceof se)){n.warn(\"Condition always true [{file}:{line},{col}]\",e.condition.start);r=[];return e.alternative&&w(n,e.alternative,r),r.push(X(le,e.condition,{body:e.condition})),r.push(e.body),X(de,e,{body:r}).optimize(n)}}var o=e.condition.negate(n),a=e.condition.print_to_string().length,s=o.print_to_string().length,u=s<a;if(e.alternative&&u){u=!1,e.condition=o;var c=e.body;e.body=e.alternative||X(he,e),e.alternative=c}if(j(e.body)&&j(e.alternative))return X(le,e.condition,{body:e.condition.clone()}).optimize(n);if(e.body instanceof le&&e.alternative instanceof le)return X(le,e,{body:X(tn,e,{condition:e.condition,consequent:e.body.body,alternative:e.alternative.body})}).optimize(n);if(j(e.alternative)&&e.body instanceof le)return a===s&&!u&&e.condition instanceof nn&&\"||\"==e.condition.operator&&(u=!0),u?X(le,e,{body:X(nn,e,{operator:\"||\",left:o,right:e.body.body})}).optimize(n):X(le,e,{body:X(nn,e,{operator:\"&&\",left:e.condition,right:e.body.body})}).optimize(n);if(e.body instanceof he&&e.alternative instanceof le)return X(le,e,{body:X(nn,e,{operator:\"||\",left:e.condition,right:e.alternative.body})}).optimize(n);if(e.body instanceof Se&&e.alternative instanceof Se&&e.body.TYPE==e.alternative.TYPE)return X(e.body.CTOR,e,{value:X(tn,e,{condition:e.condition,consequent:e.body.value||X(En,e.body),alternative:e.alternative.value||X(En,e.alternative)}).transform(n)}).optimize(n);if(e.body instanceof Me&&!e.body.alternative&&!e.alternative&&(e=X(Me,e,{condition:X(nn,e.condition,{operator:\"&&\",left:e.condition,right:e.body.condition}),body:e.body.body,alternative:null})),A(e.body)&&e.alternative){var f=e.alternative;return e.alternative=null,X(de,e,{body:[e,f]}).optimize(n)}if(A(e.alternative)){r=e.body;return e.body=e.alternative,e.condition=u?o:e.condition.negate(n),e.alternative=null,X(de,e,{body:[e,r]}).optimize(n)}return e}),e(qe,function(n,t){if(!t.option(\"switches\"))return n;var e,i=n.expression.evaluate(t);if(!(i instanceof se)){var r=n.expression;n.expression=q(i,r),n.expression=x(n.expression.transform(t),r)}if(!t.option(\"dead_code\"))return n;i instanceof se&&(i=n.expression.tail_node().evaluate(t));for(var o,a,s=[],u=[],c=0,f=n.body.length;c<f&&!a;c++){if((e=n.body[c])instanceof Ne)o?g(e,u[u.length-1]):o=e;else if(!(i instanceof se)){if(!((_=e.expression.evaluate(t))instanceof se)&&_!==i){g(e,u[u.length-1]);continue}if(_ instanceof se&&(_=e.expression.tail_node().evaluate(t)),_===i&&(a=e,o)){var l=u.indexOf(o);u.splice(l,1),g(o,u[l-1]),o=null}}if(A(e)){var p=u[u.length-1];A(p)&&p.body.length==e.body.length&&X(de,p,p).equivalent_to(X(de,e,e))&&(p.body=[])}u.push(e)}for(;c<f;)g(n.body[c++],u[u.length-1]);for(0<u.length&&(u[0].body=s.concat(u[0].body)),n.body=u;e=u[u.length-1];){var d=e.body[e.body.length-1];if(d instanceof $e&&t.loopcontrol_target(d)===n&&e.body.pop(),e.body.length||e instanceof He&&(o||e.expression.has_side_effects(t)))break;u.pop()===o&&(o=null)}if(0==u.length)return X(de,n,{body:s.concat(X(le,n.expression,{body:n.expression}))}).optimize(t);if(1==u.length&&(u[0]===a||u[0]===o)){var h=!1,v=new Sn(function(e){if(h||e instanceof ke||e instanceof le)return!0;e instanceof $e&&v.loopcontrol_target(e)===n&&(h=!0)});if(n.walk(v),!h){var _,m=u[0].body.slice();return(_=u[0].expression)&&m.unshift(X(le,_,{body:_})),m.unshift(X(le,n.expression,{body:n.expression})),X(de,n,{body:m}).optimize(t)}}return n;function g(e,n){n&&!A(n)?n.body=n.body.concat(e.body):w(t,e,s)}}),e(Re,function(e,n){if(u(e.body,n),e.bcatch&&e.bfinally&&oe(e.bfinally.body,j)&&(e.bfinally=null),n.option(\"dead_code\")&&oe(e.body,j)){var t=[];return e.bcatch&&(w(n,e.bcatch,t),t.forEach(function(e){e instanceof Ue&&e.definitions.forEach(function(e){var n=e.name.definition().redefined();n&&(e.name=e.name.clone(),e.name.thedef=n)})})),e.bfinally&&(t=t.concat(e.bfinally.body)),X(de,e,{body:t}).optimize(n)}return e}),Ue.DEFMETHOD(\"remove_initializers\",function(){this.definitions.forEach(function(e){e.value=null})}),Ue.DEFMETHOD(\"to_assignments\",function(e){var i=e.option(\"reduce_vars\"),n=this.definitions.reduce(function(e,n){if(n.value){var t=X(_n,n.name,n.name);e.push(X(rn,n,{operator:\"=\",left:t,right:n.value})),i&&(t.definition().fixed=!1)}return(n=n.name.definition()).eliminated++,n.replaced--,e},[]);return 0==n.length?null:M(this,n)}),e(Ue,function(e,n){return 0==e.definitions.length?X(he,e):e}),e(Ye,function(s,r){var e=s.expression,p=e;r.option(\"reduce_vars\")&&p instanceof _n&&(p=p.fixed_value());var n=p instanceof ke;if(r.option(\"unused\")&&n&&!p.uses_arguments&&!p.uses_eval){for(var t=0,i=0,o=0,a=s.args.length;o<a;o++){var u=o>=p.argnames.length;if(u||p.argnames[o].__unused){if(d=s.args[o].drop_side_effect_free(r))s.args[t++]=d;else if(!u){s.args[t++]=X(yn,s.args[o],{value:0});continue}}else s.args[t++]=s.args[o];i=t}s.args.length=i}if(r.option(\"unsafe\"))if(H(e))switch(e.name){case\"Array\":if(1!=s.args.length)return X(on,s,{elements:s.args}).optimize(r);break;case\"Object\":if(0==s.args.length)return X(an,s,{properties:[]});break;case\"String\":if(0==s.args.length)return X(bn,s,{value:\"\"});if(s.args.length<=1)return X(nn,s,{left:s.args[0],operator:\"+\",right:X(bn,s,{value:\"\"})}).optimize(r);break;case\"Number\":if(0==s.args.length)return X(yn,s,{value:0});if(1==s.args.length)return X(Qe,s,{expression:s.args[0],operator:\"+\"}).optimize(r);case\"Boolean\":if(0==s.args.length)return X(Cn,s);if(1==s.args.length)return X(Qe,s,{expression:X(Qe,s,{expression:s.args[0],operator:\"!\"}),operator:\"!\"}).optimize(r);break;case\"RegExp\":var c=[];if(oe(s.args,function(e){var n=e.evaluate(r);return c.unshift(n),e!==n}))try{return I(r,s,X(wn,s,{value:RegExp.apply(RegExp,c)}))}catch(e){r.warn(\"Error converting {expr} [{file}:{line},{col}]\",{expr:s.print_to_string(),file:s.start.file,line:s.start.line,col:s.start.col})}}else if(e instanceof Xe)switch(e.property){case\"toString\":if(0==s.args.length&&!e.expression.may_throw_on_access(r))return X(nn,s,{left:X(bn,s,{value:\"\"}),operator:\"+\",right:e.expression}).optimize(r);break;case\"join\":var f;if(e.expression instanceof on)if(!(0<s.args.length&&(f=s.args[0].evaluate(r))===s.args[0])){var l,d,h=[],v=[];return e.expression.elements.forEach(function(e){var n=e.evaluate(r);n!==e?v.push(n):(0<v.length&&(h.push(X(bn,s,{value:v.join(f)})),v.length=0),h.push(e))}),0<v.length&&h.push(X(bn,s,{value:v.join(f)})),0==h.length?X(bn,s,{value:\"\"}):1==h.length?h[0].is_string(r)?h[0]:X(nn,h[0],{operator:\"+\",left:X(bn,s,{value:\"\"}),right:h[0]}):\"\"==f?(l=h[0].is_string(r)||h[1].is_string(r)?h.shift():X(bn,s,{value:\"\"}),h.reduce(function(e,n){return X(nn,n,{operator:\"+\",left:e,right:n})},l).optimize(r)):((d=s.clone()).expression=d.expression.clone(),d.expression.expression=d.expression.expression.clone(),d.expression.expression.elements=h,I(r,s,d))}break;case\"charAt\":if(e.expression.is_string(r)){var _=s.args[0],m=_?_.evaluate(r):0;if(m!==_)return X(Ze,e,{expression:e.expression,property:q(0|m,_||e)}).optimize(r)}break;case\"apply\":if(2==s.args.length&&s.args[1]instanceof on)return(k=s.args[1].elements.slice()).unshift(s.args[0]),X(Ye,s,{expression:X(Xe,e,{expression:e.expression,property:\"call\"}),args:k}).optimize(r);break;case\"call\":var g=e.expression;if(g instanceof _n&&(g=g.fixed_value()),g instanceof ke&&!g.contains_this())return M(this,[s.args[0],X(Ye,s,{expression:e.expression,args:s.args.slice(1)})]).optimize(r)}if(r.option(\"unsafe_Function\")&&H(e)&&\"Function\"==e.name){if(0==s.args.length)return X(Fe,s,{argnames:[],body:[]});if(oe(s.args,function(e){return e instanceof bn}))try{var b=Gn(A=\"n(function(\"+s.args.slice(0,-1).map(function(e){return e.value}).join(\",\")+\"){\"+s.args[s.args.length-1].value+\"})\"),y={ie8:r.option(\"ie8\")};b.figure_out_scope(y);var w,x=new et(r.options);(b=b.transform(x)).figure_out_scope(y),b.compute_char_frequency(y),b.mangle_names(y),b.walk(new Sn(function(e){return!!w||(e instanceof ke?(w=e,!0):void 0)}));var A=Qn();return de.prototype._codegen.call(w,w,A),s.args=[X(bn,s,{value:w.argnames.map(function(e){return e.print_to_string()}).join(\",\")}),X(bn,s.args[s.args.length-1],{value:A.get().replace(/^\\{|\\}$/g,\"\")})],s}catch(e){if(!(e instanceof Hn))throw e;r.warn(\"Error parsing code passed to new Function [{file}:{line},{col}]\",s.args[s.args.length-1].start),r.warn(e.toString())}}var E=n&&p.body[0];if(r.option(\"inline\")&&E instanceof Te&&(!(F=E.value)||F.is_constant_expression())){var k=s.args.concat(F||X(En,s));return M(s,k).optimize(r)}if(n){var D,F,C,B,S=-1;if(r.option(\"inline\")&&!p.uses_arguments&&!p.uses_eval&&!(p.name&&p instanceof Fe)&&(F=function(e){var n=p.body.length;if(r.option(\"inline\")<3)return 1==n&&$(e);e=null;for(var t=0;t<n;t++){var i=p.body[t];if(i instanceof Le){if(e&&!oe(i.definitions,function(e){return!e.value}))return!1}else{if(i instanceof he)continue;if(e)return!1;e=i}}return $(e)}(E))&&(e===p||r.option(\"unused\")&&1==(D=e.definition()).references.length&&!P(r,D)&&p.is_constant_expression(e.scope))&&!s.pure&&!p.contains_this()&&function(){var e=Object.create(null);do{if((C=r.parent(++S))instanceof Ie)e[C.argname.name]=!0;else if(C instanceof _e)B=[];else if(C instanceof _n&&C.fixed_value()instanceof Ae)return!1}while(!(C instanceof Ae));var n=!(C instanceof Ee)||r.toplevel.vars,t=r.option(\"inline\");return!(!function(e,n){for(var t=p.body.length,i=0;i<t;i++){var r=p.body[i];if(r instanceof Le){if(!n)return!1;for(var o=r.definitions.length;0<=--o;){var a=r.definitions[o].name;if(e[a.name]||R(a.name)||C.var_names()[a.name])return!1;B&&B.push(a.definition())}}}return!0}(e,3<=t&&n)||!function(e,n){for(var t=0,i=p.argnames.length;t<i;t++){var r=p.argnames[t];if(!r.__unused){if(!n||e[r.name]||R(r.name)||C.var_names()[r.name])return!1;B&&B.push(r.definition())}}return!0}(e,2<=t&&n)||B&&0!=B.length&&U(p,B))}())return p._squeezed=!0,M(s,function(){var e=[],n=[];(function(e,n){for(var t=p.argnames.length,i=s.args.length;--i>=t;)n.push(s.args[i]);for(i=t;0<=--i;){var r=p.argnames[i],o=s.args[i];if(r.__unused||C.var_names()[r.name])o&&n.push(o);else{var a=X(ln,r,r);r.definition().orig.push(a),!o&&B&&(o=X(En,s)),z(e,n,a,o)}}e.reverse(),n.reverse()})(e,n),function(e,n){for(var t=n.length,i=0,r=p.body.length;i<r;i++){var o=p.body[i];if(o instanceof Le)for(var a=0,s=o.definitions.length;a<s;a++){var u=o.definitions[a],c=u.name;if(z(e,n,c,u.value),B){var f=c.definition(),l=X(_n,c,c);f.references.push(l),n.splice(t++,0,X(rn,u,{operator:\"=\",left:l,right:X(En,c)}))}}}}(e,n),n.push(F),e.length&&(o=C.body.indexOf(r.parent(S-1))+1,C.body.splice(o,0,X(Le,p,{definitions:e})));return n}()).optimize(r);if(r.option(\"side_effects\")&&oe(p.body,j)){k=s.args.concat(X(En,s));return M(s,k).optimize(r)}}if(r.option(\"drop_console\")&&e instanceof Ge){for(var T=e.expression;T.expression;)T=T.expression;if(H(T)&&\"console\"==T.name)return X(En,s).optimize(r)}if(r.option(\"negate_iife\")&&r.parent()instanceof le&&N(s))return s.negate(r,!0);var O=s.evaluate(r);return O!==s?(O=q(O,s).optimize(r),I(r,O,s)):s;function $(e){return e?e instanceof Te?e.value?e.value.clone(!0):X(En,s):e instanceof le?X(Qe,e,{operator:\"void\",expression:e.body.clone(!0)}):void 0:X(En,s)}function z(e,n,t,i){var r=t.definition();C.variables.set(t.name,r),C.enclosed.push(r),C.var_names()[t.name]||(C.var_names()[t.name]=!0,e.push(X(Ve,t,{name:t,value:null})));var o=X(_n,t,t);r.references.push(o),i&&n.push(X(rn,s,{operator:\"=\",left:o,right:i}))}}),e(Je,function(e,n){if(n.option(\"unsafe\")){var t=e.expression;if(H(t))switch(t.name){case\"Object\":case\"RegExp\":case\"Function\":case\"Error\":case\"Array\":return X(Ye,e,e).transform(n)}}return e}),e(We,function(e,t){if(!t.option(\"side_effects\"))return e;var i,r,o=[];i=$(t),r=e.expressions.length-1,e.expressions.forEach(function(e,n){n<r&&(e=e.drop_side_effect_free(t,i)),e&&(l(o,e),i=!1)});var n=o.length-1;return function(){for(;0<n&&g(o[n],t);)n--;n<o.length-1&&(o[n]=X(Qe,e,{operator:\"void\",expression:o[n]}),o.length=n+1)}(),0==n?(e=Z(t.parent(),t.self(),o[0]))instanceof We||(e=e.optimize(t)):e.expressions=o,e}),Ke.DEFMETHOD(\"lift_sequences\",function(e){if(e.option(\"sequences\")&&this.expression instanceof We){var n=this.expression.expressions.slice(),t=this.clone();return t.expression=n.pop(),n.push(t),M(this,n).optimize(e)}return this}),e(en,function(e,n){return e.lift_sequences(n)}),e(Qe,function(e,n){var t=e.expression;if(\"delete\"==e.operator&&!(t instanceof _n||t instanceof Ge||Q(t)))return t instanceof We?((t=t.expressions.slice()).push(X(Bn,e)),M(e,t).optimize(n)):M(e,[t,X(Bn,e)]).optimize(n);var i=e.lift_sequences(n);if(i!==e)return i;if(n.option(\"side_effects\")&&\"void\"==e.operator)return(t=t.drop_side_effect_free(n))?(e.expression=t,e):X(En,e).optimize(n);if(n.option(\"booleans\")){if(\"!\"==e.operator&&t.is_truthy())return M(e,[t,X(Cn,e)]).optimize(n);if(n.in_boolean_context())switch(e.operator){case\"!\":if(t instanceof Qe&&\"!\"==t.operator)return t.expression;t instanceof nn&&(e=I(n,e,t.negate(n,$(n))));break;case\"typeof\":return n.warn(\"Boolean expression always true [{file}:{line},{col}]\",e.start),(t instanceof _n?X(Bn,e):M(e,[t,X(Bn,e)])).optimize(n)}}if(\"-\"==e.operator&&t instanceof Dn&&(t=t.transform(n)),t instanceof nn&&(\"+\"==e.operator||\"-\"==e.operator)&&(\"*\"==t.operator||\"/\"==t.operator||\"%\"==t.operator))return X(nn,e,{operator:t.operator,left:X(Qe,t.left,{operator:e.operator,expression:t.left}),right:t.right});if(\"-\"!=e.operator||!(t instanceof yn||t instanceof Dn)){var r=e.evaluate(n);if(r!==e)return I(n,r=q(r,e).optimize(n),e)}return e}),nn.DEFMETHOD(\"lift_sequences\",function(e){if(e.option(\"sequences\")){if(this.left instanceof We){var n=this.left.expressions.slice();return(t=this.clone()).left=n.pop(),n.push(t),M(this,n).optimize(e)}if(this.right instanceof We&&!this.left.has_side_effects(e)){for(var t,i=\"=\"==this.operator&&this.left instanceof _n,r=(n=this.right.expressions).length-1,o=0;o<r&&(i||!n[o].has_side_effects(e));o++);if(o==r)return n=n.slice(),(t=this.clone()).right=n.pop(),n.push(t),M(this,n).optimize(e);if(0<o)return(t=this.clone()).right=M(this.right,n.slice(o)),(n=n.slice(0,o)).push(t),M(this,n).optimize(e)}}return this});var E=W(\"== === != !== * & | ^\");function P(e,n){for(var t,i=0;t=e.parent(i);i++)if(t instanceof ke){var r=t.name;if(r&&r.definition()===n)break}return t}function k(e,n){return e instanceof _n||e.TYPE===n.TYPE}function U(t,n){var i=!1,r=new Sn(function(e){return!!i||(e instanceof _n&&te(e.definition(),n)?i=!0:void 0)}),o=new Sn(function(e){if(i)return!0;if(e instanceof Ae&&e!==t){var n=o.parent();if(n instanceof Ye&&n.expression===e)return;return e.walk(r),!0}});return t.walk(o),i}e(nn,function(t,n){function i(){return t.left.is_constant()||t.right.is_constant()||!t.left.has_side_effects(n)&&!t.right.has_side_effects(n)}function e(e){if(i()){e&&(t.operator=e);var n=t.left;t.left=t.right,t.right=n}}if(E(t.operator)&&t.right.is_constant()&&!t.left.is_constant()&&(t.left instanceof nn&&Jn[t.left.operator]>=Jn[t.operator]||e()),t=t.lift_sequences(n),n.option(\"comparisons\"))switch(t.operator){case\"===\":case\"!==\":var r=!0;(t.left.is_string(n)&&t.right.is_string(n)||t.left.is_number(n)&&t.right.is_number(n)||t.left.is_boolean()&&t.right.is_boolean()||t.left.equivalent_to(t.right))&&(t.operator=t.operator.substr(0,2));case\"==\":case\"!=\":if(!r&&g(t.left,n))t.left=X(xn,t.left);else if(n.option(\"typeofs\")&&t.left instanceof bn&&\"undefined\"==t.left.value&&t.right instanceof Qe&&\"typeof\"==t.right.operator){var o=t.right.expression;(o instanceof _n?!o.is_declared(n):o instanceof Ge&&n.option(\"ie8\"))||(t.right=o,t.left=X(En,t.left).optimize(n),2==t.operator.length&&(t.operator+=\"=\"))}else if(t.left instanceof _n&&t.right instanceof _n&&t.left.definition()===t.right.definition()&&((u=t.left.fixed_value())instanceof on||u instanceof ke||u instanceof an))return X(\"=\"==t.operator[0]?Bn:Cn,t);break;case\"&&\":case\"||\":var a=t.left;if(a.operator==t.operator&&(a=a.right),a instanceof nn&&a.operator==(\"&&\"==t.operator?\"!==\":\"===\")&&t.right instanceof nn&&a.operator==t.right.operator&&(g(a.left,n)&&t.right.left instanceof xn||a.left instanceof xn&&g(t.right.left,n))&&!a.right.has_side_effects(n)&&a.right.equivalent_to(t.right.right)){var s=X(nn,t,{operator:a.operator.slice(0,-1),left:X(xn,t),right:a.right});return a!==t.left&&(s=X(nn,t,{operator:t.operator,left:t.left.left,right:s})),s}}var u;if(n.option(\"booleans\")&&\"+\"==t.operator&&n.in_boolean_context()){var c=t.left.evaluate(n),f=t.right.evaluate(n);if(c&&\"string\"==typeof c)return n.warn(\"+ in boolean context always true [{file}:{line},{col}]\",t.start),M(t,[t.right,X(Bn,t)]).optimize(n);if(f&&\"string\"==typeof f)return n.warn(\"+ in boolean context always true [{file}:{line},{col}]\",t.start),M(t,[t.left,X(Bn,t)]).optimize(n)}if(n.option(\"comparisons\")&&t.is_boolean()){if(!(n.parent()instanceof nn)||n.parent()instanceof rn){var l=X(Qe,t,{operator:\"!\",expression:t.negate(n,$(n))});t=I(n,t,l)}switch(t.operator){case\">\":e(\"<\");break;case\">=\":e(\"<=\")}}if(\"+\"==t.operator){if(t.right instanceof bn&&\"\"==t.right.getValue()&&t.left.is_string(n))return t.left;if(t.left instanceof bn&&\"\"==t.left.getValue()&&t.right.is_string(n))return t.right;if(t.left instanceof nn&&\"+\"==t.left.operator&&t.left.left instanceof bn&&\"\"==t.left.left.getValue()&&t.right.is_string(n))return t.left=t.left.right,t.transform(n)}if(n.option(\"evaluate\")){switch(t.operator){case\"&&\":if(!(c=m(t.left)))return n.warn(\"Condition left of && always false [{file}:{line},{col}]\",t.start),Z(n.parent(),n.self(),t.left).optimize(n);if(!(c instanceof se))return n.warn(\"Condition left of && always true [{file}:{line},{col}]\",t.start),M(t,[t.left,t.right]).optimize(n);if(f=t.right.evaluate(n)){if(!(f instanceof se)){if(\"&&\"==(p=n.parent()).operator&&p.left===n.self()||n.option(\"booleans\")&&n.in_boolean_context())return n.warn(\"Dropping side-effect-free && [{file}:{line},{col}]\",t.start),t.left.optimize(n)}}else{if(n.option(\"booleans\")&&n.in_boolean_context())return n.warn(\"Boolean && always false [{file}:{line},{col}]\",t.start),M(t,[t.left,X(Cn,t)]).optimize(n);t.falsy=!0}if(\"||\"==t.left.operator)if(!(d=t.left.right.evaluate(n)))return X(tn,t,{condition:t.left.left,consequent:t.right,alternative:t.left.right}).optimize(n);break;case\"||\":var p,d;if(!(c=m(t.left)))return n.warn(\"Condition left of || always false [{file}:{line},{col}]\",t.start),M(t,[t.left,t.right]).optimize(n);if(!(c instanceof se))return n.warn(\"Condition left of || always true [{file}:{line},{col}]\",t.start),Z(n.parent(),n.self(),t.left).optimize(n);if(f=t.right.evaluate(n)){if(!(f instanceof se)){if(n.option(\"booleans\")&&n.in_boolean_context())return n.warn(\"Boolean || always true [{file}:{line},{col}]\",t.start),M(t,[t.left,X(Bn,t)]).optimize(n);t.truthy=!0}}else if(\"||\"==(p=n.parent()).operator&&p.left===n.self()||n.option(\"booleans\")&&n.in_boolean_context())return n.warn(\"Dropping side-effect-free || [{file}:{line},{col}]\",t.start),t.left.optimize(n);if(\"&&\"==t.left.operator)if((d=t.left.right.evaluate(n))&&!(d instanceof se))return X(tn,t,{condition:t.left.left,consequent:t.left.right,alternative:t.right}).optimize(n)}var h=!0;switch(t.operator){case\"+\":if(t.left instanceof gn&&t.right instanceof nn&&\"+\"==t.right.operator&&t.right.left instanceof gn&&t.right.is_string(n)&&(t=X(nn,t,{operator:\"+\",left:X(bn,t.left,{value:\"\"+t.left.getValue()+t.right.left.getValue(),start:t.left.start,end:t.right.left.end}),right:t.right.right})),t.right instanceof gn&&t.left instanceof nn&&\"+\"==t.left.operator&&t.left.right instanceof gn&&t.left.is_string(n)&&(t=X(nn,t,{operator:\"+\",left:t.left.left,right:X(bn,t.right,{value:\"\"+t.left.right.getValue()+t.right.getValue(),start:t.left.right.start,end:t.right.end})})),t.left instanceof nn&&\"+\"==t.left.operator&&t.left.is_string(n)&&t.left.right instanceof gn&&t.right instanceof nn&&\"+\"==t.right.operator&&t.right.left instanceof gn&&t.right.is_string(n)&&(t=X(nn,t,{operator:\"+\",left:X(nn,t.left,{operator:\"+\",left:t.left.left,right:X(bn,t.left.right,{value:\"\"+t.left.right.getValue()+t.right.left.getValue(),start:t.left.right.start,end:t.right.left.end})}),right:t.right.right})),t.right instanceof Qe&&\"-\"==t.right.operator&&t.left.is_number(n)){t=X(nn,t,{operator:\"-\",left:t.left,right:t.right.expression});break}if(t.left instanceof Qe&&\"-\"==t.left.operator&&i()&&t.right.is_number(n)){t=X(nn,t,{operator:\"-\",left:t.right,right:t.left.expression});break}case\"*\":h=n.option(\"unsafe_math\");case\"&\":case\"|\":case\"^\":if(t.left.is_number(n)&&t.right.is_number(n)&&i()&&!(t.left instanceof nn&&t.left.operator!=t.operator&&Jn[t.left.operator]>=Jn[t.operator])){var v=X(nn,t,{operator:t.operator,left:t.right,right:t.left});t=t.right instanceof gn&&!(t.left instanceof gn)?I(n,v,t):I(n,t,v)}h&&t.is_number(n)&&(t.right instanceof nn&&t.right.operator==t.operator&&(t=X(nn,t,{operator:t.operator,left:X(nn,t.left,{operator:t.operator,left:t.left,right:t.right.left,start:t.left.start,end:t.right.left.end}),right:t.right.right})),t.right instanceof gn&&t.left instanceof nn&&t.left.operator==t.operator&&(t.left.left instanceof gn?t=X(nn,t,{operator:t.operator,left:X(nn,t.left,{operator:t.operator,left:t.left.left,right:t.right,start:t.left.left.start,end:t.right.end}),right:t.left.right}):t.left.right instanceof gn&&(t=X(nn,t,{operator:t.operator,left:X(nn,t.left,{operator:t.operator,left:t.left.right,right:t.right,start:t.left.right.start,end:t.right.end}),right:t.left.left}))),t.left instanceof nn&&t.left.operator==t.operator&&t.left.right instanceof gn&&t.right instanceof nn&&t.right.operator==t.operator&&t.right.left instanceof gn&&(t=X(nn,t,{operator:t.operator,left:X(nn,t.left,{operator:t.operator,left:X(nn,t.left.left,{operator:t.operator,left:t.left.right,right:t.right.left,start:t.left.right.start,end:t.right.left.end}),right:t.left.left}),right:t.right.right})))}}if(t.right instanceof nn&&t.right.operator==t.operator&&(ee(t.operator)||\"+\"==t.operator&&(t.right.left.is_string(n)||t.left.is_string(n)&&t.right.right.is_string(n))))return t.left=X(nn,t.left,{operator:t.operator,left:t.left,right:t.right.left}),t.right=t.right.right,t.transform(n);var _=t.evaluate(n);return _!==t?(_=q(_,t).optimize(n),I(n,_,t)):t;function m(e){return!!e.truthy||!e.falsy&&(!!e.is_truthy()||e.evaluate(n))}}),e(_n,function(e,n){var t,i=e.resolve_defines(n);if(i)return i.optimize(n);if(!n.option(\"ie8\")&&H(e)&&(!e.scope.uses_with||!n.find_parent(xe)))switch(e.name){case\"undefined\":return X(En,e).optimize(n);case\"NaN\":return X(An,e).optimize(n);case\"Infinity\":return X(Dn,e).optimize(n)}if(n.option(\"reduce_vars\")&&ne(e,n.parent())!==e){var r=e.definition(),o=e.fixed_value(),a=r.single_use;if(a&&o instanceof ke)if(r.scope===e.scope||n.option(\"reduce_funcs\")&&1!=r.escaped&&!o.inlined){if(P(n,r))a=!1;else if((r.scope!==e.scope||r.orig[0]instanceof pn)&&\"f\"==(a=o.is_constant_expression(e.scope)))for(var s=e.scope;(s instanceof Ce||s instanceof Fe)&&(s.inlined=!0),s=s.parent_scope;);}else a=!1;if(a&&o){var u;if(o instanceof Ce&&(o._squeezed=!0,o=X(Fe,o,o)),0<r.recursive_refs&&o.name instanceof dn){var c=(u=o.clone(!0)).name.definition(),f=u.variables.get(u.name.name),l=f&&f.orig[0];l instanceof hn||(((l=X(hn,u.name,u.name)).scope=u).name=l,f=u.def_function(l)),u.walk(new Sn(function(e){e instanceof _n&&e.definition()===c&&(e.thedef=f).references.push(e)}))}else(u=o.optimize(n))===o&&(u=o.clone(!0));return u}if(o&&void 0===r.should_replace){var p;if(o instanceof mn)r.orig[0]instanceof pn||!oe(r.references,function(e){return r.scope===e.scope})||(p=o);else{var d=o.evaluate(n);d===o||!n.option(\"unsafe_regexp\")&&d instanceof RegExp||(p=q(d,o))}if(p){var h,v=p.optimize(n).print_to_string().length;o.walk(new Sn(function(e){if(e instanceof _n&&(t=!0),t)return!0})),t?h=function(){var e=p.optimize(n);return e===p?e.clone(!0):e}:(v=Math.min(v,o.print_to_string().length),h=function(){var e=x(p.optimize(n),o);return e===p||e===o?e.clone(!0):e});var _=r.name.length,m=0;n.option(\"unused\")&&!n.exposed(r)&&(m=(_+2+v)/(r.references.length-r.assignments)),r.should_replace=v<=_+m&&h}else r.should_replace=!1}if(r.should_replace)return r.should_replace()}return e}),e(En,function(e,n){if(n.option(\"unsafe_undefined\")){var t=o(n,\"undefined\");if(t){var i=X(_n,e,{name:\"undefined\",scope:t.scope,thedef:t});return i.is_undefined=!0,i}}var r=ne(n.self(),n.parent());return r&&k(r,e)?e:X(Qe,e,{operator:\"void\",expression:X(yn,e,{value:0})})}),e(Dn,function(e,n){var t=ne(n.self(),n.parent());return t&&k(t,e)?e:!n.option(\"keep_infinity\")||t&&!k(t,e)||o(n,\"Infinity\")?X(nn,e,{operator:\"/\",left:X(yn,e,{value:1}),right:X(yn,e,{value:0})}):e}),e(An,function(e,n){var t=ne(n.self(),n.parent());return t&&!k(t,e)||o(n,\"NaN\")?X(nn,e,{operator:\"/\",left:X(yn,e,{value:0}),right:X(yn,e,{value:0})}):e});var D=[\"+\",\"-\",\"/\",\"*\",\"%\",\">>\",\"<<\",\">>>\",\"|\",\"^\",\"&\"],F=[\"*\",\"|\",\"^\",\"&\"];e(rn,function(a,s){var e;if(s.option(\"dead_code\")&&a.left instanceof _n&&(e=a.left.definition()).scope===s.find_parent(ke)){var n,t=0,i=a;do{if(n=i,(i=s.parent(t++))instanceof Se){if(r(t,i))break;if(U(e.scope,[e]))break;return\"=\"==a.operator?a.right:(e.fixed=!1,X(nn,a,{operator:a.operator.slice(0,-1),left:a.left,right:a.right}).optimize(s))}}while(i instanceof nn&&i.right===n||i instanceof We&&i.tail_node()===n)}return\"=\"==(a=a.lift_sequences(s)).operator&&a.left instanceof _n&&a.right instanceof nn&&(a.right.left instanceof _n&&a.right.left.name==a.left.name&&te(a.right.operator,D)?(a.operator=a.right.operator+\"=\",a.right=a.right.right):a.right.right instanceof _n&&a.right.right.name==a.left.name&&te(a.right.operator,F)&&!a.right.left.has_side_effects(s)&&(a.operator=a.right.operator+\"=\",a.right=a.right.left)),a;function r(e,n){var t=a.right;a.right=X(xn,t);var i=n.may_throw(s);a.right=t;for(var r,o=a.left.definition().scope;(r=s.parent(e++))!==o;)if(r instanceof Re){if(r.bfinally)return!0;if(i&&r.bcatch)return!0}}}),e(tn,function(e,n){if(!n.option(\"conditionals\"))return e;if(e.condition instanceof We){var t=e.condition.expressions.slice();return e.condition=t.pop(),t.push(e),M(e,t)}var i=e.condition.is_truthy()||e.condition.tail_node().evaluate(n);if(!i)return n.warn(\"Condition always false [{file}:{line},{col}]\",e.start),M(e,[e.condition,e.alternative]).optimize(n);if(!(i instanceof se))return n.warn(\"Condition always true [{file}:{line},{col}]\",e.start),M(e,[e.condition,e.consequent]).optimize(n);var r=i.negate(n,$(n));I(n,i,r)===r&&(e=X(tn,e,{condition:r,consequent:e.alternative,alternative:e.consequent}));var o,a=e.condition,s=e.consequent,u=e.alternative;if(a instanceof _n&&s instanceof _n&&a.definition()===s.definition())return X(nn,e,{operator:\"||\",left:a,right:u});if(s instanceof rn&&u instanceof rn&&s.operator==u.operator&&s.left.equivalent_to(u.left)&&(!e.condition.has_side_effects(n)||\"=\"==s.operator&&!s.left.has_side_effects(n)))return X(rn,e,{operator:s.operator,left:s.left,right:X(tn,e,{condition:e.condition,consequent:s.right,alternative:u.right})});if(s instanceof Ye&&u.TYPE===s.TYPE&&0<s.args.length&&s.args.length==u.args.length&&s.expression.equivalent_to(u.expression)&&!e.condition.has_side_effects(n)&&!s.expression.has_side_effects(n)&&\"number\"==typeof(o=function(){for(var e=s.args,n=u.args,t=0,i=e.length;t<i;t++)if(!e[t].equivalent_to(n[t])){for(var r=t+1;r<i;r++)if(!e[r].equivalent_to(n[r]))return;return t}}())){var c=s.clone();return c.args[o]=X(tn,e,{condition:e.condition,consequent:s.args[o],alternative:u.args[o]}),c}if(s instanceof tn&&s.alternative.equivalent_to(u))return X(tn,e,{condition:X(nn,e,{left:e.condition,operator:\"&&\",right:s.condition}),consequent:s.consequent,alternative:u});if(s.equivalent_to(u))return M(e,[e.condition,s]).optimize(n);if((s instanceof We||u instanceof We)&&s.tail_node().equivalent_to(u.tail_node()))return M(e,[X(tn,e,{condition:e.condition,consequent:h(s),alternative:h(u)}),s.tail_node()]).optimize(n);if(s instanceof nn&&\"||\"==s.operator&&s.right.equivalent_to(u))return X(nn,e,{operator:\"||\",left:X(nn,e,{operator:\"&&\",left:e.condition,right:s.left}),right:u}).optimize(n);var f=n.option(\"booleans\")&&n.in_boolean_context();return p(e.consequent)?d(e.alternative)?l(e.condition):X(nn,e,{operator:\"||\",left:l(e.condition),right:e.alternative}):d(e.consequent)?p(e.alternative)?l(e.condition.negate(n)):X(nn,e,{operator:\"&&\",left:l(e.condition.negate(n)),right:e.alternative}):p(e.alternative)?X(nn,e,{operator:\"||\",left:l(e.condition.negate(n)),right:e.consequent}):d(e.alternative)?X(nn,e,{operator:\"&&\",left:l(e.condition),right:e.consequent}):e;function l(e){return e.is_boolean()?e:X(Qe,e,{operator:\"!\",expression:e.negate(n)})}function p(e){return e instanceof Bn||f&&e instanceof gn&&e.getValue()||e instanceof Qe&&\"!\"==e.operator&&e.expression instanceof gn&&!e.expression.getValue()}function d(e){return e instanceof Cn||f&&e instanceof gn&&!e.getValue()||e instanceof Qe&&\"!\"==e.operator&&e.expression instanceof gn&&e.expression.getValue()}function h(e){return e instanceof We?M(e,e.expressions.slice(0,-1)):X(yn,e,{value:0})}}),e(Fn,function(e,n){if(!n.option(\"booleans\"))return e;if(n.in_boolean_context())return X(yn,e,{value:+e.value});var t=n.parent();return t instanceof nn&&(\"==\"==t.operator||\"!=\"==t.operator)?(n.warn(\"Non-strict equality against boolean: {operator} {value} [{file}:{line},{col}]\",{operator:t.operator,value:e.value,file:t.start.file,line:t.start.line,col:t.start.col}),X(yn,e,{value:+e.value})):X(Qe,e,{operator:\"!\",expression:X(yn,e,{value:1-e.value})})}),e(Ze,function(e,n){var t,i=e.expression,r=e.property;if(n.option(\"properties\")){var o=r.evaluate(n);if(o!==r){if(\"string\"==typeof o)if(\"undefined\"==o)o=void 0;else(h=parseFloat(o)).toString()==o&&(o=h);r=e.property=x(r,q(o,r).transform(n));var a=\"\"+o;if(Nn(a)&&a.length<=r.print_to_string().length+1)return X(Xe,e,{expression:i,property:a}).optimize(n)}}if(ne(e,n.parent()))return e;if(o!==r){var s=e.flatten_object(a,n);s&&(i=e.expression=s.expression,r=e.property=s.property)}if(n.option(\"properties\")&&n.option(\"side_effects\")&&r instanceof yn&&i instanceof on){var u=r.getValue(),c=i.elements;if(u in c){for(var f=!0,l=[],p=c.length;--p>u;){(h=c[p].drop_side_effect_free(n))&&(l.unshift(h),f&&h.has_side_effects(n)&&(f=!1))}var d=c[u];for(d=d instanceof kn?X(En,d):d,f||l.unshift(d);0<=--p;){var h;(h=c[p].drop_side_effect_free(n))?l.unshift(h):u--}return f?(l.push(d),M(e,l).optimize(n)):X(Ze,e,{expression:X(on,i,{elements:l}),property:X(yn,r,{value:u})})}}if(n.option(\"arguments\")&&i instanceof _n&&\"arguments\"==i.name&&1==i.definition().orig.length&&(t=i.scope)instanceof ke&&r instanceof yn){u=r.getValue();var v=t.argnames[u];if(!v&&!n.option(\"keep_fargs\"))for(;u>=t.argnames.length;)v=X(pn,t,{name:t.make_var_name(\"argument_\"+t.argnames.length),scope:t}),t.argnames.push(v),t.enclosed.push(t.def_variable(v));if(v){var _=X(_n,e,v);return _.reference({}),_}}var m=e.evaluate(n);return m!==e?I(n,m=q(m,e).optimize(n),e):e}),ke.DEFMETHOD(\"contains_this\",function(){var n,t=this;return t.walk(new Sn(function(e){return!!n||(e instanceof mn?n=!0:e!==t&&e instanceof Ae||void 0)})),n}),Ge.DEFMETHOD(\"flatten_object\",function(e,n){if(n.option(\"properties\")){var t=this.expression;if(t instanceof an)for(var i=t.properties,r=i.length;0<=--r;){var o=i[r];if(\"\"+o.key==e){if(!oe(i,function(e){return e instanceof un}))break;var a=o.value;if(a instanceof Fe&&!(n.parent()instanceof Je)&&a.contains_this())break;return X(Ze,this,{expression:X(on,t,{elements:i.map(function(e){return e.value})}),property:X(yn,this,{value:r})})}}}}),e(Xe,function(e,n){\"arguments\"!=e.property&&\"caller\"!=e.property||n.warn(\"Function.protoype.{prop} not supported [{file}:{line},{col}]\",{prop:e.property,file:e.start.file,line:e.start.line,col:e.start.col});var t=e.resolve_defines(n);if(t)return t.optimize(n);if(ne(e,n.parent()))return e;if(n.option(\"unsafe_proto\")&&e.expression instanceof Xe&&\"prototype\"==e.expression.property){var i=e.expression.expression;if(H(i))switch(i.name){case\"Array\":e.expression=X(on,e.expression,{elements:[]});break;case\"Function\":e.expression=X(Fe,e.expression,{argnames:[],body:[]});break;case\"Number\":e.expression=X(yn,e.expression,{value:0});break;case\"Object\":e.expression=X(an,e.expression,{properties:[]});break;case\"RegExp\":e.expression=X(wn,e.expression,{value:/t/});break;case\"String\":e.expression=X(bn,e.expression,{value:\"\"})}}var r=e.flatten_object(e.property,n);if(r)return r.optimize(n);var o=e.evaluate(n);return o!==e?I(n,o=q(o,e).optimize(n),e):e}),e(Te,function(e,n){return e.value&&g(e.value,n)&&(e.value=null),e}),e(Ve,function(e,n){var t=n.option(\"global_defs\");return t&&ae(t,e.name.name)&&n.warn(\"global_defs \"+e.name.name+\" redefined [{file}:{line},{col}]\",e.start),e})}(),function(){var n=function(e){for(var n=!0,t=0;t<e.length;t++)n&&e[t]instanceof ue&&e[t].body instanceof bn?e[t]=new fe({start:e[t].start,end:e[t].end,value:e[t].body.value}):!n||e[t]instanceof ue&&e[t].body instanceof bn||(n=!1);return e},i={Program:function(e){return new Ee({start:s(e),end:u(e),body:n(e.body.map(c))})},FunctionDeclaration:function(e){return new Ce({start:s(e),end:u(e),name:c(e.id),argnames:e.params.map(c),body:n(c(e.body).body)})},FunctionExpression:function(e){return new Fe({start:s(e),end:u(e),name:c(e.id),argnames:e.params.map(c),body:n(c(e.body).body)})},ExpressionStatement:function(e){return new le({start:s(e),end:u(e),body:c(e.expression)})},TryStatement:function(e){var n=e.handlers||[e.handler];if(1<n.length||e.guardedHandlers&&e.guardedHandlers.length)throw new Error(\"Multiple catch clauses are not supported.\");return new Re({start:s(e),end:u(e),body:c(e.block).body,bcatch:c(n[0]),bfinally:e.finalizer?new Pe(c(e.finalizer)):null})},Property:function(e){var n=e.key,t={start:s(n),end:u(e.value),key:\"Identifier\"==n.type?n.name:n.value,value:c(e.value)};return\"init\"==e.kind?new un(t):(t.key=new K({name:t.key}),t.value=new De(t.value),\"get\"==e.kind?new Z(t):\"set\"==e.kind?new X(t):void 0)},ArrayExpression:function(e){return new on({start:s(e),end:u(e),elements:e.elements.map(function(e){return null===e?new kn:c(e)})})},ObjectExpression:function(e){return new an({start:s(e),end:u(e),properties:e.properties.map(function(e){return e.type=\"Property\",c(e)})})},SequenceExpression:function(e){return new We({start:s(e),end:u(e),expressions:e.expressions.map(c)})},MemberExpression:function(e){return new(e.computed?Ze:Xe)({start:s(e),end:u(e),property:e.computed?c(e.property):e.property.name,expression:c(e.object)})},SwitchCase:function(e){return new(e.test?He:Ne)({start:s(e),end:u(e),expression:c(e.test),body:e.consequent.map(c)})},VariableDeclaration:function(e){return new Le({start:s(e),end:u(e),definitions:e.declarations.map(c)})},Literal:function(e){var n=e.value,t={start:s(e),end:u(e)};if(null===n)return new xn(t);switch(typeof n){case\"string\":return t.value=n,new bn(t);case\"number\":return t.value=n,new yn(t);case\"boolean\":return new(n?Bn:Cn)(t);default:var i=e.regex;return i&&i.pattern?t.value=new RegExp(i.pattern,i.flags).toString():t.value=e.regex&&e.raw?e.raw:n,new wn(t)}},Identifier:function(e){var n=o[o.length-2];return new(\"LabeledStatement\"==n.type?Q:\"VariableDeclarator\"==n.type&&n.id===e?ln:\"FunctionExpression\"==n.type?n.id===e?hn:pn:\"FunctionDeclaration\"==n.type?n.id===e?dn:pn:\"CatchClause\"==n.type?vn:\"BreakStatement\"==n.type||\"ContinueStatement\"==n.type?ee:_n)({start:s(e),end:u(e),name:e.name})}};function r(e){if(\"Literal\"==e.type)return null!=e.raw?e.raw:e.value+\"\"}function s(e){var n=e.loc,t=n&&n.start,i=e.range;return new F({file:n&&n.source,line:t&&t.line,col:t&&t.column,pos:i?i[0]:e.start,endline:t&&t.line,endcol:t&&t.column,endpos:i?i[0]:e.start,raw:r(e)})}function u(e){var n=e.loc,t=n&&n.end,i=e.range;return new F({file:n&&n.source,line:t&&t.line,col:t&&t.column,pos:i?i[1]:e.end,endline:t&&t.line,endcol:t&&t.column,endpos:i?i[1]:e.end,raw:r(e)})}function e(e,n,t){var o=\"function From_Moz_\"+e+\"(M){\\n\";o+=\"return new U2.\"+n.name+\"({\\nstart: my_start_token(M),\\nend: my_end_token(M)\";var a=\"function To_Moz_\"+e+\"(M){\\n\";a+=\"return {\\ntype: \"+JSON.stringify(e),t&&t.split(/\\s*,\\s*/).forEach(function(e){var n=/([a-z0-9$_]+)(=|@|>|%)([a-z0-9$_]+)/i.exec(e);if(!n)throw new Error(\"Can't understand property map: \"+e);var t=n[1],i=n[2],r=n[3];switch(o+=\",\\n\"+r+\": \",a+=\",\\n\"+t+\": \",i){case\"@\":o+=\"M.\"+t+\".map(from_moz)\",a+=\"M.\"+r+\".map(to_moz)\";break;case\">\":o+=\"from_moz(M.\"+t+\")\",a+=\"to_moz(M.\"+r+\")\";break;case\"=\":o+=\"M.\"+t,a+=\"M.\"+r;break;case\"%\":o+=\"from_moz(M.\"+t+\").body\",a+=\"to_moz_block(M)\";break;default:throw new Error(\"Can't understand operator in propmap: \"+e)}}),o+=\"\\n})\\n}\",a+=\"\\n}\\n}\",o=new Function(\"U2\",\"my_start_token\",\"my_end_token\",\"from_moz\",\"return(\"+o+\")\")(h,s,u,c),a=new Function(\"to_moz\",\"to_moz_block\",\"to_moz_scope\",\"return(\"+a+\")\")(l,p,d),i[e]=o,f(n,a)}i.UpdateExpression=i.UnaryExpression=function(e){return new((\"prefix\"in e?e.prefix:\"UnaryExpression\"==e.type)?Qe:en)({start:s(e),end:u(e),operator:e.operator,expression:c(e.argument)})},e(\"EmptyStatement\",he),e(\"BlockStatement\",de,\"body@body\"),e(\"IfStatement\",Me,\"test>condition, consequent>body, alternate>alternative\"),e(\"LabeledStatement\",ve,\"label>label, body>body\"),e(\"BreakStatement\",$e,\"label>label\"),e(\"ContinueStatement\",ze,\"label>label\"),e(\"WithStatement\",xe,\"object>expression, body>body\"),e(\"SwitchStatement\",qe,\"discriminant>expression, cases@body\"),e(\"ReturnStatement\",Te,\"argument>value\"),e(\"ThrowStatement\",G,\"argument>value\"),e(\"WhileStatement\",be,\"test>condition, body>body\"),e(\"DoWhileStatement\",ge,\"test>condition, body>body\"),e(\"ForStatement\",ye,\"init>init, test>condition, update>step, body>body\"),e(\"ForInStatement\",we,\"left>init, right>object, body>body\"),e(\"DebuggerStatement\",ce),e(\"VariableDeclarator\",Ve,\"id>name, init>value\"),e(\"CatchClause\",Ie,\"param>argname, body%body\"),e(\"ThisExpression\",mn),e(\"BinaryExpression\",nn,\"operator=operator, left>left, right>right\"),e(\"LogicalExpression\",nn,\"operator=operator, left>left, right>right\"),e(\"AssignmentExpression\",rn,\"operator=operator, left>left, right>right\"),e(\"ConditionalExpression\",tn,\"test>condition, consequent>consequent, alternate>alternative\"),e(\"NewExpression\",Je,\"callee>expression, arguments@args\"),e(\"CallExpression\",Ye,\"callee>expression, arguments@args\"),f(Ee,function(e){return d(\"Program\",e)}),f(Ce,function(e){return{type:\"FunctionDeclaration\",id:l(e.name),params:e.argnames.map(l),body:d(\"BlockStatement\",e)}}),f(Fe,function(e){return{type:\"FunctionExpression\",id:l(e.name),params:e.argnames.map(l),body:d(\"BlockStatement\",e)}}),f(fe,function(e){return{type:\"ExpressionStatement\",expression:{type:\"Literal\",value:e.value}}}),f(le,function(e){return{type:\"ExpressionStatement\",expression:l(e.body)}}),f(je,function(e){return{type:\"SwitchCase\",test:l(e.expression),consequent:e.body.map(l)}}),f(Re,function(e){return{type:\"TryStatement\",block:p(e),handler:l(e.bcatch),guardedHandlers:[],finalizer:l(e.bfinally)}}),f(Ie,function(e){return{type:\"CatchClause\",param:l(e.argname),guard:null,body:p(e)}}),f(Ue,function(e){return{type:\"VariableDeclaration\",kind:\"var\",declarations:e.definitions.map(l)}}),f(We,function(e){return{type:\"SequenceExpression\",expressions:e.expressions.map(l)}}),f(Ge,function(e){var n=e instanceof Ze;return{type:\"MemberExpression\",object:l(e.expression),computed:n,property:n?l(e.property):{type:\"Identifier\",name:e.property}}}),f(Ke,function(e){return{type:\"++\"==e.operator||\"--\"==e.operator?\"UpdateExpression\":\"UnaryExpression\",operator:e.operator,prefix:e instanceof Qe,argument:l(e.expression)}}),f(nn,function(e){return{type:\"&&\"==e.operator||\"||\"==e.operator?\"LogicalExpression\":\"BinaryExpression\",left:l(e.left),operator:e.operator,right:l(e.right)}}),f(on,function(e){return{type:\"ArrayExpression\",elements:e.elements.map(l)}}),f(an,function(e){return{type:\"ObjectExpression\",properties:e.properties.map(l)}}),f(sn,function(e){var n,t={type:\"Literal\",value:e.key instanceof K?e.key.name:e.key};return e instanceof un?n=\"init\":e instanceof Z?n=\"get\":e instanceof X&&(n=\"set\"),{type:\"Property\",kind:n,key:t,value:l(e.value)}}),f(cn,function(e){var n=e.definition();return{type:\"Identifier\",name:n?n.mangled_name||n.name:e.name}}),f(wn,function(e){var n=e.value;return{type:\"Literal\",value:n,raw:n.toString(),regex:{pattern:n.source,flags:n.toString().match(/[gimuy]*$/)[0]}}}),f(gn,function(e){var n=e.value;return\"number\"==typeof n&&(n<0||0===n&&1/n<0)?{type:\"UnaryExpression\",operator:\"-\",prefix:!0,argument:{type:\"Literal\",value:-n,raw:e.start.raw}}:{type:\"Literal\",value:n,raw:e.start.raw}}),f(a,function(e){return{type:\"Identifier\",name:String(e.value)}}),Fn.DEFMETHOD(\"to_mozilla_ast\",gn.prototype.to_mozilla_ast),xn.DEFMETHOD(\"to_mozilla_ast\",gn.prototype.to_mozilla_ast),kn.DEFMETHOD(\"to_mozilla_ast\",function(){return null}),pe.DEFMETHOD(\"to_mozilla_ast\",de.prototype.to_mozilla_ast),ke.DEFMETHOD(\"to_mozilla_ast\",Fe.prototype.to_mozilla_ast);var o=null;function c(e){o.push(e);var n=null!=e?i[e.type](e):null;return o.pop(),n}function f(e,r){e.DEFMETHOD(\"to_mozilla_ast\",function(){return n=r(e=this),t=e.start,i=e.end,null!=t.pos&&null!=i.endpos&&(n.range=[t.pos,i.endpos]),t.line&&(n.loc={start:{line:t.line,column:t.col},end:i.endline?{line:i.endline,column:i.endcol}:null},t.file&&(n.loc.source=t.file)),n;var e,n,t,i})}function l(e){return null!=e?e.to_mozilla_ast():null}function p(e){return{type:\"BlockStatement\",body:e.body.map(l)}}function d(e,n){var t=n.body.map(l);return n.body[0]instanceof le&&n.body[0].body instanceof bn&&t.unshift(l(new he(n.body[0]))),{type:e,body:t}}se.from_mozilla_ast=function(e){var n=o;o=[];var t=c(e);return o=n,t}}();var y=\"undefined\"==typeof atob?function(e){return new Buffer(e,\"base64\").toString()}:atob,w=\"undefined\"==typeof btoa?function(e){return new Buffer(e).toString(\"base64\")}:btoa;function x(n,t,e){t[n]&&e.forEach(function(e){t[e]&&(\"object\"!=typeof t[e]&&(t[e]={}),n in t[e]||(t[e][n]=t[n]))})}function A(e){e&&(\"props\"in e?e.props instanceof O||(e.props=O.fromObject(e.props)):e.props=new O)}function E(e){return{props:e.props.toObject()}}h.Dictionary=O,h.TreeWalker=Sn,h.TreeTransformer=Xn,h.minify=function(e,n){var t,i,r=se.warn_function;try{var o,a=(n=Y(n,{compress:{},ie8:!1,keep_fnames:!1,mangle:{},nameCache:null,output:{},parse:{},rename:void 0,sourceMap:!1,timings:!1,toplevel:!1,warnings:!1,wrap:!1},!0)).timings&&{start:Date.now()};void 0===n.rename&&(n.rename=n.compress&&n.mangle),x(\"ie8\",n,[\"compress\",\"mangle\",\"output\"]),x(\"keep_fnames\",n,[\"compress\",\"mangle\"]),x(\"toplevel\",n,[\"compress\",\"mangle\"]),x(\"warnings\",n,[\"compress\"]),n.mangle&&(n.mangle=Y(n.mangle,{cache:n.nameCache&&(n.nameCache.vars||{}),eval:!1,ie8:!1,keep_fnames:!1,properties:!1,reserved:[],toplevel:!1},!0),n.mangle.properties&&(\"object\"!=typeof n.mangle.properties&&(n.mangle.properties={}),n.mangle.properties.keep_quoted&&(o=n.mangle.properties.reserved,Array.isArray(o)||(o=[]),n.mangle.properties.reserved=o),!n.nameCache||\"cache\"in n.mangle.properties||(n.mangle.properties.cache=n.nameCache.props||{})),A(n.mangle.cache),A(n.mangle.properties.cache)),n.sourceMap&&(n.sourceMap=Y(n.sourceMap,{content:null,filename:null,includeSources:!1,root:null,url:null},!0));var s,u=[];if(n.warnings&&!se.warn_function&&(se.warn_function=function(e){u.push(e)}),a&&(a.parse=Date.now()),e instanceof Ee)s=e;else{for(var c in\"string\"==typeof e&&(e=[e]),n.parse=n.parse||{},n.parse.toplevel=null,e)if(ae(e,c)&&(n.parse.filename=c,n.parse.toplevel=Gn(e[c],n.parse),n.sourceMap&&\"inline\"==n.sourceMap.content)){if(1<Object.keys(e).length)throw new Error(\"inline source map only works with singular input\");n.sourceMap.content=(t=e[c],(i=/\\n\\/\\/# sourceMappingURL=data:application\\/json(;.*?)?;base64,(.*)/.exec(t))?y(i[2]):(se.warn(\"inline source map not found\"),null))}s=n.parse.toplevel}o&&function(e,n){function t(e){v(n,e)}e.walk(new Sn(function(e){e instanceof un&&e.quote?t(e.key):e instanceof Ze&&b(e.property,t)}))}(s,o),n.wrap&&(s=s.wrap_commonjs(n.wrap)),a&&(a.rename=Date.now()),n.rename&&(s.figure_out_scope(n.mangle),s.expand_names(n.mangle)),a&&(a.compress=Date.now()),n.compress&&(s=new et(n.compress).compress(s)),a&&(a.scope=Date.now()),n.mangle&&s.figure_out_scope(n.mangle),a&&(a.mangle=Date.now()),n.mangle&&(s.compute_char_frequency(n.mangle),s.mangle_names(n.mangle)),a&&(a.properties=Date.now()),n.mangle&&n.mangle.properties&&(s=d(s,n.mangle.properties)),a&&(a.output=Date.now());var f={};if(n.output.ast&&(f.ast=s),!ae(n.output,\"code\")||n.output.code){if(n.sourceMap&&(\"string\"==typeof n.sourceMap.content&&(n.sourceMap.content=JSON.parse(n.sourceMap.content)),n.output.source_map=function(s){s=Y(s,{file:null,root:null,orig:null,orig_line_diff:0,dest_line_diff:0});var u=new MOZ_SourceMap.SourceMapGenerator({file:s.file,sourceRoot:s.root}),c=s.orig&&new MOZ_SourceMap.SourceMapConsumer(s.orig);return c&&Array.isArray(s.orig.sources)&&c._sources.toArray().forEach(function(e){var n=c.sourceContentFor(e,!0);n&&u.setSourceContent(e,n)}),{add:function(e,n,t,i,r,o){if(c){var a=c.originalPositionFor({line:i,column:r});if(null===a.source)return;e=a.source,i=a.line,r=a.column,o=a.name||o}u.addMapping({generated:{line:n+s.dest_line_diff,column:t},original:{line:i+s.orig_line_diff,column:r},source:e,name:o})},get:function(){return u},toString:function(){return JSON.stringify(u.toJSON())}}}({file:n.sourceMap.filename,orig:n.sourceMap.content,root:n.sourceMap.root}),n.sourceMap.includeSources)){if(e instanceof Ee)throw new Error(\"original source content unavailable\");for(var c in e)ae(e,c)&&n.output.source_map.get().setSourceContent(c,e[c])}delete n.output.ast,delete n.output.code;var l=Qn(n.output);s.print(l),f.code=l.get(),n.sourceMap&&(f.map=n.output.source_map.toString(),\"inline\"==n.sourceMap.url?f.code+=\"\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,\"+w(f.map):n.sourceMap.url&&(f.code+=\"\\n//# sourceMappingURL=\"+n.sourceMap.url))}return n.nameCache&&n.mangle&&(n.mangle.cache&&(n.nameCache.vars=E(n.mangle.cache)),n.mangle.properties&&n.mangle.properties.cache&&(n.nameCache.props=E(n.mangle.properties.cache))),a&&(a.end=Date.now(),f.timings={parse:.001*(a.rename-a.parse),rename:.001*(a.compress-a.rename),compress:.001*(a.scope-a.compress),scope:.001*(a.mangle-a.scope),mangle:.001*(a.properties-a.mangle),properties:.001*(a.output-a.properties),output:.001*(a.end-a.output),total:.001*(a.end-a.start)}),u.length&&(f.warnings=u),f}catch(e){return{error:e}}finally{se.warn_function=r}},h.parse=Gn,h._push_uniq=v}(\"undefined\"==typeof UglifyJS?UglifyJS={}:UglifyJS);module.exports = global.UglifyJS\ndelete global.UglifyJS\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./../buffer/index.js */ 6).Buffer, __webpack_require__(/*! ./../webpack/buildin/global.js */ 1)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdWdsaWZ5anMtYnJvd3Nlci9idWlsZC5qcz8yYjE3Il0sInNvdXJjZXNDb250ZW50IjpbIiFmdW5jdGlvbihoKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBlKGUpe3JldHVybiBlLnNwbGl0KFwiXCIpfWZ1bmN0aW9uIHRlKGUsbil7cmV0dXJuIDA8PW4uaW5kZXhPZihlKX1mdW5jdGlvbiBWKGUsbil7Zm9yKHZhciB0PTAsaT1uLmxlbmd0aDt0PGk7Kyt0KWlmKGUoblt0XSkpcmV0dXJuIG5bdF19ZnVuY3Rpb24gbihlKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZS5wcm90b3R5cGUsXCJzdGFja1wiLHtnZXQ6ZnVuY3Rpb24oKXt2YXIgZT1uZXcgRXJyb3IodGhpcy5tZXNzYWdlKTtlLm5hbWU9dGhpcy5uYW1lO3RyeXt0aHJvdyBlfWNhdGNoKGUpe3JldHVybiBlLnN0YWNrfX19KX1mdW5jdGlvbiBvKGUsbil7dGhpcy5tZXNzYWdlPWUsdGhpcy5kZWZzPW59ZnVuY3Rpb24gWShlLG4sdCl7ITA9PT1lJiYoZT17fSk7dmFyIGk9ZXx8e307aWYodClmb3IodmFyIHIgaW4gaSlhZShpLHIpJiYhYWUobixyKSYmby5jcm9hayhcImBcIityK1wiYCBpcyBub3QgYSBzdXBwb3J0ZWQgb3B0aW9uXCIsbik7Zm9yKHZhciByIGluIG4pYWUobixyKSYmKGlbcl09ZSYmYWUoZSxyKT9lW3JdOm5bcl0pO3JldHVybiBpfWZ1bmN0aW9uIHQoZSxuKXt2YXIgdD0wO2Zvcih2YXIgaSBpbiBuKWFlKG4saSkmJihlW2ldPW5baV0sdCsrKTtyZXR1cm4gdH1mdW5jdGlvbiBMKCl7fWZ1bmN0aW9uIGllKCl7cmV0dXJuITF9ZnVuY3Rpb24gSigpe3JldHVybiEwfWZ1bmN0aW9uIEMoKXtyZXR1cm4gdGhpc31mdW5jdGlvbiBCKCl7cmV0dXJuIG51bGx9KChvLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yPW8pLnByb3RvdHlwZS5uYW1lPVwiRGVmYXVsdHNFcnJvclwiLG4obyksby5jcm9haz1mdW5jdGlvbihlLG4pe3Rocm93IG5ldyBvKGUsbil9O3ZhciByZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUodCxpLHIpe3ZhciBvLGE9W10scz1bXTtmdW5jdGlvbiBlKCl7dmFyIGU9aSh0W29dLG8pLG49ZSBpbnN0YW5jZW9mIGw7cmV0dXJuIG4mJihlPWUudiksZSBpbnN0YW5jZW9mIGM/KGU9ZS52KWluc3RhbmNlb2YgZj9zLnB1c2guYXBwbHkocyxyP2Uudi5zbGljZSgpLnJldmVyc2UoKTplLnYpOnMucHVzaChlKTplIT09dSYmKGUgaW5zdGFuY2VvZiBmP2EucHVzaC5hcHBseShhLHI/ZS52LnNsaWNlKCkucmV2ZXJzZSgpOmUudik6YS5wdXNoKGUpKSxufWlmKHQgaW5zdGFuY2VvZiBBcnJheSlpZihyKXtmb3Iobz10Lmxlbmd0aDswPD0tLW8mJiFlKCk7KTthLnJldmVyc2UoKSxzLnJldmVyc2UoKX1lbHNlIGZvcihvPTA7bzx0Lmxlbmd0aCYmIWUoKTsrK28pO2Vsc2UgZm9yKG8gaW4gdClpZihhZSh0LG8pJiZlKCkpYnJlYWs7cmV0dXJuIHMuY29uY2F0KGEpfWUuYXRfdG9wPWZ1bmN0aW9uKGUpe3JldHVybiBuZXcgYyhlKX0sZS5zcGxpY2U9ZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyBmKGUpfSxlLmxhc3Q9ZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyBsKGUpfTt2YXIgdT1lLnNraXA9e307ZnVuY3Rpb24gYyhlKXt0aGlzLnY9ZX1mdW5jdGlvbiBmKGUpe3RoaXMudj1lfWZ1bmN0aW9uIGwoZSl7dGhpcy52PWV9cmV0dXJuIGV9KCk7ZnVuY3Rpb24gdihlLG4pe2UuaW5kZXhPZihuKTwwJiZlLnB1c2gobil9ZnVuY3Rpb24gUyhlLHQpe3JldHVybiBlLnJlcGxhY2UoL1xceyguKz8pXFx9L2csZnVuY3Rpb24oZSxuKXtyZXR1cm4gdCYmdFtuXX0pfWZ1bmN0aW9uIFQoZSxuKXtmb3IodmFyIHQ9ZS5sZW5ndGg7MDw9LS10OyllW3RdPT09biYmZS5zcGxpY2UodCwxKX1mdW5jdGlvbiBzKGUsYSl7aWYoZS5sZW5ndGg8MilyZXR1cm4gZS5zbGljZSgpO3JldHVybiBmdW5jdGlvbiBlKG4pe2lmKG4ubGVuZ3RoPD0xKXJldHVybiBuO3ZhciB0PU1hdGguZmxvb3Iobi5sZW5ndGgvMiksaT1uLnNsaWNlKDAsdCkscj1uLnNsaWNlKHQpO3JldHVybiBmdW5jdGlvbihlLG4pe2Zvcih2YXIgdD1bXSxpPTAscj0wLG89MDtpPGUubGVuZ3RoJiZyPG4ubGVuZ3RoOylhKGVbaV0sbltyXSk8PTA/dFtvKytdPWVbaSsrXTp0W28rK109bltyKytdO3JldHVybiBpPGUubGVuZ3RoJiZ0LnB1c2guYXBwbHkodCxlLnNsaWNlKGkpKSxyPG4ubGVuZ3RoJiZ0LnB1c2guYXBwbHkodCxuLnNsaWNlKHIpKSx0fShpPWUoaSkscj1lKHIpKX0oZSl9ZnVuY3Rpb24gVyhlKXtlIGluc3RhbmNlb2YgQXJyYXl8fChlPWUuc3BsaXQoXCIgXCIpKTt2YXIgdD1cIlwiLG49W107ZTpmb3IodmFyIGk9MDtpPGUubGVuZ3RoOysraSl7Zm9yKHZhciByPTA7cjxuLmxlbmd0aDsrK3IpaWYobltyXVswXS5sZW5ndGg9PWVbaV0ubGVuZ3RoKXtuW3JdLnB1c2goZVtpXSk7Y29udGludWUgZX1uLnB1c2goW2VbaV1dKX1mdW5jdGlvbiBvKGUpe3JldHVybiBKU09OLnN0cmluZ2lmeShlKS5yZXBsYWNlKC9bXFx1MjAyOFxcdTIwMjldL2csZnVuY3Rpb24oZSl7c3dpdGNoKGUpe2Nhc2VcIlxcdTIwMjhcIjpyZXR1cm5cIlxcXFx1MjAyOFwiO2Nhc2VcIlxcdTIwMjlcIjpyZXR1cm5cIlxcXFx1MjAyOVwifXJldHVybiBlfSl9ZnVuY3Rpb24gYShlKXtpZigxPT1lLmxlbmd0aClyZXR1cm4gdCs9XCJyZXR1cm4gc3RyID09PSBcIitvKGVbMF0pK1wiO1wiO3QrPVwic3dpdGNoKHN0cil7XCI7Zm9yKHZhciBuPTA7bjxlLmxlbmd0aDsrK24pdCs9XCJjYXNlIFwiK28oZVtuXSkrXCI6XCI7dCs9XCJyZXR1cm4gdHJ1ZX1yZXR1cm4gZmFsc2U7XCJ9aWYoMzxuLmxlbmd0aCl7bi5zb3J0KGZ1bmN0aW9uKGUsbil7cmV0dXJuIG4ubGVuZ3RoLWUubGVuZ3RofSksdCs9XCJzd2l0Y2goc3RyLmxlbmd0aCl7XCI7Zm9yKGk9MDtpPG4ubGVuZ3RoOysraSl7dmFyIHM9bltpXTt0Kz1cImNhc2UgXCIrc1swXS5sZW5ndGgrXCI6XCIsYShzKX10Kz1cIn1cIn1lbHNlIGEoZSk7cmV0dXJuIG5ldyBGdW5jdGlvbihcInN0clwiLHQpfWZ1bmN0aW9uIG9lKGUsbil7Zm9yKHZhciB0PWUubGVuZ3RoOzA8PS0tdDspaWYoIW4oZVt0XSkpcmV0dXJuITE7cmV0dXJuITB9ZnVuY3Rpb24gTygpe3RoaXMuX3ZhbHVlcz1PYmplY3QuY3JlYXRlKG51bGwpLHRoaXMuX3NpemU9MH1mdW5jdGlvbiBhZShlLG4pe3JldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxuKX1mdW5jdGlvbiAkKGUpe2Zvcih2YXIgbix0PWUucGFyZW50KC0xKSxpPTA7bj1lLnBhcmVudChpKTtpKyspe2lmKG4gaW5zdGFuY2VvZiB1ZSYmbi5ib2R5PT09dClyZXR1cm4hMDtpZighKG4gaW5zdGFuY2VvZiBXZSYmbi5leHByZXNzaW9uc1swXT09PXR8fFwiQ2FsbFwiPT1uLlRZUEUmJm4uZXhwcmVzc2lvbj09PXR8fG4gaW5zdGFuY2VvZiBYZSYmbi5leHByZXNzaW9uPT09dHx8biBpbnN0YW5jZW9mIFplJiZuLmV4cHJlc3Npb249PT10fHxuIGluc3RhbmNlb2YgdG4mJm4uY29uZGl0aW9uPT09dHx8biBpbnN0YW5jZW9mIG5uJiZuLmxlZnQ9PT10fHxuIGluc3RhbmNlb2YgZW4mJm4uZXhwcmVzc2lvbj09PXQpKXJldHVybiExO3Q9bn19ZnVuY3Rpb24gaShlLG4sdCxpKXthcmd1bWVudHMubGVuZ3RoPDQmJihpPXNlKTt2YXIgcj1uPW4/bi5zcGxpdCgvXFxzKy8pOltdO2kmJmkuUFJPUFMmJihuPW4uY29uY2F0KGkuUFJPUFMpKTtmb3IodmFyIG89XCJyZXR1cm4gZnVuY3Rpb24gQVNUX1wiK2UrXCIocHJvcHMpeyBpZiAocHJvcHMpIHsgXCIsYT1uLmxlbmd0aDswPD0tLWE7KW8rPVwidGhpcy5cIituW2FdK1wiID0gcHJvcHMuXCIrblthXStcIjtcIjt2YXIgcz1pJiZuZXcgaTsocyYmcy5pbml0aWFsaXplfHx0JiZ0LmluaXRpYWxpemUpJiYobys9XCJ0aGlzLmluaXRpYWxpemUoKTtcIiksbys9XCJ9fVwiO3ZhciB1PW5ldyBGdW5jdGlvbihvKSgpO2lmKHMmJih1LnByb3RvdHlwZT1zLHUuQkFTRT1pKSxpJiZpLlNVQkNMQVNTRVMucHVzaCh1KSwodS5wcm90b3R5cGUuQ1RPUj11KS5QUk9QUz1ufHxudWxsLHUuU0VMRl9QUk9QUz1yLHUuU1VCQ0xBU1NFUz1bXSxlJiYodS5wcm90b3R5cGUuVFlQRT11LlRZUEU9ZSksdClmb3IoYSBpbiB0KWFlKHQsYSkmJigvXlxcJC8udGVzdChhKT91W2Euc3Vic3RyKDEpXT10W2FdOnUucHJvdG90eXBlW2FdPXRbYV0pO3JldHVybiB1LkRFRk1FVEhPRD1mdW5jdGlvbihlLG4pe3RoaXMucHJvdG90eXBlW2VdPW59LHZvaWQgMCE9PWgmJihoW1wiQVNUX1wiK2VdPXUpLHV9Ty5wcm90b3R5cGU9e3NldDpmdW5jdGlvbihlLG4pe3JldHVybiB0aGlzLmhhcyhlKXx8Kyt0aGlzLl9zaXplLHRoaXMuX3ZhbHVlc1tcIiRcIitlXT1uLHRoaXN9LGFkZDpmdW5jdGlvbihlLG4pe3JldHVybiB0aGlzLmhhcyhlKT90aGlzLmdldChlKS5wdXNoKG4pOnRoaXMuc2V0KGUsW25dKSx0aGlzfSxnZXQ6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuX3ZhbHVlc1tcIiRcIitlXX0sZGVsOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmhhcyhlKSYmKC0tdGhpcy5fc2l6ZSxkZWxldGUgdGhpcy5fdmFsdWVzW1wiJFwiK2VdKSx0aGlzfSxoYXM6ZnVuY3Rpb24oZSl7cmV0dXJuXCIkXCIrZSBpbiB0aGlzLl92YWx1ZXN9LGVhY2g6ZnVuY3Rpb24oZSl7Zm9yKHZhciBuIGluIHRoaXMuX3ZhbHVlcyllKHRoaXMuX3ZhbHVlc1tuXSxuLnN1YnN0cigxKSl9LHNpemU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fc2l6ZX0sbWFwOmZ1bmN0aW9uKGUpe3ZhciBuPVtdO2Zvcih2YXIgdCBpbiB0aGlzLl92YWx1ZXMpbi5wdXNoKGUodGhpcy5fdmFsdWVzW3RdLHQuc3Vic3RyKDEpKSk7cmV0dXJuIG59LGNsb25lOmZ1bmN0aW9uKCl7dmFyIGU9bmV3IE87Zm9yKHZhciBuIGluIHRoaXMuX3ZhbHVlcyllLl92YWx1ZXNbbl09dGhpcy5fdmFsdWVzW25dO3JldHVybiBlLl9zaXplPXRoaXMuX3NpemUsZX0sdG9PYmplY3Q6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fdmFsdWVzfX0sTy5mcm9tT2JqZWN0PWZ1bmN0aW9uKGUpe3ZhciBuPW5ldyBPO3JldHVybiBuLl9zaXplPXQobi5fdmFsdWVzLGUpLG59O3ZhciBGPWkoXCJUb2tlblwiLFwidHlwZSB2YWx1ZSBsaW5lIGNvbCBwb3MgZW5kbGluZSBlbmRjb2wgZW5kcG9zIG5sYiBjb21tZW50c19iZWZvcmUgY29tbWVudHNfYWZ0ZXIgZmlsZSByYXdcIix7fSxudWxsKSxzZT1pKFwiTm9kZVwiLFwic3RhcnQgZW5kXCIse19jbG9uZTpmdW5jdGlvbihlKXtpZihlKXt2YXIgbj10aGlzLmNsb25lKCk7cmV0dXJuIG4udHJhbnNmb3JtKG5ldyBYbihmdW5jdGlvbihlKXtpZihlIT09bilyZXR1cm4gZS5jbG9uZSghMCl9KSl9cmV0dXJuIG5ldyB0aGlzLkNUT1IodGhpcyl9LGNsb25lOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLl9jbG9uZShlKX0sJGRvY3VtZW50YXRpb246XCJCYXNlIGNsYXNzIG9mIGFsbCBBU1Qgbm9kZXNcIiwkcHJvcGRvYzp7c3RhcnQ6XCJbQVNUX1Rva2VuXSBUaGUgZmlyc3QgdG9rZW4gb2YgdGhpcyBub2RlXCIsZW5kOlwiW0FTVF9Ub2tlbl0gVGhlIGxhc3QgdG9rZW4gb2YgdGhpcyBub2RlXCJ9LF93YWxrOmZ1bmN0aW9uKGUpe3JldHVybiBlLl92aXNpdCh0aGlzKX0sd2FsazpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5fd2FsayhlKX19LG51bGwpO3NlLndhcm5fZnVuY3Rpb249bnVsbCxzZS53YXJuPWZ1bmN0aW9uKGUsbil7c2Uud2Fybl9mdW5jdGlvbiYmc2Uud2Fybl9mdW5jdGlvbihTKGUsbikpfTt2YXIgdWU9aShcIlN0YXRlbWVudFwiLG51bGwseyRkb2N1bWVudGF0aW9uOlwiQmFzZSBjbGFzcyBvZiBhbGwgc3RhdGVtZW50c1wifSksY2U9aShcIkRlYnVnZ2VyXCIsbnVsbCx7JGRvY3VtZW50YXRpb246XCJSZXByZXNlbnRzIGEgZGVidWdnZXIgc3RhdGVtZW50XCJ9LHVlKSxmZT1pKFwiRGlyZWN0aXZlXCIsXCJ2YWx1ZSBxdW90ZVwiLHskZG9jdW1lbnRhdGlvbjonUmVwcmVzZW50cyBhIGRpcmVjdGl2ZSwgbGlrZSBcInVzZSBzdHJpY3RcIjsnLCRwcm9wZG9jOnt2YWx1ZTpcIltzdHJpbmddIFRoZSB2YWx1ZSBvZiB0aGlzIGRpcmVjdGl2ZSBhcyBhIHBsYWluIHN0cmluZyAoaXQncyBub3QgYW4gQVNUX1N0cmluZyEpXCIscXVvdGU6XCJbc3RyaW5nXSB0aGUgb3JpZ2luYWwgcXVvdGUgY2hhcmFjdGVyXCJ9fSx1ZSksbGU9aShcIlNpbXBsZVN0YXRlbWVudFwiLFwiYm9keVwiLHskZG9jdW1lbnRhdGlvbjpcIkEgc3RhdGVtZW50IGNvbnNpc3Rpbmcgb2YgYW4gZXhwcmVzc2lvbiwgaS5lLiBhID0gMSArIDJcIiwkcHJvcGRvYzp7Ym9keTpcIltBU1RfTm9kZV0gYW4gZXhwcmVzc2lvbiBub2RlIChzaG91bGQgbm90IGJlIGluc3RhbmNlb2YgQVNUX1N0YXRlbWVudClcIn0sX3dhbGs6ZnVuY3Rpb24oZSl7cmV0dXJuIGUuX3Zpc2l0KHRoaXMsZnVuY3Rpb24oKXt0aGlzLmJvZHkuX3dhbGsoZSl9KX19LHVlKTtmdW5jdGlvbiB6KGUsbil7dmFyIHQ9ZS5ib2R5O2lmKHQgaW5zdGFuY2VvZiB1ZSl0Ll93YWxrKG4pO2Vsc2UgZm9yKHZhciBpPTAscj10Lmxlbmd0aDtpPHI7aSsrKXRbaV0uX3dhbGsobil9dmFyIHBlPWkoXCJCbG9ja1wiLFwiYm9keVwiLHskZG9jdW1lbnRhdGlvbjpcIkEgYm9keSBvZiBzdGF0ZW1lbnRzICh1c3VhbGx5IGJyYWNlZClcIiwkcHJvcGRvYzp7Ym9keTpcIltBU1RfU3RhdGVtZW50Kl0gYW4gYXJyYXkgb2Ygc3RhdGVtZW50c1wifSxfd2FsazpmdW5jdGlvbihlKXtyZXR1cm4gZS5fdmlzaXQodGhpcyxmdW5jdGlvbigpe3oodGhpcyxlKX0pfX0sdWUpLGRlPWkoXCJCbG9ja1N0YXRlbWVudFwiLG51bGwseyRkb2N1bWVudGF0aW9uOlwiQSBibG9jayBzdGF0ZW1lbnRcIn0scGUpLGhlPWkoXCJFbXB0eVN0YXRlbWVudFwiLG51bGwseyRkb2N1bWVudGF0aW9uOlwiVGhlIGVtcHR5IHN0YXRlbWVudCAoZW1wdHkgYmxvY2sgb3Igc2ltcGx5IGEgc2VtaWNvbG9uKVwifSx1ZSksXz1pKFwiU3RhdGVtZW50V2l0aEJvZHlcIixcImJvZHlcIix7JGRvY3VtZW50YXRpb246XCJCYXNlIGNsYXNzIGZvciBhbGwgc3RhdGVtZW50cyB0aGF0IGNvbnRhaW4gb25lIG5lc3RlZCBib2R5OiBgRm9yYCwgYEZvckluYCwgYERvYCwgYFdoaWxlYCwgYFdpdGhgXCIsJHByb3Bkb2M6e2JvZHk6XCJbQVNUX1N0YXRlbWVudF0gdGhlIGJvZHk7IHRoaXMgc2hvdWxkIGFsd2F5cyBiZSBwcmVzZW50LCBldmVuIGlmIGl0J3MgYW4gQVNUX0VtcHR5U3RhdGVtZW50XCJ9fSx1ZSksdmU9aShcIkxhYmVsZWRTdGF0ZW1lbnRcIixcImxhYmVsXCIseyRkb2N1bWVudGF0aW9uOlwiU3RhdGVtZW50IHdpdGggYSBsYWJlbFwiLCRwcm9wZG9jOntsYWJlbDpcIltBU1RfTGFiZWxdIGEgbGFiZWwgZGVmaW5pdGlvblwifSxfd2FsazpmdW5jdGlvbihlKXtyZXR1cm4gZS5fdmlzaXQodGhpcyxmdW5jdGlvbigpe3RoaXMubGFiZWwuX3dhbGsoZSksdGhpcy5ib2R5Ll93YWxrKGUpfSl9LGNsb25lOmZ1bmN0aW9uKGUpe3ZhciBuPXRoaXMuX2Nsb25lKGUpO2lmKGUpe3ZhciB0PW4ubGFiZWwsaT10aGlzLmxhYmVsO24ud2FsayhuZXcgU24oZnVuY3Rpb24oZSl7ZSBpbnN0YW5jZW9mIE9lJiZlLmxhYmVsJiZlLmxhYmVsLnRoZWRlZj09PWkmJihlLmxhYmVsLnRoZWRlZj10KS5yZWZlcmVuY2VzLnB1c2goZSl9KSl9cmV0dXJuIG59fSxfKSxfZT1pKFwiSXRlcmF0aW9uU3RhdGVtZW50XCIsbnVsbCx7JGRvY3VtZW50YXRpb246XCJJbnRlcm5hbCBjbGFzcy4gIEFsbCBsb29wcyBpbmhlcml0IGZyb20gaXQuXCJ9LF8pLG1lPWkoXCJEV0xvb3BcIixcImNvbmRpdGlvblwiLHskZG9jdW1lbnRhdGlvbjpcIkJhc2UgY2xhc3MgZm9yIGRvL3doaWxlIHN0YXRlbWVudHNcIiwkcHJvcGRvYzp7Y29uZGl0aW9uOlwiW0FTVF9Ob2RlXSB0aGUgbG9vcCBjb25kaXRpb24uICBTaG91bGQgbm90IGJlIGluc3RhbmNlb2YgQVNUX1N0YXRlbWVudFwifX0sX2UpLGdlPWkoXCJEb1wiLG51bGwseyRkb2N1bWVudGF0aW9uOlwiQSBgZG9gIHN0YXRlbWVudFwiLF93YWxrOmZ1bmN0aW9uKGUpe3JldHVybiBlLl92aXNpdCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5ib2R5Ll93YWxrKGUpLHRoaXMuY29uZGl0aW9uLl93YWxrKGUpfSl9fSxtZSksYmU9aShcIldoaWxlXCIsbnVsbCx7JGRvY3VtZW50YXRpb246XCJBIGB3aGlsZWAgc3RhdGVtZW50XCIsX3dhbGs6ZnVuY3Rpb24oZSl7cmV0dXJuIGUuX3Zpc2l0KHRoaXMsZnVuY3Rpb24oKXt0aGlzLmNvbmRpdGlvbi5fd2FsayhlKSx0aGlzLmJvZHkuX3dhbGsoZSl9KX19LG1lKSx5ZT1pKFwiRm9yXCIsXCJpbml0IGNvbmRpdGlvbiBzdGVwXCIseyRkb2N1bWVudGF0aW9uOlwiQSBgZm9yYCBzdGF0ZW1lbnRcIiwkcHJvcGRvYzp7aW5pdDpcIltBU1RfTm9kZT9dIHRoZSBgZm9yYCBpbml0aWFsaXphdGlvbiBjb2RlLCBvciBudWxsIGlmIGVtcHR5XCIsY29uZGl0aW9uOlwiW0FTVF9Ob2RlP10gdGhlIGBmb3JgIHRlcm1pbmF0aW9uIGNsYXVzZSwgb3IgbnVsbCBpZiBlbXB0eVwiLHN0ZXA6XCJbQVNUX05vZGU/XSB0aGUgYGZvcmAgdXBkYXRlIGNsYXVzZSwgb3IgbnVsbCBpZiBlbXB0eVwifSxfd2FsazpmdW5jdGlvbihlKXtyZXR1cm4gZS5fdmlzaXQodGhpcyxmdW5jdGlvbigpe3RoaXMuaW5pdCYmdGhpcy5pbml0Ll93YWxrKGUpLHRoaXMuY29uZGl0aW9uJiZ0aGlzLmNvbmRpdGlvbi5fd2FsayhlKSx0aGlzLnN0ZXAmJnRoaXMuc3RlcC5fd2FsayhlKSx0aGlzLmJvZHkuX3dhbGsoZSl9KX19LF9lKSx3ZT1pKFwiRm9ySW5cIixcImluaXQgb2JqZWN0XCIseyRkb2N1bWVudGF0aW9uOlwiQSBgZm9yIC4uLiBpbmAgc3RhdGVtZW50XCIsJHByb3Bkb2M6e2luaXQ6XCJbQVNUX05vZGVdIHRoZSBgZm9yL2luYCBpbml0aWFsaXphdGlvbiBjb2RlXCIsb2JqZWN0OlwiW0FTVF9Ob2RlXSB0aGUgb2JqZWN0IHRoYXQgd2UncmUgbG9vcGluZyB0aHJvdWdoXCJ9LF93YWxrOmZ1bmN0aW9uKGUpe3JldHVybiBlLl92aXNpdCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5pbml0Ll93YWxrKGUpLHRoaXMub2JqZWN0Ll93YWxrKGUpLHRoaXMuYm9keS5fd2FsayhlKX0pfX0sX2UpLHhlPWkoXCJXaXRoXCIsXCJleHByZXNzaW9uXCIseyRkb2N1bWVudGF0aW9uOlwiQSBgd2l0aGAgc3RhdGVtZW50XCIsJHByb3Bkb2M6e2V4cHJlc3Npb246XCJbQVNUX05vZGVdIHRoZSBgd2l0aGAgZXhwcmVzc2lvblwifSxfd2FsazpmdW5jdGlvbihlKXtyZXR1cm4gZS5fdmlzaXQodGhpcyxmdW5jdGlvbigpe3RoaXMuZXhwcmVzc2lvbi5fd2FsayhlKSx0aGlzLmJvZHkuX3dhbGsoZSl9KX19LF8pLEFlPWkoXCJTY29wZVwiLFwidmFyaWFibGVzIGZ1bmN0aW9ucyB1c2VzX3dpdGggdXNlc19ldmFsIHBhcmVudF9zY29wZSBlbmNsb3NlZCBjbmFtZVwiLHskZG9jdW1lbnRhdGlvbjpcIkJhc2UgY2xhc3MgZm9yIGFsbCBzdGF0ZW1lbnRzIGludHJvZHVjaW5nIGEgbGV4aWNhbCBzY29wZVwiLCRwcm9wZG9jOnt2YXJpYWJsZXM6XCJbT2JqZWN0L1NdIGEgbWFwIG9mIG5hbWUgLT4gU3ltYm9sRGVmIGZvciBhbGwgdmFyaWFibGVzL2Z1bmN0aW9ucyBkZWZpbmVkIGluIHRoaXMgc2NvcGVcIixmdW5jdGlvbnM6XCJbT2JqZWN0L1NdIGxpa2UgYHZhcmlhYmxlc2AsIGJ1dCBvbmx5IGxpc3RzIGZ1bmN0aW9uIGRlY2xhcmF0aW9uc1wiLHVzZXNfd2l0aDpcIltib29sZWFuL1NdIHRlbGxzIHdoZXRoZXIgdGhpcyBzY29wZSB1c2VzIHRoZSBgd2l0aGAgc3RhdGVtZW50XCIsdXNlc19ldmFsOlwiW2Jvb2xlYW4vU10gdGVsbHMgd2hldGhlciB0aGlzIHNjb3BlIGNvbnRhaW5zIGEgZGlyZWN0IGNhbGwgdG8gdGhlIGdsb2JhbCBgZXZhbGBcIixwYXJlbnRfc2NvcGU6XCJbQVNUX1Njb3BlPy9TXSBsaW5rIHRvIHRoZSBwYXJlbnQgc2NvcGVcIixlbmNsb3NlZDpcIltTeW1ib2xEZWYqL1NdIGEgbGlzdCBvZiBhbGwgc3ltYm9sIGRlZmluaXRpb25zIHRoYXQgYXJlIGFjY2Vzc2VkIGZyb20gdGhpcyBzY29wZSBvciBhbnkgc3Vic2NvcGVzXCIsY25hbWU6XCJbaW50ZWdlci9TXSBjdXJyZW50IGluZGV4IGZvciBtYW5nbGluZyB2YXJpYWJsZXMgKHVzZWQgaW50ZXJuYWxseSBieSB0aGUgbWFuZ2xlcilcIn0sY2xvbmU6ZnVuY3Rpb24oZSl7dmFyIG49dGhpcy5fY2xvbmUoZSk7cmV0dXJuIHRoaXMudmFyaWFibGVzJiYobi52YXJpYWJsZXM9dGhpcy52YXJpYWJsZXMuY2xvbmUoKSksdGhpcy5mdW5jdGlvbnMmJihuLmZ1bmN0aW9ucz10aGlzLmZ1bmN0aW9ucy5jbG9uZSgpKSx0aGlzLmVuY2xvc2VkJiYobi5lbmNsb3NlZD10aGlzLmVuY2xvc2VkLnNsaWNlKCkpLG59fSxwZSksRWU9aShcIlRvcGxldmVsXCIsXCJnbG9iYWxzXCIseyRkb2N1bWVudGF0aW9uOlwiVGhlIHRvcGxldmVsIHNjb3BlXCIsJHByb3Bkb2M6e2dsb2JhbHM6XCJbT2JqZWN0L1NdIGEgbWFwIG9mIG5hbWUgLT4gU3ltYm9sRGVmIGZvciBhbGwgdW5kZWNsYXJlZCBuYW1lc1wifSx3cmFwX2NvbW1vbmpzOmZ1bmN0aW9uKGUpe3ZhciBuPXRoaXMuYm9keSx0PVwiKGZ1bmN0aW9uKGV4cG9ydHMpeyckT1JJRyc7fSkodHlwZW9mIFwiK2UrXCI9PSd1bmRlZmluZWQnPyhcIitlK1wiPXt9KTpcIitlK1wiKTtcIjtyZXR1cm4gdD0odD1Hbih0KSkudHJhbnNmb3JtKG5ldyBYbihmdW5jdGlvbihlKXtpZihlIGluc3RhbmNlb2YgZmUmJlwiJE9SSUdcIj09ZS52YWx1ZSlyZXR1cm4gcmUuc3BsaWNlKG4pfSkpfX0sQWUpLGtlPWkoXCJMYW1iZGFcIixcIm5hbWUgYXJnbmFtZXMgdXNlc19hcmd1bWVudHNcIix7JGRvY3VtZW50YXRpb246XCJCYXNlIGNsYXNzIGZvciBmdW5jdGlvbnNcIiwkcHJvcGRvYzp7bmFtZTpcIltBU1RfU3ltYm9sRGVjbGFyYXRpb24/XSB0aGUgbmFtZSBvZiB0aGlzIGZ1bmN0aW9uXCIsYXJnbmFtZXM6XCJbQVNUX1N5bWJvbEZ1bmFyZypdIGFycmF5IG9mIGZ1bmN0aW9uIGFyZ3VtZW50c1wiLHVzZXNfYXJndW1lbnRzOlwiW2Jvb2xlYW4vU10gdGVsbHMgd2hldGhlciB0aGlzIGZ1bmN0aW9uIGFjY2Vzc2VzIHRoZSBhcmd1bWVudHMgYXJyYXlcIn0sX3dhbGs6ZnVuY3Rpb24oaSl7cmV0dXJuIGkuX3Zpc2l0KHRoaXMsZnVuY3Rpb24oKXt0aGlzLm5hbWUmJnRoaXMubmFtZS5fd2FsayhpKTtmb3IodmFyIGU9dGhpcy5hcmduYW1lcyxuPTAsdD1lLmxlbmd0aDtuPHQ7bisrKWVbbl0uX3dhbGsoaSk7eih0aGlzLGkpfSl9fSxBZSksRGU9aShcIkFjY2Vzc29yXCIsbnVsbCx7JGRvY3VtZW50YXRpb246XCJBIHNldHRlci9nZXR0ZXIgZnVuY3Rpb24uICBUaGUgYG5hbWVgIHByb3BlcnR5IGlzIGFsd2F5cyBudWxsLlwifSxrZSksRmU9aShcIkZ1bmN0aW9uXCIsXCJpbmxpbmVkXCIseyRkb2N1bWVudGF0aW9uOlwiQSBmdW5jdGlvbiBleHByZXNzaW9uXCJ9LGtlKSxDZT1pKFwiRGVmdW5cIixcImlubGluZWRcIix7JGRvY3VtZW50YXRpb246XCJBIGZ1bmN0aW9uIGRlZmluaXRpb25cIn0sa2UpLEJlPWkoXCJKdW1wXCIsbnVsbCx7JGRvY3VtZW50YXRpb246XCJCYXNlIGNsYXNzIGZvciDigJxqdW1wc+KAnSAoZm9yIG5vdyB0aGF0J3MgYHJldHVybmAsIGB0aHJvd2AsIGBicmVha2AgYW5kIGBjb250aW51ZWApXCJ9LHVlKSxTZT1pKFwiRXhpdFwiLFwidmFsdWVcIix7JGRvY3VtZW50YXRpb246XCJCYXNlIGNsYXNzIGZvciDigJxleGl0c+KAnSAoYHJldHVybmAgYW5kIGB0aHJvd2ApXCIsJHByb3Bkb2M6e3ZhbHVlOlwiW0FTVF9Ob2RlP10gdGhlIHZhbHVlIHJldHVybmVkIG9yIHRocm93biBieSB0aGlzIHN0YXRlbWVudDsgY291bGQgYmUgbnVsbCBmb3IgQVNUX1JldHVyblwifSxfd2FsazpmdW5jdGlvbihlKXtyZXR1cm4gZS5fdmlzaXQodGhpcyx0aGlzLnZhbHVlJiZmdW5jdGlvbigpe3RoaXMudmFsdWUuX3dhbGsoZSl9KX19LEJlKSxUZT1pKFwiUmV0dXJuXCIsbnVsbCx7JGRvY3VtZW50YXRpb246XCJBIGByZXR1cm5gIHN0YXRlbWVudFwifSxTZSksRz1pKFwiVGhyb3dcIixudWxsLHskZG9jdW1lbnRhdGlvbjpcIkEgYHRocm93YCBzdGF0ZW1lbnRcIn0sU2UpLE9lPWkoXCJMb29wQ29udHJvbFwiLFwibGFiZWxcIix7JGRvY3VtZW50YXRpb246XCJCYXNlIGNsYXNzIGZvciBsb29wIGNvbnRyb2wgc3RhdGVtZW50cyAoYGJyZWFrYCBhbmQgYGNvbnRpbnVlYClcIiwkcHJvcGRvYzp7bGFiZWw6XCJbQVNUX0xhYmVsUmVmP10gdGhlIGxhYmVsLCBvciBudWxsIGlmIG5vbmVcIn0sX3dhbGs6ZnVuY3Rpb24oZSl7cmV0dXJuIGUuX3Zpc2l0KHRoaXMsdGhpcy5sYWJlbCYmZnVuY3Rpb24oKXt0aGlzLmxhYmVsLl93YWxrKGUpfSl9fSxCZSksJGU9aShcIkJyZWFrXCIsbnVsbCx7JGRvY3VtZW50YXRpb246XCJBIGBicmVha2Agc3RhdGVtZW50XCJ9LE9lKSx6ZT1pKFwiQ29udGludWVcIixudWxsLHskZG9jdW1lbnRhdGlvbjpcIkEgYGNvbnRpbnVlYCBzdGF0ZW1lbnRcIn0sT2UpLE1lPWkoXCJJZlwiLFwiY29uZGl0aW9uIGFsdGVybmF0aXZlXCIseyRkb2N1bWVudGF0aW9uOlwiQSBgaWZgIHN0YXRlbWVudFwiLCRwcm9wZG9jOntjb25kaXRpb246XCJbQVNUX05vZGVdIHRoZSBgaWZgIGNvbmRpdGlvblwiLGFsdGVybmF0aXZlOlwiW0FTVF9TdGF0ZW1lbnQ/XSB0aGUgYGVsc2VgIHBhcnQsIG9yIG51bGwgaWYgbm90IHByZXNlbnRcIn0sX3dhbGs6ZnVuY3Rpb24oZSl7cmV0dXJuIGUuX3Zpc2l0KHRoaXMsZnVuY3Rpb24oKXt0aGlzLmNvbmRpdGlvbi5fd2FsayhlKSx0aGlzLmJvZHkuX3dhbGsoZSksdGhpcy5hbHRlcm5hdGl2ZSYmdGhpcy5hbHRlcm5hdGl2ZS5fd2FsayhlKX0pfX0sXykscWU9aShcIlN3aXRjaFwiLFwiZXhwcmVzc2lvblwiLHskZG9jdW1lbnRhdGlvbjpcIkEgYHN3aXRjaGAgc3RhdGVtZW50XCIsJHByb3Bkb2M6e2V4cHJlc3Npb246XCJbQVNUX05vZGVdIHRoZSBgc3dpdGNoYCDigJxkaXNjcmltaW5hbnTigJ1cIn0sX3dhbGs6ZnVuY3Rpb24oZSl7cmV0dXJuIGUuX3Zpc2l0KHRoaXMsZnVuY3Rpb24oKXt0aGlzLmV4cHJlc3Npb24uX3dhbGsoZSkseih0aGlzLGUpfSl9fSxwZSksamU9aShcIlN3aXRjaEJyYW5jaFwiLG51bGwseyRkb2N1bWVudGF0aW9uOlwiQmFzZSBjbGFzcyBmb3IgYHN3aXRjaGAgYnJhbmNoZXNcIn0scGUpLE5lPWkoXCJEZWZhdWx0XCIsbnVsbCx7JGRvY3VtZW50YXRpb246XCJBIGBkZWZhdWx0YCBzd2l0Y2ggYnJhbmNoXCJ9LGplKSxIZT1pKFwiQ2FzZVwiLFwiZXhwcmVzc2lvblwiLHskZG9jdW1lbnRhdGlvbjpcIkEgYGNhc2VgIHN3aXRjaCBicmFuY2hcIiwkcHJvcGRvYzp7ZXhwcmVzc2lvbjpcIltBU1RfTm9kZV0gdGhlIGBjYXNlYCBleHByZXNzaW9uXCJ9LF93YWxrOmZ1bmN0aW9uKGUpe3JldHVybiBlLl92aXNpdCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5leHByZXNzaW9uLl93YWxrKGUpLHoodGhpcyxlKX0pfX0samUpLFJlPWkoXCJUcnlcIixcImJjYXRjaCBiZmluYWxseVwiLHskZG9jdW1lbnRhdGlvbjpcIkEgYHRyeWAgc3RhdGVtZW50XCIsJHByb3Bkb2M6e2JjYXRjaDpcIltBU1RfQ2F0Y2g/XSB0aGUgY2F0Y2ggYmxvY2ssIG9yIG51bGwgaWYgbm90IHByZXNlbnRcIixiZmluYWxseTpcIltBU1RfRmluYWxseT9dIHRoZSBmaW5hbGx5IGJsb2NrLCBvciBudWxsIGlmIG5vdCBwcmVzZW50XCJ9LF93YWxrOmZ1bmN0aW9uKGUpe3JldHVybiBlLl92aXNpdCh0aGlzLGZ1bmN0aW9uKCl7eih0aGlzLGUpLHRoaXMuYmNhdGNoJiZ0aGlzLmJjYXRjaC5fd2FsayhlKSx0aGlzLmJmaW5hbGx5JiZ0aGlzLmJmaW5hbGx5Ll93YWxrKGUpfSl9fSxwZSksSWU9aShcIkNhdGNoXCIsXCJhcmduYW1lXCIseyRkb2N1bWVudGF0aW9uOlwiQSBgY2F0Y2hgIG5vZGU7IG9ubHkgbWFrZXMgc2Vuc2UgYXMgcGFydCBvZiBhIGB0cnlgIHN0YXRlbWVudFwiLCRwcm9wZG9jOnthcmduYW1lOlwiW0FTVF9TeW1ib2xDYXRjaF0gc3ltYm9sIGZvciB0aGUgZXhjZXB0aW9uXCJ9LF93YWxrOmZ1bmN0aW9uKGUpe3JldHVybiBlLl92aXNpdCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5hcmduYW1lLl93YWxrKGUpLHoodGhpcyxlKX0pfX0scGUpLFBlPWkoXCJGaW5hbGx5XCIsbnVsbCx7JGRvY3VtZW50YXRpb246XCJBIGBmaW5hbGx5YCBub2RlOyBvbmx5IG1ha2VzIHNlbnNlIGFzIHBhcnQgb2YgYSBgdHJ5YCBzdGF0ZW1lbnRcIn0scGUpLFVlPWkoXCJEZWZpbml0aW9uc1wiLFwiZGVmaW5pdGlvbnNcIix7JGRvY3VtZW50YXRpb246XCJCYXNlIGNsYXNzIGZvciBgdmFyYCBub2RlcyAodmFyaWFibGUgZGVjbGFyYXRpb25zL2luaXRpYWxpemF0aW9ucylcIiwkcHJvcGRvYzp7ZGVmaW5pdGlvbnM6XCJbQVNUX1ZhckRlZipdIGFycmF5IG9mIHZhcmlhYmxlIGRlZmluaXRpb25zXCJ9LF93YWxrOmZ1bmN0aW9uKGkpe3JldHVybiBpLl92aXNpdCh0aGlzLGZ1bmN0aW9uKCl7Zm9yKHZhciBlPXRoaXMuZGVmaW5pdGlvbnMsbj0wLHQ9ZS5sZW5ndGg7bjx0O24rKyllW25dLl93YWxrKGkpfSl9fSx1ZSksTGU9aShcIlZhclwiLG51bGwseyRkb2N1bWVudGF0aW9uOlwiQSBgdmFyYCBzdGF0ZW1lbnRcIn0sVWUpLFZlPWkoXCJWYXJEZWZcIixcIm5hbWUgdmFsdWVcIix7JGRvY3VtZW50YXRpb246XCJBIHZhcmlhYmxlIGRlY2xhcmF0aW9uOyBvbmx5IGFwcGVhcnMgaW4gYSBBU1RfRGVmaW5pdGlvbnMgbm9kZVwiLCRwcm9wZG9jOntuYW1lOlwiW0FTVF9TeW1ib2xWYXJdIG5hbWUgb2YgdGhlIHZhcmlhYmxlXCIsdmFsdWU6XCJbQVNUX05vZGU/XSBpbml0aWFsaXplciwgb3IgbnVsbCBvZiB0aGVyZSdzIG5vIGluaXRpYWxpemVyXCJ9LF93YWxrOmZ1bmN0aW9uKGUpe3JldHVybiBlLl92aXNpdCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5uYW1lLl93YWxrKGUpLHRoaXMudmFsdWUmJnRoaXMudmFsdWUuX3dhbGsoZSl9KX19KSxZZT1pKFwiQ2FsbFwiLFwiZXhwcmVzc2lvbiBhcmdzXCIseyRkb2N1bWVudGF0aW9uOlwiQSBmdW5jdGlvbiBjYWxsIGV4cHJlc3Npb25cIiwkcHJvcGRvYzp7ZXhwcmVzc2lvbjpcIltBU1RfTm9kZV0gZXhwcmVzc2lvbiB0byBpbnZva2UgYXMgZnVuY3Rpb25cIixhcmdzOlwiW0FTVF9Ob2RlKl0gYXJyYXkgb2YgYXJndW1lbnRzXCJ9LF93YWxrOmZ1bmN0aW9uKGkpe3JldHVybiBpLl92aXNpdCh0aGlzLGZ1bmN0aW9uKCl7Zm9yKHZhciBlPXRoaXMuYXJncyxuPTAsdD1lLmxlbmd0aDtuPHQ7bisrKWVbbl0uX3dhbGsoaSk7dGhpcy5leHByZXNzaW9uLl93YWxrKGkpfSl9fSksSmU9aShcIk5ld1wiLG51bGwseyRkb2N1bWVudGF0aW9uOlwiQW4gb2JqZWN0IGluc3RhbnRpYXRpb24uICBEZXJpdmVzIGZyb20gYSBmdW5jdGlvbiBjYWxsIHNpbmNlIGl0IGhhcyBleGFjdGx5IHRoZSBzYW1lIHByb3BlcnRpZXNcIn0sWWUpLFdlPWkoXCJTZXF1ZW5jZVwiLFwiZXhwcmVzc2lvbnNcIix7JGRvY3VtZW50YXRpb246XCJBIHNlcXVlbmNlIGV4cHJlc3Npb24gKGNvbW1hLXNlcGFyYXRlZCBleHByZXNzaW9ucylcIiwkcHJvcGRvYzp7ZXhwcmVzc2lvbnM6XCJbQVNUX05vZGUqXSBhcnJheSBvZiBleHByZXNzaW9ucyAoYXQgbGVhc3QgdHdvKVwifSxfd2FsazpmdW5jdGlvbihuKXtyZXR1cm4gbi5fdmlzaXQodGhpcyxmdW5jdGlvbigpe3RoaXMuZXhwcmVzc2lvbnMuZm9yRWFjaChmdW5jdGlvbihlKXtlLl93YWxrKG4pfSl9KX19KSxHZT1pKFwiUHJvcEFjY2Vzc1wiLFwiZXhwcmVzc2lvbiBwcm9wZXJ0eVwiLHskZG9jdW1lbnRhdGlvbjonQmFzZSBjbGFzcyBmb3IgcHJvcGVydHkgYWNjZXNzIGV4cHJlc3Npb25zLCBpLmUuIGBhLmZvb2Agb3IgYGFbXCJmb29cIl1gJywkcHJvcGRvYzp7ZXhwcmVzc2lvbjpcIltBU1RfTm9kZV0gdGhlIOKAnGNvbnRhaW5lcuKAnSBleHByZXNzaW9uXCIscHJvcGVydHk6XCJbQVNUX05vZGV8c3RyaW5nXSB0aGUgcHJvcGVydHkgdG8gYWNjZXNzLiAgRm9yIEFTVF9Eb3QgdGhpcyBpcyBhbHdheXMgYSBwbGFpbiBzdHJpbmcsIHdoaWxlIGZvciBBU1RfU3ViIGl0J3MgYW4gYXJiaXRyYXJ5IEFTVF9Ob2RlXCJ9fSksWGU9aShcIkRvdFwiLG51bGwseyRkb2N1bWVudGF0aW9uOlwiQSBkb3R0ZWQgcHJvcGVydHkgYWNjZXNzIGV4cHJlc3Npb25cIixfd2FsazpmdW5jdGlvbihlKXtyZXR1cm4gZS5fdmlzaXQodGhpcyxmdW5jdGlvbigpe3RoaXMuZXhwcmVzc2lvbi5fd2FsayhlKX0pfX0sR2UpLFplPWkoXCJTdWJcIixudWxsLHskZG9jdW1lbnRhdGlvbjonSW5kZXgtc3R5bGUgcHJvcGVydHkgYWNjZXNzLCBpLmUuIGBhW1wiZm9vXCJdYCcsX3dhbGs6ZnVuY3Rpb24oZSl7cmV0dXJuIGUuX3Zpc2l0KHRoaXMsZnVuY3Rpb24oKXt0aGlzLmV4cHJlc3Npb24uX3dhbGsoZSksdGhpcy5wcm9wZXJ0eS5fd2FsayhlKX0pfX0sR2UpLEtlPWkoXCJVbmFyeVwiLFwib3BlcmF0b3IgZXhwcmVzc2lvblwiLHskZG9jdW1lbnRhdGlvbjpcIkJhc2UgY2xhc3MgZm9yIHVuYXJ5IGV4cHJlc3Npb25zXCIsJHByb3Bkb2M6e29wZXJhdG9yOlwiW3N0cmluZ10gdGhlIG9wZXJhdG9yXCIsZXhwcmVzc2lvbjpcIltBU1RfTm9kZV0gZXhwcmVzc2lvbiB0aGF0IHRoaXMgdW5hcnkgb3BlcmF0b3IgYXBwbGllcyB0b1wifSxfd2FsazpmdW5jdGlvbihlKXtyZXR1cm4gZS5fdmlzaXQodGhpcyxmdW5jdGlvbigpe3RoaXMuZXhwcmVzc2lvbi5fd2FsayhlKX0pfX0pLFFlPWkoXCJVbmFyeVByZWZpeFwiLG51bGwseyRkb2N1bWVudGF0aW9uOlwiVW5hcnkgcHJlZml4IGV4cHJlc3Npb24sIGkuZS4gYHR5cGVvZiBpYCBvciBgKytpYFwifSxLZSksZW49aShcIlVuYXJ5UG9zdGZpeFwiLG51bGwseyRkb2N1bWVudGF0aW9uOlwiVW5hcnkgcG9zdGZpeCBleHByZXNzaW9uLCBpLmUuIGBpKytgXCJ9LEtlKSxubj1pKFwiQmluYXJ5XCIsXCJvcGVyYXRvciBsZWZ0IHJpZ2h0XCIseyRkb2N1bWVudGF0aW9uOlwiQmluYXJ5IGV4cHJlc3Npb24sIGkuZS4gYGEgKyBiYFwiLCRwcm9wZG9jOntsZWZ0OlwiW0FTVF9Ob2RlXSBsZWZ0LWhhbmQgc2lkZSBleHByZXNzaW9uXCIsb3BlcmF0b3I6XCJbc3RyaW5nXSB0aGUgb3BlcmF0b3JcIixyaWdodDpcIltBU1RfTm9kZV0gcmlnaHQtaGFuZCBzaWRlIGV4cHJlc3Npb25cIn0sX3dhbGs6ZnVuY3Rpb24oZSl7cmV0dXJuIGUuX3Zpc2l0KHRoaXMsZnVuY3Rpb24oKXt0aGlzLmxlZnQuX3dhbGsoZSksdGhpcy5yaWdodC5fd2FsayhlKX0pfX0pLHRuPWkoXCJDb25kaXRpb25hbFwiLFwiY29uZGl0aW9uIGNvbnNlcXVlbnQgYWx0ZXJuYXRpdmVcIix7JGRvY3VtZW50YXRpb246XCJDb25kaXRpb25hbCBleHByZXNzaW9uIHVzaW5nIHRoZSB0ZXJuYXJ5IG9wZXJhdG9yLCBpLmUuIGBhID8gYiA6IGNgXCIsJHByb3Bkb2M6e2NvbmRpdGlvbjpcIltBU1RfTm9kZV1cIixjb25zZXF1ZW50OlwiW0FTVF9Ob2RlXVwiLGFsdGVybmF0aXZlOlwiW0FTVF9Ob2RlXVwifSxfd2FsazpmdW5jdGlvbihlKXtyZXR1cm4gZS5fdmlzaXQodGhpcyxmdW5jdGlvbigpe3RoaXMuY29uZGl0aW9uLl93YWxrKGUpLHRoaXMuY29uc2VxdWVudC5fd2FsayhlKSx0aGlzLmFsdGVybmF0aXZlLl93YWxrKGUpfSl9fSkscm49aShcIkFzc2lnblwiLG51bGwseyRkb2N1bWVudGF0aW9uOlwiQW4gYXNzaWdubWVudCBleHByZXNzaW9uIOKAlCBgYSA9IGIgKyA1YFwifSxubiksb249aShcIkFycmF5XCIsXCJlbGVtZW50c1wiLHskZG9jdW1lbnRhdGlvbjpcIkFuIGFycmF5IGxpdGVyYWxcIiwkcHJvcGRvYzp7ZWxlbWVudHM6XCJbQVNUX05vZGUqXSBhcnJheSBvZiBlbGVtZW50c1wifSxfd2FsazpmdW5jdGlvbihpKXtyZXR1cm4gaS5fdmlzaXQodGhpcyxmdW5jdGlvbigpe2Zvcih2YXIgZT10aGlzLmVsZW1lbnRzLG49MCx0PWUubGVuZ3RoO248dDtuKyspZVtuXS5fd2FsayhpKX0pfX0pLGFuPWkoXCJPYmplY3RcIixcInByb3BlcnRpZXNcIix7JGRvY3VtZW50YXRpb246XCJBbiBvYmplY3QgbGl0ZXJhbFwiLCRwcm9wZG9jOntwcm9wZXJ0aWVzOlwiW0FTVF9PYmplY3RQcm9wZXJ0eSpdIGFycmF5IG9mIHByb3BlcnRpZXNcIn0sX3dhbGs6ZnVuY3Rpb24oaSl7cmV0dXJuIGkuX3Zpc2l0KHRoaXMsZnVuY3Rpb24oKXtmb3IodmFyIGU9dGhpcy5wcm9wZXJ0aWVzLG49MCx0PWUubGVuZ3RoO248dDtuKyspZVtuXS5fd2FsayhpKX0pfX0pLHNuPWkoXCJPYmplY3RQcm9wZXJ0eVwiLFwia2V5IHZhbHVlXCIseyRkb2N1bWVudGF0aW9uOlwiQmFzZSBjbGFzcyBmb3IgbGl0ZXJhbCBvYmplY3QgcHJvcGVydGllc1wiLCRwcm9wZG9jOntrZXk6XCJbc3RyaW5nfEFTVF9TeW1ib2xBY2Nlc3Nvcl0gcHJvcGVydHkgbmFtZS4gRm9yIE9iamVjdEtleVZhbCB0aGlzIGlzIGEgc3RyaW5nLiBGb3IgZ2V0dGVycyBhbmQgc2V0dGVycyB0aGlzIGlzIGFuIEFTVF9TeW1ib2xBY2Nlc3Nvci5cIix2YWx1ZTpcIltBU1RfTm9kZV0gcHJvcGVydHkgdmFsdWUuICBGb3IgZ2V0dGVycyBhbmQgc2V0dGVycyB0aGlzIGlzIGFuIEFTVF9BY2Nlc3Nvci5cIn0sX3dhbGs6ZnVuY3Rpb24oZSl7cmV0dXJuIGUuX3Zpc2l0KHRoaXMsZnVuY3Rpb24oKXt0aGlzLnZhbHVlLl93YWxrKGUpfSl9fSksdW49aShcIk9iamVjdEtleVZhbFwiLFwicXVvdGVcIix7JGRvY3VtZW50YXRpb246XCJBIGtleTogdmFsdWUgb2JqZWN0IHByb3BlcnR5XCIsJHByb3Bkb2M6e3F1b3RlOlwiW3N0cmluZ10gdGhlIG9yaWdpbmFsIHF1b3RlIGNoYXJhY3RlclwifX0sc24pLFg9aShcIk9iamVjdFNldHRlclwiLG51bGwseyRkb2N1bWVudGF0aW9uOlwiQW4gb2JqZWN0IHNldHRlciBwcm9wZXJ0eVwifSxzbiksWj1pKFwiT2JqZWN0R2V0dGVyXCIsbnVsbCx7JGRvY3VtZW50YXRpb246XCJBbiBvYmplY3QgZ2V0dGVyIHByb3BlcnR5XCJ9LHNuKSxjbj1pKFwiU3ltYm9sXCIsXCJzY29wZSBuYW1lIHRoZWRlZlwiLHskcHJvcGRvYzp7bmFtZTpcIltzdHJpbmddIG5hbWUgb2YgdGhpcyBzeW1ib2xcIixzY29wZTpcIltBU1RfU2NvcGUvU10gdGhlIGN1cnJlbnQgc2NvcGUgKG5vdCBuZWNlc3NhcmlseSB0aGUgZGVmaW5pdGlvbiBzY29wZSlcIix0aGVkZWY6XCJbU3ltYm9sRGVmL1NdIHRoZSBkZWZpbml0aW9uIG9mIHRoaXMgc3ltYm9sXCJ9LCRkb2N1bWVudGF0aW9uOlwiQmFzZSBjbGFzcyBmb3IgYWxsIHN5bWJvbHNcIn0pLEs9aShcIlN5bWJvbEFjY2Vzc29yXCIsbnVsbCx7JGRvY3VtZW50YXRpb246XCJUaGUgbmFtZSBvZiBhIHByb3BlcnR5IGFjY2Vzc29yIChzZXR0ZXIvZ2V0dGVyIGZ1bmN0aW9uKVwifSxjbiksZm49aShcIlN5bWJvbERlY2xhcmF0aW9uXCIsXCJpbml0XCIseyRkb2N1bWVudGF0aW9uOlwiQSBkZWNsYXJhdGlvbiBzeW1ib2wgKHN5bWJvbCBpbiB2YXIsIGZ1bmN0aW9uIG5hbWUgb3IgYXJndW1lbnQsIHN5bWJvbCBpbiBjYXRjaClcIn0sY24pLGxuPWkoXCJTeW1ib2xWYXJcIixudWxsLHskZG9jdW1lbnRhdGlvbjpcIlN5bWJvbCBkZWZpbmluZyBhIHZhcmlhYmxlXCJ9LGZuKSxwbj1pKFwiU3ltYm9sRnVuYXJnXCIsbnVsbCx7JGRvY3VtZW50YXRpb246XCJTeW1ib2wgbmFtaW5nIGEgZnVuY3Rpb24gYXJndW1lbnRcIn0sbG4pLGRuPWkoXCJTeW1ib2xEZWZ1blwiLG51bGwseyRkb2N1bWVudGF0aW9uOlwiU3ltYm9sIGRlZmluaW5nIGEgZnVuY3Rpb25cIn0sZm4pLGhuPWkoXCJTeW1ib2xMYW1iZGFcIixudWxsLHskZG9jdW1lbnRhdGlvbjpcIlN5bWJvbCBuYW1pbmcgYSBmdW5jdGlvbiBleHByZXNzaW9uXCJ9LGZuKSx2bj1pKFwiU3ltYm9sQ2F0Y2hcIixudWxsLHskZG9jdW1lbnRhdGlvbjpcIlN5bWJvbCBuYW1pbmcgdGhlIGV4Y2VwdGlvbiBpbiBjYXRjaFwifSxmbiksUT1pKFwiTGFiZWxcIixcInJlZmVyZW5jZXNcIix7JGRvY3VtZW50YXRpb246XCJTeW1ib2wgbmFtaW5nIGEgbGFiZWwgKGRlY2xhcmF0aW9uKVwiLCRwcm9wZG9jOntyZWZlcmVuY2VzOlwiW0FTVF9Mb29wQ29udHJvbCpdIGEgbGlzdCBvZiBub2RlcyByZWZlcnJpbmcgdG8gdGhpcyBsYWJlbFwifSxpbml0aWFsaXplOmZ1bmN0aW9uKCl7dGhpcy5yZWZlcmVuY2VzPVtdLHRoaXMudGhlZGVmPXRoaXN9fSxjbiksX249aShcIlN5bWJvbFJlZlwiLG51bGwseyRkb2N1bWVudGF0aW9uOlwiUmVmZXJlbmNlIHRvIHNvbWUgc3ltYm9sIChub3QgZGVmaW5pdGlvbi9kZWNsYXJhdGlvbilcIn0sY24pLGVlPWkoXCJMYWJlbFJlZlwiLG51bGwseyRkb2N1bWVudGF0aW9uOlwiUmVmZXJlbmNlIHRvIGEgbGFiZWwgc3ltYm9sXCJ9LGNuKSxtbj1pKFwiVGhpc1wiLG51bGwseyRkb2N1bWVudGF0aW9uOlwiVGhlIGB0aGlzYCBzeW1ib2xcIn0sY24pLGduPWkoXCJDb25zdGFudFwiLG51bGwseyRkb2N1bWVudGF0aW9uOlwiQmFzZSBjbGFzcyBmb3IgYWxsIGNvbnN0YW50c1wiLGdldFZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmFsdWV9fSksYm49aShcIlN0cmluZ1wiLFwidmFsdWUgcXVvdGVcIix7JGRvY3VtZW50YXRpb246XCJBIHN0cmluZyBsaXRlcmFsXCIsJHByb3Bkb2M6e3ZhbHVlOlwiW3N0cmluZ10gdGhlIGNvbnRlbnRzIG9mIHRoaXMgc3RyaW5nXCIscXVvdGU6XCJbc3RyaW5nXSB0aGUgb3JpZ2luYWwgcXVvdGUgY2hhcmFjdGVyXCJ9fSxnbikseW49aShcIk51bWJlclwiLFwidmFsdWUgbGl0ZXJhbFwiLHskZG9jdW1lbnRhdGlvbjpcIkEgbnVtYmVyIGxpdGVyYWxcIiwkcHJvcGRvYzp7dmFsdWU6XCJbbnVtYmVyXSB0aGUgbnVtZXJpYyB2YWx1ZVwiLGxpdGVyYWw6XCJbc3RyaW5nXSBudW1lcmljIHZhbHVlIGFzIHN0cmluZyAob3B0aW9uYWwpXCJ9fSxnbiksd249aShcIlJlZ0V4cFwiLFwidmFsdWVcIix7JGRvY3VtZW50YXRpb246XCJBIHJlZ2V4cCBsaXRlcmFsXCIsJHByb3Bkb2M6e3ZhbHVlOlwiW1JlZ0V4cF0gdGhlIGFjdHVhbCByZWdleHBcIn19LGduKSxhPWkoXCJBdG9tXCIsbnVsbCx7JGRvY3VtZW50YXRpb246XCJCYXNlIGNsYXNzIGZvciBhdG9tc1wifSxnbikseG49aShcIk51bGxcIixudWxsLHskZG9jdW1lbnRhdGlvbjpcIlRoZSBgbnVsbGAgYXRvbVwiLHZhbHVlOm51bGx9LGEpLEFuPWkoXCJOYU5cIixudWxsLHskZG9jdW1lbnRhdGlvbjpcIlRoZSBpbXBvc3NpYmxlIHZhbHVlXCIsdmFsdWU6TmFOfSxhKSxFbj1pKFwiVW5kZWZpbmVkXCIsbnVsbCx7JGRvY3VtZW50YXRpb246XCJUaGUgYHVuZGVmaW5lZGAgdmFsdWVcIix2YWx1ZTp2b2lkIDB9LGEpLGtuPWkoXCJIb2xlXCIsbnVsbCx7JGRvY3VtZW50YXRpb246XCJBIGhvbGUgaW4gYW4gYXJyYXlcIix2YWx1ZTp2b2lkIDB9LGEpLERuPWkoXCJJbmZpbml0eVwiLG51bGwseyRkb2N1bWVudGF0aW9uOlwiVGhlIGBJbmZpbml0eWAgdmFsdWVcIix2YWx1ZToxLzB9LGEpLEZuPWkoXCJCb29sZWFuXCIsbnVsbCx7JGRvY3VtZW50YXRpb246XCJCYXNlIGNsYXNzIGZvciBib29sZWFuc1wifSxhKSxDbj1pKFwiRmFsc2VcIixudWxsLHskZG9jdW1lbnRhdGlvbjpcIlRoZSBgZmFsc2VgIGF0b21cIix2YWx1ZTohMX0sRm4pLEJuPWkoXCJUcnVlXCIsbnVsbCx7JGRvY3VtZW50YXRpb246XCJUaGUgYHRydWVgIGF0b21cIix2YWx1ZTohMH0sRm4pO2Z1bmN0aW9uIFNuKGUpe3RoaXMudmlzaXQ9ZSx0aGlzLnN0YWNrPVtdLHRoaXMuZGlyZWN0aXZlcz1PYmplY3QuY3JlYXRlKG51bGwpfVNuLnByb3RvdHlwZT17X3Zpc2l0OmZ1bmN0aW9uKGUsbil7dGhpcy5wdXNoKGUpO3ZhciB0PXRoaXMudmlzaXQoZSxuP2Z1bmN0aW9uKCl7bi5jYWxsKGUpfTpMKTtyZXR1cm4hdCYmbiYmbi5jYWxsKGUpLHRoaXMucG9wKCksdH0scGFyZW50OmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoLTItKGV8fDApXX0scHVzaDpmdW5jdGlvbihlKXtlIGluc3RhbmNlb2Yga2U/dGhpcy5kaXJlY3RpdmVzPU9iamVjdC5jcmVhdGUodGhpcy5kaXJlY3RpdmVzKTplIGluc3RhbmNlb2YgZmUmJiF0aGlzLmRpcmVjdGl2ZXNbZS52YWx1ZV0mJih0aGlzLmRpcmVjdGl2ZXNbZS52YWx1ZV09ZSksdGhpcy5zdGFjay5wdXNoKGUpfSxwb3A6ZnVuY3Rpb24oKXt0aGlzLnN0YWNrLnBvcCgpaW5zdGFuY2VvZiBrZSYmKHRoaXMuZGlyZWN0aXZlcz1PYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcy5kaXJlY3RpdmVzKSl9LHNlbGY6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aC0xXX0sZmluZF9wYXJlbnQ6ZnVuY3Rpb24oZSl7Zm9yKHZhciBuPXRoaXMuc3RhY2ssdD1uLmxlbmd0aDswPD0tLXQ7KXt2YXIgaT1uW3RdO2lmKGkgaW5zdGFuY2VvZiBlKXJldHVybiBpfX0saGFzX2RpcmVjdGl2ZTpmdW5jdGlvbihlKXt2YXIgbj10aGlzLmRpcmVjdGl2ZXNbZV07aWYobilyZXR1cm4gbjt2YXIgdD10aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoLTFdO2lmKHQgaW5zdGFuY2VvZiBBZSlmb3IodmFyIGk9MDtpPHQuYm9keS5sZW5ndGg7KytpKXt2YXIgcj10LmJvZHlbaV07aWYoIShyIGluc3RhbmNlb2YgZmUpKWJyZWFrO2lmKHIudmFsdWU9PWUpcmV0dXJuIHJ9fSxsb29wY29udHJvbF90YXJnZXQ6ZnVuY3Rpb24oZSl7dmFyIG49dGhpcy5zdGFjaztpZihlLmxhYmVsKWZvcih2YXIgdD1uLmxlbmd0aDswPD0tLXQ7KXtpZigoaT1uW3RdKWluc3RhbmNlb2YgdmUmJmkubGFiZWwubmFtZT09ZS5sYWJlbC5uYW1lKXJldHVybiBpLmJvZHl9ZWxzZSBmb3IodD1uLmxlbmd0aDswPD0tLXQ7KXt2YXIgaTtpZigoaT1uW3RdKWluc3RhbmNlb2YgX2V8fGUgaW5zdGFuY2VvZiAkZSYmaSBpbnN0YW5jZW9mIHFlKXJldHVybiBpfX0saW5fYm9vbGVhbl9jb250ZXh0OmZ1bmN0aW9uKCl7Zm9yKHZhciBlLG49dGhpcy5zZWxmKCksdD0wO2U9dGhpcy5wYXJlbnQodCk7dCsrKXtpZihlIGluc3RhbmNlb2YgbGV8fGUgaW5zdGFuY2VvZiB0biYmZS5jb25kaXRpb249PT1ufHxlIGluc3RhbmNlb2YgbWUmJmUuY29uZGl0aW9uPT09bnx8ZSBpbnN0YW5jZW9mIHllJiZlLmNvbmRpdGlvbj09PW58fGUgaW5zdGFuY2VvZiBNZSYmZS5jb25kaXRpb249PT1ufHxlIGluc3RhbmNlb2YgUWUmJlwiIVwiPT1lLm9wZXJhdG9yJiZlLmV4cHJlc3Npb249PT1uKXJldHVybiEwO2lmKCEoZSBpbnN0YW5jZW9mIG5uJiYoXCImJlwiPT1lLm9wZXJhdG9yfHxcInx8XCI9PWUub3BlcmF0b3IpfHxlIGluc3RhbmNlb2YgdG58fGUudGFpbF9ub2RlKCk9PT1uKSlyZXR1cm4hMTtuPWV9fX07dmFyIG5lPVwiYnJlYWsgY2FzZSBjYXRjaCBjb25zdCBjb250aW51ZSBkZWJ1Z2dlciBkZWZhdWx0IGRlbGV0ZSBkbyBlbHNlIGZpbmFsbHkgZm9yIGZ1bmN0aW9uIGlmIGluIGluc3RhbmNlb2YgbmV3IHJldHVybiBzd2l0Y2ggdGhyb3cgdHJ5IHR5cGVvZiB2YXIgdm9pZCB3aGlsZSB3aXRoXCIsTT1cImZhbHNlIG51bGwgdHJ1ZVwiLG09XCJhYnN0cmFjdCBib29sZWFuIGJ5dGUgY2hhciBjbGFzcyBkb3VibGUgZW51bSBleHBvcnQgZXh0ZW5kcyBmaW5hbCBmbG9hdCBnb3RvIGltcGxlbWVudHMgaW1wb3J0IGludCBpbnRlcmZhY2UgbGV0IGxvbmcgbmF0aXZlIHBhY2thZ2UgcHJpdmF0ZSBwcm90ZWN0ZWQgcHVibGljIHNob3J0IHN0YXRpYyBzdXBlciBzeW5jaHJvbml6ZWQgdGhpcyB0aHJvd3MgdHJhbnNpZW50IHZvbGF0aWxlIHlpZWxkIFwiK00rXCIgXCIrbmUscT1cInJldHVybiBuZXcgZGVsZXRlIHRocm93IGVsc2UgY2FzZVwiO25lPVcobmUpLG09VyhtKSxxPVcocSksTT1XKE0pO3ZhciBqPVcoZShcIistKiYlPTw+IT98fl5cIikpLE49L14weFswLTlhLWZdKyQvaSxIPS9eMFswLTddKyQvLFI9VyhbXCJpblwiLFwiaW5zdGFuY2VvZlwiLFwidHlwZW9mXCIsXCJuZXdcIixcInZvaWRcIixcImRlbGV0ZVwiLFwiKytcIixcIi0tXCIsXCIrXCIsXCItXCIsXCIhXCIsXCJ+XCIsXCImXCIsXCJ8XCIsXCJeXCIsXCIqXCIsXCIvXCIsXCIlXCIsXCI+PlwiLFwiPDxcIixcIj4+PlwiLFwiPFwiLFwiPlwiLFwiPD1cIixcIj49XCIsXCI9PVwiLFwiPT09XCIsXCIhPVwiLFwiIT09XCIsXCI/XCIsXCI9XCIsXCIrPVwiLFwiLT1cIixcIi89XCIsXCIqPVwiLFwiJT1cIixcIj4+PVwiLFwiPDw9XCIsXCI+Pj49XCIsXCJ8PVwiLFwiXj1cIixcIiY9XCIsXCImJlwiLFwifHxcIl0pLEk9VyhlKFwiIMKgXFxuXFxyXFx0XFxmXFx24oCL4oCA4oCB4oCC4oCD4oCE4oCF4oCG4oCH4oCI4oCJ4oCKXFx1MjAyOFxcdTIwMjnigK/igZ/jgIBcXHVmZWZmXCIpKSxQPVcoZShcIlxcblxcclxcdTIwMjhcXHUyMDI5XCIpKSxVPVcoZShcIlt7KCw7OlwiKSksVG49VyhlKFwiW117fSgpLDs6XCIpKSx1PXtsZXR0ZXI6bmV3IFJlZ0V4cChcIltcXFxcdTAwNDEtXFxcXHUwMDVBXFxcXHUwMDYxLVxcXFx1MDA3QVxcXFx1MDBBQVxcXFx1MDBCNVxcXFx1MDBCQVxcXFx1MDBDMC1cXFxcdTAwRDZcXFxcdTAwRDgtXFxcXHUwMEY2XFxcXHUwMEY4LVxcXFx1MDJDMVxcXFx1MDJDNi1cXFxcdTAyRDFcXFxcdTAyRTAtXFxcXHUwMkU0XFxcXHUwMkVDXFxcXHUwMkVFXFxcXHUwMzcwLVxcXFx1MDM3NFxcXFx1MDM3NlxcXFx1MDM3N1xcXFx1MDM3QS1cXFxcdTAzN0RcXFxcdTAzN0ZcXFxcdTAzODZcXFxcdTAzODgtXFxcXHUwMzhBXFxcXHUwMzhDXFxcXHUwMzhFLVxcXFx1MDNBMVxcXFx1MDNBMy1cXFxcdTAzRjVcXFxcdTAzRjctXFxcXHUwNDgxXFxcXHUwNDhBLVxcXFx1MDUyRlxcXFx1MDUzMS1cXFxcdTA1NTZcXFxcdTA1NTlcXFxcdTA1NjEtXFxcXHUwNTg3XFxcXHUwNUQwLVxcXFx1MDVFQVxcXFx1MDVGMC1cXFxcdTA1RjJcXFxcdTA2MjAtXFxcXHUwNjRBXFxcXHUwNjZFXFxcXHUwNjZGXFxcXHUwNjcxLVxcXFx1MDZEM1xcXFx1MDZENVxcXFx1MDZFNVxcXFx1MDZFNlxcXFx1MDZFRVxcXFx1MDZFRlxcXFx1MDZGQS1cXFxcdTA2RkNcXFxcdTA2RkZcXFxcdTA3MTBcXFxcdTA3MTItXFxcXHUwNzJGXFxcXHUwNzRELVxcXFx1MDdBNVxcXFx1MDdCMVxcXFx1MDdDQS1cXFxcdTA3RUFcXFxcdTA3RjRcXFxcdTA3RjVcXFxcdTA3RkFcXFxcdTA4MDAtXFxcXHUwODE1XFxcXHUwODFBXFxcXHUwODI0XFxcXHUwODI4XFxcXHUwODQwLVxcXFx1MDg1OFxcXFx1MDhBMC1cXFxcdTA4QjJcXFxcdTA5MDQtXFxcXHUwOTM5XFxcXHUwOTNEXFxcXHUwOTUwXFxcXHUwOTU4LVxcXFx1MDk2MVxcXFx1MDk3MS1cXFxcdTA5ODBcXFxcdTA5ODUtXFxcXHUwOThDXFxcXHUwOThGXFxcXHUwOTkwXFxcXHUwOTkzLVxcXFx1MDlBOFxcXFx1MDlBQS1cXFxcdTA5QjBcXFxcdTA5QjJcXFxcdTA5QjYtXFxcXHUwOUI5XFxcXHUwOUJEXFxcXHUwOUNFXFxcXHUwOURDXFxcXHUwOUREXFxcXHUwOURGLVxcXFx1MDlFMVxcXFx1MDlGMFxcXFx1MDlGMVxcXFx1MEEwNS1cXFxcdTBBMEFcXFxcdTBBMEZcXFxcdTBBMTBcXFxcdTBBMTMtXFxcXHUwQTI4XFxcXHUwQTJBLVxcXFx1MEEzMFxcXFx1MEEzMlxcXFx1MEEzM1xcXFx1MEEzNVxcXFx1MEEzNlxcXFx1MEEzOFxcXFx1MEEzOVxcXFx1MEE1OS1cXFxcdTBBNUNcXFxcdTBBNUVcXFxcdTBBNzItXFxcXHUwQTc0XFxcXHUwQTg1LVxcXFx1MEE4RFxcXFx1MEE4Ri1cXFxcdTBBOTFcXFxcdTBBOTMtXFxcXHUwQUE4XFxcXHUwQUFBLVxcXFx1MEFCMFxcXFx1MEFCMlxcXFx1MEFCM1xcXFx1MEFCNS1cXFxcdTBBQjlcXFxcdTBBQkRcXFxcdTBBRDBcXFxcdTBBRTBcXFxcdTBBRTFcXFxcdTBCMDUtXFxcXHUwQjBDXFxcXHUwQjBGXFxcXHUwQjEwXFxcXHUwQjEzLVxcXFx1MEIyOFxcXFx1MEIyQS1cXFxcdTBCMzBcXFxcdTBCMzJcXFxcdTBCMzNcXFxcdTBCMzUtXFxcXHUwQjM5XFxcXHUwQjNEXFxcXHUwQjVDXFxcXHUwQjVEXFxcXHUwQjVGLVxcXFx1MEI2MVxcXFx1MEI3MVxcXFx1MEI4M1xcXFx1MEI4NS1cXFxcdTBCOEFcXFxcdTBCOEUtXFxcXHUwQjkwXFxcXHUwQjkyLVxcXFx1MEI5NVxcXFx1MEI5OVxcXFx1MEI5QVxcXFx1MEI5Q1xcXFx1MEI5RVxcXFx1MEI5RlxcXFx1MEJBM1xcXFx1MEJBNFxcXFx1MEJBOC1cXFxcdTBCQUFcXFxcdTBCQUUtXFxcXHUwQkI5XFxcXHUwQkQwXFxcXHUwQzA1LVxcXFx1MEMwQ1xcXFx1MEMwRS1cXFxcdTBDMTBcXFxcdTBDMTItXFxcXHUwQzI4XFxcXHUwQzJBLVxcXFx1MEMzOVxcXFx1MEMzRFxcXFx1MEM1OFxcXFx1MEM1OVxcXFx1MEM2MFxcXFx1MEM2MVxcXFx1MEM4NS1cXFxcdTBDOENcXFxcdTBDOEUtXFxcXHUwQzkwXFxcXHUwQzkyLVxcXFx1MENBOFxcXFx1MENBQS1cXFxcdTBDQjNcXFxcdTBDQjUtXFxcXHUwQ0I5XFxcXHUwQ0JEXFxcXHUwQ0RFXFxcXHUwQ0UwXFxcXHUwQ0UxXFxcXHUwQ0YxXFxcXHUwQ0YyXFxcXHUwRDA1LVxcXFx1MEQwQ1xcXFx1MEQwRS1cXFxcdTBEMTBcXFxcdTBEMTItXFxcXHUwRDNBXFxcXHUwRDNEXFxcXHUwRDRFXFxcXHUwRDYwXFxcXHUwRDYxXFxcXHUwRDdBLVxcXFx1MEQ3RlxcXFx1MEQ4NS1cXFxcdTBEOTZcXFxcdTBEOUEtXFxcXHUwREIxXFxcXHUwREIzLVxcXFx1MERCQlxcXFx1MERCRFxcXFx1MERDMC1cXFxcdTBEQzZcXFxcdTBFMDEtXFxcXHUwRTMwXFxcXHUwRTMyXFxcXHUwRTMzXFxcXHUwRTQwLVxcXFx1MEU0NlxcXFx1MEU4MVxcXFx1MEU4MlxcXFx1MEU4NFxcXFx1MEU4N1xcXFx1MEU4OFxcXFx1MEU4QVxcXFx1MEU4RFxcXFx1MEU5NC1cXFxcdTBFOTdcXFxcdTBFOTktXFxcXHUwRTlGXFxcXHUwRUExLVxcXFx1MEVBM1xcXFx1MEVBNVxcXFx1MEVBN1xcXFx1MEVBQVxcXFx1MEVBQlxcXFx1MEVBRC1cXFxcdTBFQjBcXFxcdTBFQjJcXFxcdTBFQjNcXFxcdTBFQkRcXFxcdTBFQzAtXFxcXHUwRUM0XFxcXHUwRUM2XFxcXHUwRURDLVxcXFx1MEVERlxcXFx1MEYwMFxcXFx1MEY0MC1cXFxcdTBGNDdcXFxcdTBGNDktXFxcXHUwRjZDXFxcXHUwRjg4LVxcXFx1MEY4Q1xcXFx1MTAwMC1cXFxcdTEwMkFcXFxcdTEwM0ZcXFxcdTEwNTAtXFxcXHUxMDU1XFxcXHUxMDVBLVxcXFx1MTA1RFxcXFx1MTA2MVxcXFx1MTA2NVxcXFx1MTA2NlxcXFx1MTA2RS1cXFxcdTEwNzBcXFxcdTEwNzUtXFxcXHUxMDgxXFxcXHUxMDhFXFxcXHUxMEEwLVxcXFx1MTBDNVxcXFx1MTBDN1xcXFx1MTBDRFxcXFx1MTBEMC1cXFxcdTEwRkFcXFxcdTEwRkMtXFxcXHUxMjQ4XFxcXHUxMjRBLVxcXFx1MTI0RFxcXFx1MTI1MC1cXFxcdTEyNTZcXFxcdTEyNThcXFxcdTEyNUEtXFxcXHUxMjVEXFxcXHUxMjYwLVxcXFx1MTI4OFxcXFx1MTI4QS1cXFxcdTEyOERcXFxcdTEyOTAtXFxcXHUxMkIwXFxcXHUxMkIyLVxcXFx1MTJCNVxcXFx1MTJCOC1cXFxcdTEyQkVcXFxcdTEyQzBcXFxcdTEyQzItXFxcXHUxMkM1XFxcXHUxMkM4LVxcXFx1MTJENlxcXFx1MTJEOC1cXFxcdTEzMTBcXFxcdTEzMTItXFxcXHUxMzE1XFxcXHUxMzE4LVxcXFx1MTM1QVxcXFx1MTM4MC1cXFxcdTEzOEZcXFxcdTEzQTAtXFxcXHUxM0Y0XFxcXHUxNDAxLVxcXFx1MTY2Q1xcXFx1MTY2Ri1cXFxcdTE2N0ZcXFxcdTE2ODEtXFxcXHUxNjlBXFxcXHUxNkEwLVxcXFx1MTZFQVxcXFx1MTZFRS1cXFxcdTE2RjhcXFxcdTE3MDAtXFxcXHUxNzBDXFxcXHUxNzBFLVxcXFx1MTcxMVxcXFx1MTcyMC1cXFxcdTE3MzFcXFxcdTE3NDAtXFxcXHUxNzUxXFxcXHUxNzYwLVxcXFx1MTc2Q1xcXFx1MTc2RS1cXFxcdTE3NzBcXFxcdTE3ODAtXFxcXHUxN0IzXFxcXHUxN0Q3XFxcXHUxN0RDXFxcXHUxODIwLVxcXFx1MTg3N1xcXFx1MTg4MC1cXFxcdTE4QThcXFxcdTE4QUFcXFxcdTE4QjAtXFxcXHUxOEY1XFxcXHUxOTAwLVxcXFx1MTkxRVxcXFx1MTk1MC1cXFxcdTE5NkRcXFxcdTE5NzAtXFxcXHUxOTc0XFxcXHUxOTgwLVxcXFx1MTlBQlxcXFx1MTlDMS1cXFxcdTE5QzdcXFxcdTFBMDAtXFxcXHUxQTE2XFxcXHUxQTIwLVxcXFx1MUE1NFxcXFx1MUFBN1xcXFx1MUIwNS1cXFxcdTFCMzNcXFxcdTFCNDUtXFxcXHUxQjRCXFxcXHUxQjgzLVxcXFx1MUJBMFxcXFx1MUJBRVxcXFx1MUJBRlxcXFx1MUJCQS1cXFxcdTFCRTVcXFxcdTFDMDAtXFxcXHUxQzIzXFxcXHUxQzRELVxcXFx1MUM0RlxcXFx1MUM1QS1cXFxcdTFDN0RcXFxcdTFDRTktXFxcXHUxQ0VDXFxcXHUxQ0VFLVxcXFx1MUNGMVxcXFx1MUNGNVxcXFx1MUNGNlxcXFx1MUQwMC1cXFxcdTFEQkZcXFxcdTFFMDAtXFxcXHUxRjE1XFxcXHUxRjE4LVxcXFx1MUYxRFxcXFx1MUYyMC1cXFxcdTFGNDVcXFxcdTFGNDgtXFxcXHUxRjREXFxcXHUxRjUwLVxcXFx1MUY1N1xcXFx1MUY1OVxcXFx1MUY1QlxcXFx1MUY1RFxcXFx1MUY1Ri1cXFxcdTFGN0RcXFxcdTFGODAtXFxcXHUxRkI0XFxcXHUxRkI2LVxcXFx1MUZCQ1xcXFx1MUZCRVxcXFx1MUZDMi1cXFxcdTFGQzRcXFxcdTFGQzYtXFxcXHUxRkNDXFxcXHUxRkQwLVxcXFx1MUZEM1xcXFx1MUZENi1cXFxcdTFGREJcXFxcdTFGRTAtXFxcXHUxRkVDXFxcXHUxRkYyLVxcXFx1MUZGNFxcXFx1MUZGNi1cXFxcdTFGRkNcXFxcdTIwNzFcXFxcdTIwN0ZcXFxcdTIwOTAtXFxcXHUyMDlDXFxcXHUyMTAyXFxcXHUyMTA3XFxcXHUyMTBBLVxcXFx1MjExM1xcXFx1MjExNVxcXFx1MjExOS1cXFxcdTIxMURcXFxcdTIxMjRcXFxcdTIxMjZcXFxcdTIxMjhcXFxcdTIxMkEtXFxcXHUyMTJEXFxcXHUyMTJGLVxcXFx1MjEzOVxcXFx1MjEzQy1cXFxcdTIxM0ZcXFxcdTIxNDUtXFxcXHUyMTQ5XFxcXHUyMTRFXFxcXHUyMTYwLVxcXFx1MjE4OFxcXFx1MkMwMC1cXFxcdTJDMkVcXFxcdTJDMzAtXFxcXHUyQzVFXFxcXHUyQzYwLVxcXFx1MkNFNFxcXFx1MkNFQi1cXFxcdTJDRUVcXFxcdTJDRjJcXFxcdTJDRjNcXFxcdTJEMDAtXFxcXHUyRDI1XFxcXHUyRDI3XFxcXHUyRDJEXFxcXHUyRDMwLVxcXFx1MkQ2N1xcXFx1MkQ2RlxcXFx1MkQ4MC1cXFxcdTJEOTZcXFxcdTJEQTAtXFxcXHUyREE2XFxcXHUyREE4LVxcXFx1MkRBRVxcXFx1MkRCMC1cXFxcdTJEQjZcXFxcdTJEQjgtXFxcXHUyREJFXFxcXHUyREMwLVxcXFx1MkRDNlxcXFx1MkRDOC1cXFxcdTJEQ0VcXFxcdTJERDAtXFxcXHUyREQ2XFxcXHUyREQ4LVxcXFx1MkRERVxcXFx1MkUyRlxcXFx1MzAwNS1cXFxcdTMwMDdcXFxcdTMwMjEtXFxcXHUzMDI5XFxcXHUzMDMxLVxcXFx1MzAzNVxcXFx1MzAzOC1cXFxcdTMwM0NcXFxcdTMwNDEtXFxcXHUzMDk2XFxcXHUzMDlELVxcXFx1MzA5RlxcXFx1MzBBMS1cXFxcdTMwRkFcXFxcdTMwRkMtXFxcXHUzMEZGXFxcXHUzMTA1LVxcXFx1MzEyRFxcXFx1MzEzMS1cXFxcdTMxOEVcXFxcdTMxQTAtXFxcXHUzMUJBXFxcXHUzMUYwLVxcXFx1MzFGRlxcXFx1MzQwMC1cXFxcdTREQjVcXFxcdTRFMDAtXFxcXHU5RkNDXFxcXHVBMDAwLVxcXFx1QTQ4Q1xcXFx1QTREMC1cXFxcdUE0RkRcXFxcdUE1MDAtXFxcXHVBNjBDXFxcXHVBNjEwLVxcXFx1QTYxRlxcXFx1QTYyQVxcXFx1QTYyQlxcXFx1QTY0MC1cXFxcdUE2NkVcXFxcdUE2N0YtXFxcXHVBNjlEXFxcXHVBNkEwLVxcXFx1QTZFRlxcXFx1QTcxNy1cXFxcdUE3MUZcXFxcdUE3MjItXFxcXHVBNzg4XFxcXHVBNzhCLVxcXFx1QTc4RVxcXFx1QTc5MC1cXFxcdUE3QURcXFxcdUE3QjBcXFxcdUE3QjFcXFxcdUE3RjctXFxcXHVBODAxXFxcXHVBODAzLVxcXFx1QTgwNVxcXFx1QTgwNy1cXFxcdUE4MEFcXFxcdUE4MEMtXFxcXHVBODIyXFxcXHVBODQwLVxcXFx1QTg3M1xcXFx1QTg4Mi1cXFxcdUE4QjNcXFxcdUE4RjItXFxcXHVBOEY3XFxcXHVBOEZCXFxcXHVBOTBBLVxcXFx1QTkyNVxcXFx1QTkzMC1cXFxcdUE5NDZcXFxcdUE5NjAtXFxcXHVBOTdDXFxcXHVBOTg0LVxcXFx1QTlCMlxcXFx1QTlDRlxcXFx1QTlFMC1cXFxcdUE5RTRcXFxcdUE5RTYtXFxcXHVBOUVGXFxcXHVBOUZBLVxcXFx1QTlGRVxcXFx1QUEwMC1cXFxcdUFBMjhcXFxcdUFBNDAtXFxcXHVBQTQyXFxcXHVBQTQ0LVxcXFx1QUE0QlxcXFx1QUE2MC1cXFxcdUFBNzZcXFxcdUFBN0FcXFxcdUFBN0UtXFxcXHVBQUFGXFxcXHVBQUIxXFxcXHVBQUI1XFxcXHVBQUI2XFxcXHVBQUI5LVxcXFx1QUFCRFxcXFx1QUFDMFxcXFx1QUFDMlxcXFx1QUFEQi1cXFxcdUFBRERcXFxcdUFBRTAtXFxcXHVBQUVBXFxcXHVBQUYyLVxcXFx1QUFGNFxcXFx1QUIwMS1cXFxcdUFCMDZcXFxcdUFCMDktXFxcXHVBQjBFXFxcXHVBQjExLVxcXFx1QUIxNlxcXFx1QUIyMC1cXFxcdUFCMjZcXFxcdUFCMjgtXFxcXHVBQjJFXFxcXHVBQjMwLVxcXFx1QUI1QVxcXFx1QUI1Qy1cXFxcdUFCNUZcXFxcdUFCNjRcXFxcdUFCNjVcXFxcdUFCQzAtXFxcXHVBQkUyXFxcXHVBQzAwLVxcXFx1RDdBM1xcXFx1RDdCMC1cXFxcdUQ3QzZcXFxcdUQ3Q0ItXFxcXHVEN0ZCXFxcXHVGOTAwLVxcXFx1RkE2RFxcXFx1RkE3MC1cXFxcdUZBRDlcXFxcdUZCMDAtXFxcXHVGQjA2XFxcXHVGQjEzLVxcXFx1RkIxN1xcXFx1RkIxRFxcXFx1RkIxRi1cXFxcdUZCMjhcXFxcdUZCMkEtXFxcXHVGQjM2XFxcXHVGQjM4LVxcXFx1RkIzQ1xcXFx1RkIzRVxcXFx1RkI0MFxcXFx1RkI0MVxcXFx1RkI0M1xcXFx1RkI0NFxcXFx1RkI0Ni1cXFxcdUZCQjFcXFxcdUZCRDMtXFxcXHVGRDNEXFxcXHVGRDUwLVxcXFx1RkQ4RlxcXFx1RkQ5Mi1cXFxcdUZEQzdcXFxcdUZERjAtXFxcXHVGREZCXFxcXHVGRTcwLVxcXFx1RkU3NFxcXFx1RkU3Ni1cXFxcdUZFRkNcXFxcdUZGMjEtXFxcXHVGRjNBXFxcXHVGRjQxLVxcXFx1RkY1QVxcXFx1RkY2Ni1cXFxcdUZGQkVcXFxcdUZGQzItXFxcXHVGRkM3XFxcXHVGRkNBLVxcXFx1RkZDRlxcXFx1RkZEMi1cXFxcdUZGRDdcXFxcdUZGREEtXFxcXHVGRkRDXVwiKSxkaWdpdDpuZXcgUmVnRXhwKFwiW1xcXFx1MDAzMC1cXFxcdTAwMzlcXFxcdTA2NjAtXFxcXHUwNjY5XFxcXHUwNkYwLVxcXFx1MDZGOVxcXFx1MDdDMC1cXFxcdTA3QzlcXFxcdTA5NjYtXFxcXHUwOTZGXFxcXHUwOUU2LVxcXFx1MDlFRlxcXFx1MEE2Ni1cXFxcdTBBNkZcXFxcdTBBRTYtXFxcXHUwQUVGXFxcXHUwQjY2LVxcXFx1MEI2RlxcXFx1MEJFNi1cXFxcdTBCRUZcXFxcdTBDNjYtXFxcXHUwQzZGXFxcXHUwQ0U2LVxcXFx1MENFRlxcXFx1MEQ2Ni1cXFxcdTBENkZcXFxcdTBERTYtXFxcXHUwREVGXFxcXHUwRTUwLVxcXFx1MEU1OVxcXFx1MEVEMC1cXFxcdTBFRDlcXFxcdTBGMjAtXFxcXHUwRjI5XFxcXHUxMDQwLVxcXFx1MTA0OVxcXFx1MTA5MC1cXFxcdTEwOTlcXFxcdTE3RTAtXFxcXHUxN0U5XFxcXHUxODEwLVxcXFx1MTgxOVxcXFx1MTk0Ni1cXFxcdTE5NEZcXFxcdTE5RDAtXFxcXHUxOUQ5XFxcXHUxQTgwLVxcXFx1MUE4OVxcXFx1MUE5MC1cXFxcdTFBOTlcXFxcdTFCNTAtXFxcXHUxQjU5XFxcXHUxQkIwLVxcXFx1MUJCOVxcXFx1MUM0MC1cXFxcdTFDNDlcXFxcdTFDNTAtXFxcXHUxQzU5XFxcXHVBNjIwLVxcXFx1QTYyOVxcXFx1QThEMC1cXFxcdUE4RDlcXFxcdUE5MDAtXFxcXHVBOTA5XFxcXHVBOUQwLVxcXFx1QTlEOVxcXFx1QTlGMC1cXFxcdUE5RjlcXFxcdUFBNTAtXFxcXHVBQTU5XFxcXHVBQkYwLVxcXFx1QUJGOVxcXFx1RkYxMC1cXFxcdUZGMTldXCIpLG5vbl9zcGFjaW5nX21hcms6bmV3IFJlZ0V4cChcIltcXFxcdTAzMDAtXFxcXHUwMzZGXFxcXHUwNDgzLVxcXFx1MDQ4N1xcXFx1MDU5MS1cXFxcdTA1QkRcXFxcdTA1QkZcXFxcdTA1QzFcXFxcdTA1QzJcXFxcdTA1QzRcXFxcdTA1QzVcXFxcdTA1QzdcXFxcdTA2MTAtXFxcXHUwNjFBXFxcXHUwNjRCLVxcXFx1MDY1RVxcXFx1MDY3MFxcXFx1MDZENi1cXFxcdTA2RENcXFxcdTA2REYtXFxcXHUwNkU0XFxcXHUwNkU3XFxcXHUwNkU4XFxcXHUwNkVBLVxcXFx1MDZFRFxcXFx1MDcxMVxcXFx1MDczMC1cXFxcdTA3NEFcXFxcdTA3QTYtXFxcXHUwN0IwXFxcXHUwN0VCLVxcXFx1MDdGM1xcXFx1MDgxNi1cXFxcdTA4MTlcXFxcdTA4MUItXFxcXHUwODIzXFxcXHUwODI1LVxcXFx1MDgyN1xcXFx1MDgyOS1cXFxcdTA4MkRcXFxcdTA5MDAtXFxcXHUwOTAyXFxcXHUwOTNDXFxcXHUwOTQxLVxcXFx1MDk0OFxcXFx1MDk0RFxcXFx1MDk1MS1cXFxcdTA5NTVcXFxcdTA5NjJcXFxcdTA5NjNcXFxcdTA5ODFcXFxcdTA5QkNcXFxcdTA5QzEtXFxcXHUwOUM0XFxcXHUwOUNEXFxcXHUwOUUyXFxcXHUwOUUzXFxcXHUwQTAxXFxcXHUwQTAyXFxcXHUwQTNDXFxcXHUwQTQxXFxcXHUwQTQyXFxcXHUwQTQ3XFxcXHUwQTQ4XFxcXHUwQTRCLVxcXFx1MEE0RFxcXFx1MEE1MVxcXFx1MEE3MFxcXFx1MEE3MVxcXFx1MEE3NVxcXFx1MEE4MVxcXFx1MEE4MlxcXFx1MEFCQ1xcXFx1MEFDMS1cXFxcdTBBQzVcXFxcdTBBQzdcXFxcdTBBQzhcXFxcdTBBQ0RcXFxcdTBBRTJcXFxcdTBBRTNcXFxcdTBCMDFcXFxcdTBCM0NcXFxcdTBCM0ZcXFxcdTBCNDEtXFxcXHUwQjQ0XFxcXHUwQjREXFxcXHUwQjU2XFxcXHUwQjYyXFxcXHUwQjYzXFxcXHUwQjgyXFxcXHUwQkMwXFxcXHUwQkNEXFxcXHUwQzNFLVxcXFx1MEM0MFxcXFx1MEM0Ni1cXFxcdTBDNDhcXFxcdTBDNEEtXFxcXHUwQzREXFxcXHUwQzU1XFxcXHUwQzU2XFxcXHUwQzYyXFxcXHUwQzYzXFxcXHUwQ0JDXFxcXHUwQ0JGXFxcXHUwQ0M2XFxcXHUwQ0NDXFxcXHUwQ0NEXFxcXHUwQ0UyXFxcXHUwQ0UzXFxcXHUwRDQxLVxcXFx1MEQ0NFxcXFx1MEQ0RFxcXFx1MEQ2MlxcXFx1MEQ2M1xcXFx1MERDQVxcXFx1MEREMi1cXFxcdTBERDRcXFxcdTBERDZcXFxcdTBFMzFcXFxcdTBFMzQtXFxcXHUwRTNBXFxcXHUwRTQ3LVxcXFx1MEU0RVxcXFx1MEVCMVxcXFx1MEVCNC1cXFxcdTBFQjlcXFxcdTBFQkJcXFxcdTBFQkNcXFxcdTBFQzgtXFxcXHUwRUNEXFxcXHUwRjE4XFxcXHUwRjE5XFxcXHUwRjM1XFxcXHUwRjM3XFxcXHUwRjM5XFxcXHUwRjcxLVxcXFx1MEY3RVxcXFx1MEY4MC1cXFxcdTBGODRcXFxcdTBGODZcXFxcdTBGODdcXFxcdTBGOTAtXFxcXHUwRjk3XFxcXHUwRjk5LVxcXFx1MEZCQ1xcXFx1MEZDNlxcXFx1MTAyRC1cXFxcdTEwMzBcXFxcdTEwMzItXFxcXHUxMDM3XFxcXHUxMDM5XFxcXHUxMDNBXFxcXHUxMDNEXFxcXHUxMDNFXFxcXHUxMDU4XFxcXHUxMDU5XFxcXHUxMDVFLVxcXFx1MTA2MFxcXFx1MTA3MS1cXFxcdTEwNzRcXFxcdTEwODJcXFxcdTEwODVcXFxcdTEwODZcXFxcdTEwOERcXFxcdTEwOURcXFxcdTEzNUZcXFxcdTE3MTItXFxcXHUxNzE0XFxcXHUxNzMyLVxcXFx1MTczNFxcXFx1MTc1MlxcXFx1MTc1M1xcXFx1MTc3MlxcXFx1MTc3M1xcXFx1MTdCNy1cXFxcdTE3QkRcXFxcdTE3QzZcXFxcdTE3QzktXFxcXHUxN0QzXFxcXHUxN0REXFxcXHUxODBCLVxcXFx1MTgwRFxcXFx1MThBOVxcXFx1MTkyMC1cXFxcdTE5MjJcXFxcdTE5MjdcXFxcdTE5MjhcXFxcdTE5MzJcXFxcdTE5MzktXFxcXHUxOTNCXFxcXHUxQTE3XFxcXHUxQTE4XFxcXHUxQTU2XFxcXHUxQTU4LVxcXFx1MUE1RVxcXFx1MUE2MFxcXFx1MUE2MlxcXFx1MUE2NS1cXFxcdTFBNkNcXFxcdTFBNzMtXFxcXHUxQTdDXFxcXHUxQTdGXFxcXHUxQjAwLVxcXFx1MUIwM1xcXFx1MUIzNFxcXFx1MUIzNi1cXFxcdTFCM0FcXFxcdTFCM0NcXFxcdTFCNDJcXFxcdTFCNkItXFxcXHUxQjczXFxcXHUxQjgwXFxcXHUxQjgxXFxcXHUxQkEyLVxcXFx1MUJBNVxcXFx1MUJBOFxcXFx1MUJBOVxcXFx1MUMyQy1cXFxcdTFDMzNcXFxcdTFDMzZcXFxcdTFDMzdcXFxcdTFDRDAtXFxcXHUxQ0QyXFxcXHUxQ0Q0LVxcXFx1MUNFMFxcXFx1MUNFMi1cXFxcdTFDRThcXFxcdTFDRURcXFxcdTFEQzAtXFxcXHUxREU2XFxcXHUxREZELVxcXFx1MURGRlxcXFx1MjBEMC1cXFxcdTIwRENcXFxcdTIwRTFcXFxcdTIwRTUtXFxcXHUyMEYwXFxcXHUyQ0VGLVxcXFx1MkNGMVxcXFx1MkRFMC1cXFxcdTJERkZcXFxcdTMwMkEtXFxcXHUzMDJGXFxcXHUzMDk5XFxcXHUzMDlBXFxcXHVBNjZGXFxcXHVBNjdDXFxcXHVBNjdEXFxcXHVBNkYwXFxcXHVBNkYxXFxcXHVBODAyXFxcXHVBODA2XFxcXHVBODBCXFxcXHVBODI1XFxcXHVBODI2XFxcXHVBOEM0XFxcXHVBOEUwLVxcXFx1QThGMVxcXFx1QTkyNi1cXFxcdUE5MkRcXFxcdUE5NDctXFxcXHVBOTUxXFxcXHVBOTgwLVxcXFx1QTk4MlxcXFx1QTlCM1xcXFx1QTlCNi1cXFxcdUE5QjlcXFxcdUE5QkNcXFxcdUFBMjktXFxcXHVBQTJFXFxcXHVBQTMxXFxcXHVBQTMyXFxcXHVBQTM1XFxcXHVBQTM2XFxcXHVBQTQzXFxcXHVBQTRDXFxcXHVBQUIwXFxcXHVBQUIyLVxcXFx1QUFCNFxcXFx1QUFCN1xcXFx1QUFCOFxcXFx1QUFCRVxcXFx1QUFCRlxcXFx1QUFDMVxcXFx1QUJFNVxcXFx1QUJFOFxcXFx1QUJFRFxcXFx1RkIxRVxcXFx1RkUwMC1cXFxcdUZFMEZcXFxcdUZFMjAtXFxcXHVGRTI2XVwiKSxzcGFjZV9jb21iaW5pbmdfbWFyazpuZXcgUmVnRXhwKFwiW1xcXFx1MDkwM1xcXFx1MDkzRS1cXFxcdTA5NDBcXFxcdTA5NDktXFxcXHUwOTRDXFxcXHUwOTRFXFxcXHUwOTgyXFxcXHUwOTgzXFxcXHUwOUJFLVxcXFx1MDlDMFxcXFx1MDlDN1xcXFx1MDlDOFxcXFx1MDlDQlxcXFx1MDlDQ1xcXFx1MDlEN1xcXFx1MEEwM1xcXFx1MEEzRS1cXFxcdTBBNDBcXFxcdTBBODNcXFxcdTBBQkUtXFxcXHUwQUMwXFxcXHUwQUM5XFxcXHUwQUNCXFxcXHUwQUNDXFxcXHUwQjAyXFxcXHUwQjAzXFxcXHUwQjNFXFxcXHUwQjQwXFxcXHUwQjQ3XFxcXHUwQjQ4XFxcXHUwQjRCXFxcXHUwQjRDXFxcXHUwQjU3XFxcXHUwQkJFXFxcXHUwQkJGXFxcXHUwQkMxXFxcXHUwQkMyXFxcXHUwQkM2LVxcXFx1MEJDOFxcXFx1MEJDQS1cXFxcdTBCQ0NcXFxcdTBCRDdcXFxcdTBDMDEtXFxcXHUwQzAzXFxcXHUwQzQxLVxcXFx1MEM0NFxcXFx1MEM4MlxcXFx1MEM4M1xcXFx1MENCRVxcXFx1MENDMC1cXFxcdTBDQzRcXFxcdTBDQzdcXFxcdTBDQzhcXFxcdTBDQ0FcXFxcdTBDQ0JcXFxcdTBDRDVcXFxcdTBDRDZcXFxcdTBEMDJcXFxcdTBEMDNcXFxcdTBEM0UtXFxcXHUwRDQwXFxcXHUwRDQ2LVxcXFx1MEQ0OFxcXFx1MEQ0QS1cXFxcdTBENENcXFxcdTBENTdcXFxcdTBEODJcXFxcdTBEODNcXFxcdTBEQ0YtXFxcXHUwREQxXFxcXHUwREQ4LVxcXFx1MERERlxcXFx1MERGMlxcXFx1MERGM1xcXFx1MEYzRVxcXFx1MEYzRlxcXFx1MEY3RlxcXFx1MTAyQlxcXFx1MTAyQ1xcXFx1MTAzMVxcXFx1MTAzOFxcXFx1MTAzQlxcXFx1MTAzQ1xcXFx1MTA1NlxcXFx1MTA1N1xcXFx1MTA2Mi1cXFxcdTEwNjRcXFxcdTEwNjctXFxcXHUxMDZEXFxcXHUxMDgzXFxcXHUxMDg0XFxcXHUxMDg3LVxcXFx1MTA4Q1xcXFx1MTA4RlxcXFx1MTA5QS1cXFxcdTEwOUNcXFxcdTE3QjZcXFxcdTE3QkUtXFxcXHUxN0M1XFxcXHUxN0M3XFxcXHUxN0M4XFxcXHUxOTIzLVxcXFx1MTkyNlxcXFx1MTkyOS1cXFxcdTE5MkJcXFxcdTE5MzBcXFxcdTE5MzFcXFxcdTE5MzMtXFxcXHUxOTM4XFxcXHUxOUIwLVxcXFx1MTlDMFxcXFx1MTlDOFxcXFx1MTlDOVxcXFx1MUExOS1cXFxcdTFBMUJcXFxcdTFBNTVcXFxcdTFBNTdcXFxcdTFBNjFcXFxcdTFBNjNcXFxcdTFBNjRcXFxcdTFBNkQtXFxcXHUxQTcyXFxcXHUxQjA0XFxcXHUxQjM1XFxcXHUxQjNCXFxcXHUxQjNELVxcXFx1MUI0MVxcXFx1MUI0M1xcXFx1MUI0NFxcXFx1MUI4MlxcXFx1MUJBMVxcXFx1MUJBNlxcXFx1MUJBN1xcXFx1MUJBQVxcXFx1MUMyNC1cXFxcdTFDMkJcXFxcdTFDMzRcXFxcdTFDMzVcXFxcdTFDRTFcXFxcdTFDRjJcXFxcdUE4MjNcXFxcdUE4MjRcXFxcdUE4MjdcXFxcdUE4ODBcXFxcdUE4ODFcXFxcdUE4QjQtXFxcXHVBOEMzXFxcXHVBOTUyXFxcXHVBOTUzXFxcXHVBOTgzXFxcXHVBOUI0XFxcXHVBOUI1XFxcXHVBOUJBXFxcXHVBOUJCXFxcXHVBOUJELVxcXFx1QTlDMFxcXFx1QUEyRlxcXFx1QUEzMFxcXFx1QUEzM1xcXFx1QUEzNFxcXFx1QUE0RFxcXFx1QUE3QlxcXFx1QUJFM1xcXFx1QUJFNFxcXFx1QUJFNlxcXFx1QUJFN1xcXFx1QUJFOVxcXFx1QUJFQVxcXFx1QUJFQ11cIiksY29ubmVjdG9yX3B1bmN0dWF0aW9uOm5ldyBSZWdFeHAoXCJbXFxcXHUwMDVGXFxcXHUyMDNGXFxcXHUyMDQwXFxcXHUyMDU0XFxcXHVGRTMzXFxcXHVGRTM0XFxcXHVGRTRELVxcXFx1RkU0RlxcXFx1RkYzRl1cIil9O2Z1bmN0aW9uIE9uKGUpe3JldHVybiA5Nzw9ZSYmZTw9MTIyfHw2NTw9ZSYmZTw9OTB8fDE3MDw9ZSYmdS5sZXR0ZXIudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGUpKX1mdW5jdGlvbiAkbihlKXtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgZSYmKGU9ZS5jaGFyQ29kZUF0KDApKSw1NTI5Njw9ZSYmZTw9NTYzMTl9ZnVuY3Rpb24gem4oZSl7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIGUmJihlPWUuY2hhckNvZGVBdCgwKSksNTYzMjA8PWUmJmU8PTU3MzQzfWZ1bmN0aW9uIE1uKGUpe3JldHVybiA0ODw9ZSYmZTw9NTd9ZnVuY3Rpb24gbChlKXtyZXR1cm4hbShlKSYmL15bYS16XyRdW2EtejAtOV8kXSokL2kudGVzdChlKX1mdW5jdGlvbiBxbihlKXtyZXR1cm4gMzY9PWV8fDk1PT1lfHxPbihlKX1mdW5jdGlvbiBqbihlKXt2YXIgbix0LGkscj1lLmNoYXJDb2RlQXQoMCk7cmV0dXJuIHFuKHIpfHxNbihyKXx8ODIwND09cnx8ODIwNT09cnx8KGk9ZSx1Lm5vbl9zcGFjaW5nX21hcmsudGVzdChpKXx8dS5zcGFjZV9jb21iaW5pbmdfbWFyay50ZXN0KGkpKXx8KHQ9ZSx1LmNvbm5lY3Rvcl9wdW5jdHVhdGlvbi50ZXN0KHQpKXx8KG49cix1LmRpZ2l0LnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShuKSkpfWZ1bmN0aW9uIE5uKGUpe3JldHVybi9eW2Etel8kXVthLXowLTlfJF0qJC9pLnRlc3QoZSl9ZnVuY3Rpb24gSG4oZSxuLHQsaSxyKXt0aGlzLm1lc3NhZ2U9ZSx0aGlzLmZpbGVuYW1lPW4sdGhpcy5saW5lPXQsdGhpcy5jb2w9aSx0aGlzLnBvcz1yfWZ1bmN0aW9uIFJuKGUsbix0LGkscil7dGhyb3cgbmV3IEhuKGUsbix0LGkscil9ZnVuY3Rpb24gSW4oZSxuLHQpe3JldHVybiBlLnR5cGU9PW4mJihudWxsPT10fHxlLnZhbHVlPT10KX0oKEhuLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yPUhuKS5wcm90b3R5cGUubmFtZT1cIlN5bnRheEVycm9yXCIsbihIbik7dmFyIFBuPXt9O2Z1bmN0aW9uIFVuKHIsbyxhLHMpe3ZhciB1PXt0ZXh0OnIsZmlsZW5hbWU6byxwb3M6MCx0b2twb3M6MCxsaW5lOjEsdG9rbGluZTowLGNvbDowLHRva2NvbDowLG5ld2xpbmVfYmVmb3JlOiExLHJlZ2V4X2FsbG93ZWQ6ITEsY29tbWVudHNfYmVmb3JlOltdLGRpcmVjdGl2ZXM6e30sZGlyZWN0aXZlX3N0YWNrOltdfTtmdW5jdGlvbiBjKCl7cmV0dXJuIHUudGV4dC5jaGFyQXQodS5wb3MpfWZ1bmN0aW9uIGYoZSxuKXt2YXIgdD11LnRleHQuY2hhckF0KHUucG9zKyspO2lmKGUmJiF0KXRocm93IFBuO3JldHVybiBQKHQpPyh1Lm5ld2xpbmVfYmVmb3JlPXUubmV3bGluZV9iZWZvcmV8fCFuLCsrdS5saW5lLHUuY29sPTAsbnx8XCJcXHJcIiE9dHx8XCJcXG5cIiE9YygpfHwoKyt1LnBvcyx0PVwiXFxuXCIpKTorK3UuY29sLHR9ZnVuY3Rpb24gbChlKXtmb3IoOzA8ZS0tOylmKCl9ZnVuY3Rpb24gcChlKXtyZXR1cm4gdS50ZXh0LnN1YnN0cih1LnBvcyxlLmxlbmd0aCk9PWV9ZnVuY3Rpb24gZCgpe3UudG9rbGluZT11LmxpbmUsdS50b2tjb2w9dS5jb2wsdS50b2twb3M9dS5wb3N9dmFyIGg9ITE7ZnVuY3Rpb24gdihlLG4sdCl7dS5yZWdleF9hbGxvd2VkPVwib3BlcmF0b3JcIj09ZSYmIVZuKG4pfHxcImtleXdvcmRcIj09ZSYmcShuKXx8XCJwdW5jXCI9PWUmJlUobiksXCJwdW5jXCI9PWUmJlwiLlwiPT1uP2g9ITA6dHx8KGg9ITEpO3ZhciBpPXt0eXBlOmUsdmFsdWU6bixsaW5lOnUudG9rbGluZSxjb2w6dS50b2tjb2wscG9zOnUudG9rcG9zLGVuZGxpbmU6dS5saW5lLGVuZGNvbDp1LmNvbCxlbmRwb3M6dS5wb3MsbmxiOnUubmV3bGluZV9iZWZvcmUsZmlsZTpvfTtyZXR1cm4vXig/Om51bXxzdHJpbmd8cmVnZXhwKSQvaS50ZXN0KGUpJiYoaS5yYXc9ci5zdWJzdHJpbmcoaS5wb3MsaS5lbmRwb3MpKSx0fHwoaS5jb21tZW50c19iZWZvcmU9dS5jb21tZW50c19iZWZvcmUsaS5jb21tZW50c19hZnRlcj11LmNvbW1lbnRzX2JlZm9yZT1bXSksdS5uZXdsaW5lX2JlZm9yZT0hMSxuZXcgRihpKX1mdW5jdGlvbiBfKCl7Zm9yKDtJKGMoKSk7KWYoKX1mdW5jdGlvbiBtKGUpe1JuKGUsbyx1LnRva2xpbmUsdS50b2tjb2wsdS50b2twb3MpfWZ1bmN0aW9uIGcocil7dmFyIG89ITEsYT0hMSxzPSExLHU9XCIuXCI9PXIsZT1mdW5jdGlvbihlKXtmb3IodmFyIG4sdD1cIlwiLGk9MDsobj1jKCkpJiZlKG4saSsrKTspdCs9ZigpO3JldHVybiB0fShmdW5jdGlvbihlLG4pe3ZhciB0LGk9ZS5jaGFyQ29kZUF0KDApO3N3aXRjaChpKXtjYXNlIDEyMDpjYXNlIDg4OnJldHVybiFzJiYocz0hMCk7Y2FzZSAxMDE6Y2FzZSA2OTpyZXR1cm4hIXN8fCFvJiYobz1hPSEwKTtjYXNlIDQ1OnJldHVybiBhfHwwPT1uJiYhcjtjYXNlIDQzOnJldHVybiBhO2Nhc2UgYT0hMSw0NjpyZXR1cm4hKHV8fHN8fG8pJiYodT0hMCl9cmV0dXJuIE1uKHQ9aSl8fE9uKHQpfSk7ciYmKGU9citlKSxILnRlc3QoZSkmJkQuaGFzX2RpcmVjdGl2ZShcInVzZSBzdHJpY3RcIikmJm0oXCJMZWdhY3kgb2N0YWwgbGl0ZXJhbHMgYXJlIG5vdCBhbGxvd2VkIGluIHN0cmljdCBtb2RlXCIpO3ZhciBuPWZ1bmN0aW9uKGUpe2lmKE4udGVzdChlKSlyZXR1cm4gcGFyc2VJbnQoZS5zdWJzdHIoMiksMTYpO2lmKEgudGVzdChlKSlyZXR1cm4gcGFyc2VJbnQoZS5zdWJzdHIoMSksOCk7dmFyIG49cGFyc2VGbG9hdChlKTtyZXR1cm4gbj09ZT9uOnZvaWQgMH0oZSk7aWYoIWlzTmFOKG4pKXJldHVybiB2KFwibnVtXCIsbik7bShcIkludmFsaWQgc3ludGF4OiBcIitlKX1mdW5jdGlvbiBiKGUpe3ZhciBuPWYoITAsZSk7c3dpdGNoKG4uY2hhckNvZGVBdCgwKSl7Y2FzZSAxMTA6cmV0dXJuXCJcXG5cIjtjYXNlIDExNDpyZXR1cm5cIlxcclwiO2Nhc2UgMTE2OnJldHVyblwiXFx0XCI7Y2FzZSA5ODpyZXR1cm5cIlxcYlwiO2Nhc2UgMTE4OnJldHVyblwiXFx2XCI7Y2FzZSAxMDI6cmV0dXJuXCJcXGZcIjtjYXNlIDEyMDpyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSh0KDIpKTtjYXNlIDExNzpyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSh0KDQpKTtjYXNlIDEwOnJldHVyblwiXCI7Y2FzZSAxMzppZihcIlxcblwiPT1jKCkpcmV0dXJuIGYoITAsZSksXCJcIn1yZXR1cm5cIjBcIjw9biYmbjw9XCI3XCI/ZnVuY3Rpb24oZSl7dmFyIG49YygpO1wiMFwiPD1uJiZuPD1cIjdcIiYmKGUrPWYoITApKVswXTw9XCIzXCImJlwiMFwiPD0obj1jKCkpJiZuPD1cIjdcIiYmKGUrPWYoITApKTtpZihcIjBcIj09PWUpcmV0dXJuXCJcXDBcIjswPGUubGVuZ3RoJiZELmhhc19kaXJlY3RpdmUoXCJ1c2Ugc3RyaWN0XCIpJiZtKFwiTGVnYWN5IG9jdGFsIGVzY2FwZSBzZXF1ZW5jZXMgYXJlIG5vdCBhbGxvd2VkIGluIHN0cmljdCBtb2RlXCIpO3JldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KGUsOCkpfShuKTpufWZ1bmN0aW9uIHQoZSl7Zm9yKHZhciBuPTA7MDxlOy0tZSl7dmFyIHQ9cGFyc2VJbnQoZighMCksMTYpO2lzTmFOKHQpJiZtKFwiSW52YWxpZCBoZXgtY2hhcmFjdGVyIHBhdHRlcm4gaW4gc3RyaW5nXCIpLG49bjw8NHx0fXJldHVybiBufXZhciB5PW4oXCJVbnRlcm1pbmF0ZWQgc3RyaW5nIGNvbnN0YW50XCIsZnVuY3Rpb24oZSl7Zm9yKHZhciBuPWYoKSx0PVwiXCI7Oyl7dmFyIGk9ZighMCwhMCk7aWYoXCJcXFxcXCI9PWkpaT1iKCEwKTtlbHNlIGlmKFAoaSkpbShcIlVudGVybWluYXRlZCBzdHJpbmcgY29uc3RhbnRcIik7ZWxzZSBpZihpPT1uKWJyZWFrO3QrPWl9dmFyIHI9dihcInN0cmluZ1wiLHQpO3JldHVybiByLnF1b3RlPWUscn0pO2Z1bmN0aW9uIHcoZSl7dmFyIG4sdD11LnJlZ2V4X2FsbG93ZWQsaT1mdW5jdGlvbigpe2Zvcih2YXIgZT11LnRleHQsbj11LnBvcyx0PXUudGV4dC5sZW5ndGg7bjx0Oysrbil7dmFyIGk9ZVtuXTtpZihQKGkpKXJldHVybiBufXJldHVybi0xfSgpO3JldHVybi0xPT1pPyhuPXUudGV4dC5zdWJzdHIodS5wb3MpLHUucG9zPXUudGV4dC5sZW5ndGgpOihuPXUudGV4dC5zdWJzdHJpbmcodS5wb3MsaSksdS5wb3M9aSksdS5jb2w9dS50b2tjb2wrKHUucG9zLXUudG9rcG9zKSx1LmNvbW1lbnRzX2JlZm9yZS5wdXNoKHYoZSxuLCEwKSksdS5yZWdleF9hbGxvd2VkPXQsRH12YXIgZT1uKFwiVW50ZXJtaW5hdGVkIG11bHRpbGluZSBjb21tZW50XCIsZnVuY3Rpb24oKXt2YXIgZT11LnJlZ2V4X2FsbG93ZWQsbj1mdW5jdGlvbihlLG4pe3ZhciB0PXUudGV4dC5pbmRleE9mKGUsdS5wb3MpO2lmKG4mJi0xPT10KXRocm93IFBuO3JldHVybiB0fShcIiovXCIsITApLHQ9dS50ZXh0LnN1YnN0cmluZyh1LnBvcyxuKS5yZXBsYWNlKC9cXHJcXG58XFxyfFxcdTIwMjh8XFx1MjAyOS9nLFwiXFxuXCIpO3JldHVybiBsKHQubGVuZ3RoKzIpLHUuY29tbWVudHNfYmVmb3JlLnB1c2godihcImNvbW1lbnQyXCIsdCwhMCkpLHUucmVnZXhfYWxsb3dlZD1lLER9KTtmdW5jdGlvbiB4KCl7Zm9yKHZhciBlLG4sdD0hMSxpPVwiXCIscj0hMTtudWxsIT0oZT1jKCkpOylpZih0KVwidVwiIT1lJiZtKFwiRXhwZWN0aW5nIFVuaWNvZGVFc2NhcGVTZXF1ZW5jZSAtLSB1WFhYWFwiKSxqbihlPWIoKSl8fG0oXCJVbmljb2RlIGNoYXI6IFwiK2UuY2hhckNvZGVBdCgwKStcIiBpcyBub3QgdmFsaWQgaW4gaWRlbnRpZmllclwiKSxpKz1lLHQ9ITE7ZWxzZSBpZihcIlxcXFxcIj09ZSlyPXQ9ITAsZigpO2Vsc2V7aWYoIWpuKGUpKWJyZWFrO2krPWYoKX1yZXR1cm4gbmUoaSkmJnImJihuPWkuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSxpPVwiXFxcXHVcIitcIjAwMDBcIi5zdWJzdHIobi5sZW5ndGgpK24raS5zbGljZSgxKSksaX12YXIgQT1uKFwiVW50ZXJtaW5hdGVkIHJlZ3VsYXIgZXhwcmVzc2lvblwiLGZ1bmN0aW9uKGUpe2Zvcih2YXIgbix0PSExLGk9ITE7bj1mKCEwKTspaWYoUChuKSltKFwiVW5leHBlY3RlZCBsaW5lIHRlcm1pbmF0b3JcIik7ZWxzZSBpZih0KWUrPVwiXFxcXFwiK24sdD0hMTtlbHNlIGlmKFwiW1wiPT1uKWk9ITAsZSs9bjtlbHNlIGlmKFwiXVwiPT1uJiZpKWk9ITEsZSs9bjtlbHNle2lmKFwiL1wiPT1uJiYhaSlicmVhaztcIlxcXFxcIj09bj90PSEwOmUrPW59dmFyIHI9eCgpO3RyeXt2YXIgbz1uZXcgUmVnRXhwKGUscik7cmV0dXJuIG8ucmF3X3NvdXJjZT1lLHYoXCJyZWdleHBcIixvKX1jYXRjaChlKXttKGUubWVzc2FnZSl9fSk7ZnVuY3Rpb24gRShlKXtyZXR1cm4gdihcIm9wZXJhdG9yXCIsZnVuY3Rpb24gZShuKXtpZighYygpKXJldHVybiBuO3ZhciB0PW4rYygpO3JldHVybiBSKHQpPyhmKCksZSh0KSk6bn0oZXx8ZigpKSl9ZnVuY3Rpb24gaygpe3N3aXRjaChmKCksYygpKXtjYXNlXCIvXCI6cmV0dXJuIGYoKSx3KFwiY29tbWVudDFcIik7Y2FzZVwiKlwiOnJldHVybiBmKCksZSgpfXJldHVybiB1LnJlZ2V4X2FsbG93ZWQ/QShcIlwiKTpFKFwiL1wiKX1mdW5jdGlvbiBuKG4sdCl7cmV0dXJuIGZ1bmN0aW9uKGUpe3RyeXtyZXR1cm4gdChlKX1jYXRjaChlKXtpZihlIT09UG4pdGhyb3cgZTttKG4pfX19ZnVuY3Rpb24gRChlKXtpZihudWxsIT1lKXJldHVybiBBKGUpO2ZvcihzJiYwPT11LnBvcyYmcChcIiMhXCIpJiYoZCgpLGwoMiksdyhcImNvbW1lbnQ1XCIpKTs7KXtpZihfKCksZCgpLGEpe2lmKHAoXCJcXHgzYyEtLVwiKSl7bCg0KSx3KFwiY29tbWVudDNcIik7Y29udGludWV9aWYocChcIi0tXFx4M2VcIikmJnUubmV3bGluZV9iZWZvcmUpe2woMyksdyhcImNvbW1lbnQ0XCIpO2NvbnRpbnVlfX12YXIgbj1jKCk7aWYoIW4pcmV0dXJuIHYoXCJlb2ZcIik7dmFyIHQ9bi5jaGFyQ29kZUF0KDApO3N3aXRjaCh0KXtjYXNlIDM0OmNhc2UgMzk6cmV0dXJuIHkobik7Y2FzZSA0NjpyZXR1cm4gZigpLE1uKGMoKS5jaGFyQ29kZUF0KDApKT9nKFwiLlwiKTp2KFwicHVuY1wiLFwiLlwiKTtjYXNlIDQ3OnZhciBpPWsoKTtpZihpPT09RCljb250aW51ZTtyZXR1cm4gaX1pZihNbih0KSlyZXR1cm4gZygpO2lmKFRuKG4pKXJldHVybiB2KFwicHVuY1wiLGYoKSk7aWYoaihuKSlyZXR1cm4gRSgpO2lmKDkyPT10fHxxbih0KSlyZXR1cm4gdm9pZCAwLHI9eCgpLGg/dihcIm5hbWVcIixyKTpNKHIpP3YoXCJhdG9tXCIscik6bmUocik/UihyKT92KFwib3BlcmF0b3JcIixyKTp2KFwia2V5d29yZFwiLHIpOnYoXCJuYW1lXCIscik7YnJlYWt9dmFyIHI7bShcIlVuZXhwZWN0ZWQgY2hhcmFjdGVyICdcIituK1wiJ1wiKX1yZXR1cm4gRC5jb250ZXh0PWZ1bmN0aW9uKGUpe3JldHVybiBlJiYodT1lKSx1fSxELmFkZF9kaXJlY3RpdmU9ZnVuY3Rpb24oZSl7dS5kaXJlY3RpdmVfc3RhY2tbdS5kaXJlY3RpdmVfc3RhY2subGVuZ3RoLTFdLnB1c2goZSksdm9pZCAwPT09dS5kaXJlY3RpdmVzW2VdP3UuZGlyZWN0aXZlc1tlXT0xOnUuZGlyZWN0aXZlc1tlXSsrfSxELnB1c2hfZGlyZWN0aXZlc19zdGFjaz1mdW5jdGlvbigpe3UuZGlyZWN0aXZlX3N0YWNrLnB1c2goW10pfSxELnBvcF9kaXJlY3RpdmVzX3N0YWNrPWZ1bmN0aW9uKCl7Zm9yKHZhciBlPXUuZGlyZWN0aXZlX3N0YWNrW3UuZGlyZWN0aXZlX3N0YWNrLmxlbmd0aC0xXSxuPTA7bjxlLmxlbmd0aDtuKyspdS5kaXJlY3RpdmVzW2Vbbl1dLS07dS5kaXJlY3RpdmVfc3RhY2sucG9wKCl9LEQuaGFzX2RpcmVjdGl2ZT1mdW5jdGlvbihlKXtyZXR1cm4gMDx1LmRpcmVjdGl2ZXNbZV19LER9dmFyIExuPVcoW1widHlwZW9mXCIsXCJ2b2lkXCIsXCJkZWxldGVcIixcIi0tXCIsXCIrK1wiLFwiIVwiLFwiflwiLFwiLVwiLFwiK1wiXSksVm49VyhbXCItLVwiLFwiKytcIl0pLFluPVcoW1wiPVwiLFwiKz1cIixcIi09XCIsXCIvPVwiLFwiKj1cIixcIiU9XCIsXCI+Pj1cIixcIjw8PVwiLFwiPj4+PVwiLFwifD1cIixcIl49XCIsXCImPVwiXSksSm49ZnVuY3Rpb24oZSxuKXtmb3IodmFyIHQ9MDt0PGUubGVuZ3RoOysrdClmb3IodmFyIGk9ZVt0XSxyPTA7cjxpLmxlbmd0aDsrK3IpbltpW3JdXT10KzE7cmV0dXJuIG59KFtbXCJ8fFwiXSxbXCImJlwiXSxbXCJ8XCJdLFtcIl5cIl0sW1wiJlwiXSxbXCI9PVwiLFwiPT09XCIsXCIhPVwiLFwiIT09XCJdLFtcIjxcIixcIj5cIixcIjw9XCIsXCI+PVwiLFwiaW5cIixcImluc3RhbmNlb2ZcIl0sW1wiPj5cIixcIjw8XCIsXCI+Pj5cIl0sW1wiK1wiLFwiLVwiXSxbXCIqXCIsXCIvXCIsXCIlXCJdXSx7fSksV249VyhbXCJhdG9tXCIsXCJudW1cIixcInN0cmluZ1wiLFwicmVnZXhwXCIsXCJuYW1lXCJdKTtmdW5jdGlvbiBHbihlLHUpe3U9WSh1LHtiYXJlX3JldHVybnM6ITEsZXhwcmVzc2lvbjohMSxmaWxlbmFtZTpudWxsLGh0bWw1X2NvbW1lbnRzOiEwLHNoZWJhbmc6ITAsc3RyaWN0OiExLHRvcGxldmVsOm51bGx9LCEwKTt2YXIgYz17aW5wdXQ6XCJzdHJpbmdcIj09dHlwZW9mIGU/VW4oZSx1LmZpbGVuYW1lLHUuaHRtbDVfY29tbWVudHMsdS5zaGViYW5nKTplLHRva2VuOm51bGwscHJldjpudWxsLHBlZWtlZDpudWxsLGluX2Z1bmN0aW9uOjAsaW5fZGlyZWN0aXZlczohMCxpbl9sb29wOjAsbGFiZWxzOltdfTtmdW5jdGlvbiBmKGUsbil7cmV0dXJuIEluKGMudG9rZW4sZSxuKX1mdW5jdGlvbiBsKCl7cmV0dXJuIGMucGVla2VkfHwoYy5wZWVrZWQ9Yy5pbnB1dCgpKX1mdW5jdGlvbiBwKCl7cmV0dXJuIGMucHJldj1jLnRva2VuLGMucGVla2VkPyhjLnRva2VuPWMucGVla2VkLGMucGVla2VkPW51bGwpOmMudG9rZW49Yy5pbnB1dCgpLGMuaW5fZGlyZWN0aXZlcz1jLmluX2RpcmVjdGl2ZXMmJihcInN0cmluZ1wiPT1jLnRva2VuLnR5cGV8fGYoXCJwdW5jXCIsXCI7XCIpKSxjLnRva2VufWZ1bmN0aW9uIGQoKXtyZXR1cm4gYy5wcmV2fWZ1bmN0aW9uIGgoZSxuLHQsaSl7dmFyIHI9Yy5pbnB1dC5jb250ZXh0KCk7Um4oZSxyLmZpbGVuYW1lLG51bGwhPW4/bjpyLnRva2xpbmUsbnVsbCE9dD90OnIudG9rY29sLG51bGwhPWk/aTpyLnRva3Bvcyl9ZnVuY3Rpb24gdChlLG4pe2gobixlLmxpbmUsZS5jb2wpfWZ1bmN0aW9uIHYoZSl7bnVsbD09ZSYmKGU9Yy50b2tlbiksdChlLFwiVW5leHBlY3RlZCB0b2tlbjogXCIrZS50eXBlK1wiIChcIitlLnZhbHVlK1wiKVwiKX1mdW5jdGlvbiBfKGUsbil7aWYoZihlLG4pKXJldHVybiBwKCk7dChjLnRva2VuLFwiVW5leHBlY3RlZCB0b2tlbiBcIitjLnRva2VuLnR5cGUrXCIgwqtcIitjLnRva2VuLnZhbHVlK1wiwrssIGV4cGVjdGVkIFwiK2UrXCIgwqtcIituK1wiwrtcIil9ZnVuY3Rpb24gbShlKXtyZXR1cm4gXyhcInB1bmNcIixlKX1mdW5jdGlvbiBnKGUpe3JldHVybiBlLm5sYnx8IW9lKGUuY29tbWVudHNfYmVmb3JlLGZ1bmN0aW9uKGUpe3JldHVybiFlLm5sYn0pfWZ1bmN0aW9uIGIoKXtyZXR1cm4hdS5zdHJpY3QmJihmKFwiZW9mXCIpfHxmKFwicHVuY1wiLFwifVwiKXx8ZyhjLnRva2VuKSl9ZnVuY3Rpb24geShlKXtmKFwicHVuY1wiLFwiO1wiKT9wKCk6ZXx8YigpfHx2KCl9ZnVuY3Rpb24gdygpe20oXCIoXCIpO3ZhciBlPVUoITApO3JldHVybiBtKFwiKVwiKSxlfWZ1bmN0aW9uIG4oaSl7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIGU9Yy50b2tlbixuPWkuYXBwbHkobnVsbCxhcmd1bWVudHMpLHQ9ZCgpO3JldHVybiBuLnN0YXJ0PWUsbi5lbmQ9dCxufX1mdW5jdGlvbiB4KCl7KGYoXCJvcGVyYXRvclwiLFwiL1wiKXx8ZihcIm9wZXJhdG9yXCIsXCIvPVwiKSkmJihjLnBlZWtlZD1udWxsLGMudG9rZW49Yy5pbnB1dChjLnRva2VuLnZhbHVlLnN1YnN0cigxKSkpfWMudG9rZW49cCgpO3ZhciBBPW4oZnVuY3Rpb24oZSl7c3dpdGNoKHgoKSxjLnRva2VuLnR5cGUpe2Nhc2VcInN0cmluZ1wiOmlmKGMuaW5fZGlyZWN0aXZlcyl7dmFyIG49bCgpOy0xPT1jLnRva2VuLnJhdy5pbmRleE9mKFwiXFxcXFwiKSYmKEluKG4sXCJwdW5jXCIsXCI7XCIpfHxJbihuLFwicHVuY1wiLFwifVwiKXx8ZyhuKXx8SW4obixcImVvZlwiKSk/Yy5pbnB1dC5hZGRfZGlyZWN0aXZlKGMudG9rZW4udmFsdWUpOmMuaW5fZGlyZWN0aXZlcz0hMX12YXIgdD1jLmluX2RpcmVjdGl2ZXMsaT1FKCk7cmV0dXJuIHQ/bmV3IGZlKGkuYm9keSk6aTtjYXNlXCJudW1cIjpjYXNlXCJyZWdleHBcIjpjYXNlXCJvcGVyYXRvclwiOmNhc2VcImF0b21cIjpyZXR1cm4gRSgpO2Nhc2VcIm5hbWVcIjpyZXR1cm4gSW4obCgpLFwicHVuY1wiLFwiOlwiKT9mdW5jdGlvbigpe3ZhciBuPXEoUSk7VihmdW5jdGlvbihlKXtyZXR1cm4gZS5uYW1lPT1uLm5hbWV9LGMubGFiZWxzKSYmaChcIkxhYmVsIFwiK24ubmFtZStcIiBkZWZpbmVkIHR3aWNlXCIpO20oXCI6XCIpLGMubGFiZWxzLnB1c2gobik7dmFyIGU9QSgpO2MubGFiZWxzLnBvcCgpLGUgaW5zdGFuY2VvZiBfZXx8bi5yZWZlcmVuY2VzLmZvckVhY2goZnVuY3Rpb24oZSl7ZSBpbnN0YW5jZW9mIHplJiYoZT1lLmxhYmVsLnN0YXJ0LGgoXCJDb250aW51ZSBsYWJlbCBgXCIrbi5uYW1lK1wiYCByZWZlcnMgdG8gbm9uLUl0ZXJhdGlvblN0YXRlbWVudC5cIixlLmxpbmUsZS5jb2wsZS5wb3MpKX0pO3JldHVybiBuZXcgdmUoe2JvZHk6ZSxsYWJlbDpufSl9KCk6RSgpO2Nhc2VcInB1bmNcIjpzd2l0Y2goYy50b2tlbi52YWx1ZSl7Y2FzZVwie1wiOnJldHVybiBuZXcgZGUoe3N0YXJ0OmMudG9rZW4sYm9keTpGKCksZW5kOmQoKX0pO2Nhc2VcIltcIjpjYXNlXCIoXCI6cmV0dXJuIEUoKTtjYXNlXCI7XCI6cmV0dXJuIGMuaW5fZGlyZWN0aXZlcz0hMSxwKCksbmV3IGhlO2RlZmF1bHQ6digpfWNhc2VcImtleXdvcmRcIjpzd2l0Y2goYy50b2tlbi52YWx1ZSl7Y2FzZVwiYnJlYWtcIjpyZXR1cm4gcCgpLGsoJGUpO2Nhc2VcImNvbnRpbnVlXCI6cmV0dXJuIHAoKSxrKHplKTtjYXNlXCJkZWJ1Z2dlclwiOnJldHVybiBwKCkseSgpLG5ldyBjZTtjYXNlXCJkb1wiOnAoKTt2YXIgcj1MKEEpO18oXCJrZXl3b3JkXCIsXCJ3aGlsZVwiKTt2YXIgbz13KCk7cmV0dXJuIHkoITApLG5ldyBnZSh7Ym9keTpyLGNvbmRpdGlvbjpvfSk7Y2FzZVwid2hpbGVcIjpyZXR1cm4gcCgpLG5ldyBiZSh7Y29uZGl0aW9uOncoKSxib2R5OkwoQSl9KTtjYXNlXCJmb3JcIjpyZXR1cm4gcCgpLGZ1bmN0aW9uKCl7bShcIihcIik7dmFyIGU9bnVsbDtpZighZihcInB1bmNcIixcIjtcIikmJihlPWYoXCJrZXl3b3JkXCIsXCJ2YXJcIik/KHAoKSxCKCEwKSk6VSghMCwhMCksZihcIm9wZXJhdG9yXCIsXCJpblwiKSkpcmV0dXJuIGUgaW5zdGFuY2VvZiBMZT8xPGUuZGVmaW5pdGlvbnMubGVuZ3RoJiZoKFwiT25seSBvbmUgdmFyaWFibGUgZGVjbGFyYXRpb24gYWxsb3dlZCBpbiBmb3IuLmluIGxvb3BcIixlLnN0YXJ0LmxpbmUsZS5zdGFydC5jb2wsZS5zdGFydC5wb3MpOkkoZSl8fGgoXCJJbnZhbGlkIGxlZnQtaGFuZCBzaWRlIGluIGZvci4uaW4gbG9vcFwiLGUuc3RhcnQubGluZSxlLnN0YXJ0LmNvbCxlLnN0YXJ0LnBvcykscCgpLG49ZSx0PVUoITApLG0oXCIpXCIpLG5ldyB3ZSh7aW5pdDpuLG9iamVjdDp0LGJvZHk6TChBKX0pO3ZhciBuLHQ7cmV0dXJuIGZ1bmN0aW9uKGUpe20oXCI7XCIpO3ZhciBuPWYoXCJwdW5jXCIsXCI7XCIpP251bGw6VSghMCk7bShcIjtcIik7dmFyIHQ9ZihcInB1bmNcIixcIilcIik/bnVsbDpVKCEwKTtyZXR1cm4gbShcIilcIiksbmV3IHllKHtpbml0OmUsY29uZGl0aW9uOm4sc3RlcDp0LGJvZHk6TChBKX0pfShlKX0oKTtjYXNlXCJmdW5jdGlvblwiOnJldHVybiFlJiZjLmlucHV0Lmhhc19kaXJlY3RpdmUoXCJ1c2Ugc3RyaWN0XCIpJiZoKFwiSW4gc3RyaWN0IG1vZGUgY29kZSwgZnVuY3Rpb25zIGNhbiBvbmx5IGJlIGRlY2xhcmVkIGF0IHRvcCBsZXZlbCBvciBpbW1lZGlhdGVseSB3aXRoaW4gYW5vdGhlciBmdW5jdGlvbi5cIikscCgpLEQoQ2UpO2Nhc2VcImlmXCI6cmV0dXJuIHAoKSxmdW5jdGlvbigpe3ZhciBlPXcoKSxuPUEoKSx0PW51bGw7ZihcImtleXdvcmRcIixcImVsc2VcIikmJihwKCksdD1BKCkpO3JldHVybiBuZXcgTWUoe2NvbmRpdGlvbjplLGJvZHk6bixhbHRlcm5hdGl2ZTp0fSl9KCk7Y2FzZVwicmV0dXJuXCI6MCE9Yy5pbl9mdW5jdGlvbnx8dS5iYXJlX3JldHVybnN8fGgoXCIncmV0dXJuJyBvdXRzaWRlIG9mIGZ1bmN0aW9uXCIpLHAoKTt2YXIgYT1udWxsO3JldHVybiBmKFwicHVuY1wiLFwiO1wiKT9wKCk6YigpfHwoYT1VKCEwKSx5KCkpLG5ldyBUZSh7dmFsdWU6YX0pO2Nhc2VcInN3aXRjaFwiOnJldHVybiBwKCksbmV3IHFlKHtleHByZXNzaW9uOncoKSxib2R5OkwoQyl9KTtjYXNlXCJ0aHJvd1wiOnAoKSxnKGMudG9rZW4pJiZoKFwiSWxsZWdhbCBuZXdsaW5lIGFmdGVyICd0aHJvdydcIik7YT1VKCEwKTtyZXR1cm4geSgpLG5ldyBHKHt2YWx1ZTphfSk7Y2FzZVwidHJ5XCI6cmV0dXJuIHAoKSxmdW5jdGlvbigpe3ZhciBlPUYoKSxuPW51bGwsdD1udWxsO2lmKGYoXCJrZXl3b3JkXCIsXCJjYXRjaFwiKSl7dmFyIGk9Yy50b2tlbjtwKCksbShcIihcIik7dmFyIHI9cSh2bik7bShcIilcIiksbj1uZXcgSWUoe3N0YXJ0OmksYXJnbmFtZTpyLGJvZHk6RigpLGVuZDpkKCl9KX1pZihmKFwia2V5d29yZFwiLFwiZmluYWxseVwiKSl7dmFyIGk9Yy50b2tlbjtwKCksdD1uZXcgUGUoe3N0YXJ0OmksYm9keTpGKCksZW5kOmQoKX0pfW58fHR8fGgoXCJNaXNzaW5nIGNhdGNoL2ZpbmFsbHkgYmxvY2tzXCIpO3JldHVybiBuZXcgUmUoe2JvZHk6ZSxiY2F0Y2g6bixiZmluYWxseTp0fSl9KCk7Y2FzZVwidmFyXCI6cCgpO3ZhciBzPUIoKTtyZXR1cm4geSgpLHM7Y2FzZVwid2l0aFwiOnJldHVybiBjLmlucHV0Lmhhc19kaXJlY3RpdmUoXCJ1c2Ugc3RyaWN0XCIpJiZoKFwiU3RyaWN0IG1vZGUgbWF5IG5vdCBpbmNsdWRlIGEgd2l0aCBzdGF0ZW1lbnRcIikscCgpLG5ldyB4ZSh7ZXhwcmVzc2lvbjp3KCksYm9keTpBKCl9KX19digpfSk7ZnVuY3Rpb24gRShlKXtyZXR1cm4gbmV3IGxlKHtib2R5OihlPVUoITApLHkoKSxlKX0pfWZ1bmN0aW9uIGsoZSl7dmFyIG4sdD1udWxsO2IoKXx8KHQ9cShlZSwhMCkpLG51bGwhPXQ/KChuPVYoZnVuY3Rpb24oZSl7cmV0dXJuIGUubmFtZT09dC5uYW1lfSxjLmxhYmVscykpfHxoKFwiVW5kZWZpbmVkIGxhYmVsIFwiK3QubmFtZSksdC50aGVkZWY9bik6MD09Yy5pbl9sb29wJiZoKGUuVFlQRStcIiBub3QgaW5zaWRlIGEgbG9vcCBvciBzd2l0Y2hcIikseSgpO3ZhciBpPW5ldyBlKHtsYWJlbDp0fSk7cmV0dXJuIG4mJm4ucmVmZXJlbmNlcy5wdXNoKGkpLGl9dmFyIEQ9ZnVuY3Rpb24oZSl7dmFyIG49ZT09PUNlLHQ9ZihcIm5hbWVcIik/cShuP2RuOmhuKTpudWxsO24mJiF0JiZ2KCksIXR8fGU9PT1EZXx8dCBpbnN0YW5jZW9mIGZufHx2KGQoKSksbShcIihcIik7Zm9yKHZhciBpPVtdLHI9ITA7IWYoXCJwdW5jXCIsXCIpXCIpOylyP3I9ITE6bShcIixcIiksaS5wdXNoKHEocG4pKTtwKCk7dmFyIG89Yy5pbl9sb29wLGE9Yy5sYWJlbHM7KytjLmluX2Z1bmN0aW9uLGMuaW5fZGlyZWN0aXZlcz0hMCxjLmlucHV0LnB1c2hfZGlyZWN0aXZlc19zdGFjaygpLGMuaW5fbG9vcD0wLGMubGFiZWxzPVtdO3ZhciBzPUYoITApO3JldHVybiBjLmlucHV0Lmhhc19kaXJlY3RpdmUoXCJ1c2Ugc3RyaWN0XCIpJiYodCYmTSh0KSxpLmZvckVhY2goTSkpLGMuaW5wdXQucG9wX2RpcmVjdGl2ZXNfc3RhY2soKSwtLWMuaW5fZnVuY3Rpb24sYy5pbl9sb29wPW8sYy5sYWJlbHM9YSxuZXcgZSh7bmFtZTp0LGFyZ25hbWVzOmksYm9keTpzfSl9O2Z1bmN0aW9uIEYoZSl7bShcIntcIik7Zm9yKHZhciBuPVtdOyFmKFwicHVuY1wiLFwifVwiKTspZihcImVvZlwiKSYmdigpLG4ucHVzaChBKGUpKTtyZXR1cm4gcCgpLG59ZnVuY3Rpb24gQygpe20oXCJ7XCIpO2Zvcih2YXIgZSxuPVtdLHQ9bnVsbCxpPW51bGw7IWYoXCJwdW5jXCIsXCJ9XCIpOylmKFwiZW9mXCIpJiZ2KCksZihcImtleXdvcmRcIixcImNhc2VcIik/KGkmJihpLmVuZD1kKCkpLHQ9W10saT1uZXcgSGUoe3N0YXJ0OihlPWMudG9rZW4scCgpLGUpLGV4cHJlc3Npb246VSghMCksYm9keTp0fSksbi5wdXNoKGkpLG0oXCI6XCIpKTpmKFwia2V5d29yZFwiLFwiZGVmYXVsdFwiKT8oaSYmKGkuZW5kPWQoKSksdD1bXSxpPW5ldyBOZSh7c3RhcnQ6KGU9Yy50b2tlbixwKCksbShcIjpcIiksZSksYm9keTp0fSksbi5wdXNoKGkpKToodHx8digpLHQucHVzaChBKCkpKTtyZXR1cm4gaSYmKGkuZW5kPWQoKSkscCgpLG59dmFyIEI9ZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyBMZSh7c3RhcnQ6ZCgpLGRlZmluaXRpb25zOmZ1bmN0aW9uKGUpe2Zvcih2YXIgbj1bXTtuLnB1c2gobmV3IFZlKHtzdGFydDpjLnRva2VuLG5hbWU6cShsbiksdmFsdWU6ZihcIm9wZXJhdG9yXCIsXCI9XCIpPyhwKCksVSghMSxlKSk6bnVsbCxlbmQ6ZCgpfSkpLGYoXCJwdW5jXCIsXCIsXCIpOylwKCk7cmV0dXJuIG59KGUpLGVuZDpkKCl9KX07dmFyIHM9ZnVuY3Rpb24oZSl7aWYoZihcIm9wZXJhdG9yXCIsXCJuZXdcIikpcmV0dXJuIGZ1bmN0aW9uKGUpe3ZhciBuPWMudG9rZW47XyhcIm9wZXJhdG9yXCIsXCJuZXdcIik7dmFyIHQsaT1zKCExKTtmKFwicHVuY1wiLFwiKFwiKT8ocCgpLHQ9UyhcIilcIikpOnQ9W107dmFyIHI9bmV3IEplKHtzdGFydDpuLGV4cHJlc3Npb246aSxhcmdzOnQsZW5kOmQoKX0pO3JldHVybiBqKHIpLE4ocixlKX0oZSk7dmFyIG49Yy50b2tlbjtpZihmKFwicHVuY1wiKSl7c3dpdGNoKG4udmFsdWUpe2Nhc2VcIihcIjpwKCk7dmFyIHQ9VSghMCksaT1uLmNvbW1lbnRzX2JlZm9yZS5sZW5ndGg7aWYoW10udW5zaGlmdC5hcHBseSh0LnN0YXJ0LmNvbW1lbnRzX2JlZm9yZSxuLmNvbW1lbnRzX2JlZm9yZSksbi5jb21tZW50c19iZWZvcmU9dC5zdGFydC5jb21tZW50c19iZWZvcmUsMD09KG4uY29tbWVudHNfYmVmb3JlX2xlbmd0aD1pKSYmMDxuLmNvbW1lbnRzX2JlZm9yZS5sZW5ndGgpe3ZhciByPW4uY29tbWVudHNfYmVmb3JlWzBdO3IubmxifHwoci5ubGI9bi5ubGIsbi5ubGI9ITEpfW4uY29tbWVudHNfYWZ0ZXI9dC5zdGFydC5jb21tZW50c19hZnRlcix0LnN0YXJ0PW4sbShcIilcIik7dmFyIG89ZCgpO3JldHVybiBvLmNvbW1lbnRzX2JlZm9yZT10LmVuZC5jb21tZW50c19iZWZvcmUsW10ucHVzaC5hcHBseSh0LmVuZC5jb21tZW50c19hZnRlcixvLmNvbW1lbnRzX2FmdGVyKSxvLmNvbW1lbnRzX2FmdGVyPXQuZW5kLmNvbW1lbnRzX2FmdGVyLHQuZW5kPW8sdCBpbnN0YW5jZW9mIFllJiZqKHQpLE4odCxlKTtjYXNlXCJbXCI6cmV0dXJuIE4oVCgpLGUpO2Nhc2VcIntcIjpyZXR1cm4gTihPKCksZSl9digpfWlmKGYoXCJrZXl3b3JkXCIsXCJmdW5jdGlvblwiKSl7cCgpO3ZhciBhPUQoRmUpO3JldHVybiBhLnN0YXJ0PW4sYS5lbmQ9ZCgpLE4oYSxlKX1pZihXbihjLnRva2VuLnR5cGUpKXJldHVybiBOKGZ1bmN0aW9uKCl7dmFyIGUsbj1jLnRva2VuO3N3aXRjaChuLnR5cGUpe2Nhc2VcIm5hbWVcIjplPXooX24pO2JyZWFrO2Nhc2VcIm51bVwiOmU9bmV3IHluKHtzdGFydDpuLGVuZDpuLHZhbHVlOm4udmFsdWV9KTticmVhaztjYXNlXCJzdHJpbmdcIjplPW5ldyBibih7c3RhcnQ6bixlbmQ6bix2YWx1ZTpuLnZhbHVlLHF1b3RlOm4ucXVvdGV9KTticmVhaztjYXNlXCJyZWdleHBcIjplPW5ldyB3bih7c3RhcnQ6bixlbmQ6bix2YWx1ZTpuLnZhbHVlfSk7YnJlYWs7Y2FzZVwiYXRvbVwiOnN3aXRjaChuLnZhbHVlKXtjYXNlXCJmYWxzZVwiOmU9bmV3IENuKHtzdGFydDpuLGVuZDpufSk7YnJlYWs7Y2FzZVwidHJ1ZVwiOmU9bmV3IEJuKHtzdGFydDpuLGVuZDpufSk7YnJlYWs7Y2FzZVwibnVsbFwiOmU9bmV3IHhuKHtzdGFydDpuLGVuZDpufSl9fXJldHVybiBwKCksZX0oKSxlKTt2KCl9O2Z1bmN0aW9uIFMoZSxuLHQpe2Zvcih2YXIgaT0hMCxyPVtdOyFmKFwicHVuY1wiLGUpJiYoaT9pPSExOm0oXCIsXCIpLCFufHwhZihcInB1bmNcIixlKSk7KWYoXCJwdW5jXCIsXCIsXCIpJiZ0P3IucHVzaChuZXcga24oe3N0YXJ0OmMudG9rZW4sZW5kOmMudG9rZW59KSk6ci5wdXNoKFUoITEpKTtyZXR1cm4gcCgpLHJ9dmFyIFQ9bihmdW5jdGlvbigpe3JldHVybiBtKFwiW1wiKSxuZXcgb24oe2VsZW1lbnRzOlMoXCJdXCIsIXUuc3RyaWN0LCEwKX0pfSksYT1uKGZ1bmN0aW9uKCl7cmV0dXJuIEQoRGUpfSksTz1uKGZ1bmN0aW9uKCl7bShcIntcIik7Zm9yKHZhciBlPSEwLG49W107IWYoXCJwdW5jXCIsXCJ9XCIpJiYoZT9lPSExOm0oXCIsXCIpLHUuc3RyaWN0fHwhZihcInB1bmNcIixcIn1cIikpOyl7dmFyIHQ9Yy50b2tlbixpPXQudHlwZSxyPSQoKTtpZihcIm5hbWVcIj09aSYmIWYoXCJwdW5jXCIsXCI6XCIpKXt2YXIgbz1uZXcgSyh7c3RhcnQ6Yy50b2tlbixuYW1lOlwiXCIrJCgpLGVuZDpkKCl9KTtpZihcImdldFwiPT1yKXtuLnB1c2gobmV3IFooe3N0YXJ0OnQsa2V5Om8sdmFsdWU6YSgpLGVuZDpkKCl9KSk7Y29udGludWV9aWYoXCJzZXRcIj09cil7bi5wdXNoKG5ldyBYKHtzdGFydDp0LGtleTpvLHZhbHVlOmEoKSxlbmQ6ZCgpfSkpO2NvbnRpbnVlfX1tKFwiOlwiKSxuLnB1c2gobmV3IHVuKHtzdGFydDp0LHF1b3RlOnQucXVvdGUsa2V5OlwiXCIrcix2YWx1ZTpVKCExKSxlbmQ6ZCgpfSkpfXJldHVybiBwKCksbmV3IGFuKHtwcm9wZXJ0aWVzOm59KX0pO2Z1bmN0aW9uICQoKXt2YXIgZT1jLnRva2VuO3N3aXRjaChlLnR5cGUpe2Nhc2VcIm9wZXJhdG9yXCI6bmUoZS52YWx1ZSl8fHYoKTtjYXNlXCJudW1cIjpjYXNlXCJzdHJpbmdcIjpjYXNlXCJuYW1lXCI6Y2FzZVwia2V5d29yZFwiOmNhc2VcImF0b21cIjpyZXR1cm4gcCgpLGUudmFsdWU7ZGVmYXVsdDp2KCl9fWZ1bmN0aW9uIHooZSl7dmFyIG49Yy50b2tlbi52YWx1ZTtyZXR1cm4gbmV3KFwidGhpc1wiPT1uP21uOmUpKHtuYW1lOlN0cmluZyhuKSxzdGFydDpjLnRva2VuLGVuZDpjLnRva2VufSl9ZnVuY3Rpb24gTShlKXtcImFyZ3VtZW50c1wiIT1lLm5hbWUmJlwiZXZhbFwiIT1lLm5hbWV8fGgoXCJVbmV4cGVjdGVkIFwiK2UubmFtZStcIiBpbiBzdHJpY3QgbW9kZVwiLGUuc3RhcnQubGluZSxlLnN0YXJ0LmNvbCxlLnN0YXJ0LnBvcyl9ZnVuY3Rpb24gcShlLG4pe2lmKCFmKFwibmFtZVwiKSlyZXR1cm4gbnx8aChcIk5hbWUgZXhwZWN0ZWRcIiksbnVsbDt2YXIgdD16KGUpO3JldHVybiBjLmlucHV0Lmhhc19kaXJlY3RpdmUoXCJ1c2Ugc3RyaWN0XCIpJiZ0IGluc3RhbmNlb2YgZm4mJk0odCkscCgpLHR9ZnVuY3Rpb24gaihlKXtmb3IodmFyIG49ZS5zdGFydCx0PW4uY29tbWVudHNfYmVmb3JlLGk9YWUobixcImNvbW1lbnRzX2JlZm9yZV9sZW5ndGhcIik/bi5jb21tZW50c19iZWZvcmVfbGVuZ3RoOnQubGVuZ3RoOzA8PS0taTspe3ZhciByPXRbaV07aWYoL1tAI11fX1BVUkVfXy8udGVzdChyLnZhbHVlKSl7ZS5wdXJlPXI7YnJlYWt9fX12YXIgTj1mdW5jdGlvbihlLG4pe3ZhciB0LGk9ZS5zdGFydDtpZihmKFwicHVuY1wiLFwiLlwiKSlyZXR1cm4gcCgpLE4obmV3IFhlKHtzdGFydDppLGV4cHJlc3Npb246ZSxwcm9wZXJ0eToodD1jLnRva2VuLFwibmFtZVwiIT10LnR5cGUmJnYoKSxwKCksdC52YWx1ZSksZW5kOmQoKX0pLG4pO2lmKGYoXCJwdW5jXCIsXCJbXCIpKXtwKCk7dmFyIHI9VSghMCk7cmV0dXJuIG0oXCJdXCIpLE4obmV3IFplKHtzdGFydDppLGV4cHJlc3Npb246ZSxwcm9wZXJ0eTpyLGVuZDpkKCl9KSxuKX1pZihuJiZmKFwicHVuY1wiLFwiKFwiKSl7cCgpO3ZhciBvPW5ldyBZZSh7c3RhcnQ6aSxleHByZXNzaW9uOmUsYXJnczpTKFwiKVwiKSxlbmQ6ZCgpfSk7cmV0dXJuIGoobyksTihvLCEwKX1yZXR1cm4gZX0sSD1mdW5jdGlvbihlKXt2YXIgbj1jLnRva2VuO2lmKGYoXCJvcGVyYXRvclwiKSYmTG4obi52YWx1ZSkpe3AoKSx4KCk7dmFyIHQ9cihRZSxuLEgoZSkpO3JldHVybiB0LnN0YXJ0PW4sdC5lbmQ9ZCgpLHR9Zm9yKHZhciBpPXMoZSk7ZihcIm9wZXJhdG9yXCIpJiZWbihjLnRva2VuLnZhbHVlKSYmIWcoYy50b2tlbik7KShpPXIoZW4sYy50b2tlbixpKSkuc3RhcnQ9bixpLmVuZD1jLnRva2VuLHAoKTtyZXR1cm4gaX07ZnVuY3Rpb24gcihlLG4sdCl7dmFyIGk9bi52YWx1ZTtzd2l0Y2goaSl7Y2FzZVwiKytcIjpjYXNlXCItLVwiOkkodCl8fGgoXCJJbnZhbGlkIHVzZSBvZiBcIitpK1wiIG9wZXJhdG9yXCIsbi5saW5lLG4uY29sLG4ucG9zKTticmVhaztjYXNlXCJkZWxldGVcIjp0IGluc3RhbmNlb2YgX24mJmMuaW5wdXQuaGFzX2RpcmVjdGl2ZShcInVzZSBzdHJpY3RcIikmJmgoXCJDYWxsaW5nIGRlbGV0ZSBvbiBleHByZXNzaW9uIG5vdCBhbGxvd2VkIGluIHN0cmljdCBtb2RlXCIsdC5zdGFydC5saW5lLHQuc3RhcnQuY29sLHQuc3RhcnQucG9zKX1yZXR1cm4gbmV3IGUoe29wZXJhdG9yOmksZXhwcmVzc2lvbjp0fSl9dmFyIFI9ZnVuY3Rpb24oZSxuLHQpe3ZhciBpPWYoXCJvcGVyYXRvclwiKT9jLnRva2VuLnZhbHVlOm51bGw7XCJpblwiPT1pJiZ0JiYoaT1udWxsKTt2YXIgcj1udWxsIT1pP0puW2ldOm51bGw7aWYobnVsbCE9ciYmbjxyKXtwKCk7dmFyIG89UihIKCEwKSxyLHQpO3JldHVybiBSKG5ldyBubih7c3RhcnQ6ZS5zdGFydCxsZWZ0OmUsb3BlcmF0b3I6aSxyaWdodDpvLGVuZDpvLmVuZH0pLG4sdCl9cmV0dXJuIGV9O3ZhciBvPWZ1bmN0aW9uKGUpe3ZhciBuLHQ9Yy50b2tlbixpPShuPWUsUihIKCEwKSwwLG4pKTtpZihmKFwib3BlcmF0b3JcIixcIj9cIikpe3AoKTt2YXIgcj1VKCExKTtyZXR1cm4gbShcIjpcIiksbmV3IHRuKHtzdGFydDp0LGNvbmRpdGlvbjppLGNvbnNlcXVlbnQ6cixhbHRlcm5hdGl2ZTpVKCExLGUpLGVuZDpkKCl9KX1yZXR1cm4gaX07ZnVuY3Rpb24gSShlKXtyZXR1cm4gZSBpbnN0YW5jZW9mIEdlfHxlIGluc3RhbmNlb2YgX259dmFyIFA9ZnVuY3Rpb24oZSl7dmFyIG49Yy50b2tlbix0PW8oZSksaT1jLnRva2VuLnZhbHVlO2lmKGYoXCJvcGVyYXRvclwiKSYmWW4oaSkpe2lmKEkodCkpcmV0dXJuIHAoKSxuZXcgcm4oe3N0YXJ0Om4sbGVmdDp0LG9wZXJhdG9yOmkscmlnaHQ6UChlKSxlbmQ6ZCgpfSk7aChcIkludmFsaWQgYXNzaWdubWVudFwiKX1yZXR1cm4gdH0sVT1mdW5jdGlvbihlLG4pe2Zvcih2YXIgdD1jLnRva2VuLGk9W107aS5wdXNoKFAobikpLGUmJmYoXCJwdW5jXCIsXCIsXCIpOylwKCksZT0hMDtyZXR1cm4gMT09aS5sZW5ndGg/aVswXTpuZXcgV2Uoe3N0YXJ0OnQsZXhwcmVzc2lvbnM6aSxlbmQ6bCgpfSl9O2Z1bmN0aW9uIEwoZSl7KytjLmluX2xvb3A7dmFyIG49ZSgpO3JldHVybi0tYy5pbl9sb29wLG59cmV0dXJuIHUuZXhwcmVzc2lvbj9VKCEwKTpmdW5jdGlvbigpe3ZhciBlPWMudG9rZW4sbj1bXTtmb3IoYy5pbnB1dC5wdXNoX2RpcmVjdGl2ZXNfc3RhY2soKTshZihcImVvZlwiKTspbi5wdXNoKEEoITApKTtjLmlucHV0LnBvcF9kaXJlY3RpdmVzX3N0YWNrKCk7dmFyIHQ9ZCgpLGk9dS50b3BsZXZlbDtyZXR1cm4gaT8oaS5ib2R5PWkuYm9keS5jb25jYXQobiksaS5lbmQ9dCk6aT1uZXcgRWUoe3N0YXJ0OmUsYm9keTpuLGVuZDp0fSksaX0oKX1mdW5jdGlvbiBYbihlLG4pe1NuLmNhbGwodGhpcyksdGhpcy5iZWZvcmU9ZSx0aGlzLmFmdGVyPW59ZnVuY3Rpb24gcihlLG4sdCl7dGhpcy5uYW1lPW4ubmFtZSx0aGlzLm9yaWc9W25dLHRoaXMuaW5pdD10LHRoaXMuZWxpbWluYXRlZD0wLHRoaXMuc2NvcGU9ZSx0aGlzLnJlZmVyZW5jZXM9W10sdGhpcy5yZXBsYWNlZD0wLHRoaXMuZ2xvYmFsPSExLHRoaXMubWFuZ2xlZF9uYW1lPW51bGwsdGhpcy51bmRlY2xhcmVkPSExLHRoaXMuaWQ9ci5uZXh0X2lkKyt9ZnVuY3Rpb24gcChlLG4pe3ZhciB0PWUubmFtZXNfaW5fdXNlO3JldHVybiB0fHwoZS5uYW1lc19pbl91c2U9dD1PYmplY3QuY3JlYXRlKGUubWFuZ2xlZF9uYW1lc3x8bnVsbCksZS5jbmFtZV9ob2xlcz1bXSxlLmVuY2xvc2VkLmZvckVhY2goZnVuY3Rpb24oZSl7ZS51bm1hbmdsZWFibGUobikmJih0W2UubmFtZV09ITApfSkpLHR9ZnVuY3Rpb24gZihlKXtyZXR1cm4gZT1ZKGUse2V2YWw6ITEsaWU4OiExLGtlZXBfZm5hbWVzOiExLHJlc2VydmVkOltdLHRvcGxldmVsOiExfSksQXJyYXkuaXNBcnJheShlLnJlc2VydmVkKXx8KGUucmVzZXJ2ZWQ9W10pLHYoZS5yZXNlcnZlZCxcImFyZ3VtZW50c1wiKSxlfVhuLnByb3RvdHlwZT1uZXcgU24sZnVuY3Rpb24obyl7ZnVuY3Rpb24gZShlLHIpe2UuREVGTUVUSE9EKFwidHJhbnNmb3JtXCIsZnVuY3Rpb24oZSxuKXt2YXIgdCxpO3JldHVybiBlLnB1c2godGhpcyksZS5iZWZvcmUmJih0PWUuYmVmb3JlKHRoaXMscixuKSksdD09PW8mJihyKHQ9dGhpcyxlKSxlLmFmdGVyJiYoaT1lLmFmdGVyKHQsbikpIT09byYmKHQ9aSkpLGUucG9wKCksdH0pfWZ1bmN0aW9uIHQoZSxuKXtyZXR1cm4gcmUoZSxmdW5jdGlvbihlKXtyZXR1cm4gZS50cmFuc2Zvcm0obiwhMCl9KX1lKHNlLEwpLGUodmUsZnVuY3Rpb24oZSxuKXtlLmxhYmVsPWUubGFiZWwudHJhbnNmb3JtKG4pLGUuYm9keT1lLmJvZHkudHJhbnNmb3JtKG4pfSksZShsZSxmdW5jdGlvbihlLG4pe2UuYm9keT1lLmJvZHkudHJhbnNmb3JtKG4pfSksZShwZSxmdW5jdGlvbihlLG4pe2UuYm9keT10KGUuYm9keSxuKX0pLGUobWUsZnVuY3Rpb24oZSxuKXtlLmNvbmRpdGlvbj1lLmNvbmRpdGlvbi50cmFuc2Zvcm0obiksZS5ib2R5PWUuYm9keS50cmFuc2Zvcm0obil9KSxlKHllLGZ1bmN0aW9uKGUsbil7ZS5pbml0JiYoZS5pbml0PWUuaW5pdC50cmFuc2Zvcm0obikpLGUuY29uZGl0aW9uJiYoZS5jb25kaXRpb249ZS5jb25kaXRpb24udHJhbnNmb3JtKG4pKSxlLnN0ZXAmJihlLnN0ZXA9ZS5zdGVwLnRyYW5zZm9ybShuKSksZS5ib2R5PWUuYm9keS50cmFuc2Zvcm0obil9KSxlKHdlLGZ1bmN0aW9uKGUsbil7ZS5pbml0PWUuaW5pdC50cmFuc2Zvcm0obiksZS5vYmplY3Q9ZS5vYmplY3QudHJhbnNmb3JtKG4pLGUuYm9keT1lLmJvZHkudHJhbnNmb3JtKG4pfSksZSh4ZSxmdW5jdGlvbihlLG4pe2UuZXhwcmVzc2lvbj1lLmV4cHJlc3Npb24udHJhbnNmb3JtKG4pLGUuYm9keT1lLmJvZHkudHJhbnNmb3JtKG4pfSksZShTZSxmdW5jdGlvbihlLG4pe2UudmFsdWUmJihlLnZhbHVlPWUudmFsdWUudHJhbnNmb3JtKG4pKX0pLGUoT2UsZnVuY3Rpb24oZSxuKXtlLmxhYmVsJiYoZS5sYWJlbD1lLmxhYmVsLnRyYW5zZm9ybShuKSl9KSxlKE1lLGZ1bmN0aW9uKGUsbil7ZS5jb25kaXRpb249ZS5jb25kaXRpb24udHJhbnNmb3JtKG4pLGUuYm9keT1lLmJvZHkudHJhbnNmb3JtKG4pLGUuYWx0ZXJuYXRpdmUmJihlLmFsdGVybmF0aXZlPWUuYWx0ZXJuYXRpdmUudHJhbnNmb3JtKG4pKX0pLGUocWUsZnVuY3Rpb24oZSxuKXtlLmV4cHJlc3Npb249ZS5leHByZXNzaW9uLnRyYW5zZm9ybShuKSxlLmJvZHk9dChlLmJvZHksbil9KSxlKEhlLGZ1bmN0aW9uKGUsbil7ZS5leHByZXNzaW9uPWUuZXhwcmVzc2lvbi50cmFuc2Zvcm0obiksZS5ib2R5PXQoZS5ib2R5LG4pfSksZShSZSxmdW5jdGlvbihlLG4pe2UuYm9keT10KGUuYm9keSxuKSxlLmJjYXRjaCYmKGUuYmNhdGNoPWUuYmNhdGNoLnRyYW5zZm9ybShuKSksZS5iZmluYWxseSYmKGUuYmZpbmFsbHk9ZS5iZmluYWxseS50cmFuc2Zvcm0obikpfSksZShJZSxmdW5jdGlvbihlLG4pe2UuYXJnbmFtZT1lLmFyZ25hbWUudHJhbnNmb3JtKG4pLGUuYm9keT10KGUuYm9keSxuKX0pLGUoVWUsZnVuY3Rpb24oZSxuKXtlLmRlZmluaXRpb25zPXQoZS5kZWZpbml0aW9ucyxuKX0pLGUoVmUsZnVuY3Rpb24oZSxuKXtlLm5hbWU9ZS5uYW1lLnRyYW5zZm9ybShuKSxlLnZhbHVlJiYoZS52YWx1ZT1lLnZhbHVlLnRyYW5zZm9ybShuKSl9KSxlKGtlLGZ1bmN0aW9uKGUsbil7ZS5uYW1lJiYoZS5uYW1lPWUubmFtZS50cmFuc2Zvcm0obikpLGUuYXJnbmFtZXM9dChlLmFyZ25hbWVzLG4pLGUuYm9keT10KGUuYm9keSxuKX0pLGUoWWUsZnVuY3Rpb24oZSxuKXtlLmV4cHJlc3Npb249ZS5leHByZXNzaW9uLnRyYW5zZm9ybShuKSxlLmFyZ3M9dChlLmFyZ3Msbil9KSxlKFdlLGZ1bmN0aW9uKGUsbil7ZS5leHByZXNzaW9ucz10KGUuZXhwcmVzc2lvbnMsbil9KSxlKFhlLGZ1bmN0aW9uKGUsbil7ZS5leHByZXNzaW9uPWUuZXhwcmVzc2lvbi50cmFuc2Zvcm0obil9KSxlKFplLGZ1bmN0aW9uKGUsbil7ZS5leHByZXNzaW9uPWUuZXhwcmVzc2lvbi50cmFuc2Zvcm0obiksZS5wcm9wZXJ0eT1lLnByb3BlcnR5LnRyYW5zZm9ybShuKX0pLGUoS2UsZnVuY3Rpb24oZSxuKXtlLmV4cHJlc3Npb249ZS5leHByZXNzaW9uLnRyYW5zZm9ybShuKX0pLGUobm4sZnVuY3Rpb24oZSxuKXtlLmxlZnQ9ZS5sZWZ0LnRyYW5zZm9ybShuKSxlLnJpZ2h0PWUucmlnaHQudHJhbnNmb3JtKG4pfSksZSh0bixmdW5jdGlvbihlLG4pe2UuY29uZGl0aW9uPWUuY29uZGl0aW9uLnRyYW5zZm9ybShuKSxlLmNvbnNlcXVlbnQ9ZS5jb25zZXF1ZW50LnRyYW5zZm9ybShuKSxlLmFsdGVybmF0aXZlPWUuYWx0ZXJuYXRpdmUudHJhbnNmb3JtKG4pfSksZShvbixmdW5jdGlvbihlLG4pe2UuZWxlbWVudHM9dChlLmVsZW1lbnRzLG4pfSksZShhbixmdW5jdGlvbihlLG4pe2UucHJvcGVydGllcz10KGUucHJvcGVydGllcyxuKX0pLGUoc24sZnVuY3Rpb24oZSxuKXtlLnZhbHVlPWUudmFsdWUudHJhbnNmb3JtKG4pfSl9KCksci5uZXh0X2lkPTEsci5wcm90b3R5cGU9e3VubWFuZ2xlYWJsZTpmdW5jdGlvbihlKXtyZXR1cm4gZXx8KGU9e30pLHRoaXMuZ2xvYmFsJiYhZS50b3BsZXZlbHx8dGhpcy51bmRlY2xhcmVkfHwhZS5ldmFsJiYodGhpcy5zY29wZS51c2VzX2V2YWx8fHRoaXMuc2NvcGUudXNlc193aXRoKXx8ZS5rZWVwX2ZuYW1lcyYmKHRoaXMub3JpZ1swXWluc3RhbmNlb2YgaG58fHRoaXMub3JpZ1swXWluc3RhbmNlb2YgZG4pfSxtYW5nbGU6ZnVuY3Rpb24oZSl7dmFyIG49ZS5jYWNoZSYmZS5jYWNoZS5wcm9wcztpZih0aGlzLmdsb2JhbCYmbiYmbi5oYXModGhpcy5uYW1lKSl0aGlzLm1hbmdsZWRfbmFtZT1uLmdldCh0aGlzLm5hbWUpO2Vsc2UgaWYoIXRoaXMubWFuZ2xlZF9uYW1lJiYhdGhpcy51bm1hbmdsZWFibGUoZSkpe3ZhciB0Oyh0PXRoaXMucmVkZWZpbmVkKCkpP3RoaXMubWFuZ2xlZF9uYW1lPXQubWFuZ2xlZF9uYW1lfHx0Lm5hbWU6dGhpcy5tYW5nbGVkX25hbWU9ZnVuY3Rpb24oZSxpLG4pe3ZhciB0PXAoZSxpKSxyPWUuY25hbWVfaG9sZXMsbz1PYmplY3QuY3JlYXRlKG51bGwpO2lmKGUgaW5zdGFuY2VvZiBGZSYmZS5uYW1lJiZuLm9yaWdbMF1pbnN0YW5jZW9mIHBuKXt2YXIgYT1lLm5hbWUuZGVmaW5pdGlvbigpO29bYS5tYW5nbGVkX25hbWV8fGEubmFtZV09ITB9dmFyIHMsdT1bZV07bi5yZWZlcmVuY2VzLmZvckVhY2goZnVuY3Rpb24oZSl7dmFyIG49ZS5zY29wZTtkb3tpZighKHUuaW5kZXhPZihuKTwwKSlicmVhaztmb3IodmFyIHQgaW4gcChuLGkpKW9bdF09ITA7dS5wdXNoKG4pfXdoaWxlKG49bi5wYXJlbnRfc2NvcGUpfSk7Zm9yKHZhciBjPTAsZj1yLmxlbmd0aDtjPGY7YysrKWlmKHM9ZyhyW2NdKSwhb1tzXSlyZXR1cm4gci5zcGxpY2UoYywxKSxlLm5hbWVzX2luX3VzZVtzXT0hMCxzO2Zvcig7OylpZihzPWcoKytlLmNuYW1lKSwhdFtzXSYmbChzKSYmIXRlKHMsaS5yZXNlcnZlZCkpe2lmKCFvW3NdKWJyZWFrO3IucHVzaChlLmNuYW1lKX1lLm5hbWVzX2luX3VzZVtzXT0hMCxpLmllOCYmbi5vcmlnWzBdaW5zdGFuY2VvZiBobiYmKHAoZS5wYXJlbnRfc2NvcGUsaSlbc109ITApO3JldHVybiBzfSh0aGlzLnNjb3BlLGUsdGhpcyksdGhpcy5nbG9iYWwmJm4mJm4uc2V0KHRoaXMubmFtZSx0aGlzLm1hbmdsZWRfbmFtZSl9fSxyZWRlZmluZWQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kZWZ1biYmdGhpcy5kZWZ1bi52YXJpYWJsZXMuZ2V0KHRoaXMubmFtZSl9fSxFZS5ERUZNRVRIT0QoXCJmaWd1cmVfb3V0X3Njb3BlXCIsZnVuY3Rpb24oYyl7Yz1ZKGMse2NhY2hlOm51bGwsaWU4OiExfSk7dmFyIGE9dGhpcyxmPWEucGFyZW50X3Njb3BlPW51bGwsbD1uZXcgTyxwPW51bGwscz1uZXcgU24oZnVuY3Rpb24oZSxuKXtpZihlIGluc3RhbmNlb2YgSWUpe3ZhciB0PWY7cmV0dXJuKGY9bmV3IEFlKGUpKS5pbml0X3Njb3BlX3ZhcnModCksbigpLGY9dCwhMH1pZihlIGluc3RhbmNlb2YgQWUpe2UuaW5pdF9zY29wZV92YXJzKGYpO3Q9Zjt2YXIgaT1wLHI9bDtyZXR1cm4gcD1mPWUsbD1uZXcgTyxuKCksZj10LHA9aSxsPXIsITB9aWYoZSBpbnN0YW5jZW9mIHZlKXt2YXIgbz1lLmxhYmVsO2lmKGwuaGFzKG8ubmFtZSkpdGhyb3cgbmV3IEVycm9yKFMoXCJMYWJlbCB7bmFtZX0gZGVmaW5lZCB0d2ljZVwiLG8pKTtyZXR1cm4gbC5zZXQoby5uYW1lLG8pLG4oKSxsLmRlbChvLm5hbWUpLCEwfWlmKGUgaW5zdGFuY2VvZiB4ZSlmb3IodmFyIGE9ZjthO2E9YS5wYXJlbnRfc2NvcGUpYS51c2VzX3dpdGg9ITA7ZWxzZSBpZihlIGluc3RhbmNlb2YgY24mJihlLnNjb3BlPWYpLGUgaW5zdGFuY2VvZiBRJiYoKGUudGhlZGVmPWUpLnJlZmVyZW5jZXM9W10pLGUgaW5zdGFuY2VvZiBobilwLmRlZl9mdW5jdGlvbihlLFwiYXJndW1lbnRzXCI9PWUubmFtZT92b2lkIDA6cCk7ZWxzZSBpZihlIGluc3RhbmNlb2YgZG4pKGUuc2NvcGU9cC5wYXJlbnRfc2NvcGUpLmRlZl9mdW5jdGlvbihlLHApO2Vsc2UgaWYoZSBpbnN0YW5jZW9mIGxuKXtpZihwLmRlZl92YXJpYWJsZShlLFwiU3ltYm9sVmFyXCI9PWUuVFlQRT9udWxsOnZvaWQgMCkscCE9PWYpe2UubWFya19lbmNsb3NlZChjKTt2YXIgcz1mLmZpbmRfdmFyaWFibGUoZSk7ZS50aGVkZWYhPT1zJiYoZS50aGVkZWY9cyksZS5yZWZlcmVuY2UoYyl9fWVsc2UgaWYoZSBpbnN0YW5jZW9mIHZuKWYuZGVmX3ZhcmlhYmxlKGUpLmRlZnVuPXA7ZWxzZSBpZihlIGluc3RhbmNlb2YgZWUpe3ZhciB1PWwuZ2V0KGUubmFtZSk7aWYoIXUpdGhyb3cgbmV3IEVycm9yKFMoXCJVbmRlZmluZWQgbGFiZWwge25hbWV9IFt7bGluZX0se2NvbH1dXCIse25hbWU6ZS5uYW1lLGxpbmU6ZS5zdGFydC5saW5lLGNvbDplLnN0YXJ0LmNvbH0pKTtlLnRoZWRlZj11fX0pO2Eud2FsayhzKSxhLmdsb2JhbHM9bmV3IE87cz1uZXcgU24oZnVuY3Rpb24oZSxuKXtpZihlIGluc3RhbmNlb2YgT2UmJmUubGFiZWwpcmV0dXJuIGUubGFiZWwudGhlZGVmLnJlZmVyZW5jZXMucHVzaChlKSwhMDtpZihlIGluc3RhbmNlb2YgX24pe3ZhciB0PWUubmFtZTtpZihcImV2YWxcIj09dCYmcy5wYXJlbnQoKWluc3RhbmNlb2YgWWUpZm9yKHZhciBpPWUuc2NvcGU7aSYmIWkudXNlc19ldmFsO2k9aS5wYXJlbnRfc2NvcGUpaS51c2VzX2V2YWw9ITA7dmFyIHI9ZS5zY29wZS5maW5kX3ZhcmlhYmxlKHQpO3JldHVybiByP3Iuc2NvcGUgaW5zdGFuY2VvZiBrZSYmXCJhcmd1bWVudHNcIj09dCYmKHIuc2NvcGUudXNlc19hcmd1bWVudHM9ITApOnI9YS5kZWZfZ2xvYmFsKGUpLGUudGhlZGVmPXIsZS5yZWZlcmVuY2UoYyksITB9dmFyIG87aWYoZSBpbnN0YW5jZW9mIHZuJiYobz1lLmRlZmluaXRpb24oKS5yZWRlZmluZWQoKSkpZm9yKGk9ZS5zY29wZTtpJiYodihpLmVuY2xvc2VkLG8pLGkhPT1vLnNjb3BlKTspaT1pLnBhcmVudF9zY29wZX0pO2Eud2FsayhzKSxjLmllOCYmYS53YWxrKG5ldyBTbihmdW5jdGlvbihlLG4pe2lmKGUgaW5zdGFuY2VvZiB2bil7dmFyIHQ9ZS5uYW1lLGk9ZS50aGVkZWYucmVmZXJlbmNlcyxyPWUudGhlZGVmLmRlZnVuLG89ci5maW5kX3ZhcmlhYmxlKHQpfHxhLmdsb2JhbHMuZ2V0KHQpfHxyLmRlZl92YXJpYWJsZShlKTtyZXR1cm4gaS5mb3JFYWNoKGZ1bmN0aW9uKGUpe2UudGhlZGVmPW8sZS5yZWZlcmVuY2UoYyl9KSxlLnRoZWRlZj1vLGUucmVmZXJlbmNlKGMpLCEwfX0pKX0pLEVlLkRFRk1FVEhPRChcImRlZl9nbG9iYWxcIixmdW5jdGlvbihlKXt2YXIgbj10aGlzLmdsb2JhbHMsdD1lLm5hbWU7aWYobi5oYXModCkpcmV0dXJuIG4uZ2V0KHQpO3ZhciBpPW5ldyByKHRoaXMsZSk7cmV0dXJuIGkudW5kZWNsYXJlZD0hMCxpLmdsb2JhbD0hMCxuLnNldCh0LGkpLGl9KSxBZS5ERUZNRVRIT0QoXCJpbml0X3Njb3BlX3ZhcnNcIixmdW5jdGlvbihlKXt0aGlzLnZhcmlhYmxlcz1uZXcgTyx0aGlzLmZ1bmN0aW9ucz1uZXcgTyx0aGlzLnVzZXNfd2l0aD0hMSx0aGlzLnVzZXNfZXZhbD0hMSx0aGlzLnBhcmVudF9zY29wZT1lLHRoaXMuZW5jbG9zZWQ9W10sdGhpcy5jbmFtZT0tMX0pLGtlLkRFRk1FVEhPRChcImluaXRfc2NvcGVfdmFyc1wiLGZ1bmN0aW9uKCl7QWUucHJvdG90eXBlLmluaXRfc2NvcGVfdmFycy5hcHBseSh0aGlzLGFyZ3VtZW50cyksdGhpcy51c2VzX2FyZ3VtZW50cz0hMSx0aGlzLmRlZl92YXJpYWJsZShuZXcgcG4oe25hbWU6XCJhcmd1bWVudHNcIixzdGFydDp0aGlzLnN0YXJ0LGVuZDp0aGlzLmVuZH0pKX0pLGNuLkRFRk1FVEhPRChcIm1hcmtfZW5jbG9zZWRcIixmdW5jdGlvbihlKXtmb3IodmFyIG49dGhpcy5kZWZpbml0aW9uKCksdD10aGlzLnNjb3BlO3QmJih2KHQuZW5jbG9zZWQsbiksZS5rZWVwX2ZuYW1lcyYmdC5mdW5jdGlvbnMuZWFjaChmdW5jdGlvbihlKXt2KG4uc2NvcGUuZW5jbG9zZWQsZSl9KSx0IT09bi5zY29wZSk7KXQ9dC5wYXJlbnRfc2NvcGV9KSxjbi5ERUZNRVRIT0QoXCJyZWZlcmVuY2VcIixmdW5jdGlvbihlKXt0aGlzLmRlZmluaXRpb24oKS5yZWZlcmVuY2VzLnB1c2godGhpcyksdGhpcy5tYXJrX2VuY2xvc2VkKGUpfSksQWUuREVGTUVUSE9EKFwiZmluZF92YXJpYWJsZVwiLGZ1bmN0aW9uKGUpe3JldHVybiBlIGluc3RhbmNlb2YgY24mJihlPWUubmFtZSksdGhpcy52YXJpYWJsZXMuZ2V0KGUpfHx0aGlzLnBhcmVudF9zY29wZSYmdGhpcy5wYXJlbnRfc2NvcGUuZmluZF92YXJpYWJsZShlKX0pLEFlLkRFRk1FVEhPRChcImRlZl9mdW5jdGlvblwiLGZ1bmN0aW9uKGUsbil7dmFyIHQ9dGhpcy5kZWZfdmFyaWFibGUoZSxuKTtyZXR1cm4oIXQuaW5pdHx8dC5pbml0IGluc3RhbmNlb2YgQ2UpJiYodC5pbml0PW4pLHRoaXMuZnVuY3Rpb25zLnNldChlLm5hbWUsdCksdH0pLEFlLkRFRk1FVEhPRChcImRlZl92YXJpYWJsZVwiLGZ1bmN0aW9uKGUsbil7dmFyIHQ9dGhpcy52YXJpYWJsZXMuZ2V0KGUubmFtZSk7cmV0dXJuIHQ/KHQub3JpZy5wdXNoKGUpLHQuaW5pdCYmKHQuc2NvcGUhPT1lLnNjb3BlfHx0LmluaXQgaW5zdGFuY2VvZiBGZSkmJih0LmluaXQ9bikpOih0PW5ldyByKHRoaXMsZSxuKSx0aGlzLnZhcmlhYmxlcy5zZXQoZS5uYW1lLHQpLHQuZ2xvYmFsPSF0aGlzLnBhcmVudF9zY29wZSksZS50aGVkZWY9dH0pLGNuLkRFRk1FVEhPRChcInVubWFuZ2xlYWJsZVwiLGZ1bmN0aW9uKGUpe3ZhciBuPXRoaXMuZGVmaW5pdGlvbigpO3JldHVybiFufHxuLnVubWFuZ2xlYWJsZShlKX0pLFEuREVGTUVUSE9EKFwidW5tYW5nbGVhYmxlXCIsaWUpLGNuLkRFRk1FVEhPRChcInVucmVmZXJlbmNlZFwiLGZ1bmN0aW9uKCl7cmV0dXJuIDA9PXRoaXMuZGVmaW5pdGlvbigpLnJlZmVyZW5jZXMubGVuZ3RoJiYhKHRoaXMuc2NvcGUudXNlc19ldmFsfHx0aGlzLnNjb3BlLnVzZXNfd2l0aCl9KSxjbi5ERUZNRVRIT0QoXCJkZWZpbml0aW9uXCIsZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aGVkZWZ9KSxjbi5ERUZNRVRIT0QoXCJnbG9iYWxcIixmdW5jdGlvbigpe3JldHVybiB0aGlzLmRlZmluaXRpb24oKS5nbG9iYWx9KSxFZS5ERUZNRVRIT0QoXCJtYW5nbGVfbmFtZXNcIixmdW5jdGlvbihhKXthPWYoYSk7dmFyIHM9LTE7aWYoYS5jYWNoZSYmYS5jYWNoZS5wcm9wcyl7dmFyIG49dGhpcy5tYW5nbGVkX25hbWVzPU9iamVjdC5jcmVhdGUobnVsbCk7YS5jYWNoZS5wcm9wcy5lYWNoKGZ1bmN0aW9uKGUpe25bZV09ITB9KX12YXIgdT1bXSxlPW5ldyBTbihmdW5jdGlvbihlLG4pe2lmKGUgaW5zdGFuY2VvZiB2ZSl7dmFyIHQ9cztyZXR1cm4gbigpLHM9dCwhMH1pZihlIGluc3RhbmNlb2YgQWUpcmV0dXJuIG4oKSxhLmNhY2hlJiZlIGluc3RhbmNlb2YgRWUmJmUuZ2xvYmFscy5lYWNoKGMpLGUudmFyaWFibGVzLmVhY2goYyksITA7aWYoZSBpbnN0YW5jZW9mIFEpe2Zvcih2YXIgaTshbChpPWcoKytzKSk7KTtyZXR1cm4gZS5tYW5nbGVkX25hbWU9aSwhMH1pZighYS5pZTgmJmUgaW5zdGFuY2VvZiBJZSl7dmFyIHI9ZS5hcmduYW1lLmRlZmluaXRpb24oKSxvPXIucmVkZWZpbmVkKCk7cmV0dXJuIG8mJih1LnB1c2gociksci5yZWZlcmVuY2VzLmZvckVhY2goZnVuY3Rpb24oZSl7ZS50aGVkZWY9byxlLnJlZmVyZW5jZShhKSxlLnRoZWRlZj1yfSkpLG4oKSxvfHxjKHIpLCEwfX0pO2Z1bmN0aW9uIGMoZSl7dGUoZS5uYW1lLGEucmVzZXJ2ZWQpfHxlLm1hbmdsZShhKX10aGlzLndhbGsoZSksdS5mb3JFYWNoKGMpfSksRWUuREVGTUVUSE9EKFwiZmluZF9jb2xsaWRpbmdfbmFtZXNcIixmdW5jdGlvbih0KXt2YXIgaT10LmNhY2hlJiZ0LmNhY2hlLnByb3BzLG49T2JqZWN0LmNyZWF0ZShudWxsKTtyZXR1cm4gdC5yZXNlcnZlZC5mb3JFYWNoKHIpLHRoaXMuZ2xvYmFscy5lYWNoKG8pLHRoaXMud2FsayhuZXcgU24oZnVuY3Rpb24oZSl7ZSBpbnN0YW5jZW9mIEFlJiZlLnZhcmlhYmxlcy5lYWNoKG8pLGUgaW5zdGFuY2VvZiB2biYmbyhlLmRlZmluaXRpb24oKSl9KSksbjtmdW5jdGlvbiByKGUpe25bZV09ITB9ZnVuY3Rpb24gbyhlKXt2YXIgbj1lLm5hbWU7aWYoZS5nbG9iYWwmJmkmJmkuaGFzKG4pKW49aS5nZXQobik7ZWxzZSBpZighZS51bm1hbmdsZWFibGUodCkpcmV0dXJuO3Iobil9fSksRWUuREVGTUVUSE9EKFwiZXhwYW5kX25hbWVzXCIsZnVuY3Rpb24odCl7Zy5yZXNldCgpLGcuc29ydCgpLHQ9Zih0KTt2YXIgaT10aGlzLmZpbmRfY29sbGlkaW5nX25hbWVzKHQpLHI9MDtmdW5jdGlvbiBuKG4pe2lmKCEobi5nbG9iYWwmJnQuY2FjaGV8fG4udW5tYW5nbGVhYmxlKHQpfHx0ZShuLm5hbWUsdC5yZXNlcnZlZCkpKXt2YXIgZT1uLnJlZGVmaW5lZCgpO24ubmFtZT1lP2UubmFtZTpmdW5jdGlvbigpe2Zvcih2YXIgZTtlPWcocisrKSxpW2VdfHwhbChlKTspO3JldHVybiBlfSgpLG4ub3JpZy5mb3JFYWNoKGZ1bmN0aW9uKGUpe2UubmFtZT1uLm5hbWV9KSxuLnJlZmVyZW5jZXMuZm9yRWFjaChmdW5jdGlvbihlKXtlLm5hbWU9bi5uYW1lfSl9fXRoaXMuZ2xvYmFscy5lYWNoKG4pLHRoaXMud2FsayhuZXcgU24oZnVuY3Rpb24oZSl7ZSBpbnN0YW5jZW9mIEFlJiZlLnZhcmlhYmxlcy5lYWNoKG4pLGUgaW5zdGFuY2VvZiB2biYmbihlLmRlZmluaXRpb24oKSl9KSl9KSxzZS5ERUZNRVRIT0QoXCJ0YWlsX25vZGVcIixDKSxXZS5ERUZNRVRIT0QoXCJ0YWlsX25vZGVcIixmdW5jdGlvbigpe3JldHVybiB0aGlzLmV4cHJlc3Npb25zW3RoaXMuZXhwcmVzc2lvbnMubGVuZ3RoLTFdfSksRWUuREVGTUVUSE9EKFwiY29tcHV0ZV9jaGFyX2ZyZXF1ZW5jeVwiLGZ1bmN0aW9uKHQpe3Q9Zih0KSxnLnJlc2V0KCk7dHJ5e3NlLnByb3RvdHlwZS5wcmludD1mdW5jdGlvbihlLG4pe3RoaXMuX3ByaW50KGUsbiksdGhpcyBpbnN0YW5jZW9mIGNuJiYhdGhpcy51bm1hbmdsZWFibGUodCk/Zy5jb25zaWRlcih0aGlzLm5hbWUsLTEpOnQucHJvcGVydGllcyYmKHRoaXMgaW5zdGFuY2VvZiBYZT9nLmNvbnNpZGVyKHRoaXMucHJvcGVydHksLTEpOnRoaXMgaW5zdGFuY2VvZiBaZSYmZnVuY3Rpb24gZShuKXtuIGluc3RhbmNlb2YgYm4/Zy5jb25zaWRlcihuLnZhbHVlLC0xKTpuIGluc3RhbmNlb2YgdG4/KGUobi5jb25zZXF1ZW50KSxlKG4uYWx0ZXJuYXRpdmUpKTpuIGluc3RhbmNlb2YgV2UmJmUobi50YWlsX25vZGUoKSl9KHRoaXMucHJvcGVydHkpKX0sZy5jb25zaWRlcih0aGlzLnByaW50X3RvX3N0cmluZygpLDEpfWZpbmFsbHl7c2UucHJvdG90eXBlLnByaW50PXNlLnByb3RvdHlwZS5fcHJpbnR9Zy5zb3J0KCl9KTt2YXIgZz1mdW5jdGlvbigpe3ZhciBpLHIsZT1cImFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVokX1wiLnNwbGl0KFwiXCIpLG49XCIwMTIzNDU2Nzg5XCIuc3BsaXQoXCJcIik7ZnVuY3Rpb24gdCgpe3I9T2JqZWN0LmNyZWF0ZShudWxsKSxlLmZvckVhY2goZnVuY3Rpb24oZSl7cltlXT0wfSksbi5mb3JFYWNoKGZ1bmN0aW9uKGUpe3JbZV09MH0pfWZ1bmN0aW9uIG8oZSxuKXtyZXR1cm4gcltuXS1yW2VdfWZ1bmN0aW9uIGEoZSl7dmFyIG49XCJcIix0PTU0O2ZvcihlKys7bis9aVstLWUldF0sZT1NYXRoLmZsb29yKGUvdCksdD02NCwwPGU7KTtyZXR1cm4gbn1yZXR1cm4gYS5jb25zaWRlcj1mdW5jdGlvbihlLG4pe2Zvcih2YXIgdD1lLmxlbmd0aDswPD0tLXQ7KXJbZVt0XV0rPW59LGEuc29ydD1mdW5jdGlvbigpe2k9cyhlLG8pLmNvbmNhdChzKG4sbykpfSwoYS5yZXNldD10KSgpLGF9KCksWm49L14kfFs7e11bXFxzXFxuXSokLztmdW5jdGlvbiBLbihlKXtyZXR1cm5cImNvbW1lbnQyXCI9PWUudHlwZSYmL0BwcmVzZXJ2ZXxAbGljZW5zZXxAY2Nfb24vaS50ZXN0KGUudmFsdWUpfWZ1bmN0aW9uIFFuKHMpe3ZhciBlPSFzO3M9WShzLHthc2NpaV9vbmx5OiExLGJlYXV0aWZ5OiExLGJyYWNlczohMSxjb21tZW50czohMSxpZTg6ITEsaW5kZW50X2xldmVsOjQsaW5kZW50X3N0YXJ0OjAsaW5saW5lX3NjcmlwdDohMCxrZWVwX3F1b3RlZF9wcm9wczohMSxtYXhfbGluZV9sZW46ITEscHJlYW1ibGU6bnVsbCxwcmVzZXJ2ZV9saW5lOiExLHF1b3RlX2tleXM6ITEscXVvdGVfc3R5bGU6MCxzZW1pY29sb25zOiEwLHNoZWJhbmc6ITAsc291cmNlX21hcDpudWxsLHdlYmtpdDohMSx3aWR0aDo4MCx3cmFwX2lpZmU6ITF9LCEwKTt2YXIgdT1pZTtpZihzLmNvbW1lbnRzKXt2YXIgbj1zLmNvbW1lbnRzO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBzLmNvbW1lbnRzJiYvXlxcLy4qXFwvW2EtekEtWl0qJC8udGVzdChzLmNvbW1lbnRzKSl7dmFyIHQ9cy5jb21tZW50cy5sYXN0SW5kZXhPZihcIi9cIik7bj1uZXcgUmVnRXhwKHMuY29tbWVudHMuc3Vic3RyKDEsdC0xKSxzLmNvbW1lbnRzLnN1YnN0cih0KzEpKX11PW4gaW5zdGFuY2VvZiBSZWdFeHA/ZnVuY3Rpb24oZSl7cmV0dXJuXCJjb21tZW50NVwiIT1lLnR5cGUmJm4udGVzdChlLnZhbHVlKX06XCJmdW5jdGlvblwiPT10eXBlb2Ygbj9mdW5jdGlvbihlKXtyZXR1cm5cImNvbW1lbnQ1XCIhPWUudHlwZSYmbih0aGlzLGUpfTpcInNvbWVcIj09PW4/S246Sn12YXIgcj0wLGE9MCxjPTEsZj0wLGw9XCJcIixwPXMuYXNjaWlfb25seT9mdW5jdGlvbihlLHQpe3JldHVybiBlLnJlcGxhY2UoL1tcXHUwMDAwLVxcdTAwMWZcXHUwMDdmLVxcdWZmZmZdL2csZnVuY3Rpb24oZSl7dmFyIG49ZS5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KTtpZihuLmxlbmd0aDw9MiYmIXQpe2Zvcig7bi5sZW5ndGg8Mjspbj1cIjBcIituO3JldHVyblwiXFxcXHhcIitufWZvcig7bi5sZW5ndGg8NDspbj1cIjBcIituO3JldHVyblwiXFxcXHVcIitufSl9OmZ1bmN0aW9uKGUpe2Zvcih2YXIgbj1cIlwiLHQ9MCxpPWUubGVuZ3RoO3Q8aTt0KyspJG4oZVt0XSkmJiF6bihlW3QrMV0pfHx6bihlW3RdKSYmISRuKGVbdC0xXSk/bis9XCJcXFxcdVwiK2UuY2hhckNvZGVBdCh0KS50b1N0cmluZygxNik6bis9ZVt0XTtyZXR1cm4gbn07ZnVuY3Rpb24gbyhlLG4pe3ZhciB0PWZ1bmN0aW9uKHQsZSl7dmFyIGk9MCxyPTA7ZnVuY3Rpb24gbigpe3JldHVyblwiJ1wiK3QucmVwbGFjZSgvXFx4MjcvZyxcIlxcXFwnXCIpK1wiJ1wifWZ1bmN0aW9uIG8oKXtyZXR1cm4nXCInK3QucmVwbGFjZSgvXFx4MjIvZywnXFxcXFwiJykrJ1wiJ31zd2l0Y2godD10LnJlcGxhY2UoL1tcXFxcXFxiXFxmXFxuXFxyXFx2XFx0XFx4MjJcXHgyN1xcdTIwMjhcXHUyMDI5XFwwXFx1ZmVmZl0vZyxmdW5jdGlvbihlLG4pe3N3aXRjaChlKXtjYXNlJ1wiJzpyZXR1cm4rK2ksJ1wiJztjYXNlXCInXCI6cmV0dXJuKytyLFwiJ1wiO2Nhc2VcIlxcXFxcIjpyZXR1cm5cIlxcXFxcXFxcXCI7Y2FzZVwiXFxuXCI6cmV0dXJuXCJcXFxcblwiO2Nhc2VcIlxcclwiOnJldHVyblwiXFxcXHJcIjtjYXNlXCJcXHRcIjpyZXR1cm5cIlxcXFx0XCI7Y2FzZVwiXFxiXCI6cmV0dXJuXCJcXFxcYlwiO2Nhc2VcIlxcZlwiOnJldHVyblwiXFxcXGZcIjtjYXNlXCJcXHZcIjpyZXR1cm4gcy5pZTg/XCJcXFxceDBCXCI6XCJcXFxcdlwiO2Nhc2VcIlxcdTIwMjhcIjpyZXR1cm5cIlxcXFx1MjAyOFwiO2Nhc2VcIlxcdTIwMjlcIjpyZXR1cm5cIlxcXFx1MjAyOVwiO2Nhc2VcIlxcdWZlZmZcIjpyZXR1cm5cIlxcXFx1ZmVmZlwiO2Nhc2VcIlxcMFwiOnJldHVybi9bMC05XS8udGVzdCh0LmNoYXJBdChuKzEpKT9cIlxcXFx4MDBcIjpcIlxcXFwwXCJ9cmV0dXJuIGV9KSx0PXAodCkscy5xdW90ZV9zdHlsZSl7Y2FzZSAxOnJldHVybiBuKCk7Y2FzZSAyOnJldHVybiBvKCk7Y2FzZSAzOnJldHVyblwiJ1wiPT1lP24oKTpvKCk7ZGVmYXVsdDpyZXR1cm4gcjxpP24oKTpvKCl9fShlLG4pO3JldHVybiBzLmlubGluZV9zY3JpcHQmJih0PSh0PSh0PXQucmVwbGFjZSgvPFxceDJmKHNjcmlwdCkoWz5cXC9cXHRcXG5cXGZcXHIgXSkvZ2ksXCI8XFxcXC8kMSQyXCIpKS5yZXBsYWNlKC9cXHgzYyEtLS9nLFwiXFxcXHgzYyEtLVwiKSkucmVwbGFjZSgvLS1cXHgzZS9nLFwiLS1cXFxceDNlXCIpKSx0fWZ1bmN0aW9uIGkoZSl7cmV0dXJuIGZ1bmN0aW9uIGUobix0KXtpZih0PD0wKXJldHVyblwiXCI7aWYoMT09dClyZXR1cm4gbjt2YXIgaT1lKG4sdD4+MSk7cmV0dXJuIGkrPWksMSZ0JiYoaSs9biksaX0oXCIgXCIscy5pbmRlbnRfc3RhcnQrci1lKnMuaW5kZW50X2xldmVsKX12YXIgZCxoLHY9ITEsXz0hMSxtPTAsZz0hMSxiPSExLHk9LTEsdz1cIlwiLHg9cy5zb3VyY2VfbWFwJiZbXSxBPXg/ZnVuY3Rpb24oKXt4LmZvckVhY2goZnVuY3Rpb24obil7dHJ5e3Muc291cmNlX21hcC5hZGQobi50b2tlbi5maWxlLG4ubGluZSxuLmNvbCxuLnRva2VuLmxpbmUsbi50b2tlbi5jb2wsbi5uYW1lfHxcIm5hbWVcIiE9bi50b2tlbi50eXBlP24ubmFtZTpuLnRva2VuLnZhbHVlKX1jYXRjaChlKXtzZS53YXJuKFwiQ291bGRuJ3QgZmlndXJlIG91dCBtYXBwaW5nIGZvciB7ZmlsZX06e2xpbmV9LHtjb2x9IOKGkiB7Y2xpbmV9LHtjY29sfSBbe25hbWV9XVwiLHtmaWxlOm4udG9rZW4uZmlsZSxsaW5lOm4udG9rZW4ubGluZSxjb2w6bi50b2tlbi5jb2wsY2xpbmU6bi5saW5lLGNjb2w6bi5jb2wsbmFtZTpuLm5hbWV8fFwiXCJ9KX19KSx4PVtdfTpMLEU9cy5tYXhfbGluZV9sZW4/ZnVuY3Rpb24oKXtpZihhPnMubWF4X2xpbmVfbGVuKXtpZihtKXt2YXIgZT1sLnNsaWNlKDAsbSksbj1sLnNsaWNlKG0pO2lmKHgpe3ZhciB0PW4ubGVuZ3RoLWE7eC5mb3JFYWNoKGZ1bmN0aW9uKGUpe2UubGluZSsrLGUuY29sKz10fSl9bD1lK1wiXFxuXCIrbixjKyssZisrLGE9bi5sZW5ndGh9YT5zLm1heF9saW5lX2xlbiYmc2Uud2FybihcIk91dHB1dCBleGNlZWRzIHttYXhfbGluZV9sZW59IGNoYXJhY3RlcnNcIixzKX1tJiYobT0wLEEoKSl9Okwsaz1XKFwiKCBbICsgKiAvIC0gLCAuXCIpO2Z1bmN0aW9uIEQoZSl7dmFyIG49KGU9U3RyaW5nKGUpKS5jaGFyQXQoMCk7ZyYmbiYmKGc9ITEsXCJcXG5cIiE9biYmKEQoXCJcXG5cIiksQygpKSksYiYmbiYmKGI9ITEsL1tcXHM7fSldLy50ZXN0KG4pfHxGKCkpLHk9LTE7dmFyIHQ9dy5jaGFyQXQody5sZW5ndGgtMSk7aWYoXyYmKF89ITEsKFwiOlwiPT10JiZcIn1cIj09bnx8KCFufHxcIjt9XCIuaW5kZXhPZihuKTwwKSYmXCI7XCIhPXQpJiYocy5zZW1pY29sb25zfHxrKG4pPyhsKz1cIjtcIixhKyssZisrKTooRSgpLGwrPVwiXFxuXCIsZisrLGMrKyxhPTAsL15cXHMrJC8udGVzdChlKSYmKF89ITApKSxzLmJlYXV0aWZ5fHwodj0hMSkpKSwhcy5iZWF1dGlmeSYmcy5wcmVzZXJ2ZV9saW5lJiZxW3EubGVuZ3RoLTFdKWZvcih2YXIgaT1xW3EubGVuZ3RoLTFdLnN0YXJ0LmxpbmU7YzxpOylFKCksbCs9XCJcXG5cIixmKyssYysrLGE9MCx2PSExO3YmJigoam4odCkmJihqbihuKXx8XCJcXFxcXCI9PW4pfHxcIi9cIj09biYmbj09dHx8KFwiK1wiPT1ufHxcIi1cIj09bikmJm49PXcpJiYobCs9XCIgXCIsYSsrLGYrKyksdj0hMSksZCYmKHgucHVzaCh7dG9rZW46ZCxuYW1lOmgsbGluZTpjLGNvbDphfSksZD0hMSxtfHxBKCkpLGwrPWUsZis9ZS5sZW5ndGg7dmFyIHI9ZS5zcGxpdCgvXFxyP1xcbi8pLG89ci5sZW5ndGgtMTtjKz1vLGErPXJbMF0ubGVuZ3RoLDA8byYmKEUoKSxhPXJbb10ubGVuZ3RoKSx3PWV9dmFyIEY9cy5iZWF1dGlmeT9mdW5jdGlvbigpe0QoXCIgXCIpfTpmdW5jdGlvbigpe3Y9ITB9LEM9cy5iZWF1dGlmeT9mdW5jdGlvbihlKXtzLmJlYXV0aWZ5JiZEKGkoZT8uNTowKSl9OkwsQj1zLmJlYXV0aWZ5P2Z1bmN0aW9uKGUsbil7ITA9PT1lJiYoZT0kKCkpO3ZhciB0PXI7cj1lO3ZhciBpPW4oKTtyZXR1cm4gcj10LGl9OmZ1bmN0aW9uKGUsbil7cmV0dXJuIG4oKX0sUz1zLmJlYXV0aWZ5P2Z1bmN0aW9uKCl7aWYoeTwwKXJldHVybiBEKFwiXFxuXCIpO1wiXFxuXCIhPWxbeV0mJihsPWwuc2xpY2UoMCx5KStcIlxcblwiK2wuc2xpY2UoeSksZisrLGMrKykseSsrfTpzLm1heF9saW5lX2xlbj9mdW5jdGlvbigpe0UoKSxtPWwubGVuZ3RofTpMLFQ9cy5iZWF1dGlmeT9mdW5jdGlvbigpe0QoXCI7XCIpfTpmdW5jdGlvbigpe189ITB9O2Z1bmN0aW9uIE8oKXtfPSExLEQoXCI7XCIpfWZ1bmN0aW9uICQoKXtyZXR1cm4gcitzLmluZGVudF9sZXZlbH1mdW5jdGlvbiB6KCl7cmV0dXJuIG0mJkUoKSxsfWZ1bmN0aW9uIE0oKXt2YXIgZT1sLmxhc3RJbmRleE9mKFwiXFxuXCIpO3JldHVybi9eICokLy50ZXN0KGwuc2xpY2UoZSsxKSl9dmFyIHE9W107cmV0dXJue2dldDp6LHRvU3RyaW5nOnosaW5kZW50OkMsaW5kZW50YXRpb246ZnVuY3Rpb24oKXtyZXR1cm4gcn0sY3VycmVudF93aWR0aDpmdW5jdGlvbigpe3JldHVybiBhLXJ9LHNob3VsZF9icmVhazpmdW5jdGlvbigpe3JldHVybiBzLndpZHRoJiZ0aGlzLmN1cnJlbnRfd2lkdGgoKT49cy53aWR0aH0saGFzX3BhcmVuczpmdW5jdGlvbigpe3JldHVyblwiKFwiPT1sLnNsaWNlKC0xKX0sbmV3bGluZTpTLHByaW50OkQsc3BhY2U6Rixjb21tYTpmdW5jdGlvbigpe0QoXCIsXCIpLEYoKX0sY29sb246ZnVuY3Rpb24oKXtEKFwiOlwiKSxGKCl9LGxhc3Q6ZnVuY3Rpb24oKXtyZXR1cm4gd30sc2VtaWNvbG9uOlQsZm9yY2Vfc2VtaWNvbG9uOk8sdG9fdXRmODpwLHByaW50X25hbWU6ZnVuY3Rpb24oZSl7dmFyIG47RCgobj0obj1lKS50b1N0cmluZygpLG49cChuLCEwKSkpfSxwcmludF9zdHJpbmc6ZnVuY3Rpb24oZSxuLHQpe3ZhciBpPW8oZSxuKTshMD09PXQmJi0xPT09aS5pbmRleE9mKFwiXFxcXFwiKSYmKFpuLnRlc3QobCl8fE8oKSxPKCkpLEQoaSl9LGVuY29kZV9zdHJpbmc6byxuZXh0X2luZGVudDokLHdpdGhfaW5kZW50OkIsd2l0aF9ibG9jazpmdW5jdGlvbihlKXt2YXIgbjtyZXR1cm4gRChcIntcIiksUygpLEIoJCgpLGZ1bmN0aW9uKCl7bj1lKCl9KSxDKCksRChcIn1cIiksbn0sd2l0aF9wYXJlbnM6ZnVuY3Rpb24oZSl7RChcIihcIik7dmFyIG49ZSgpO3JldHVybiBEKFwiKVwiKSxufSx3aXRoX3NxdWFyZTpmdW5jdGlvbihlKXtEKFwiW1wiKTt2YXIgbj1lKCk7cmV0dXJuIEQoXCJdXCIpLG59LGFkZF9tYXBwaW5nOng/ZnVuY3Rpb24oZSxuKXtkPWUsaD1ufTpMLG9wdGlvbjpmdW5jdGlvbihlKXtyZXR1cm4gc1tlXX0scHJlcGVuZF9jb21tZW50czplP0w6ZnVuY3Rpb24oZSl7dmFyIGk9dGhpcyxuPWUuc3RhcnQ7aWYobiYmKCFuLmNvbW1lbnRzX2JlZm9yZXx8bi5jb21tZW50c19iZWZvcmUuX2R1bXBlZCE9PWkpKXt2YXIgcj1uLmNvbW1lbnRzX2JlZm9yZTtpZihyfHwocj1uLmNvbW1lbnRzX2JlZm9yZT1bXSksci5fZHVtcGVkPWksZSBpbnN0YW5jZW9mIFNlJiZlLnZhbHVlKXt2YXIgbz1uZXcgU24oZnVuY3Rpb24oZSl7dmFyIG49by5wYXJlbnQoKTtpZighKG4gaW5zdGFuY2VvZiBTZXx8biBpbnN0YW5jZW9mIG5uJiZuLmxlZnQ9PT1lfHxcIkNhbGxcIj09bi5UWVBFJiZuLmV4cHJlc3Npb249PT1lfHxuIGluc3RhbmNlb2YgdG4mJm4uY29uZGl0aW9uPT09ZXx8biBpbnN0YW5jZW9mIFhlJiZuLmV4cHJlc3Npb249PT1lfHxuIGluc3RhbmNlb2YgV2UmJm4uZXhwcmVzc2lvbnNbMF09PT1lfHxuIGluc3RhbmNlb2YgWmUmJm4uZXhwcmVzc2lvbj09PWV8fG4gaW5zdGFuY2VvZiBlbikpcmV0dXJuITA7dmFyIHQ9ZS5zdGFydC5jb21tZW50c19iZWZvcmU7dCYmdC5fZHVtcGVkIT09aSYmKHQuX2R1bXBlZD1pLHI9ci5jb25jYXQodCkpfSk7by5wdXNoKGUpLGUudmFsdWUud2FsayhvKX1pZigwPT1mKXswPHIubGVuZ3RoJiZzLnNoZWJhbmcmJlwiY29tbWVudDVcIj09clswXS50eXBlJiYoRChcIiMhXCIrci5zaGlmdCgpLnZhbHVlK1wiXFxuXCIpLEMoKSk7dmFyIHQ9cy5wcmVhbWJsZTt0JiZEKHQucmVwbGFjZSgvXFxyXFxuP3xbXFxuXFx1MjAyOFxcdTIwMjldfFxccyokL2csXCJcXG5cIikpfWlmKDAhPShyPXIuZmlsdGVyKHUsZSkpLmxlbmd0aCl7dmFyIGE9TSgpO3IuZm9yRWFjaChmdW5jdGlvbihlLG4pe2F8fChlLm5sYj8oRChcIlxcblwiKSxDKCksYT0hMCk6MDxuJiZGKCkpLC9jb21tZW50WzEzNF0vLnRlc3QoZS50eXBlKT8oRChcIi8vXCIrZS52YWx1ZS5yZXBsYWNlKC9bQCNdX19QVVJFX18vZyxcIiBcIikrXCJcXG5cIiksQygpLGE9ITApOlwiY29tbWVudDJcIj09ZS50eXBlJiYoRChcIi8qXCIrZS52YWx1ZS5yZXBsYWNlKC9bQCNdX19QVVJFX18vZyxcIiBcIikrXCIqL1wiKSxhPSExKX0pLGF8fChuLm5sYj8oRChcIlxcblwiKSxDKCkpOkYoKSl9fX0sYXBwZW5kX2NvbW1lbnRzOmV8fHU9PT1pZT9MOmZ1bmN0aW9uKGUsdCl7dmFyIG49ZS5lbmQ7aWYobil7dmFyIGk9blt0P1wiY29tbWVudHNfYmVmb3JlXCI6XCJjb21tZW50c19hZnRlclwiXTtpZihpJiZpLl9kdW1wZWQhPT10aGlzJiYoZSBpbnN0YW5jZW9mIHVlfHxvZShpLGZ1bmN0aW9uKGUpe3JldHVybiEvY29tbWVudFsxMzRdLy50ZXN0KGUudHlwZSl9KSkpe2kuX2R1bXBlZD10aGlzO3ZhciByPWwubGVuZ3RoO2kuZmlsdGVyKHUsZSkuZm9yRWFjaChmdW5jdGlvbihlLG4pe2I9ITEsZz8oRChcIlxcblwiKSxDKCksZz0hMSk6ZS5ubGImJigwPG58fCFNKCkpPyhEKFwiXFxuXCIpLEMoKSk6KDA8bnx8IXQpJiZGKCksL2NvbW1lbnRbMTM0XS8udGVzdChlLnR5cGUpPyhEKFwiLy9cIitlLnZhbHVlLnJlcGxhY2UoL1tAI11fX1BVUkVfXy9nLFwiIFwiKSksZz0hMCk6XCJjb21tZW50MlwiPT1lLnR5cGUmJihEKFwiLypcIitlLnZhbHVlLnJlcGxhY2UoL1tAI11fX1BVUkVfXy9nLFwiIFwiKStcIiovXCIpLGI9ITApfSksbC5sZW5ndGg+ciYmKHk9cil9fX0sbGluZTpmdW5jdGlvbigpe3JldHVybiBjfSxjb2w6ZnVuY3Rpb24oKXtyZXR1cm4gYX0scG9zOmZ1bmN0aW9uKCl7cmV0dXJuIGZ9LHB1c2hfbm9kZTpmdW5jdGlvbihlKXtxLnB1c2goZSl9LHBvcF9ub2RlOmZ1bmN0aW9uKCl7cmV0dXJuIHEucG9wKCl9LHBhcmVudDpmdW5jdGlvbihlKXtyZXR1cm4gcVtxLmxlbmd0aC0yLShlfHwwKV19fX1mdW5jdGlvbiBldChlLG4pe2lmKCEodGhpcyBpbnN0YW5jZW9mIGV0KSlyZXR1cm4gbmV3IGV0KGUsbik7WG4uY2FsbCh0aGlzLHRoaXMuYmVmb3JlLHRoaXMuYWZ0ZXIpLHRoaXMub3B0aW9ucz1ZKGUse2FyZ3VtZW50czohbixib29sZWFuczohbixjb2xsYXBzZV92YXJzOiFuLGNvbXBhcmlzb25zOiFuLGNvbmRpdGlvbmFsczohbixkZWFkX2NvZGU6IW4sZHJvcF9jb25zb2xlOiExLGRyb3BfZGVidWdnZXI6IW4sZXZhbHVhdGU6IW4sZXhwcmVzc2lvbjohMSxnbG9iYWxfZGVmczp7fSxob2lzdF9mdW5zOiExLGhvaXN0X3Byb3BzOiFuLGhvaXN0X3ZhcnM6ITEsaWU4OiExLGlmX3JldHVybjohbixpbmxpbmU6IW4sam9pbl92YXJzOiFuLGtlZXBfZmFyZ3M6ITAsa2VlcF9mbmFtZXM6ITEsa2VlcF9pbmZpbml0eTohMSxsb29wczohbixuZWdhdGVfaWlmZTohbixwYXNzZXM6MSxwcm9wZXJ0aWVzOiFuLHB1cmVfZ2V0dGVyczohbiYmXCJzdHJpY3RcIixwdXJlX2Z1bmNzOm51bGwscmVkdWNlX2Z1bmNzOiFuLHJlZHVjZV92YXJzOiFuLHNlcXVlbmNlczohbixzaWRlX2VmZmVjdHM6IW4sc3dpdGNoZXM6IW4sdG9wX3JldGFpbjpudWxsLHRvcGxldmVsOiEoIWV8fCFlLnRvcF9yZXRhaW4pLHR5cGVvZnM6IW4sdW5zYWZlOiExLHVuc2FmZV9jb21wczohMSx1bnNhZmVfRnVuY3Rpb246ITEsdW5zYWZlX21hdGg6ITEsdW5zYWZlX3Byb3RvOiExLHVuc2FmZV9yZWdleHA6ITEsdW5zYWZlX3VuZGVmaW5lZDohMSx1bnVzZWQ6IW4sd2FybmluZ3M6ITF9LCEwKTt2YXIgdD10aGlzLm9wdGlvbnMuZ2xvYmFsX2RlZnM7aWYoXCJvYmplY3RcIj09dHlwZW9mIHQpZm9yKHZhciBpIGluIHQpL15ALy50ZXN0KGkpJiZhZSh0LGkpJiYodFtpLnNsaWNlKDEpXT1Hbih0W2ldLHtleHByZXNzaW9uOiEwfSkpOyEwPT09dGhpcy5vcHRpb25zLmlubGluZSYmKHRoaXMub3B0aW9ucy5pbmxpbmU9Myk7dmFyIHI9dGhpcy5vcHRpb25zLnB1cmVfZnVuY3M7dGhpcy5wdXJlX2Z1bmNzPVwiZnVuY3Rpb25cIj09dHlwZW9mIHI/cjpyP2Z1bmN0aW9uKGUpe3JldHVybiByLmluZGV4T2YoZS5leHByZXNzaW9uLnByaW50X3RvX3N0cmluZygpKTwwfTpKO3ZhciBvPXRoaXMub3B0aW9ucy50b3BfcmV0YWluO28gaW5zdGFuY2VvZiBSZWdFeHA/dGhpcy50b3BfcmV0YWluPWZ1bmN0aW9uKGUpe3JldHVybiBvLnRlc3QoZS5uYW1lKX06XCJmdW5jdGlvblwiPT10eXBlb2Ygbz90aGlzLnRvcF9yZXRhaW49bzpvJiYoXCJzdHJpbmdcIj09dHlwZW9mIG8mJihvPW8uc3BsaXQoLywvKSksdGhpcy50b3BfcmV0YWluPWZ1bmN0aW9uKGUpe3JldHVybiAwPD1vLmluZGV4T2YoZS5uYW1lKX0pO3ZhciBhPXRoaXMub3B0aW9ucy50b3BsZXZlbDt0aGlzLnRvcGxldmVsPVwic3RyaW5nXCI9PXR5cGVvZiBhP3tmdW5jczovZnVuY3MvLnRlc3QoYSksdmFyczovdmFycy8udGVzdChhKX06e2Z1bmNzOmEsdmFyczphfTt2YXIgcz10aGlzLm9wdGlvbnMuc2VxdWVuY2VzO3RoaXMuc2VxdWVuY2VzX2xpbWl0PTE9PXM/ODAwOjB8cyx0aGlzLndhcm5pbmdzX3Byb2R1Y2VkPXt9fWZ1bmN0aW9uIGIoZSxuKXtlLndhbGsobmV3IFNuKGZ1bmN0aW9uKGUpe3JldHVybiBlIGluc3RhbmNlb2YgV2U/YihlLnRhaWxfbm9kZSgpLG4pOmUgaW5zdGFuY2VvZiBibj9uKGUudmFsdWUpOmUgaW5zdGFuY2VvZiB0biYmKGIoZS5jb25zZXF1ZW50LG4pLGIoZS5hbHRlcm5hdGl2ZSxuKSksITB9KSl9ZnVuY3Rpb24gZChlLG4pe3ZhciB0PShuPVkobix7YnVpbHRpbnM6ITEsY2FjaGU6bnVsbCxkZWJ1ZzohMSxrZWVwX3F1b3RlZDohMSxvbmx5X2NhY2hlOiExLHJlZ2V4Om51bGwscmVzZXJ2ZWQ6bnVsbH0sITApKS5yZXNlcnZlZDtBcnJheS5pc0FycmF5KHQpfHwodD1bXSksbi5idWlsdGluc3x8ZnVuY3Rpb24obil7ZnVuY3Rpb24gdChlKXt2KG4sZSl9W1wibnVsbFwiLFwidHJ1ZVwiLFwiZmFsc2VcIixcIkluZmluaXR5XCIsXCItSW5maW5pdHlcIixcInVuZGVmaW5lZFwiXS5mb3JFYWNoKHQpLFtPYmplY3QsQXJyYXksRnVuY3Rpb24sTnVtYmVyLFN0cmluZyxCb29sZWFuLEVycm9yLE1hdGgsRGF0ZSxSZWdFeHBdLmZvckVhY2goZnVuY3Rpb24oZSl7T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZSkubWFwKHQpLGUucHJvdG90eXBlJiZPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhlLnByb3RvdHlwZSkubWFwKHQpfSl9KHQpO3ZhciBpLHI9LTE7bi5jYWNoZT8oaT1uLmNhY2hlLnByb3BzKS5lYWNoKGZ1bmN0aW9uKGUpe3YodCxlKX0pOmk9bmV3IE87dmFyIG8sYT1uLnJlZ2V4LHM9ITEhPT1uLmRlYnVnO3MmJihvPSEwPT09bi5kZWJ1Zz9cIlwiOm4uZGVidWcpO3ZhciB1PVtdLGM9W107cmV0dXJuIGUud2FsayhuZXcgU24oZnVuY3Rpb24oZSl7ZSBpbnN0YW5jZW9mIHVuP3AoZS5rZXkpOmUgaW5zdGFuY2VvZiBzbj9wKGUua2V5Lm5hbWUpOmUgaW5zdGFuY2VvZiBYZT9wKGUucHJvcGVydHkpOmUgaW5zdGFuY2VvZiBaZSYmYihlLnByb3BlcnR5LHApfSkpLGUudHJhbnNmb3JtKG5ldyBYbihmdW5jdGlvbihlKXtlIGluc3RhbmNlb2YgdW4/ZS5rZXk9ZChlLmtleSk6ZSBpbnN0YW5jZW9mIHNuP2Uua2V5Lm5hbWU9ZChlLmtleS5uYW1lKTplIGluc3RhbmNlb2YgWGU/ZS5wcm9wZXJ0eT1kKGUucHJvcGVydHkpOiFuLmtlZXBfcXVvdGVkJiZlIGluc3RhbmNlb2YgWmUmJihlLnByb3BlcnR5PWZ1bmN0aW9uIHQoZSl7cmV0dXJuIGUudHJhbnNmb3JtKG5ldyBYbihmdW5jdGlvbihlKXtpZihlIGluc3RhbmNlb2YgV2Upe3ZhciBuPWUuZXhwcmVzc2lvbnMubGVuZ3RoLTE7ZS5leHByZXNzaW9uc1tuXT10KGUuZXhwcmVzc2lvbnNbbl0pfWVsc2UgZSBpbnN0YW5jZW9mIGJuP2UudmFsdWU9ZChlLnZhbHVlKTplIGluc3RhbmNlb2YgdG4mJihlLmNvbnNlcXVlbnQ9dChlLmNvbnNlcXVlbnQpLGUuYWx0ZXJuYXRpdmU9dChlLmFsdGVybmF0aXZlKSk7cmV0dXJuIGV9KSl9KGUucHJvcGVydHkpKX0pKTtmdW5jdGlvbiBmKGUpe3JldHVybiEoMDw9Yy5pbmRleE9mKGUpKSYmKCEoMDw9dC5pbmRleE9mKGUpKSYmKG4ub25seV9jYWNoZT9pLmhhcyhlKTohL14tP1swLTldKyhcXC5bMC05XSspPyhlWystXVswLTldKyk/JC8udGVzdChlKSkpfWZ1bmN0aW9uIGwoZSl7cmV0dXJuIShhJiYhYS50ZXN0KGUpKSYmKCEoMDw9dC5pbmRleE9mKGUpKSYmKGkuaGFzKGUpfHwwPD11LmluZGV4T2YoZSkpKX1mdW5jdGlvbiBwKGUpe2YoZSkmJnYodSxlKSxsKGUpfHx2KGMsZSl9ZnVuY3Rpb24gZChlKXtpZighbChlKSlyZXR1cm4gZTt2YXIgbj1pLmdldChlKTtpZighbil7aWYocyl7dmFyIHQ9XCJfJFwiK2UrXCIkXCIrbytcIl9cIjtmKHQpJiYobj10KX1pZighbilmb3IoOyFmKG49ZygrK3IpKTspO2kuc2V0KGUsbil9cmV0dXJuIG59fSFmdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSxuKXtlLkRFRk1FVEhPRChcIl9jb2RlZ2VuXCIsbil9dmFyIG89ITEsYT1udWxsLHM9bnVsbDtmdW5jdGlvbiB0KGUsbil7QXJyYXkuaXNBcnJheShlKT9lLmZvckVhY2goZnVuY3Rpb24oZSl7dChlLG4pfSk6ZS5ERUZNRVRIT0QoXCJuZWVkc19wYXJlbnNcIixuKX1mdW5jdGlvbiBpKGUsdCxpLG4pe3ZhciByPWUubGVuZ3RoLTE7bz1uLGUuZm9yRWFjaChmdW5jdGlvbihlLG4peyEwIT09b3x8ZSBpbnN0YW5jZW9mIGZlfHxlIGluc3RhbmNlb2YgaGV8fGUgaW5zdGFuY2VvZiBsZSYmZS5ib2R5IGluc3RhbmNlb2YgYm58fChvPSExKSxlIGluc3RhbmNlb2YgaGV8fChpLmluZGVudCgpLGUucHJpbnQoaSksbj09ciYmdHx8KGkubmV3bGluZSgpLHQmJmkubmV3bGluZSgpKSksITA9PT1vJiZlIGluc3RhbmNlb2YgbGUmJmUuYm9keSBpbnN0YW5jZW9mIGJuJiYobz0hMSl9KSxvPSExfWZ1bmN0aW9uIHIoZSxuKXtuLnByaW50KFwie1wiKSxuLndpdGhfaW5kZW50KG4ubmV4dF9pbmRlbnQoKSxmdW5jdGlvbigpe24uYXBwZW5kX2NvbW1lbnRzKGUsITApfSksbi5wcmludChcIn1cIil9ZnVuY3Rpb24gdShlLG4sdCl7MDxlLmJvZHkubGVuZ3RoP24ud2l0aF9ibG9jayhmdW5jdGlvbigpe2koZS5ib2R5LCExLG4sdCl9KTpyKGUsbil9ZnVuY3Rpb24gYyhlLG4sdCl7dmFyIGk9ITE7dCYmZS53YWxrKG5ldyBTbihmdW5jdGlvbihlKXtyZXR1cm4hIShpfHxlIGluc3RhbmNlb2YgQWUpfHwoZSBpbnN0YW5jZW9mIG5uJiZcImluXCI9PWUub3BlcmF0b3I/aT0hMDp2b2lkIDApfSkpLGUucHJpbnQobixpKX1mdW5jdGlvbiBmKGUsbix0KXt0Lm9wdGlvbihcInF1b3RlX2tleXNcIik/dC5wcmludF9zdHJpbmcoZSk6XCJcIisgK2U9PWUmJjA8PWU/dC5wcmludChkKGUpKToobShlKT8hdC5vcHRpb24oXCJpZThcIik6Tm4oZSkpP24mJnQub3B0aW9uKFwia2VlcF9xdW90ZWRfcHJvcHNcIik/dC5wcmludF9zdHJpbmcoZSxuKTp0LnByaW50X25hbWUoZSk6dC5wcmludF9zdHJpbmcoZSxuKX1mdW5jdGlvbiBsKGUsbil7bi5vcHRpb24oXCJicmFjZXNcIik/aChlLG4pOiFlfHxlIGluc3RhbmNlb2YgaGU/bi5mb3JjZV9zZW1pY29sb24oKTplLnByaW50KG4pfWZ1bmN0aW9uIHAoZSxuKXtyZXR1cm4gMDxlLmFyZ3MubGVuZ3RofHxuLm9wdGlvbihcImJlYXV0aWZ5XCIpfWZ1bmN0aW9uIGQoZSl7dmFyIG4sdD1lLnRvU3RyaW5nKDEwKSxpPVt0LnJlcGxhY2UoL14wXFwuLyxcIi5cIikucmVwbGFjZShcImUrXCIsXCJlXCIpXTtyZXR1cm4gTWF0aC5mbG9vcihlKT09PWU/KDA8PWU/aS5wdXNoKFwiMHhcIitlLnRvU3RyaW5nKDE2KS50b0xvd2VyQ2FzZSgpLFwiMFwiK2UudG9TdHJpbmcoOCkpOmkucHVzaChcIi0weFwiKygtZSkudG9TdHJpbmcoMTYpLnRvTG93ZXJDYXNlKCksXCItMFwiKygtZSkudG9TdHJpbmcoOCkpLChuPS9eKC4qPykoMCspJC8uZXhlYyhlKSkmJmkucHVzaChuWzFdK1wiZVwiK25bMl0ubGVuZ3RoKSk6KG49L14wP1xcLigwKykoLiopJC8uZXhlYyhlKSkmJmkucHVzaChuWzJdK1wiZS1cIisoblsxXS5sZW5ndGgrblsyXS5sZW5ndGgpLHQuc3Vic3RyKHQuaW5kZXhPZihcIi5cIikpKSxmdW5jdGlvbihlKXtmb3IodmFyIG49ZVswXSx0PW4ubGVuZ3RoLGk9MTtpPGUubGVuZ3RoOysraSllW2ldLmxlbmd0aDx0JiYodD0obj1lW2ldKS5sZW5ndGgpO3JldHVybiBufShpKX1mdW5jdGlvbiBoKGUsbil7IWV8fGUgaW5zdGFuY2VvZiBoZT9uLnByaW50KFwie31cIik6ZSBpbnN0YW5jZW9mIGRlP2UucHJpbnQobik6bi53aXRoX2Jsb2NrKGZ1bmN0aW9uKCl7bi5pbmRlbnQoKSxlLnByaW50KG4pLG4ubmV3bGluZSgpfSl9ZnVuY3Rpb24gbihlLG4pe2UuREVGTUVUSE9EKFwiYWRkX3NvdXJjZV9tYXBcIixmdW5jdGlvbihlKXtuKHRoaXMsZSl9KX1mdW5jdGlvbiB2KGUsbil7bi5hZGRfbWFwcGluZyhlLnN0YXJ0KX1zZS5ERUZNRVRIT0QoXCJwcmludFwiLGZ1bmN0aW9uKGUsbil7dmFyIHQ9dGhpcyxpPXQuX2NvZGVnZW47ZnVuY3Rpb24gcigpe2UucHJlcGVuZF9jb21tZW50cyh0KSx0LmFkZF9zb3VyY2VfbWFwKGUpLGkodCxlKSxlLmFwcGVuZF9jb21tZW50cyh0KX10IGluc3RhbmNlb2YgQWU/YT10OiFzJiZ0IGluc3RhbmNlb2YgZmUmJlwidXNlIGFzbVwiPT10LnZhbHVlJiYocz1hKSxlLnB1c2hfbm9kZSh0KSxufHx0Lm5lZWRzX3BhcmVucyhlKT9lLndpdGhfcGFyZW5zKHIpOnIoKSxlLnBvcF9ub2RlKCksdD09PXMmJihzPW51bGwpfSksc2UuREVGTUVUSE9EKFwiX3ByaW50XCIsc2UucHJvdG90eXBlLnByaW50KSxzZS5ERUZNRVRIT0QoXCJwcmludF90b19zdHJpbmdcIixmdW5jdGlvbihlKXt2YXIgbj1RbihlKTtyZXR1cm4gdGhpcy5wcmludChuKSxuLmdldCgpfSksdChzZSxpZSksdChGZSxmdW5jdGlvbihlKXtpZighZS5oYXNfcGFyZW5zKCkmJiQoZSkpcmV0dXJuITA7dmFyIG47aWYoZS5vcHRpb24oXCJ3ZWJraXRcIikmJigobj1lLnBhcmVudCgpKWluc3RhbmNlb2YgR2UmJm4uZXhwcmVzc2lvbj09PXRoaXMpKXJldHVybiEwO3JldHVybiEhZS5vcHRpb24oXCJ3cmFwX2lpZmVcIikmJigobj1lLnBhcmVudCgpKWluc3RhbmNlb2YgWWUmJm4uZXhwcmVzc2lvbj09PXRoaXMpfSksdChhbixmdW5jdGlvbihlKXtyZXR1cm4hZS5oYXNfcGFyZW5zKCkmJiQoZSl9KSx0KEtlLGZ1bmN0aW9uKGUpe3ZhciBuPWUucGFyZW50KCk7cmV0dXJuIG4gaW5zdGFuY2VvZiBHZSYmbi5leHByZXNzaW9uPT09dGhpc3x8biBpbnN0YW5jZW9mIFllJiZuLmV4cHJlc3Npb249PT10aGlzfSksdChXZSxmdW5jdGlvbihlKXt2YXIgbj1lLnBhcmVudCgpO3JldHVybiBuIGluc3RhbmNlb2YgWWV8fG4gaW5zdGFuY2VvZiBLZXx8biBpbnN0YW5jZW9mIG5ufHxuIGluc3RhbmNlb2YgVmV8fG4gaW5zdGFuY2VvZiBHZXx8biBpbnN0YW5jZW9mIG9ufHxuIGluc3RhbmNlb2Ygc258fG4gaW5zdGFuY2VvZiB0bn0pLHQobm4sZnVuY3Rpb24oZSl7dmFyIG49ZS5wYXJlbnQoKTtpZihuIGluc3RhbmNlb2YgWWUmJm4uZXhwcmVzc2lvbj09PXRoaXMpcmV0dXJuITA7aWYobiBpbnN0YW5jZW9mIEtlKXJldHVybiEwO2lmKG4gaW5zdGFuY2VvZiBHZSYmbi5leHByZXNzaW9uPT09dGhpcylyZXR1cm4hMDtpZihuIGluc3RhbmNlb2Ygbm4pe3ZhciB0PW4ub3BlcmF0b3IsaT1Kblt0XSxyPXRoaXMub3BlcmF0b3Isbz1KbltyXTtpZihvPGl8fGk9PW8mJnRoaXM9PT1uLnJpZ2h0KXJldHVybiEwfX0pLHQoR2UsZnVuY3Rpb24oZSl7dmFyIG49ZS5wYXJlbnQoKTtpZihuIGluc3RhbmNlb2YgSmUmJm4uZXhwcmVzc2lvbj09PXRoaXMpe3ZhciB0PSExO3JldHVybiB0aGlzLndhbGsobmV3IFNuKGZ1bmN0aW9uKGUpe3JldHVybiEhKHR8fGUgaW5zdGFuY2VvZiBBZSl8fChlIGluc3RhbmNlb2YgWWU/dD0hMDp2b2lkIDApfSkpLHR9fSksdChZZSxmdW5jdGlvbihlKXt2YXIgbix0PWUucGFyZW50KCk7cmV0dXJuIHQgaW5zdGFuY2VvZiBKZSYmdC5leHByZXNzaW9uPT09dGhpc3x8dGhpcy5leHByZXNzaW9uIGluc3RhbmNlb2YgRmUmJnQgaW5zdGFuY2VvZiBHZSYmdC5leHByZXNzaW9uPT09dGhpcyYmKG49ZS5wYXJlbnQoMSkpaW5zdGFuY2VvZiBybiYmbi5sZWZ0PT09dH0pLHQoSmUsZnVuY3Rpb24oZSl7dmFyIG49ZS5wYXJlbnQoKTtpZighcCh0aGlzLGUpJiYobiBpbnN0YW5jZW9mIEdlfHxuIGluc3RhbmNlb2YgWWUmJm4uZXhwcmVzc2lvbj09PXRoaXMpKXJldHVybiEwfSksdCh5bixmdW5jdGlvbihlKXt2YXIgbj1lLnBhcmVudCgpO2lmKG4gaW5zdGFuY2VvZiBHZSYmbi5leHByZXNzaW9uPT09dGhpcyl7dmFyIHQ9dGhpcy5nZXRWYWx1ZSgpO2lmKHQ8MHx8L14wLy50ZXN0KGQodCkpKXJldHVybiEwfX0pLHQoW3JuLHRuXSxmdW5jdGlvbihlKXt2YXIgbj1lLnBhcmVudCgpO3JldHVybiBuIGluc3RhbmNlb2YgS2V8fChuIGluc3RhbmNlb2Ygbm4mJiEobiBpbnN0YW5jZW9mIHJuKXx8KG4gaW5zdGFuY2VvZiBZZSYmbi5leHByZXNzaW9uPT09dGhpc3x8KG4gaW5zdGFuY2VvZiB0biYmbi5jb25kaXRpb249PT10aGlzfHwobiBpbnN0YW5jZW9mIEdlJiZuLmV4cHJlc3Npb249PT10aGlzfHx2b2lkIDApKSkpfSksZShmZSxmdW5jdGlvbihlLG4pe24ucHJpbnRfc3RyaW5nKGUudmFsdWUsZS5xdW90ZSksbi5zZW1pY29sb24oKX0pLGUoY2UsZnVuY3Rpb24oZSxuKXtuLnByaW50KFwiZGVidWdnZXJcIiksbi5zZW1pY29sb24oKX0pLF8uREVGTUVUSE9EKFwiX2RvX3ByaW50X2JvZHlcIixmdW5jdGlvbihlKXtsKHRoaXMuYm9keSxlKX0pLGUodWUsZnVuY3Rpb24oZSxuKXtlLmJvZHkucHJpbnQobiksbi5zZW1pY29sb24oKX0pLGUoRWUsZnVuY3Rpb24oZSxuKXtpKGUuYm9keSwhMCxuLCEwKSxuLnByaW50KFwiXCIpfSksZSh2ZSxmdW5jdGlvbihlLG4pe2UubGFiZWwucHJpbnQobiksbi5jb2xvbigpLGUuYm9keS5wcmludChuKX0pLGUobGUsZnVuY3Rpb24oZSxuKXtlLmJvZHkucHJpbnQobiksbi5zZW1pY29sb24oKX0pLGUoZGUsZnVuY3Rpb24oZSxuKXt1KGUsbil9KSxlKGhlLGZ1bmN0aW9uKGUsbil7bi5zZW1pY29sb24oKX0pLGUoZ2UsZnVuY3Rpb24oZSxuKXtuLnByaW50KFwiZG9cIiksbi5zcGFjZSgpLGgoZS5ib2R5LG4pLG4uc3BhY2UoKSxuLnByaW50KFwid2hpbGVcIiksbi5zcGFjZSgpLG4ud2l0aF9wYXJlbnMoZnVuY3Rpb24oKXtlLmNvbmRpdGlvbi5wcmludChuKX0pLG4uc2VtaWNvbG9uKCl9KSxlKGJlLGZ1bmN0aW9uKGUsbil7bi5wcmludChcIndoaWxlXCIpLG4uc3BhY2UoKSxuLndpdGhfcGFyZW5zKGZ1bmN0aW9uKCl7ZS5jb25kaXRpb24ucHJpbnQobil9KSxuLnNwYWNlKCksZS5fZG9fcHJpbnRfYm9keShuKX0pLGUoeWUsZnVuY3Rpb24oZSxuKXtuLnByaW50KFwiZm9yXCIpLG4uc3BhY2UoKSxuLndpdGhfcGFyZW5zKGZ1bmN0aW9uKCl7ZS5pbml0PyhlLmluaXQgaW5zdGFuY2VvZiBVZT9lLmluaXQucHJpbnQobik6YyhlLmluaXQsbiwhMCksbi5wcmludChcIjtcIiksbi5zcGFjZSgpKTpuLnByaW50KFwiO1wiKSxlLmNvbmRpdGlvbj8oZS5jb25kaXRpb24ucHJpbnQobiksbi5wcmludChcIjtcIiksbi5zcGFjZSgpKTpuLnByaW50KFwiO1wiKSxlLnN0ZXAmJmUuc3RlcC5wcmludChuKX0pLG4uc3BhY2UoKSxlLl9kb19wcmludF9ib2R5KG4pfSksZSh3ZSxmdW5jdGlvbihlLG4pe24ucHJpbnQoXCJmb3JcIiksbi5zcGFjZSgpLG4ud2l0aF9wYXJlbnMoZnVuY3Rpb24oKXtlLmluaXQucHJpbnQobiksbi5zcGFjZSgpLG4ucHJpbnQoXCJpblwiKSxuLnNwYWNlKCksZS5vYmplY3QucHJpbnQobil9KSxuLnNwYWNlKCksZS5fZG9fcHJpbnRfYm9keShuKX0pLGUoeGUsZnVuY3Rpb24oZSxuKXtuLnByaW50KFwid2l0aFwiKSxuLnNwYWNlKCksbi53aXRoX3BhcmVucyhmdW5jdGlvbigpe2UuZXhwcmVzc2lvbi5wcmludChuKX0pLG4uc3BhY2UoKSxlLl9kb19wcmludF9ib2R5KG4pfSksa2UuREVGTUVUSE9EKFwiX2RvX3ByaW50XCIsZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzO2V8fHQucHJpbnQoXCJmdW5jdGlvblwiKSxuLm5hbWUmJih0LnNwYWNlKCksbi5uYW1lLnByaW50KHQpKSx0LndpdGhfcGFyZW5zKGZ1bmN0aW9uKCl7bi5hcmduYW1lcy5mb3JFYWNoKGZ1bmN0aW9uKGUsbil7biYmdC5jb21tYSgpLGUucHJpbnQodCl9KX0pLHQuc3BhY2UoKSx1KG4sdCwhMCl9KSxlKGtlLGZ1bmN0aW9uKGUsbil7ZS5fZG9fcHJpbnQobil9KSxTZS5ERUZNRVRIT0QoXCJfZG9fcHJpbnRcIixmdW5jdGlvbihlLG4pe2UucHJpbnQobiksdGhpcy52YWx1ZSYmKGUuc3BhY2UoKSx0aGlzLnZhbHVlLnByaW50KGUpKSxlLnNlbWljb2xvbigpfSksZShUZSxmdW5jdGlvbihlLG4pe2UuX2RvX3ByaW50KG4sXCJyZXR1cm5cIil9KSxlKEcsZnVuY3Rpb24oZSxuKXtlLl9kb19wcmludChuLFwidGhyb3dcIil9KSxPZS5ERUZNRVRIT0QoXCJfZG9fcHJpbnRcIixmdW5jdGlvbihlLG4pe2UucHJpbnQobiksdGhpcy5sYWJlbCYmKGUuc3BhY2UoKSx0aGlzLmxhYmVsLnByaW50KGUpKSxlLnNlbWljb2xvbigpfSksZSgkZSxmdW5jdGlvbihlLG4pe2UuX2RvX3ByaW50KG4sXCJicmVha1wiKX0pLGUoemUsZnVuY3Rpb24oZSxuKXtlLl9kb19wcmludChuLFwiY29udGludWVcIil9KSxlKE1lLGZ1bmN0aW9uKGUsbil7bi5wcmludChcImlmXCIpLG4uc3BhY2UoKSxuLndpdGhfcGFyZW5zKGZ1bmN0aW9uKCl7ZS5jb25kaXRpb24ucHJpbnQobil9KSxuLnNwYWNlKCksZS5hbHRlcm5hdGl2ZT8oIWZ1bmN0aW9uKGUsbil7dmFyIHQ9ZS5ib2R5O2lmKG4ub3B0aW9uKFwiYnJhY2VzXCIpfHxuLm9wdGlvbihcImllOFwiKSYmdCBpbnN0YW5jZW9mIGdlKXJldHVybiBoKHQsbik7aWYoIXQpcmV0dXJuIG4uZm9yY2Vfc2VtaWNvbG9uKCk7Zm9yKDs7KWlmKHQgaW5zdGFuY2VvZiBNZSl7aWYoIXQuYWx0ZXJuYXRpdmUpcmV0dXJuIGgoZS5ib2R5LG4pO3Q9dC5hbHRlcm5hdGl2ZX1lbHNle2lmKCEodCBpbnN0YW5jZW9mIF8pKWJyZWFrO3Q9dC5ib2R5fWwoZS5ib2R5LG4pfShlLG4pLG4uc3BhY2UoKSxuLnByaW50KFwiZWxzZVwiKSxuLnNwYWNlKCksZS5hbHRlcm5hdGl2ZSBpbnN0YW5jZW9mIE1lP2UuYWx0ZXJuYXRpdmUucHJpbnQobik6bChlLmFsdGVybmF0aXZlLG4pKTplLl9kb19wcmludF9ib2R5KG4pfSksZShxZSxmdW5jdGlvbihlLHQpe3QucHJpbnQoXCJzd2l0Y2hcIiksdC5zcGFjZSgpLHQud2l0aF9wYXJlbnMoZnVuY3Rpb24oKXtlLmV4cHJlc3Npb24ucHJpbnQodCl9KSx0LnNwYWNlKCk7dmFyIGk9ZS5ib2R5Lmxlbmd0aC0xO2k8MD9yKGUsdCk6dC53aXRoX2Jsb2NrKGZ1bmN0aW9uKCl7ZS5ib2R5LmZvckVhY2goZnVuY3Rpb24oZSxuKXt0LmluZGVudCghMCksZS5wcmludCh0KSxuPGkmJjA8ZS5ib2R5Lmxlbmd0aCYmdC5uZXdsaW5lKCl9KX0pfSksamUuREVGTUVUSE9EKFwiX2RvX3ByaW50X2JvZHlcIixmdW5jdGlvbihuKXtuLm5ld2xpbmUoKSx0aGlzLmJvZHkuZm9yRWFjaChmdW5jdGlvbihlKXtuLmluZGVudCgpLGUucHJpbnQobiksbi5uZXdsaW5lKCl9KX0pLGUoTmUsZnVuY3Rpb24oZSxuKXtuLnByaW50KFwiZGVmYXVsdDpcIiksZS5fZG9fcHJpbnRfYm9keShuKX0pLGUoSGUsZnVuY3Rpb24oZSxuKXtuLnByaW50KFwiY2FzZVwiKSxuLnNwYWNlKCksZS5leHByZXNzaW9uLnByaW50KG4pLG4ucHJpbnQoXCI6XCIpLGUuX2RvX3ByaW50X2JvZHkobil9KSxlKFJlLGZ1bmN0aW9uKGUsbil7bi5wcmludChcInRyeVwiKSxuLnNwYWNlKCksdShlLG4pLGUuYmNhdGNoJiYobi5zcGFjZSgpLGUuYmNhdGNoLnByaW50KG4pKSxlLmJmaW5hbGx5JiYobi5zcGFjZSgpLGUuYmZpbmFsbHkucHJpbnQobikpfSksZShJZSxmdW5jdGlvbihlLG4pe24ucHJpbnQoXCJjYXRjaFwiKSxuLnNwYWNlKCksbi53aXRoX3BhcmVucyhmdW5jdGlvbigpe2UuYXJnbmFtZS5wcmludChuKX0pLG4uc3BhY2UoKSx1KGUsbil9KSxlKFBlLGZ1bmN0aW9uKGUsbil7bi5wcmludChcImZpbmFsbHlcIiksbi5zcGFjZSgpLHUoZSxuKX0pLFVlLkRFRk1FVEhPRChcIl9kb19wcmludFwiLGZ1bmN0aW9uKHQsZSl7dC5wcmludChlKSx0LnNwYWNlKCksdGhpcy5kZWZpbml0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKGUsbil7biYmdC5jb21tYSgpLGUucHJpbnQodCl9KTt2YXIgbj10LnBhcmVudCgpOyhuIGluc3RhbmNlb2YgeWV8fG4gaW5zdGFuY2VvZiB3ZSkmJm4uaW5pdD09PXRoaXN8fHQuc2VtaWNvbG9uKCl9KSxlKExlLGZ1bmN0aW9uKGUsbil7ZS5fZG9fcHJpbnQobixcInZhclwiKX0pLGUoVmUsZnVuY3Rpb24oZSxuKXtpZihlLm5hbWUucHJpbnQobiksZS52YWx1ZSl7bi5zcGFjZSgpLG4ucHJpbnQoXCI9XCIpLG4uc3BhY2UoKTt2YXIgdD1uLnBhcmVudCgxKSxpPXQgaW5zdGFuY2VvZiB5ZXx8dCBpbnN0YW5jZW9mIHdlO2MoZS52YWx1ZSxuLGkpfX0pLGUoWWUsZnVuY3Rpb24oZSx0KXtlLmV4cHJlc3Npb24ucHJpbnQodCksZSBpbnN0YW5jZW9mIEplJiYhcChlLHQpfHwoKGUuZXhwcmVzc2lvbiBpbnN0YW5jZW9mIFllfHxlLmV4cHJlc3Npb24gaW5zdGFuY2VvZiBrZSkmJnQuYWRkX21hcHBpbmcoZS5zdGFydCksdC53aXRoX3BhcmVucyhmdW5jdGlvbigpe2UuYXJncy5mb3JFYWNoKGZ1bmN0aW9uKGUsbil7biYmdC5jb21tYSgpLGUucHJpbnQodCl9KX0pKX0pLGUoSmUsZnVuY3Rpb24oZSxuKXtuLnByaW50KFwibmV3XCIpLG4uc3BhY2UoKSxZZS5wcm90b3R5cGUuX2NvZGVnZW4oZSxuKX0pLFdlLkRFRk1FVEhPRChcIl9kb19wcmludFwiLGZ1bmN0aW9uKHQpe3RoaXMuZXhwcmVzc2lvbnMuZm9yRWFjaChmdW5jdGlvbihlLG4pezA8biYmKHQuY29tbWEoKSx0LnNob3VsZF9icmVhaygpJiYodC5uZXdsaW5lKCksdC5pbmRlbnQoKSkpLGUucHJpbnQodCl9KX0pLGUoV2UsZnVuY3Rpb24oZSxuKXtlLl9kb19wcmludChuKX0pLGUoWGUsZnVuY3Rpb24oZSxuKXt2YXIgdD1lLmV4cHJlc3Npb247dC5wcmludChuKTt2YXIgaT1lLnByb3BlcnR5O24ub3B0aW9uKFwiaWU4XCIpJiZtKGkpPyhuLnByaW50KFwiW1wiKSxuLmFkZF9tYXBwaW5nKGUuZW5kKSxuLnByaW50X3N0cmluZyhpKSxuLnByaW50KFwiXVwiKSk6KHQgaW5zdGFuY2VvZiB5biYmMDw9dC5nZXRWYWx1ZSgpJiYoL1t4YS1mLildL2kudGVzdChuLmxhc3QoKSl8fG4ucHJpbnQoXCIuXCIpKSxuLnByaW50KFwiLlwiKSxuLmFkZF9tYXBwaW5nKGUuZW5kKSxuLnByaW50X25hbWUoaSkpfSksZShaZSxmdW5jdGlvbihlLG4pe2UuZXhwcmVzc2lvbi5wcmludChuKSxuLnByaW50KFwiW1wiKSxlLnByb3BlcnR5LnByaW50KG4pLG4ucHJpbnQoXCJdXCIpfSksZShRZSxmdW5jdGlvbihlLG4pe3ZhciB0PWUub3BlcmF0b3I7bi5wcmludCh0KSwoL15bYS16XS9pLnRlc3QodCl8fC9bKy1dJC8udGVzdCh0KSYmZS5leHByZXNzaW9uIGluc3RhbmNlb2YgUWUmJi9eWystXS8udGVzdChlLmV4cHJlc3Npb24ub3BlcmF0b3IpKSYmbi5zcGFjZSgpLGUuZXhwcmVzc2lvbi5wcmludChuKX0pLGUoZW4sZnVuY3Rpb24oZSxuKXtlLmV4cHJlc3Npb24ucHJpbnQobiksbi5wcmludChlLm9wZXJhdG9yKX0pLGUobm4sZnVuY3Rpb24oZSxuKXt2YXIgdD1lLm9wZXJhdG9yO2UubGVmdC5wcmludChuKSxcIj5cIj09dFswXSYmZS5sZWZ0IGluc3RhbmNlb2YgZW4mJlwiLS1cIj09ZS5sZWZ0Lm9wZXJhdG9yP24ucHJpbnQoXCIgXCIpOm4uc3BhY2UoKSxuLnByaW50KHQpLChcIjxcIj09dHx8XCI8PFwiPT10KSYmZS5yaWdodCBpbnN0YW5jZW9mIFFlJiZcIiFcIj09ZS5yaWdodC5vcGVyYXRvciYmZS5yaWdodC5leHByZXNzaW9uIGluc3RhbmNlb2YgUWUmJlwiLS1cIj09ZS5yaWdodC5leHByZXNzaW9uLm9wZXJhdG9yP24ucHJpbnQoXCIgXCIpOm4uc3BhY2UoKSxlLnJpZ2h0LnByaW50KG4pfSksZSh0bixmdW5jdGlvbihlLG4pe2UuY29uZGl0aW9uLnByaW50KG4pLG4uc3BhY2UoKSxuLnByaW50KFwiP1wiKSxuLnNwYWNlKCksZS5jb25zZXF1ZW50LnByaW50KG4pLG4uc3BhY2UoKSxuLmNvbG9uKCksZS5hbHRlcm5hdGl2ZS5wcmludChuKX0pLGUob24sZnVuY3Rpb24obixpKXtpLndpdGhfc3F1YXJlKGZ1bmN0aW9uKCl7dmFyIGU9bi5lbGVtZW50cyx0PWUubGVuZ3RoOzA8dCYmaS5zcGFjZSgpLGUuZm9yRWFjaChmdW5jdGlvbihlLG4pe24mJmkuY29tbWEoKSxlLnByaW50KGkpLG49PT10LTEmJmUgaW5zdGFuY2VvZiBrbiYmaS5jb21tYSgpfSksMDx0JiZpLnNwYWNlKCl9KX0pLGUoYW4sZnVuY3Rpb24oZSx0KXswPGUucHJvcGVydGllcy5sZW5ndGg/dC53aXRoX2Jsb2NrKGZ1bmN0aW9uKCl7ZS5wcm9wZXJ0aWVzLmZvckVhY2goZnVuY3Rpb24oZSxuKXtuJiYodC5wcmludChcIixcIiksdC5uZXdsaW5lKCkpLHQuaW5kZW50KCksZS5wcmludCh0KX0pLHQubmV3bGluZSgpfSk6cihlLHQpfSksZSh1bixmdW5jdGlvbihlLG4pe2YoZS5rZXksZS5xdW90ZSxuKSxuLmNvbG9uKCksZS52YWx1ZS5wcmludChuKX0pLHNuLkRFRk1FVEhPRChcIl9wcmludF9nZXR0ZXJfc2V0dGVyXCIsZnVuY3Rpb24oZSxuKXtuLnByaW50KGUpLG4uc3BhY2UoKSxmKHRoaXMua2V5Lm5hbWUsdGhpcy5xdW90ZSxuKSx0aGlzLnZhbHVlLl9kb19wcmludChuLCEwKX0pLGUoWCxmdW5jdGlvbihlLG4pe2UuX3ByaW50X2dldHRlcl9zZXR0ZXIoXCJzZXRcIixuKX0pLGUoWixmdW5jdGlvbihlLG4pe2UuX3ByaW50X2dldHRlcl9zZXR0ZXIoXCJnZXRcIixuKX0pLGUoY24sZnVuY3Rpb24oZSxuKXt2YXIgdD1lLmRlZmluaXRpb24oKTtuLnByaW50X25hbWUodD90Lm1hbmdsZWRfbmFtZXx8dC5uYW1lOmUubmFtZSl9KSxlKGtuLEwpLGUobW4sZnVuY3Rpb24oZSxuKXtuLnByaW50KFwidGhpc1wiKX0pLGUoZ24sZnVuY3Rpb24oZSxuKXtuLnByaW50KGUuZ2V0VmFsdWUoKSl9KSxlKGJuLGZ1bmN0aW9uKGUsbil7bi5wcmludF9zdHJpbmcoZS5nZXRWYWx1ZSgpLGUucXVvdGUsbyl9KSxlKHluLGZ1bmN0aW9uKGUsbil7cyYmZS5zdGFydCYmbnVsbCE9ZS5zdGFydC5yYXc/bi5wcmludChlLnN0YXJ0LnJhdyk6bi5wcmludChkKGUuZ2V0VmFsdWUoKSkpfSksZSh3bixmdW5jdGlvbihlLG4pe3ZhciB0PWUuZ2V0VmFsdWUoKSxpPXQudG9TdHJpbmcoKTt0LnJhd19zb3VyY2UmJihpPVwiL1wiK3QucmF3X3NvdXJjZStpLnNsaWNlKGkubGFzdEluZGV4T2YoXCIvXCIpKSksaT1uLnRvX3V0ZjgoaSksbi5wcmludChpKTt2YXIgcj1uLnBhcmVudCgpO3IgaW5zdGFuY2VvZiBubiYmL15pbi8udGVzdChyLm9wZXJhdG9yKSYmci5sZWZ0PT09ZSYmbi5wcmludChcIiBcIil9KSxuKHNlLEwpLG4oZmUsdiksbihjZSx2KSxuKGNuLHYpLG4oQmUsdiksbihfLHYpLG4odmUsTCksbihrZSx2KSxuKHFlLHYpLG4oamUsdiksbihkZSx2KSxuKEVlLEwpLG4oSmUsdiksbihSZSx2KSxuKEllLHYpLG4oUGUsdiksbihVZSx2KSxuKGduLHYpLG4oWCxmdW5jdGlvbihlLG4pe24uYWRkX21hcHBpbmcoZS5zdGFydCxlLmtleS5uYW1lKX0pLG4oWixmdW5jdGlvbihlLG4pe24uYWRkX21hcHBpbmcoZS5zdGFydCxlLmtleS5uYW1lKX0pLG4oc24sZnVuY3Rpb24oZSxuKXtuLmFkZF9tYXBwaW5nKGUuc3RhcnQsZS5rZXkpfSl9KCksdChldC5wcm90b3R5cGU9bmV3IFhuLHtvcHRpb246ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMub3B0aW9uc1tlXX0sZXhwb3NlZDpmdW5jdGlvbihlKXtpZihlLmdsb2JhbClmb3IodmFyIG49MCx0PWUub3JpZy5sZW5ndGg7bjx0O24rKylpZighdGhpcy50b3BsZXZlbFtlLm9yaWdbbl1pbnN0YW5jZW9mIGRuP1wiZnVuY3NcIjpcInZhcnNcIl0pcmV0dXJuITA7cmV0dXJuITF9LGNvbXByZXNzOmZ1bmN0aW9uKGUpe3RoaXMub3B0aW9uKFwiZXhwcmVzc2lvblwiKSYmZS5wcm9jZXNzX2V4cHJlc3Npb24oITApO2Zvcih2YXIgbj0rdGhpcy5vcHRpb25zLnBhc3Nlc3x8MSx0PTEvMCxpPSExLHI9e2llODp0aGlzLm9wdGlvbihcImllOFwiKX0sbz0wO288bjtvKyspaWYoZS5maWd1cmVfb3V0X3Njb3BlKHIpLCgwPG98fHRoaXMub3B0aW9uKFwicmVkdWNlX3ZhcnNcIikpJiZlLnJlc2V0X29wdF9mbGFncyh0aGlzKSxlPWUudHJhbnNmb3JtKHRoaXMpLDE8bil7dmFyIGE9MDtpZihlLndhbGsobmV3IFNuKGZ1bmN0aW9uKCl7YSsrfSkpLHRoaXMuaW5mbyhcInBhc3MgXCIrbytcIjogbGFzdF9jb3VudDogXCIrdCtcIiwgY291bnQ6IFwiK2EpLGE8dCl0PWEsaT0hMTtlbHNle2lmKGkpYnJlYWs7aT0hMH19cmV0dXJuIHRoaXMub3B0aW9uKFwiZXhwcmVzc2lvblwiKSYmZS5wcm9jZXNzX2V4cHJlc3Npb24oITEpLGV9LGluZm86ZnVuY3Rpb24oKXtcInZlcmJvc2VcIj09dGhpcy5vcHRpb25zLndhcm5pbmdzJiZzZS53YXJuLmFwcGx5KHNlLGFyZ3VtZW50cyl9LHdhcm46ZnVuY3Rpb24oZSxuKXtpZih0aGlzLm9wdGlvbnMud2FybmluZ3Mpe3ZhciB0PVMoZSxuKTt0IGluIHRoaXMud2FybmluZ3NfcHJvZHVjZWR8fCh0aGlzLndhcm5pbmdzX3Byb2R1Y2VkW3RdPSEwLHNlLndhcm4uYXBwbHkoc2UsYXJndW1lbnRzKSl9fSxjbGVhcl93YXJuaW5nczpmdW5jdGlvbigpe3RoaXMud2FybmluZ3NfcHJvZHVjZWQ9e319LGJlZm9yZTpmdW5jdGlvbihlLG4sdCl7aWYoZS5fc3F1ZWV6ZWQpcmV0dXJuIGU7dmFyIGk9ITE7ZSBpbnN0YW5jZW9mIEFlJiYoZT0oZT1lLmhvaXN0X3Byb3BlcnRpZXModGhpcykpLmhvaXN0X2RlY2xhcmF0aW9ucyh0aGlzKSxpPSEwKSxuKGUsdGhpcyksbihlLHRoaXMpO3ZhciByPWUub3B0aW1pemUodGhpcyk7cmV0dXJuIGkmJnIgaW5zdGFuY2VvZiBBZSYmKHIuZHJvcF91bnVzZWQodGhpcyksbihyLHRoaXMpKSxyPT09ZSYmKHIuX3NxdWVlemVkPSEwKSxyfX0pLGZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlLHQpe2UuREVGTUVUSE9EKFwib3B0aW1pemVcIixmdW5jdGlvbihlKXtpZih0aGlzLl9vcHRpbWl6ZWQpcmV0dXJuIHRoaXM7aWYoZS5oYXNfZGlyZWN0aXZlKFwidXNlIGFzbVwiKSlyZXR1cm4gdGhpczt2YXIgbj10KHRoaXMsZSk7cmV0dXJuIG4uX29wdGltaXplZD0hMCxufSl9ZnVuY3Rpb24gRyhlKXtpZihlIGluc3RhbmNlb2YgbW4pcmV0dXJuITA7aWYoZSBpbnN0YW5jZW9mIF9uKXJldHVybiBlLmRlZmluaXRpb24oKS5vcmlnWzBdaW5zdGFuY2VvZiBobjtpZihlIGluc3RhbmNlb2YgR2Upe2lmKChlPWUuZXhwcmVzc2lvbilpbnN0YW5jZW9mIF9uKXtpZihlLmlzX2ltbXV0YWJsZSgpKXJldHVybiExO2U9ZS5maXhlZF92YWx1ZSgpfXJldHVybiFlfHwoISFlLmlzX2NvbnN0YW50KCl8fEcoZSkpfXJldHVybiExfWZ1bmN0aW9uIG8oZSxuKXtmb3IodmFyIHQsaT0wOyh0PWUucGFyZW50KGkrKykpJiYhKHQgaW5zdGFuY2VvZiBBZSk7KWlmKHQgaW5zdGFuY2VvZiBJZSl7dD10LmFyZ25hbWUuZGVmaW5pdGlvbigpLnNjb3BlO2JyZWFrfXJldHVybiB0LmZpbmRfdmFyaWFibGUobil9ZnVuY3Rpb24gWChlLG4sdCl7cmV0dXJuIHR8fCh0PXt9KSxuJiYodC5zdGFydHx8KHQuc3RhcnQ9bi5zdGFydCksdC5lbmR8fCh0LmVuZD1uLmVuZCkpLG5ldyBlKHQpfWZ1bmN0aW9uIE0oZSxuKXtyZXR1cm4gMT09bi5sZW5ndGg/blswXTpYKFdlLGUse2V4cHJlc3Npb25zOm4ucmVkdWNlKGwsW10pfSl9ZnVuY3Rpb24gcShlLG4pe3N3aXRjaCh0eXBlb2YgZSl7Y2FzZVwic3RyaW5nXCI6cmV0dXJuIFgoYm4sbix7dmFsdWU6ZX0pO2Nhc2VcIm51bWJlclwiOnJldHVybiBpc05hTihlKT9YKEFuLG4pOmlzRmluaXRlKGUpPzEvZTwwP1goUWUsbix7b3BlcmF0b3I6XCItXCIsZXhwcmVzc2lvbjpYKHluLG4se3ZhbHVlOi1lfSl9KTpYKHluLG4se3ZhbHVlOmV9KTplPDA/WChRZSxuLHtvcGVyYXRvcjpcIi1cIixleHByZXNzaW9uOlgoRG4sbil9KTpYKERuLG4pO2Nhc2VcImJvb2xlYW5cIjpyZXR1cm4gWChlP0JuOkNuLG4pO2Nhc2VcInVuZGVmaW5lZFwiOnJldHVybiBYKEVuLG4pO2RlZmF1bHQ6aWYobnVsbD09PWUpcmV0dXJuIFgoeG4sbix7dmFsdWU6bnVsbH0pO2lmKGUgaW5zdGFuY2VvZiBSZWdFeHApcmV0dXJuIFgod24sbix7dmFsdWU6ZX0pO3Rocm93IG5ldyBFcnJvcihTKFwiQ2FuJ3QgaGFuZGxlIGNvbnN0YW50IG9mIHR5cGU6IHt0eXBlfVwiLHt0eXBlOnR5cGVvZiBlfSkpfX1mdW5jdGlvbiBaKGUsbix0KXtyZXR1cm4gZSBpbnN0YW5jZW9mIFFlJiZcImRlbGV0ZVwiPT1lLm9wZXJhdG9yfHxlIGluc3RhbmNlb2YgWWUmJmUuZXhwcmVzc2lvbj09PW4mJih0IGluc3RhbmNlb2YgR2V8fHQgaW5zdGFuY2VvZiBfbiYmXCJldmFsXCI9PXQubmFtZSk/TShuLFtYKHluLG4se3ZhbHVlOjB9KSx0XSk6dH1mdW5jdGlvbiBsKGUsbil7cmV0dXJuIG4gaW5zdGFuY2VvZiBXZT9lLnB1c2guYXBwbHkoZSxuLmV4cHJlc3Npb25zKTplLnB1c2gobiksZX1mdW5jdGlvbiBiKGUpe2lmKG51bGw9PT1lKXJldHVybltdO2lmKGUgaW5zdGFuY2VvZiBkZSlyZXR1cm4gZS5ib2R5O2lmKGUgaW5zdGFuY2VvZiBoZSlyZXR1cm5bXTtpZihlIGluc3RhbmNlb2YgdWUpcmV0dXJuW2VdO3Rocm93IG5ldyBFcnJvcihcIkNhbid0IGNvbnZlcnQgdGhpbmcgdG8gc3RhdGVtZW50IGFycmF5XCIpfWZ1bmN0aW9uIGooZSl7cmV0dXJuIG51bGw9PT1lfHwoZSBpbnN0YW5jZW9mIGhlfHxlIGluc3RhbmNlb2YgZGUmJjA9PWUuYm9keS5sZW5ndGgpfWZ1bmN0aW9uIHkoZSl7cmV0dXJuIGUgaW5zdGFuY2VvZiBfZSYmZS5ib2R5IGluc3RhbmNlb2YgZGU/ZS5ib2R5OmV9ZnVuY3Rpb24gSyhlKXtmb3IoO2UgaW5zdGFuY2VvZiBHZTspZT1lLmV4cHJlc3Npb247cmV0dXJuIGV9ZnVuY3Rpb24gTihlKXtyZXR1cm5cIkNhbGxcIj09ZS5UWVBFJiYoZS5leHByZXNzaW9uIGluc3RhbmNlb2YgRmV8fE4oZS5leHByZXNzaW9uKSl9ZnVuY3Rpb24gSChlKXtyZXR1cm4gZSBpbnN0YW5jZW9mIF9uJiZlLmRlZmluaXRpb24oKS51bmRlY2xhcmVkfWUoc2UsZnVuY3Rpb24oZSxuKXtyZXR1cm4gZX0pLHNlLkRFRk1FVEhPRChcImVxdWl2YWxlbnRfdG9cIixmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5UWVBFPT1lLlRZUEUmJnRoaXMucHJpbnRfdG9fc3RyaW5nKCk9PWUucHJpbnRfdG9fc3RyaW5nKCl9KSxBZS5ERUZNRVRIT0QoXCJwcm9jZXNzX2V4cHJlc3Npb25cIixmdW5jdGlvbihpLHIpe3ZhciBvPXRoaXMsYT1uZXcgWG4oZnVuY3Rpb24oZSl7aWYoaSYmZSBpbnN0YW5jZW9mIGxlKXJldHVybiBYKFRlLGUse3ZhbHVlOmUuYm9keX0pO2lmKCFpJiZlIGluc3RhbmNlb2YgVGUpe2lmKHIpe3ZhciBuPWUudmFsdWUmJmUudmFsdWUuZHJvcF9zaWRlX2VmZmVjdF9mcmVlKHIsITApO3JldHVybiBuP1gobGUsZSx7Ym9keTpufSk6WChoZSxlKX1yZXR1cm4gWChsZSxlLHtib2R5OmUudmFsdWV8fFgoUWUsZSx7b3BlcmF0b3I6XCJ2b2lkXCIsZXhwcmVzc2lvbjpYKHluLGUse3ZhbHVlOjB9KX0pfSl9aWYoZSBpbnN0YW5jZW9mIGtlJiZlIT09bylyZXR1cm4gZTtpZihlIGluc3RhbmNlb2YgcGUpe3ZhciB0PWUuYm9keS5sZW5ndGgtMTswPD10JiYoZS5ib2R5W3RdPWUuYm9keVt0XS50cmFuc2Zvcm0oYSkpfWVsc2UgZSBpbnN0YW5jZW9mIE1lPyhlLmJvZHk9ZS5ib2R5LnRyYW5zZm9ybShhKSxlLmFsdGVybmF0aXZlJiYoZS5hbHRlcm5hdGl2ZT1lLmFsdGVybmF0aXZlLnRyYW5zZm9ybShhKSkpOmUgaW5zdGFuY2VvZiB4ZSYmKGUuYm9keT1lLmJvZHkudHJhbnNmb3JtKGEpKTtyZXR1cm4gZX0pO28udHJhbnNmb3JtKGEpfSksZnVuY3Rpb24oZSl7ZnVuY3Rpb24gaShlLG4pe24uYXNzaWdubWVudHM9MCxuLmNoYWluZWQ9ITEsbi5kaXJlY3RfYWNjZXNzPSExLG4uZXNjYXBlZD0hMSxuLnNjb3BlLnVzZXNfZXZhbHx8bi5zY29wZS51c2VzX3dpdGg/bi5maXhlZD0hMTplLmV4cG9zZWQobik/bi5maXhlZD0hMTpuLmZpeGVkPW4uaW5pdCxuLnJlY3Vyc2l2ZV9yZWZzPTAsbi5yZWZlcmVuY2VzPVtdLG4uc2hvdWxkX3JlcGxhY2U9dm9pZCAwLG4uc2luZ2xlX3VzZT12b2lkIDB9ZnVuY3Rpb24gYShuLHQsZSl7ZS52YXJpYWJsZXMuZWFjaChmdW5jdGlvbihlKXtpKHQsZSksbnVsbD09PWUuZml4ZWQ/KGUuc2FmZV9pZHM9bi5zYWZlX2lkcyxjKG4sZSwhMCkpOmUuZml4ZWQmJihuLmxvb3BfaWRzW2UuaWRdPW4uaW5fbG9vcCxjKG4sZSwhMCkpfSl9ZnVuY3Rpb24gcyhlKXtlLnNhZmVfaWRzPU9iamVjdC5jcmVhdGUoZS5zYWZlX2lkcyl9ZnVuY3Rpb24gdShlKXtlLnNhZmVfaWRzPU9iamVjdC5nZXRQcm90b3R5cGVPZihlLnNhZmVfaWRzKX1mdW5jdGlvbiBjKGUsbix0KXtlLnNhZmVfaWRzW24uaWRdPXR9ZnVuY3Rpb24gZihlLG4pe2lmKGUuc2FmZV9pZHNbbi5pZF0pe2lmKG51bGw9PW4uZml4ZWQpe3ZhciB0PW4ub3JpZ1swXTtpZih0IGluc3RhbmNlb2YgcG58fFwiYXJndW1lbnRzXCI9PXQubmFtZSlyZXR1cm4hMTtuLmZpeGVkPVgoRW4sdCl9cmV0dXJuITB9cmV0dXJuIG4uZml4ZWQgaW5zdGFuY2VvZiBDZX1mdW5jdGlvbiBvKGUsbix0KXtyZXR1cm4gdm9pZCAwPT09bi5maXhlZHx8KG51bGw9PT1uLmZpeGVkJiZuLnNhZmVfaWRzPyhuLnNhZmVfaWRzW24uaWRdPSExLGRlbGV0ZSBuLnNhZmVfaWRzLCEwKTohIWFlKGUuc2FmZV9pZHMsbi5pZCkmJighIWYoZSxuKSYmKCExIT09bi5maXhlZCYmKCEobnVsbCE9bi5maXhlZCYmKCF0fHxuLnJlZmVyZW5jZXMubGVuZ3RoPm4uYXNzaWdubWVudHMpKSYmb2Uobi5vcmlnLGZ1bmN0aW9uKGUpe3JldHVybiEoZSBpbnN0YW5jZW9mIGRufHxlIGluc3RhbmNlb2YgaG4pfSkpKSkpfWZ1bmN0aW9uIGwoZSxuKXtpZighKChuPXAobikpaW5zdGFuY2VvZiBzZSkpe3ZhciB0O2lmKGUgaW5zdGFuY2VvZiBvbil7dmFyIGk9ZS5lbGVtZW50cztpZihcImxlbmd0aFwiPT1uKXJldHVybiBxKGkubGVuZ3RoLGUpO1wibnVtYmVyXCI9PXR5cGVvZiBuJiZuIGluIGkmJih0PWlbbl0pfWVsc2UgaWYoZSBpbnN0YW5jZW9mIGFuKXtuPVwiXCIrbjtmb3IodmFyIHI9ZS5wcm9wZXJ0aWVzLG89ci5sZW5ndGg7MDw9LS1vOyl7aWYoIShyW29daW5zdGFuY2VvZiB1bikpcmV0dXJuO3R8fHJbb10ua2V5IT09bnx8KHQ9cltvXS52YWx1ZSl9fXJldHVybiB0IGluc3RhbmNlb2YgX24mJnQuZml4ZWRfdmFsdWUoKXx8dH19ZShzZSxMKTt2YXIgdD1uZXcgU24oZnVuY3Rpb24oZSl7aWYoZSBpbnN0YW5jZW9mIGNuKXt2YXIgbj1lLmRlZmluaXRpb24oKTtuJiYoZSBpbnN0YW5jZW9mIF9uJiZuLnJlZmVyZW5jZXMucHVzaChlKSxuLmZpeGVkPSExKX19KTtlKERlLGZ1bmN0aW9uKGUsbix0KXtyZXR1cm4gcyhlKSxhKGUsdCx0aGlzKSxuKCksdShlKSwhMH0pLGUocm4sZnVuY3Rpb24oZSl7dmFyIG49dGhpcztpZihuLmxlZnQgaW5zdGFuY2VvZiBfbil7dmFyIHQ9bi5sZWZ0LmRlZmluaXRpb24oKSxpPXQuZml4ZWQ7aWYoKGl8fFwiPVwiPT1uLm9wZXJhdG9yKSYmbyhlLHQsbi5yaWdodCkpcmV0dXJuIHQucmVmZXJlbmNlcy5wdXNoKG4ubGVmdCksdC5hc3NpZ25tZW50cysrLFwiPVwiIT1uLm9wZXJhdG9yJiYodC5jaGFpbmVkPSEwKSx0LmZpeGVkPVwiPVwiPT1uLm9wZXJhdG9yP2Z1bmN0aW9uKCl7cmV0dXJuIG4ucmlnaHR9OmZ1bmN0aW9uKCl7cmV0dXJuIFgobm4sbix7b3BlcmF0b3I6bi5vcGVyYXRvci5zbGljZSgwLC0xKSxsZWZ0OmkgaW5zdGFuY2VvZiBzZT9pOmkoKSxyaWdodDpuLnJpZ2h0fSl9LGMoZSx0LCExKSxuLnJpZ2h0LndhbGsoZSksYyhlLHQsITApLCEwfX0pLGUobm4sZnVuY3Rpb24oZSl7aWYoZWUodGhpcy5vcGVyYXRvcikpcmV0dXJuIHRoaXMubGVmdC53YWxrKGUpLHMoZSksdGhpcy5yaWdodC53YWxrKGUpLHUoZSksITB9KSxlKEhlLGZ1bmN0aW9uKGUpe3JldHVybiBzKGUpLHRoaXMuZXhwcmVzc2lvbi53YWxrKGUpLHUoZSkscyhlKSx6KHRoaXMsZSksdShlKSwhMH0pLGUodG4sZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuY29uZGl0aW9uLndhbGsoZSkscyhlKSx0aGlzLmNvbnNlcXVlbnQud2FsayhlKSx1KGUpLHMoZSksdGhpcy5hbHRlcm5hdGl2ZS53YWxrKGUpLHUoZSksITB9KSxlKE5lLGZ1bmN0aW9uKGUsbil7cmV0dXJuIHMoZSksbigpLHUoZSksITB9KSxlKENlLGZ1bmN0aW9uKGUsbix0KXt0aGlzLmlubGluZWQ9ITE7dmFyIGk9ZS5zYWZlX2lkcztyZXR1cm4gZS5zYWZlX2lkcz1PYmplY3QuY3JlYXRlKG51bGwpLGEoZSx0LHRoaXMpLG4oKSxlLnNhZmVfaWRzPWksITB9KSxlKGdlLGZ1bmN0aW9uKGUpe3ZhciBuPWUuaW5fbG9vcDtyZXR1cm4gZS5pbl9sb29wPXRoaXMscyhlKSx0aGlzLmJvZHkud2FsayhlKSx0aGlzLmNvbmRpdGlvbi53YWxrKGUpLHUoZSksZS5pbl9sb29wPW4sITB9KSxlKHllLGZ1bmN0aW9uKGUpe3RoaXMuaW5pdCYmdGhpcy5pbml0LndhbGsoZSk7dmFyIG49ZS5pbl9sb29wO3JldHVybihlLmluX2xvb3A9dGhpcykuY29uZGl0aW9uJiYocyhlKSx0aGlzLmNvbmRpdGlvbi53YWxrKGUpLHUoZSkpLHMoZSksdGhpcy5ib2R5LndhbGsoZSksdShlKSx0aGlzLnN0ZXAmJihzKGUpLHRoaXMuc3RlcC53YWxrKGUpLHUoZSkpLGUuaW5fbG9vcD1uLCEwfSksZSh3ZSxmdW5jdGlvbihlKXt0aGlzLmluaXQud2Fsayh0KSx0aGlzLm9iamVjdC53YWxrKGUpO3ZhciBuPWUuaW5fbG9vcDtyZXR1cm4gZS5pbl9sb29wPXRoaXMscyhlKSx0aGlzLmJvZHkud2FsayhlKSx1KGUpLGUuaW5fbG9vcD1uLCEwfSksZShGZSxmdW5jdGlvbihpLGUsbil7dmFyIHIsbz10aGlzO3JldHVybiBvLmlubGluZWQ9ITEscyhpKSxhKGksbixvKSwhby5uYW1lJiYocj1pLnBhcmVudCgpKWluc3RhbmNlb2YgWWUmJnIuZXhwcmVzc2lvbj09PW8mJm8uYXJnbmFtZXMuZm9yRWFjaChmdW5jdGlvbihlLG4pe3ZhciB0PWUuZGVmaW5pdGlvbigpO28udXNlc19hcmd1bWVudHN8fHZvaWQgMCE9PXQuZml4ZWQ/dC5maXhlZD0hMToodC5maXhlZD1mdW5jdGlvbigpe3JldHVybiByLmFyZ3Nbbl18fFgoRW4scil9LGkubG9vcF9pZHNbdC5pZF09aS5pbl9sb29wLGMoaSx0LCEwKSl9KSxlKCksdShpKSwhMH0pLGUoTWUsZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuY29uZGl0aW9uLndhbGsoZSkscyhlKSx0aGlzLmJvZHkud2FsayhlKSx1KGUpLHRoaXMuYWx0ZXJuYXRpdmUmJihzKGUpLHRoaXMuYWx0ZXJuYXRpdmUud2FsayhlKSx1KGUpKSwhMH0pLGUodmUsZnVuY3Rpb24oZSl7cmV0dXJuIHMoZSksdGhpcy5ib2R5LndhbGsoZSksdShlKSwhMH0pLGUodm4sZnVuY3Rpb24oKXt0aGlzLmRlZmluaXRpb24oKS5maXhlZD0hMX0pLGUoX24sZnVuY3Rpb24oZSxuLHQpe3ZhciBpLHIsbyxhLHM9dGhpcy5kZWZpbml0aW9uKCk7cy5yZWZlcmVuY2VzLnB1c2godGhpcyksMT09cy5yZWZlcmVuY2VzLmxlbmd0aCYmIXMuZml4ZWQmJnMub3JpZ1swXWluc3RhbmNlb2YgZG4mJihlLmxvb3BfaWRzW3MuaWRdPWUuaW5fbG9vcCksdm9pZCAwIT09cy5maXhlZCYmZihlLHMpJiZcIm1cIiE9cy5zaW5nbGVfdXNlP3MuZml4ZWQmJigoaT10aGlzLmZpeGVkX3ZhbHVlKCkpaW5zdGFuY2VvZiBrZSYmUChlLHMpP3MucmVjdXJzaXZlX3JlZnMrKzppJiYobz1lLGE9cyx0Lm9wdGlvbihcInVudXNlZFwiKSYmIWEuc2NvcGUudXNlc19ldmFsJiYhYS5zY29wZS51c2VzX3dpdGgmJmEucmVmZXJlbmNlcy5sZW5ndGgtYS5yZWN1cnNpdmVfcmVmcz09MSYmby5sb29wX2lkc1thLmlkXT09PW8uaW5fbG9vcCk/cy5zaW5nbGVfdXNlPWkgaW5zdGFuY2VvZiBrZXx8cy5zY29wZT09PXRoaXMuc2NvcGUmJmkuaXNfY29uc3RhbnRfZXhwcmVzc2lvbigpOnMuc2luZ2xlX3VzZT0hMSxmdW5jdGlvbiBlKG4sdCxpLHIsbyl7dmFyIGE9bi5wYXJlbnQocik7aWYobmUodCxhKXx8IW8mJmEgaW5zdGFuY2VvZiBZZSYmYS5leHByZXNzaW9uPT09dCYmKCEoaSBpbnN0YW5jZW9mIEZlKXx8IShhIGluc3RhbmNlb2YgSmUpJiZpLmNvbnRhaW5zX3RoaXMoKSkpcmV0dXJuITA7aWYoYSBpbnN0YW5jZW9mIG9uKXJldHVybiBlKG4sYSxhLHIrMSk7aWYoYSBpbnN0YW5jZW9mIHVuJiZ0PT09YS52YWx1ZSl7dmFyIHM9bi5wYXJlbnQocisxKTtyZXR1cm4gZShuLHMscyxyKzIpfXJldHVybiBhIGluc3RhbmNlb2YgR2UmJmEuZXhwcmVzc2lvbj09PXQ/IW8mJmUobixhLGwoaSxhLnByb3BlcnR5KSxyKzEpOnZvaWQgMH0oZSx0aGlzLGksMCwhIShyPWkpJiYoci5pc19jb25zdGFudCgpfHxyIGluc3RhbmNlb2Yga2V8fHIgaW5zdGFuY2VvZiBtbikpJiYocy5zaW5nbGVfdXNlP3Muc2luZ2xlX3VzZT1cIm1cIjpzLmZpeGVkPSExKSk6cy5maXhlZD0hMSxmdW5jdGlvbiBlKG4sdCxpLHIsbyxhLHMpe3ZhciB1PW4ucGFyZW50KGEpO2lmKCFvfHwhby5pc19jb25zdGFudCgpKXtpZih1IGluc3RhbmNlb2Ygcm4mJlwiPVwiPT11Lm9wZXJhdG9yJiZyPT09dS5yaWdodHx8dSBpbnN0YW5jZW9mIFllJiZyIT09dS5leHByZXNzaW9ufHx1IGluc3RhbmNlb2YgU2UmJnI9PT11LnZhbHVlJiZyLnNjb3BlIT09dC5zY29wZXx8dSBpbnN0YW5jZW9mIFZlJiZyPT09dS52YWx1ZSlyZXR1cm4hKDE8cyl8fG8mJm8uaXNfY29uc3RhbnRfZXhwcmVzc2lvbihpKXx8KHM9MSksdm9pZCgoIXQuZXNjYXBlZHx8dC5lc2NhcGVkPnMpJiYodC5lc2NhcGVkPXMpKTtpZih1IGluc3RhbmNlb2Ygb258fHUgaW5zdGFuY2VvZiBubiYmZWUodS5vcGVyYXRvcil8fHUgaW5zdGFuY2VvZiB0biYmciE9PXUuY29uZGl0aW9ufHx1IGluc3RhbmNlb2YgV2UmJnI9PT11LnRhaWxfbm9kZSgpKWUobix0LGksdSx1LGErMSxzKTtlbHNlIGlmKHUgaW5zdGFuY2VvZiB1biYmcj09PXUudmFsdWUpe3ZhciBjPW4ucGFyZW50KGErMSk7ZShuLHQsaSxjLGMsYSsyLHMpfWVsc2UgaWYodSBpbnN0YW5jZW9mIEdlJiZyPT09dS5leHByZXNzaW9uJiYoZShuLHQsaSx1LG89bChvLHUucHJvcGVydHkpLGErMSxzKzEpLG8pKXJldHVybjswPT1hJiYodC5kaXJlY3RfYWNjZXNzPSEwKX19KGUscyx0aGlzLnNjb3BlLHRoaXMsaSwwLDEpfSksZShFZSxmdW5jdGlvbihlLG4sdCl7dGhpcy5nbG9iYWxzLmVhY2goZnVuY3Rpb24oZSl7aSh0LGUpfSksYShlLHQsdGhpcyl9KSxlKFJlLGZ1bmN0aW9uKGUpe3JldHVybiBzKGUpLHoodGhpcyxlKSx1KGUpLHRoaXMuYmNhdGNoJiYocyhlKSx0aGlzLmJjYXRjaC53YWxrKGUpLHUoZSkpLHRoaXMuYmZpbmFsbHkmJnRoaXMuYmZpbmFsbHkud2FsayhlKSwhMH0pLGUoS2UsZnVuY3Rpb24oZSxuKXt2YXIgdD10aGlzO2lmKChcIisrXCI9PXQub3BlcmF0b3J8fFwiLS1cIj09dC5vcGVyYXRvcikmJnQuZXhwcmVzc2lvbiBpbnN0YW5jZW9mIF9uKXt2YXIgaT10LmV4cHJlc3Npb24uZGVmaW5pdGlvbigpLHI9aS5maXhlZDtpZihyJiZvKGUsaSwhMCkpcmV0dXJuIGkucmVmZXJlbmNlcy5wdXNoKHQuZXhwcmVzc2lvbiksaS5hc3NpZ25tZW50cysrLGkuY2hhaW5lZD0hMCxpLmZpeGVkPWZ1bmN0aW9uKCl7cmV0dXJuIFgobm4sdCx7b3BlcmF0b3I6dC5vcGVyYXRvci5zbGljZSgwLC0xKSxsZWZ0OlgoUWUsdCx7b3BlcmF0b3I6XCIrXCIsZXhwcmVzc2lvbjpyIGluc3RhbmNlb2Ygc2U/cjpyKCl9KSxyaWdodDpYKHluLHQse3ZhbHVlOjF9KX0pfSxjKGUsaSwhMCksITB9fSksZShWZSxmdW5jdGlvbihlLG4pe3ZhciB0PXRoaXMsaT10Lm5hbWUuZGVmaW5pdGlvbigpO2lmKHQudmFsdWUpe2lmKG8oZSxpLHQudmFsdWUpKXJldHVybiBpLmZpeGVkPWZ1bmN0aW9uKCl7cmV0dXJuIHQudmFsdWV9LGUubG9vcF9pZHNbaS5pZF09ZS5pbl9sb29wLGMoZSxpLCExKSxuKCksYyhlLGksITApLCEwO2kuZml4ZWQ9ITF9fSksZShiZSxmdW5jdGlvbihlKXt2YXIgbj1lLmluX2xvb3A7cmV0dXJuIGUuaW5fbG9vcD10aGlzLHMoZSksdGhpcy5jb25kaXRpb24ud2FsayhlKSx0aGlzLmJvZHkud2FsayhlKSx1KGUpLGUuaW5fbG9vcD1uLCEwfSl9KGZ1bmN0aW9uKGUsbil7ZS5ERUZNRVRIT0QoXCJyZWR1Y2VfdmFyc1wiLG4pfSksRWUuREVGTUVUSE9EKFwicmVzZXRfb3B0X2ZsYWdzXCIsZnVuY3Rpb24odCl7dmFyIGk9dC5vcHRpb24oXCJyZWR1Y2VfdmFyc1wiKSxyPW5ldyBTbihmdW5jdGlvbihlLG4pe2lmKGUuX3NxdWVlemVkPSExLGUuX29wdGltaXplZD0hMSxpKXJldHVybiBlLnJlZHVjZV92YXJzKHIsbix0KX0pO3Iuc2FmZV9pZHM9T2JqZWN0LmNyZWF0ZShudWxsKSxyLmluX2xvb3A9bnVsbCxyLmxvb3BfaWRzPU9iamVjdC5jcmVhdGUobnVsbCksdGhpcy53YWxrKHIpfSksY24uREVGTUVUSE9EKFwiZml4ZWRfdmFsdWVcIixmdW5jdGlvbigpe3ZhciBlPXRoaXMuZGVmaW5pdGlvbigpLmZpeGVkO3JldHVybiFlfHxlIGluc3RhbmNlb2Ygc2U/ZTplKCl9KSxfbi5ERUZNRVRIT0QoXCJpc19pbW11dGFibGVcIixmdW5jdGlvbigpe3ZhciBlPXRoaXMuZGVmaW5pdGlvbigpLm9yaWc7cmV0dXJuIDE9PWUubGVuZ3RoJiZlWzBdaW5zdGFuY2VvZiBobn0pO3ZhciBuPVcoXCJBcnJheSBCb29sZWFuIGNsZWFySW50ZXJ2YWwgY2xlYXJUaW1lb3V0IGNvbnNvbGUgRGF0ZSBkZWNvZGVVUkkgZGVjb2RlVVJJQ29tcG9uZW50IGVuY29kZVVSSSBlbmNvZGVVUklDb21wb25lbnQgRXJyb3IgZXNjYXBlIGV2YWwgRXZhbEVycm9yIEZ1bmN0aW9uIGlzRmluaXRlIGlzTmFOIEpTT04gTWF0aCBOdW1iZXIgcGFyc2VGbG9hdCBwYXJzZUludCBSYW5nZUVycm9yIFJlZmVyZW5jZUVycm9yIFJlZ0V4cCBPYmplY3Qgc2V0SW50ZXJ2YWwgc2V0VGltZW91dCBTdHJpbmcgU3ludGF4RXJyb3IgVHlwZUVycm9yIHVuZXNjYXBlIFVSSUVycm9yXCIpO19uLkRFRk1FVEhPRChcImlzX2RlY2xhcmVkXCIsZnVuY3Rpb24oZSl7cmV0dXJuIXRoaXMuZGVmaW5pdGlvbigpLnVuZGVjbGFyZWR8fGUub3B0aW9uKFwidW5zYWZlXCIpJiZuKHRoaXMubmFtZSl9KTt2YXIgdCxpLHIsYSxzLFI9VyhcIkluZmluaXR5IE5hTiB1bmRlZmluZWRcIik7ZnVuY3Rpb24gUShlKXtyZXR1cm4gZSBpbnN0YW5jZW9mIERufHxlIGluc3RhbmNlb2YgQW58fGUgaW5zdGFuY2VvZiBFbn1mdW5jdGlvbiB1KGUsYyl7dmFyIFYsWSxKOyFmdW5jdGlvbigpe3ZhciBlPWMuc2VsZigpLG49MDtkb3tpZihlIGluc3RhbmNlb2YgSWV8fGUgaW5zdGFuY2VvZiBQZSluKys7ZWxzZSBpZihlIGluc3RhbmNlb2YgX2UpVj0hMDtlbHNle2lmKGUgaW5zdGFuY2VvZiBBZSl7Sj1lO2JyZWFrfWUgaW5zdGFuY2VvZiBSZSYmKFk9ITApfX13aGlsZShlPWMucGFyZW50KG4rKykpfSgpO2Zvcih2YXIgVyxuPTEwO1c9ITEscihlKSxjLm9wdGlvbihcImRlYWRfY29kZVwiKSYmbyhlLGMpLGMub3B0aW9uKFwiaWZfcmV0dXJuXCIpJiZpKGUsYyksMDxjLnNlcXVlbmNlc19saW1pdCYmKGEoZSxjKSxzKGUsYykpLGMub3B0aW9uKFwiam9pbl92YXJzXCIpJiZ1KGUpLGMub3B0aW9uKFwiY29sbGFwc2VfdmFyc1wiKSYmdChlLGMpLFcmJjA8bi0tOyk7ZnVuY3Rpb24gdCh0LGMpe2lmKEoudXNlc19ldmFsfHxKLnVzZXNfd2l0aClyZXR1cm4gdDtmb3IodmFyIGYsZSxuLGw9W10sbz10Lmxlbmd0aCxhPW5ldyBYbihmdW5jdGlvbihlKXtpZihEKXJldHVybiBlO2lmKCFrKXJldHVybiBlIT09c1t1XT9lOisrdTxzLmxlbmd0aD9PKGUpOihrPSEwLChoPWZ1bmN0aW9uIGUobix0LGkpe3ZhciByPWEucGFyZW50KHQpO2lmKHIgaW5zdGFuY2VvZiBybilyZXR1cm4gaSYmIShyLmxlZnQgaW5zdGFuY2VvZiBHZXx8ci5sZWZ0Lm5hbWUgaW4geSk/ZShyLHQrMSxpKTpuO2lmKHIgaW5zdGFuY2VvZiBubilyZXR1cm4haXx8ZWUoci5vcGVyYXRvcikmJnIubGVmdCE9PW4/bjplKHIsdCsxLGkpO2lmKHIgaW5zdGFuY2VvZiBZZSlyZXR1cm4gbjtpZihyIGluc3RhbmNlb2YgSGUpcmV0dXJuIG47aWYociBpbnN0YW5jZW9mIHRuKXJldHVybiBpJiZyLmNvbmRpdGlvbj09PW4/ZShyLHQrMSxpKTpuO2lmKHIgaW5zdGFuY2VvZiBVZSlyZXR1cm4gZShyLHQrMSwhMCk7aWYociBpbnN0YW5jZW9mIFNlKXJldHVybiBpP2Uocix0KzEsaSk6bjtpZihyIGluc3RhbmNlb2YgTWUpcmV0dXJuIGkmJnIuY29uZGl0aW9uPT09bj9lKHIsdCsxLGkpOm47aWYociBpbnN0YW5jZW9mIF9lKXJldHVybiBuO2lmKHIgaW5zdGFuY2VvZiBXZSlyZXR1cm4gZShyLHQrMSxyLnRhaWxfbm9kZSgpIT09bik7aWYociBpbnN0YW5jZW9mIGxlKXJldHVybiBlKHIsdCsxLCEwKTtpZihyIGluc3RhbmNlb2YgcWUpcmV0dXJuIG47aWYociBpbnN0YW5jZW9mIEtlKXJldHVybiBuO2lmKHIgaW5zdGFuY2VvZiBWZSlyZXR1cm4gbjtyZXR1cm4gbnVsbH0oZSwwKSk9PT1lJiYoRD0hMCksZSk7dmFyIG4sdCxpPWEucGFyZW50KCk7aWYoZSBpbnN0YW5jZW9mIHJuJiZcIj1cIiE9ZS5vcGVyYXRvciYmXy5lcXVpdmFsZW50X3RvKGUubGVmdCl8fGUgaW5zdGFuY2VvZiBZZSYmXyBpbnN0YW5jZW9mIEdlJiZfLmVxdWl2YWxlbnRfdG8oZS5leHByZXNzaW9uKXx8ZSBpbnN0YW5jZW9mIGNlfHxlIGluc3RhbmNlb2YgX2UmJiEoZSBpbnN0YW5jZW9mIHllKXx8ZSBpbnN0YW5jZW9mIE9lfHxlIGluc3RhbmNlb2YgUmV8fGUgaW5zdGFuY2VvZiB4ZXx8aSBpbnN0YW5jZW9mIHllJiZlIT09aS5pbml0fHwheCYmZSBpbnN0YW5jZW9mIF9uJiYhZS5pc19kZWNsYXJlZChjKSlyZXR1cm4gRD0hMCxlO2lmKCF2JiYoaSBpbnN0YW5jZW9mIG5uJiZlZShpLm9wZXJhdG9yKSYmaS5sZWZ0IT09ZXx8aSBpbnN0YW5jZW9mIHRuJiZpLmNvbmRpdGlvbiE9PWV8fGkgaW5zdGFuY2VvZiBNZSYmaS5jb25kaXRpb24hPT1lKSYmKHY9aSksQyYmIShlIGluc3RhbmNlb2YgZm4pJiYoZyYmXy5lcXVpdmFsZW50X3RvKGUpfHxiJiYobj1iKGUsdGhpcykpKSl7aWYodiYmKG58fCF3fHwheCkpcmV0dXJuIEQ9ITAsZTtpZihuZShlLGkpKXJldHVybiBkJiZGKyssZTtpZihXPUQ9ITAsRisrLGMuaW5mbyhcIkNvbGxhcHNpbmcge25hbWV9IFt7ZmlsZX06e2xpbmV9LHtjb2x9XVwiLHtuYW1lOmUucHJpbnRfdG9fc3RyaW5nKCksZmlsZTplLnN0YXJ0LmZpbGUsbGluZTplLnN0YXJ0LmxpbmUsY29sOmUuc3RhcnQuY29sfSkscCBpbnN0YW5jZW9mIGVuKXJldHVybiBYKFFlLHAscCk7aWYocCBpbnN0YW5jZW9mIFZlKXtpZihkKXJldHVybiBEPSExLGU7dmFyIHI9cC5uYW1lLmRlZmluaXRpb24oKSxvPXAudmFsdWU7cmV0dXJuIHIucmVmZXJlbmNlcy5sZW5ndGgtci5yZXBsYWNlZCE9MXx8Yy5leHBvc2VkKHIpP1gocm4scCx7b3BlcmF0b3I6XCI9XCIsbGVmdDpYKF9uLHAubmFtZSxwLm5hbWUpLHJpZ2h0Om99KTooci5yZXBsYWNlZCsrLEUmJlEobyk/by50cmFuc2Zvcm0oYyk6WihpLGUsbykpfXJldHVybiBwLndyaXRlX29ubHk9ITEscH1yZXR1cm4oZSBpbnN0YW5jZW9mIFllfHxlIGluc3RhbmNlb2YgU2UmJihtfHxfIGluc3RhbmNlb2YgR2V8fEwoXykpfHxlIGluc3RhbmNlb2YgR2UmJihtfHxlLmV4cHJlc3Npb24ubWF5X3Rocm93X29uX2FjY2VzcyhjKSl8fGUgaW5zdGFuY2VvZiBfbiYmKGZ1bmN0aW9uKGUpe3ZhciBuPXlbZS5uYW1lXTtpZighbilyZXR1cm47aWYobiE9PV8pcmV0dXJuITA7Yj0hMX0oZSl8fG0mJkwoZSkpfHxlIGluc3RhbmNlb2YgVmUmJmUudmFsdWUmJihlLm5hbWUubmFtZSBpbiB5fHxtJiZMKGUubmFtZSkpfHwodD1uZShlLmxlZnQsZSkpJiYodCBpbnN0YW5jZW9mIEdlfHx0Lm5hbWUgaW4geSl8fEEmJihZP2UuaGFzX3NpZGVfZWZmZWN0cyhjKTpmdW5jdGlvbiBlKG4sdCl7aWYobiBpbnN0YW5jZW9mIHJuKXJldHVybiBlKG4ubGVmdCwhMCk7aWYobiBpbnN0YW5jZW9mIEtlKXJldHVybiBlKG4uZXhwcmVzc2lvbiwhMCk7aWYobiBpbnN0YW5jZW9mIFZlKXJldHVybiBuLnZhbHVlJiZlKG4udmFsdWUpO2lmKHQpe2lmKG4gaW5zdGFuY2VvZiBYZSlyZXR1cm4gZShuLmV4cHJlc3Npb24sITApO2lmKG4gaW5zdGFuY2VvZiBaZSlyZXR1cm4gZShuLmV4cHJlc3Npb24sITApO2lmKG4gaW5zdGFuY2VvZiBfbilyZXR1cm4gbi5kZWZpbml0aW9uKCkuc2NvcGUhPT1KfXJldHVybiExfShlKSkpJiYoaD1lKWluc3RhbmNlb2YgQWUmJihEPSEwKSxPKGUpfSxmdW5jdGlvbihlKXtEfHwoaD09PWUmJihEPSEwKSx2PT09ZSYmKHY9bnVsbCkpfSksaT1uZXcgWG4oZnVuY3Rpb24oZSl7aWYoRClyZXR1cm4gZTtpZighayl7aWYoZSE9PXNbdV0pcmV0dXJuIGU7aWYoKyt1PHMubGVuZ3RoKXJldHVybjtyZXR1cm4gaz0hMCxlfXJldHVybiBlIGluc3RhbmNlb2YgX24mJmUubmFtZT09VC5uYW1lPygtLUZ8fChEPSEwKSxuZShlLGkucGFyZW50KCkpP2U6KFQucmVwbGFjZWQrKyxkLnJlcGxhY2VkLS0scC52YWx1ZSkpOmUgaW5zdGFuY2VvZiBOZXx8ZSBpbnN0YW5jZW9mIEFlP2U6dm9pZCAwfSk7MDw9LS1vOyl7MD09byYmYy5vcHRpb24oXCJ1bnVzZWRcIikmJiQoKTt2YXIgcz1bXTtmb3Ioeih0W29dKTswPGwubGVuZ3RoOyl7cz1sLnBvcCgpO3ZhciB1PTAscD1zW3MubGVuZ3RoLTFdLGQ9bnVsbCxoPW51bGwsdj1udWxsLF89TShwKSxyPXEocCksbT1fJiZfLmhhc19zaWRlX2VmZmVjdHMoYyksZz1fJiYhbSYmIUcoXyksYj1yJiZqKHIpO2lmKGd8fGIpe3ZhciB5PVIocCksdz0obj12b2lkIDAsKG49SyhlPV8pKWluc3RhbmNlb2YgX24mJm4uZGVmaW5pdGlvbigpLnNjb3BlPT09SiYmIShWJiYobi5uYW1lIGluIHkmJnlbbi5uYW1lXSE9PWV8fHAgaW5zdGFuY2VvZiBLZXx8cCBpbnN0YW5jZW9mIHJuJiZcIj1cIiE9cC5vcGVyYXRvcikpKTttfHwobT1QKHApKTt2YXIgeD1VKCksQT1wLm1heV90aHJvdyhjKSxFPXAubmFtZSBpbnN0YW5jZW9mIHBuLGs9RSxEPSExLEY9MCxDPSFmfHwhaztpZighQyl7Zm9yKHZhciBCPWMuc2VsZigpLmFyZ25hbWVzLmxhc3RJbmRleE9mKHAubmFtZSkrMTshRCYmQjxmLmxlbmd0aDtCKyspZltCXS50cmFuc2Zvcm0oYSk7Qz0hMH1mb3IodmFyIFM9bzshRCYmUzx0Lmxlbmd0aDtTKyspdFtTXS50cmFuc2Zvcm0oYSk7aWYoZCl7dmFyIFQ9cC5uYW1lLmRlZmluaXRpb24oKTtpZihEJiZULnJlZmVyZW5jZXMubGVuZ3RoLVQucmVwbGFjZWQ+RilGPSExO2Vsc2V7RD0hMSx1PTAsaz1FO2ZvcihTPW87IUQmJlM8dC5sZW5ndGg7UysrKXRbU10udHJhbnNmb3JtKGkpO2Quc2luZ2xlX3VzZT0hMX19RiYmIUkocCkmJnQuc3BsaWNlKG8sMSl9fX1mdW5jdGlvbiBPKGUpe2lmKGUgaW5zdGFuY2VvZiBBZSlyZXR1cm4gZTtpZihlIGluc3RhbmNlb2YgcWUpe2UuZXhwcmVzc2lvbj1lLmV4cHJlc3Npb24udHJhbnNmb3JtKGEpO2Zvcih2YXIgbj0wLHQ9ZS5ib2R5Lmxlbmd0aDshRCYmbjx0O24rKyl7dmFyIGk9ZS5ib2R5W25dO2lmKGkgaW5zdGFuY2VvZiBIZSl7aWYoIWspe2lmKGkhPT1zW3VdKWNvbnRpbnVlO3UrK31pZihpLmV4cHJlc3Npb249aS5leHByZXNzaW9uLnRyYW5zZm9ybShhKSwheClicmVha319cmV0dXJuIEQ9ITAsZX19ZnVuY3Rpb24gJCgpe3ZhciBlLHQ9Yy5zZWxmKCk7aWYodCBpbnN0YW5jZW9mIEZlJiYhdC5uYW1lJiYhdC51c2VzX2FyZ3VtZW50cyYmIXQudXNlc19ldmFsJiYoZT1jLnBhcmVudCgpKWluc3RhbmNlb2YgWWUmJmUuZXhwcmVzc2lvbj09PXQpe3ZhciBpPWMuaGFzX2RpcmVjdGl2ZShcInVzZSBzdHJpY3RcIik7aSYmIXRlKGksdC5ib2R5KSYmKGk9ITEpO3ZhciBuPXQuYXJnbmFtZXMubGVuZ3RoO2Y9ZS5hcmdzLnNsaWNlKG4pO2Zvcih2YXIgcj1PYmplY3QuY3JlYXRlKG51bGwpLG89bjswPD0tLW87KXt2YXIgYT10LmFyZ25hbWVzW29dLHM9ZS5hcmdzW29dO2lmKGYudW5zaGlmdChYKFZlLGEse25hbWU6YSx2YWx1ZTpzfSkpLCEoYS5uYW1lIGluIHIpKXtpZihyW2EubmFtZV09ITAscyl7dmFyIHU9bmV3IFNuKGZ1bmN0aW9uKGUpe2lmKCFzKXJldHVybiEwO2lmKGUgaW5zdGFuY2VvZiBfbiYmdC52YXJpYWJsZXMuaGFzKGUubmFtZSkpe3ZhciBuPWUuZGVmaW5pdGlvbigpLnNjb3BlO2lmKG4hPT1KKWZvcig7bj1uLnBhcmVudF9zY29wZTspaWYobj09PUopcmV0dXJuITA7cz1udWxsfXJldHVybiBlIGluc3RhbmNlb2YgbW4mJihpfHwhdS5maW5kX3BhcmVudChBZSkpPyEocz1udWxsKTp2b2lkIDB9KTtzLndhbGsodSl9ZWxzZSBzPVgoRW4sYSkudHJhbnNmb3JtKGMpO3MmJmwudW5zaGlmdChbWChWZSxhLHtuYW1lOmEsdmFsdWU6c30pXSl9fX19ZnVuY3Rpb24geihlKXtzLnB1c2goZSksZSBpbnN0YW5jZW9mIHJuPyhsLnB1c2gocy5zbGljZSgpKSx6KGUucmlnaHQpKTplIGluc3RhbmNlb2Ygbm4/KHooZS5sZWZ0KSx6KGUucmlnaHQpKTplIGluc3RhbmNlb2YgWWU/KHooZS5leHByZXNzaW9uKSxlLmFyZ3MuZm9yRWFjaCh6KSk6ZSBpbnN0YW5jZW9mIEhlP3ooZS5leHByZXNzaW9uKTplIGluc3RhbmNlb2YgdG4/KHooZS5jb25kaXRpb24pLHooZS5jb25zZXF1ZW50KSx6KGUuYWx0ZXJuYXRpdmUpKTplIGluc3RhbmNlb2YgVWU/ZS5kZWZpbml0aW9ucy5mb3JFYWNoKHopOmUgaW5zdGFuY2VvZiBtZT8oeihlLmNvbmRpdGlvbiksZS5ib2R5IGluc3RhbmNlb2YgcGV8fHooZS5ib2R5KSk6ZSBpbnN0YW5jZW9mIFNlP2UudmFsdWUmJnooZS52YWx1ZSk6ZSBpbnN0YW5jZW9mIHllPyhlLmluaXQmJnooZS5pbml0KSxlLmNvbmRpdGlvbiYmeihlLmNvbmRpdGlvbiksZS5zdGVwJiZ6KGUuc3RlcCksZS5ib2R5IGluc3RhbmNlb2YgcGV8fHooZS5ib2R5KSk6ZSBpbnN0YW5jZW9mIHdlPyh6KGUub2JqZWN0KSxlLmJvZHkgaW5zdGFuY2VvZiBwZXx8eihlLmJvZHkpKTplIGluc3RhbmNlb2YgTWU/KHooZS5jb25kaXRpb24pLGUuYm9keSBpbnN0YW5jZW9mIHBlfHx6KGUuYm9keSksIWUuYWx0ZXJuYXRpdmV8fGUuYWx0ZXJuYXRpdmUgaW5zdGFuY2VvZiBwZXx8eihlLmFsdGVybmF0aXZlKSk6ZSBpbnN0YW5jZW9mIFdlP2UuZXhwcmVzc2lvbnMuZm9yRWFjaCh6KTplIGluc3RhbmNlb2YgbGU/eihlLmJvZHkpOmUgaW5zdGFuY2VvZiBxZT8oeihlLmV4cHJlc3Npb24pLGUuYm9keS5mb3JFYWNoKHopKTplIGluc3RhbmNlb2YgS2U/XCIrK1wiPT1lLm9wZXJhdG9yfHxcIi0tXCI9PWUub3BlcmF0b3I/bC5wdXNoKHMuc2xpY2UoKSk6eihlLmV4cHJlc3Npb24pOmUgaW5zdGFuY2VvZiBWZSYmZS52YWx1ZSYmKGwucHVzaChzLnNsaWNlKCkpLHooZS52YWx1ZSkpLHMucG9wKCl9ZnVuY3Rpb24gTShlKXtpZighKGUgaW5zdGFuY2VvZiBWZSkpcmV0dXJuIGVbZSBpbnN0YW5jZW9mIHJuP1wibGVmdFwiOlwiZXhwcmVzc2lvblwiXTt2YXIgbj1lLm5hbWUuZGVmaW5pdGlvbigpO2lmKHRlKGUubmFtZSxuLm9yaWcpKXt2YXIgdD1uLm9yaWcubGVuZ3RoLW4uZWxpbWluYXRlZCxpPW4ucmVmZXJlbmNlcy5sZW5ndGgtbi5yZXBsYWNlZDtyZXR1cm4gMTx0JiYhKGUubmFtZSBpbnN0YW5jZW9mIHBuKXx8KDE8aT9mdW5jdGlvbihlKXt2YXIgbj1lLnZhbHVlO2lmKG4gaW5zdGFuY2VvZiBfbiYmXCJhcmd1bWVudHNcIiE9bi5uYW1lKXt2YXIgdD1uLmRlZmluaXRpb24oKTtpZighdC51bmRlY2xhcmVkKXJldHVybiBkPXR9fShlKTohYy5leHBvc2VkKG4pKT9YKF9uLGUubmFtZSxlLm5hbWUpOnZvaWQgMH19ZnVuY3Rpb24gcShlKXtpZihwIGluc3RhbmNlb2Ygcm4mJlwiPVwiPT1wLm9wZXJhdG9yKXJldHVybiBwLnJpZ2h0fWZ1bmN0aW9uIGooZSl7aWYoZSBpbnN0YW5jZW9mIF9uKXt2YXIgbj1lLmV2YWx1YXRlKGMpO3JldHVybiBuPT09ZT9OOkgobixOKX1pZihlIGluc3RhbmNlb2YgbW4pcmV0dXJuIE47aWYoZS5pc190cnV0aHkoKSlyZXR1cm4gSCghMCxpZSk7aWYoZS5pc19jb25zdGFudCgpKXJldHVybiBIKGUuZXZhbHVhdGUoYyksTik7aWYoIShfIGluc3RhbmNlb2YgX24pKXJldHVybiExO2lmKGUuaGFzX3NpZGVfZWZmZWN0cyhjKSlyZXR1cm4hMTt2YXIgdCxpPV8uZGVmaW5pdGlvbigpO3JldHVybiBlLndhbGsobmV3IFNuKGZ1bmN0aW9uKGUpe2lmKHQpcmV0dXJuITA7ZSBpbnN0YW5jZW9mIF9uJiZlLmRlZmluaXRpb24oKT09PWkmJih0PSEwKX0pKSwhdCYmTn1mdW5jdGlvbiBOKGUpe3JldHVybiByLmVxdWl2YWxlbnRfdG8oZSl9ZnVuY3Rpb24gSCh0LGkpe3JldHVybiBmdW5jdGlvbihlLG4pe2lmKG4uaW5fYm9vbGVhbl9jb250ZXh0KCkpe2lmKHQmJmUuaXNfdHJ1dGh5KCkmJiFlLmhhc19zaWRlX2VmZmVjdHMoYykpcmV0dXJuITA7aWYoZS5pc19jb25zdGFudCgpKXJldHVybiFlLmV2YWx1YXRlKGMpPT0hdH1yZXR1cm4gaShlKX19ZnVuY3Rpb24gUihlKXt2YXIgdD1PYmplY3QuY3JlYXRlKG51bGwpO3AgaW5zdGFuY2VvZiBWZSYmKHRbcC5uYW1lLm5hbWVdPV8pO3ZhciBpPW5ldyBTbihmdW5jdGlvbihlKXt2YXIgbj1LKGUpOyhuIGluc3RhbmNlb2YgX258fG4gaW5zdGFuY2VvZiBtbikmJih0W24ubmFtZV09dFtuLm5hbWVdfHxuZShlLGkucGFyZW50KCkpKX0pO3JldHVybiBlLndhbGsoaSksdH1mdW5jdGlvbiBJKGkpe2lmKGkubmFtZSBpbnN0YW5jZW9mIHBuKXt2YXIgZT1jLnNlbGYoKS5hcmduYW1lcy5pbmRleE9mKGkubmFtZSksbj1jLnBhcmVudCgpLmFyZ3M7cmV0dXJuIG5bZV0mJihuW2VdPVgoeW4sbltlXSx7dmFsdWU6MH0pKSwhMH12YXIgcj0hMTtyZXR1cm4gdFtvXS50cmFuc2Zvcm0obmV3IFhuKGZ1bmN0aW9uKGUsbix0KXtyZXR1cm4gcj9lOmU9PT1pfHxlLmJvZHk9PT1pPyhyPSEwLGUgaW5zdGFuY2VvZiBWZT8oZS52YWx1ZT1udWxsLGUpOnQ/cmUuc2tpcDpudWxsKTp2b2lkIDB9LGZ1bmN0aW9uKGUpe2lmKGUgaW5zdGFuY2VvZiBXZSlzd2l0Y2goZS5leHByZXNzaW9ucy5sZW5ndGgpe2Nhc2UgMDpyZXR1cm4gbnVsbDtjYXNlIDE6cmV0dXJuIGUuZXhwcmVzc2lvbnNbMF19fSkpfWZ1bmN0aW9uIFAoZSl7cmV0dXJuIShlIGluc3RhbmNlb2YgS2UpJiYobj1lLG5bbiBpbnN0YW5jZW9mIHJuP1wicmlnaHRcIjpcInZhbHVlXCJdKS5oYXNfc2lkZV9lZmZlY3RzKGMpO3ZhciBufWZ1bmN0aW9uIFUoKXtpZihtKXJldHVybiExO2lmKGQpcmV0dXJuITA7aWYoXyBpbnN0YW5jZW9mIF9uKXt2YXIgZT1fLmRlZmluaXRpb24oKTtpZihlLnJlZmVyZW5jZXMubGVuZ3RoLWUucmVwbGFjZWQ9PShwIGluc3RhbmNlb2YgVmU/MToyKSlyZXR1cm4hMH1yZXR1cm4hMX1mdW5jdGlvbiBMKGUpe3ZhciBuPWUuZGVmaW5pdGlvbigpO3JldHVybiEoMT09bi5vcmlnLmxlbmd0aCYmbi5vcmlnWzBdaW5zdGFuY2VvZiBkbikmJihuLnNjb3BlIT09Snx8IW9lKG4ucmVmZXJlbmNlcyxmdW5jdGlvbihlKXt2YXIgbj1lLnNjb3BlO3JldHVyblwiU2NvcGVcIj09bi5UWVBFJiYobj1uLnBhcmVudF9zY29wZSksbj09PUp9KSl9fWZ1bmN0aW9uIHIoZSl7Zm9yKHZhciBuPVtdLHQ9MDt0PGUubGVuZ3RoOyl7dmFyIGk9ZVt0XTtpIGluc3RhbmNlb2YgZGU/KFc9ITAscihpLmJvZHkpLFtdLnNwbGljZS5hcHBseShlLFt0LDFdLmNvbmNhdChpLmJvZHkpKSx0Kz1pLmJvZHkubGVuZ3RoKTppIGluc3RhbmNlb2YgaGU/KFc9ITAsZS5zcGxpY2UodCwxKSk6aSBpbnN0YW5jZW9mIGZlP24uaW5kZXhPZihpLnZhbHVlKTwwPyh0Kyssbi5wdXNoKGkudmFsdWUpKTooVz0hMCxlLnNwbGljZSh0LDEpKTp0Kyt9fWZ1bmN0aW9uIGkocixpKXtmb3IodmFyIG89aS5zZWxmKCksZT1mdW5jdGlvbihlKXtmb3IodmFyIG49MCx0PWUubGVuZ3RoOzA8PS0tdDspe3ZhciBpPWVbdF07aWYoaSBpbnN0YW5jZW9mIE1lJiZpLmJvZHkgaW5zdGFuY2VvZiBUZSYmMTwrK24pcmV0dXJuITB9cmV0dXJuITF9KHIpLGE9byBpbnN0YW5jZW9mIGtlLG49ci5sZW5ndGg7MDw9LS1uOyl7dmFyIHQ9cltuXSxzPV8obiksdT1yW3NdO2lmKGEmJiF1JiZ0IGluc3RhbmNlb2YgVGUpe2lmKCF0LnZhbHVlKXtXPSEwLHIuc3BsaWNlKG4sMSk7Y29udGludWV9aWYodC52YWx1ZSBpbnN0YW5jZW9mIFFlJiZcInZvaWRcIj09dC52YWx1ZS5vcGVyYXRvcil7Vz0hMCxyW25dPVgobGUsdCx7Ym9keTp0LnZhbHVlLmV4cHJlc3Npb259KTtjb250aW51ZX19aWYodCBpbnN0YW5jZW9mIE1lKXt2YXIgYztpZihkKGM9QSh0LmJvZHkpKSl7Yy5sYWJlbCYmVChjLmxhYmVsLnRoZWRlZi5yZWZlcmVuY2VzLGMpLFc9ITAsKHQ9dC5jbG9uZSgpKS5jb25kaXRpb249dC5jb25kaXRpb24ubmVnYXRlKGkpO3ZhciBmPXYodC5ib2R5LGMpO3QuYm9keT1YKGRlLHQse2JvZHk6Yih0LmFsdGVybmF0aXZlKS5jb25jYXQoaCgpKX0pLHQuYWx0ZXJuYXRpdmU9WChkZSx0LHtib2R5OmZ9KSxyW25dPXQudHJhbnNmb3JtKGkpO2NvbnRpbnVlfWlmKGQoYz1BKHQuYWx0ZXJuYXRpdmUpKSl7Yy5sYWJlbCYmVChjLmxhYmVsLnRoZWRlZi5yZWZlcmVuY2VzLGMpLFc9ITAsKHQ9dC5jbG9uZSgpKS5ib2R5PVgoZGUsdC5ib2R5LHtib2R5OmIodC5ib2R5KS5jb25jYXQoaCgpKX0pO2Y9dih0LmFsdGVybmF0aXZlLGMpO3QuYWx0ZXJuYXRpdmU9WChkZSx0LmFsdGVybmF0aXZlLHtib2R5OmZ9KSxyW25dPXQudHJhbnNmb3JtKGkpO2NvbnRpbnVlfX1pZih0IGluc3RhbmNlb2YgTWUmJnQuYm9keSBpbnN0YW5jZW9mIFRlKXt2YXIgbD10LmJvZHkudmFsdWU7aWYoIWwmJiF0LmFsdGVybmF0aXZlJiYoYSYmIXV8fHUgaW5zdGFuY2VvZiBUZSYmIXUudmFsdWUpKXtXPSEwLHJbbl09WChsZSx0LmNvbmRpdGlvbix7Ym9keTp0LmNvbmRpdGlvbn0pO2NvbnRpbnVlfWlmKGwmJiF0LmFsdGVybmF0aXZlJiZ1IGluc3RhbmNlb2YgVGUmJnUudmFsdWUpe1c9ITAsKHQ9dC5jbG9uZSgpKS5hbHRlcm5hdGl2ZT11LHIuc3BsaWNlKG4sMSx0LnRyYW5zZm9ybShpKSksci5zcGxpY2UocywxKTtjb250aW51ZX1pZihsJiYhdC5hbHRlcm5hdGl2ZSYmKCF1JiZhJiZlfHx1IGluc3RhbmNlb2YgVGUpKXtXPSEwLCh0PXQuY2xvbmUoKSkuYWx0ZXJuYXRpdmU9dXx8WChUZSx0LHt2YWx1ZTpudWxsfSksci5zcGxpY2UobiwxLHQudHJhbnNmb3JtKGkpKSx1JiZyLnNwbGljZShzLDEpO2NvbnRpbnVlfXZhciBwPXJbbShuKV07aWYoaS5vcHRpb24oXCJzZXF1ZW5jZXNcIikmJmEmJiF0LmFsdGVybmF0aXZlJiZwIGluc3RhbmNlb2YgTWUmJnAuYm9keSBpbnN0YW5jZW9mIFRlJiZfKHMpPT1yLmxlbmd0aCYmdSBpbnN0YW5jZW9mIGxlKXtXPSEwLCh0PXQuY2xvbmUoKSkuYWx0ZXJuYXRpdmU9WChkZSx1LHtib2R5Olt1LFgoVGUsdSx7dmFsdWU6bnVsbH0pXX0pLHIuc3BsaWNlKG4sMSx0LnRyYW5zZm9ybShpKSksci5zcGxpY2UocywxKTtjb250aW51ZX19fWZ1bmN0aW9uIGQoZSl7aWYoIWUpcmV0dXJuITE7dmFyIG4sdD1lIGluc3RhbmNlb2YgT2U/aS5sb29wY29udHJvbF90YXJnZXQoZSk6bnVsbDtyZXR1cm4gZSBpbnN0YW5jZW9mIFRlJiZhJiYoIShuPWUudmFsdWUpfHxuIGluc3RhbmNlb2YgUWUmJlwidm9pZFwiPT1uLm9wZXJhdG9yKXx8ZSBpbnN0YW5jZW9mIHplJiZvPT09eSh0KXx8ZSBpbnN0YW5jZW9mICRlJiZ0IGluc3RhbmNlb2YgZGUmJm89PT10fWZ1bmN0aW9uIGgoKXt2YXIgZT1yLnNsaWNlKG4rMSk7cmV0dXJuIHIubGVuZ3RoPW4rMSxlLmZpbHRlcihmdW5jdGlvbihlKXtyZXR1cm4hKGUgaW5zdGFuY2VvZiBDZSl8fChyLnB1c2goZSksITEpfSl9ZnVuY3Rpb24gdihlLG4pe3ZhciB0PWIoZSkuc2xpY2UoMCwtMSk7cmV0dXJuIG4udmFsdWUmJnQucHVzaChYKGxlLG4udmFsdWUse2JvZHk6bi52YWx1ZS5leHByZXNzaW9ufSkpLHR9ZnVuY3Rpb24gXyhlKXtmb3IodmFyIG49ZSsxLHQ9ci5sZW5ndGg7bjx0O24rKyl7dmFyIGk9cltuXTtpZighKGkgaW5zdGFuY2VvZiBMZSYmZyhpKSkpYnJlYWt9cmV0dXJuIG59ZnVuY3Rpb24gbShlKXtmb3IodmFyIG49ZTswPD0tLW47KXt2YXIgdD1yW25dO2lmKCEodCBpbnN0YW5jZW9mIExlJiZnKHQpKSlicmVha31yZXR1cm4gbn19ZnVuY3Rpb24gbyhuLHQpe2Zvcih2YXIgZSxpPXQuc2VsZigpLHI9MCxvPTAsYT1uLmxlbmd0aDtyPGE7cisrKXt2YXIgcz1uW3JdO2lmKHMgaW5zdGFuY2VvZiBPZSl7dmFyIHU9dC5sb29wY29udHJvbF90YXJnZXQocyk7cyBpbnN0YW5jZW9mICRlJiYhKHUgaW5zdGFuY2VvZiBfZSkmJnkodSk9PT1pfHxzIGluc3RhbmNlb2YgemUmJnkodSk9PT1pP3MubGFiZWwmJlQocy5sYWJlbC50aGVkZWYucmVmZXJlbmNlcyxzKTpuW28rK109c31lbHNlIG5bbysrXT1zO2lmKEEocykpe2U9bi5zbGljZShyKzEpO2JyZWFrfX1uLmxlbmd0aD1vLFc9byE9YSxlJiZlLmZvckVhY2goZnVuY3Rpb24oZSl7dyh0LGUsbil9KX1mdW5jdGlvbiBnKGUpe3JldHVybiBvZShlLmRlZmluaXRpb25zLGZ1bmN0aW9uKGUpe3JldHVybiFlLnZhbHVlfSl9ZnVuY3Rpb24gYShuLGUpe2lmKCEobi5sZW5ndGg8Mikpe2Zvcih2YXIgdD1bXSxpPTAscj0wLG89bi5sZW5ndGg7cjxvO3IrKyl7dmFyIGE9bltyXTtpZihhIGluc3RhbmNlb2YgbGUpe3QubGVuZ3RoPj1lLnNlcXVlbmNlc19saW1pdCYmdSgpO3ZhciBzPWEuYm9keTswPHQubGVuZ3RoJiYocz1zLmRyb3Bfc2lkZV9lZmZlY3RfZnJlZShlKSkscyYmbCh0LHMpfWVsc2UgYSBpbnN0YW5jZW9mIFVlJiZnKGEpfHxhIGluc3RhbmNlb2YgQ2V8fHUoKSxuW2krK109YX11KCksKG4ubGVuZ3RoPWkpIT1vJiYoVz0hMCl9ZnVuY3Rpb24gdSgpe2lmKHQubGVuZ3RoKXt2YXIgZT1NKHRbMF0sdCk7bltpKytdPVgobGUsZSx7Ym9keTplfSksdD1bXX19fWZ1bmN0aW9uIHAoZSxuKXtpZighKGUgaW5zdGFuY2VvZiBkZSkpcmV0dXJuIGU7Zm9yKHZhciB0PW51bGwsaT0wLHI9ZS5ib2R5Lmxlbmd0aDtpPHI7aSsrKXt2YXIgbz1lLmJvZHlbaV07aWYobyBpbnN0YW5jZW9mIExlJiZnKG8pKW4ucHVzaChvKTtlbHNle2lmKHQpcmV0dXJuITE7dD1vfX1yZXR1cm4gdH1mdW5jdGlvbiBzKGUsdCl7ZnVuY3Rpb24gbihlKXtyLS0sVz0hMDt2YXIgbj1pLmJvZHk7cmV0dXJuIE0obixbbixlXSkudHJhbnNmb3JtKHQpfWZvcih2YXIgaSxyPTAsbz0wO288ZS5sZW5ndGg7bysrKXt2YXIgYT1lW29dO2lmKGkpaWYoYSBpbnN0YW5jZW9mIFNlKWEudmFsdWU9bihhLnZhbHVlfHxYKEVuLGEpLnRyYW5zZm9ybSh0KSk7ZWxzZSBpZihhIGluc3RhbmNlb2YgeWUpe2lmKCEoYS5pbml0IGluc3RhbmNlb2YgVWUpKXt2YXIgcz0hMTtpLmJvZHkud2FsayhuZXcgU24oZnVuY3Rpb24oZSl7cmV0dXJuISEoc3x8ZSBpbnN0YW5jZW9mIEFlKXx8KGUgaW5zdGFuY2VvZiBubiYmXCJpblwiPT1lLm9wZXJhdG9yP3M9ITA6dm9pZCAwKX0pKSxzfHwoYS5pbml0P2EuaW5pdD1uKGEuaW5pdCk6KGEuaW5pdD1pLmJvZHksci0tLFc9ITApKX19ZWxzZSBhIGluc3RhbmNlb2Ygd2U/YS5vYmplY3Q9bihhLm9iamVjdCk6YSBpbnN0YW5jZW9mIE1lP2EuY29uZGl0aW9uPW4oYS5jb25kaXRpb24pOmEgaW5zdGFuY2VvZiBxZT9hLmV4cHJlc3Npb249bihhLmV4cHJlc3Npb24pOmEgaW5zdGFuY2VvZiB4ZSYmKGEuZXhwcmVzc2lvbj1uKGEuZXhwcmVzc2lvbikpO2lmKHQub3B0aW9uKFwiY29uZGl0aW9uYWxzXCIpJiZhIGluc3RhbmNlb2YgTWUpe3ZhciB1PVtdLGM9cChhLmJvZHksdSksZj1wKGEuYWx0ZXJuYXRpdmUsdSk7aWYoITEhPT1jJiYhMSE9PWYmJjA8dS5sZW5ndGgpe3ZhciBsPXUubGVuZ3RoO3UucHVzaChYKE1lLGEse2NvbmRpdGlvbjphLmNvbmRpdGlvbixib2R5OmN8fFgoaGUsYS5ib2R5KSxhbHRlcm5hdGl2ZTpmfSkpLHUudW5zaGlmdChyLDEpLFtdLnNwbGljZS5hcHBseShlLHUpLG8rPWwscis9bCsxLFc9IShpPW51bGwpO2NvbnRpbnVlfX1lW3IrK109YSxpPWEgaW5zdGFuY2VvZiBsZT9hOm51bGx9ZS5sZW5ndGg9cn1mdW5jdGlvbiBmKGUsbil7aWYoZSBpbnN0YW5jZW9mIFVlKXt2YXIgdCxpPWUuZGVmaW5pdGlvbnNbZS5kZWZpbml0aW9ucy5sZW5ndGgtMV07aWYoaS52YWx1ZSBpbnN0YW5jZW9mIGFuKWlmKG4gaW5zdGFuY2VvZiBybj90PVtuXTpuIGluc3RhbmNlb2YgV2UmJih0PW4uZXhwcmVzc2lvbnMuc2xpY2UoKSksdCl7dmFyIHI9ITE7ZG97dmFyIG89dFswXTtpZighKG8gaW5zdGFuY2VvZiBybikpYnJlYWs7aWYoXCI9XCIhPW8ub3BlcmF0b3IpYnJlYWs7aWYoIShvLmxlZnQgaW5zdGFuY2VvZiBHZSkpYnJlYWs7dmFyIGE9by5sZWZ0LmV4cHJlc3Npb247aWYoIShhIGluc3RhbmNlb2YgX24pKWJyZWFrO2lmKGkubmFtZS5uYW1lIT1hLm5hbWUpYnJlYWs7aWYoIW8ucmlnaHQuaXNfY29uc3RhbnRfZXhwcmVzc2lvbihKKSlicmVhazt2YXIgcz1vLmxlZnQucHJvcGVydHk7aWYocyBpbnN0YW5jZW9mIHNlJiYocz1zLmV2YWx1YXRlKGMpKSxzIGluc3RhbmNlb2Ygc2UpYnJlYWs7cz1cIlwiK3M7dmFyIHU9Yy5oYXNfZGlyZWN0aXZlKFwidXNlIHN0cmljdFwiKT9mdW5jdGlvbihlKXtyZXR1cm4gZS5rZXkhPXMmJmUua2V5Lm5hbWUhPXN9OmZ1bmN0aW9uKGUpe3JldHVybiBlLmtleS5uYW1lIT1zfTtpZighb2UoaS52YWx1ZS5wcm9wZXJ0aWVzLHUpKWJyZWFrO2kudmFsdWUucHJvcGVydGllcy5wdXNoKFgodW4sbyx7a2V5OnMsdmFsdWU6by5yaWdodH0pKSx0LnNoaWZ0KCkscj0hMH13aGlsZSh0Lmxlbmd0aCk7cmV0dXJuIHImJnR9fX1mdW5jdGlvbiB1KHQpe2Zvcih2YXIgZSxuPTAsaT0tMSxyPXQubGVuZ3RoO248cjtuKyspe3ZhciBvPXRbbl0sYT10W2ldO2lmKG8gaW5zdGFuY2VvZiBVZSlhJiZhLlRZUEU9PW8uVFlQRT8oYS5kZWZpbml0aW9ucz1hLmRlZmluaXRpb25zLmNvbmNhdChvLmRlZmluaXRpb25zKSxXPSEwKTplJiZlLlRZUEU9PW8uVFlQRSYmZyhvKT8oZS5kZWZpbml0aW9ucz1lLmRlZmluaXRpb25zLmNvbmNhdChvLmRlZmluaXRpb25zKSxXPSEwKTplPXRbKytpXT1vO2Vsc2UgaWYobyBpbnN0YW5jZW9mIFNlKW8udmFsdWU9dShvLnZhbHVlKTtlbHNlIGlmKG8gaW5zdGFuY2VvZiB5ZSl7KHM9ZihhLG8uaW5pdCkpPyhXPSEwLG8uaW5pdD1zLmxlbmd0aD9NKG8uaW5pdCxzKTpudWxsLHRbKytpXT1vKTphIGluc3RhbmNlb2YgTGUmJighby5pbml0fHxvLmluaXQuVFlQRT09YS5UWVBFKT8oby5pbml0JiYoYS5kZWZpbml0aW9ucz1hLmRlZmluaXRpb25zLmNvbmNhdChvLmluaXQuZGVmaW5pdGlvbnMpKSxvLmluaXQ9YSx0W2ldPW8sVz0hMCk6ZSYmby5pbml0JiZlLlRZUEU9PW8uaW5pdC5UWVBFJiZnKG8uaW5pdCk/KGUuZGVmaW5pdGlvbnM9ZS5kZWZpbml0aW9ucy5jb25jYXQoby5pbml0LmRlZmluaXRpb25zKSxvLmluaXQ9bnVsbCx0WysraV09byxXPSEwKTp0WysraV09b31lbHNlIGlmKG8gaW5zdGFuY2VvZiB3ZSlvLm9iamVjdD11KG8ub2JqZWN0KTtlbHNlIGlmKG8gaW5zdGFuY2VvZiBNZSlvLmNvbmRpdGlvbj11KG8uY29uZGl0aW9uKTtlbHNlIGlmKG8gaW5zdGFuY2VvZiBsZSl7dmFyIHM7aWYocz1mKGEsby5ib2R5KSl7aWYoVz0hMCwhcy5sZW5ndGgpY29udGludWU7by5ib2R5PU0oby5ib2R5LHMpfXRbKytpXT1vfWVsc2UgbyBpbnN0YW5jZW9mIHFlP28uZXhwcmVzc2lvbj11KG8uZXhwcmVzc2lvbik6byBpbnN0YW5jZW9mIHhlP28uZXhwcmVzc2lvbj11KG8uZXhwcmVzc2lvbik6dFsrK2ldPW99ZnVuY3Rpb24gdShlKXt0WysraV09bzt2YXIgbj1mKGEsZSk7cmV0dXJuIG4/KFc9ITAsbi5sZW5ndGg/TShlLG4pOmUgaW5zdGFuY2VvZiBXZT9lLnRhaWxfbm9kZSgpLmxlZnQ6ZS5sZWZ0KTplfXQubGVuZ3RoPWkrMX19ZnVuY3Rpb24gdyhuLGUsdCl7ZSBpbnN0YW5jZW9mIENlfHxuLndhcm4oXCJEcm9wcGluZyB1bnJlYWNoYWJsZSBjb2RlIFt7ZmlsZX06e2xpbmV9LHtjb2x9XVwiLGUuc3RhcnQpLGUud2FsayhuZXcgU24oZnVuY3Rpb24oZSl7cmV0dXJuIGUgaW5zdGFuY2VvZiBVZT8obi53YXJuKFwiRGVjbGFyYXRpb25zIGluIHVucmVhY2hhYmxlIGNvZGUhIFt7ZmlsZX06e2xpbmV9LHtjb2x9XVwiLGUuc3RhcnQpLGUucmVtb3ZlX2luaXRpYWxpemVycygpLHQucHVzaChlKSwhMCk6ZSBpbnN0YW5jZW9mIENlPyh0LnB1c2goZSksITApOmUgaW5zdGFuY2VvZiBBZXx8dm9pZCAwfSkpfWZ1bmN0aW9uIHAoZSl7cmV0dXJuIGUgaW5zdGFuY2VvZiBnbj9lLmdldFZhbHVlKCk6ZSBpbnN0YW5jZW9mIFFlJiZcInZvaWRcIj09ZS5vcGVyYXRvciYmZS5leHByZXNzaW9uIGluc3RhbmNlb2YgZ24/dm9pZCAwOmV9ZnVuY3Rpb24gZyhlLG4pe3JldHVybiBlLmlzX3VuZGVmaW5lZHx8ZSBpbnN0YW5jZW9mIEVufHxlIGluc3RhbmNlb2YgUWUmJlwidm9pZFwiPT1lLm9wZXJhdG9yJiYhZS5leHByZXNzaW9uLmhhc19zaWRlX2VmZmVjdHMobil9KHQ9ZnVuY3Rpb24oZSxuKXtlLkRFRk1FVEhPRChcImlzX3RydXRoeVwiLG4pfSkoc2UsaWUpLHQob24sSiksdChybixmdW5jdGlvbigpe3JldHVyblwiPVwiPT10aGlzLm9wZXJhdG9yJiZ0aGlzLnJpZ2h0LmlzX3RydXRoeSgpfSksdChrZSxKKSx0KGFuLEopLHQod24sSiksdChXZSxmdW5jdGlvbigpe3JldHVybiB0aGlzLnRhaWxfbm9kZSgpLmlzX3RydXRoeSgpfSksdChfbixmdW5jdGlvbigpe3ZhciBlPXRoaXMuZml4ZWRfdmFsdWUoKTtyZXR1cm4gZSYmZS5pc190cnV0aHkoKX0pLGZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQoZSl7cmV0dXJuL3N0cmljdC8udGVzdChlLm9wdGlvbihcInB1cmVfZ2V0dGVyc1wiKSl9c2UuREVGTUVUSE9EKFwibWF5X3Rocm93X29uX2FjY2Vzc1wiLGZ1bmN0aW9uKGUpe3JldHVybiFlLm9wdGlvbihcInB1cmVfZ2V0dGVyc1wiKXx8dGhpcy5fZG90X3Rocm93KGUpfSksZShzZSx0KSxlKHhuLEopLGUoRW4sSiksZShnbixpZSksZShvbixpZSksZShhbixmdW5jdGlvbihlKXtpZighdChlKSlyZXR1cm4hMTtmb3IodmFyIG49dGhpcy5wcm9wZXJ0aWVzLmxlbmd0aDswPD0tLW47KWlmKHRoaXMucHJvcGVydGllc1tuXS52YWx1ZSBpbnN0YW5jZW9mIERlKXJldHVybiEwO3JldHVybiExfSksZShrZSxpZSksZShlbixpZSksZShRZSxmdW5jdGlvbigpe3JldHVyblwidm9pZFwiPT10aGlzLm9wZXJhdG9yfSksZShubixmdW5jdGlvbihlKXtyZXR1cm4oXCImJlwiPT10aGlzLm9wZXJhdG9yfHxcInx8XCI9PXRoaXMub3BlcmF0b3IpJiYodGhpcy5sZWZ0Ll9kb3RfdGhyb3coZSl8fHRoaXMucmlnaHQuX2RvdF90aHJvdyhlKSl9KSxlKHJuLGZ1bmN0aW9uKGUpe3JldHVyblwiPVwiPT10aGlzLm9wZXJhdG9yJiZ0aGlzLnJpZ2h0Ll9kb3RfdGhyb3coZSl9KSxlKHRuLGZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmNvbnNlcXVlbnQuX2RvdF90aHJvdyhlKXx8dGhpcy5hbHRlcm5hdGl2ZS5fZG90X3Rocm93KGUpfSksZShYZSxmdW5jdGlvbihlKXtpZighdChlKSlyZXR1cm4hMTt2YXIgbj10aGlzLmV4cHJlc3Npb247cmV0dXJuIG4gaW5zdGFuY2VvZiBfbiYmKG49bi5maXhlZF92YWx1ZSgpKSwhKG4gaW5zdGFuY2VvZiBrZSYmXCJwcm90b3R5cGVcIj09dGhpcy5wcm9wZXJ0eSl9KSxlKFdlLGZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnRhaWxfbm9kZSgpLl9kb3RfdGhyb3coZSl9KSxlKF9uLGZ1bmN0aW9uKGUpe2lmKHRoaXMuaXNfdW5kZWZpbmVkKXJldHVybiEwO2lmKCF0KGUpKXJldHVybiExO2lmKEgodGhpcykmJnRoaXMuaXNfZGVjbGFyZWQoZSkpcmV0dXJuITE7aWYodGhpcy5pc19pbW11dGFibGUoKSlyZXR1cm4hMTt2YXIgbj10aGlzLmZpeGVkX3ZhbHVlKCk7cmV0dXJuIW58fG4uX2RvdF90aHJvdyhlKX0pfShmdW5jdGlvbihlLG4pe2UuREVGTUVUSE9EKFwiX2RvdF90aHJvd1wiLG4pfSkscj1bXCIhXCIsXCJkZWxldGVcIl0sYT1bXCJpblwiLFwiaW5zdGFuY2VvZlwiLFwiPT1cIixcIiE9XCIsXCI9PT1cIixcIiE9PVwiLFwiPFwiLFwiPD1cIixcIj49XCIsXCI+XCJdLChpPWZ1bmN0aW9uKGUsbil7ZS5ERUZNRVRIT0QoXCJpc19ib29sZWFuXCIsbil9KShzZSxpZSksaShRZSxmdW5jdGlvbigpe3JldHVybiB0ZSh0aGlzLm9wZXJhdG9yLHIpfSksaShubixmdW5jdGlvbigpe3JldHVybiB0ZSh0aGlzLm9wZXJhdG9yLGEpfHxlZSh0aGlzLm9wZXJhdG9yKSYmdGhpcy5sZWZ0LmlzX2Jvb2xlYW4oKSYmdGhpcy5yaWdodC5pc19ib29sZWFuKCl9KSxpKHRuLGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29uc2VxdWVudC5pc19ib29sZWFuKCkmJnRoaXMuYWx0ZXJuYXRpdmUuaXNfYm9vbGVhbigpfSksaShybixmdW5jdGlvbigpe3JldHVyblwiPVwiPT10aGlzLm9wZXJhdG9yJiZ0aGlzLnJpZ2h0LmlzX2Jvb2xlYW4oKX0pLGkoV2UsZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50YWlsX25vZGUoKS5pc19ib29sZWFuKCl9KSxpKEJuLEopLGkoQ24sSiksZnVuY3Rpb24oZSl7ZShzZSxpZSksZSh5bixKKTt2YXIgbj1XKFwiKyAtIH4gKysgLS1cIik7ZShLZSxmdW5jdGlvbigpe3JldHVybiBuKHRoaXMub3BlcmF0b3IpfSk7dmFyIHQ9VyhcIi0gKiAvICUgJiB8IF4gPDwgPj4gPj4+XCIpO2Uobm4sZnVuY3Rpb24oZSl7cmV0dXJuIHQodGhpcy5vcGVyYXRvcil8fFwiK1wiPT10aGlzLm9wZXJhdG9yJiZ0aGlzLmxlZnQuaXNfbnVtYmVyKGUpJiZ0aGlzLnJpZ2h0LmlzX251bWJlcihlKX0pLGUocm4sZnVuY3Rpb24oZSl7cmV0dXJuIHQodGhpcy5vcGVyYXRvci5zbGljZSgwLC0xKSl8fFwiPVwiPT10aGlzLm9wZXJhdG9yJiZ0aGlzLnJpZ2h0LmlzX251bWJlcihlKX0pLGUoV2UsZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMudGFpbF9ub2RlKCkuaXNfbnVtYmVyKGUpfSksZSh0bixmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5jb25zZXF1ZW50LmlzX251bWJlcihlKSYmdGhpcy5hbHRlcm5hdGl2ZS5pc19udW1iZXIoZSl9KX0oZnVuY3Rpb24oZSxuKXtlLkRFRk1FVEhPRChcImlzX251bWJlclwiLG4pfSksKHM9ZnVuY3Rpb24oZSxuKXtlLkRFRk1FVEhPRChcImlzX3N0cmluZ1wiLG4pfSkoc2UsaWUpLHMoYm4sSikscyhRZSxmdW5jdGlvbigpe3JldHVyblwidHlwZW9mXCI9PXRoaXMub3BlcmF0b3J9KSxzKG5uLGZ1bmN0aW9uKGUpe3JldHVyblwiK1wiPT10aGlzLm9wZXJhdG9yJiYodGhpcy5sZWZ0LmlzX3N0cmluZyhlKXx8dGhpcy5yaWdodC5pc19zdHJpbmcoZSkpfSkscyhybixmdW5jdGlvbihlKXtyZXR1cm4oXCI9XCI9PXRoaXMub3BlcmF0b3J8fFwiKz1cIj09dGhpcy5vcGVyYXRvcikmJnRoaXMucmlnaHQuaXNfc3RyaW5nKGUpfSkscyhXZSxmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy50YWlsX25vZGUoKS5pc19zdHJpbmcoZSl9KSxzKHRuLGZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmNvbnNlcXVlbnQuaXNfc3RyaW5nKGUpJiZ0aGlzLmFsdGVybmF0aXZlLmlzX3N0cmluZyhlKX0pO3ZhciBjLGVlPVcoXCImJiB8fFwiKSxmPVcoXCJkZWxldGUgKysgLS1cIik7ZnVuY3Rpb24gbmUoZSxuKXtyZXR1cm4gbiBpbnN0YW5jZW9mIEtlJiZmKG4ub3BlcmF0b3IpP24uZXhwcmVzc2lvbjpuIGluc3RhbmNlb2Ygcm4mJm4ubGVmdD09PWU/ZTp2b2lkIDB9ZnVuY3Rpb24geChlLG4pe3JldHVybiBlLnByaW50X3RvX3N0cmluZygpLmxlbmd0aD5uLnByaW50X3RvX3N0cmluZygpLmxlbmd0aD9uOmV9ZnVuY3Rpb24gSShlLG4sdCl7cmV0dXJuKCQoZSk/ZnVuY3Rpb24oZSxuKXtyZXR1cm4geChYKGxlLGUse2JvZHk6ZX0pLFgobGUsbix7Ym9keTpufSkpLmJvZHl9OngpKG4sdCl9ZnVuY3Rpb24gZChlKXtmb3IodmFyIG4gaW4gZSllW25dPVcoZVtuXSl9Yz1mdW5jdGlvbihlLG4pe2UuREVGTUVUSE9EKFwiX2ZpbmRfZGVmc1wiLG4pfSxzZS5ERUZNRVRIT0QoXCJyZXNvbHZlX2RlZmluZXNcIixmdW5jdGlvbihlKXtpZihlLm9wdGlvbihcImdsb2JhbF9kZWZzXCIpKXt2YXIgbj10aGlzLl9maW5kX2RlZnMoZSxcIlwiKTtpZihuKXtmb3IodmFyIHQsaT10aGlzLHI9MDt0PWksKGk9ZS5wYXJlbnQocisrKSlpbnN0YW5jZW9mIEdlJiZpLmV4cHJlc3Npb249PT10Oyk7aWYoIW5lKHQsaSkpcmV0dXJuIG47ZS53YXJuKFwiZ2xvYmFsX2RlZnMgXCIrdGhpcy5wcmludF90b19zdHJpbmcoKStcIiByZWRlZmluZWQgW3tmaWxlfTp7bGluZX0se2NvbH1dXCIsdGhpcy5zdGFydCl9fX0pLGMoc2UsTCksYyhYZSxmdW5jdGlvbihlLG4pe3JldHVybiB0aGlzLmV4cHJlc3Npb24uX2ZpbmRfZGVmcyhlLFwiLlwiK3RoaXMucHJvcGVydHkrbil9KSxjKF9uLGZ1bmN0aW9uKGUsbil7aWYodGhpcy5nbG9iYWwoKSl7dmFyIHQsaT1lLm9wdGlvbihcImdsb2JhbF9kZWZzXCIpO2lmKGkmJmFlKGksdD10aGlzLm5hbWUrbikpe3ZhciByPWZ1bmN0aW9uIG4oZSx0KXtpZihlIGluc3RhbmNlb2Ygc2UpcmV0dXJuIFgoZS5DVE9SLHQsZSk7aWYoQXJyYXkuaXNBcnJheShlKSlyZXR1cm4gWChvbix0LHtlbGVtZW50czplLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gbihlLHQpfSl9KTtpZihlJiZcIm9iamVjdFwiPT10eXBlb2YgZSl7dmFyIGk9W107Zm9yKHZhciByIGluIGUpYWUoZSxyKSYmaS5wdXNoKFgodW4sdCx7a2V5OnIsdmFsdWU6bihlW3JdLHQpfSkpO3JldHVybiBYKGFuLHQse3Byb3BlcnRpZXM6aX0pfXJldHVybiBxKGUsdCl9KGlbdF0sdGhpcyksbz1lLmZpbmRfcGFyZW50KEVlKTtyZXR1cm4gci53YWxrKG5ldyBTbihmdW5jdGlvbihlKXtlIGluc3RhbmNlb2YgX24mJihlLnNjb3BlPW8sZS50aGVkZWY9by5kZWZfZ2xvYmFsKGUpKX0pKSxyfX19KTt2YXIgaD1bXCJjb25zdHJ1Y3RvclwiLFwidG9TdHJpbmdcIixcInZhbHVlT2ZcIl0sdj17QXJyYXk6W1wiaW5kZXhPZlwiLFwiam9pblwiLFwibGFzdEluZGV4T2ZcIixcInNsaWNlXCJdLmNvbmNhdChoKSxCb29sZWFuOmgsRnVuY3Rpb246aCxOdW1iZXI6W1widG9FeHBvbmVudGlhbFwiLFwidG9GaXhlZFwiLFwidG9QcmVjaXNpb25cIl0uY29uY2F0KGgpLE9iamVjdDpoLFJlZ0V4cDpbXCJ0ZXN0XCJdLmNvbmNhdChoKSxTdHJpbmc6W1wiY2hhckF0XCIsXCJjaGFyQ29kZUF0XCIsXCJjb25jYXRcIixcImluZGV4T2ZcIixcIml0YWxpY3NcIixcImxhc3RJbmRleE9mXCIsXCJtYXRjaFwiLFwicmVwbGFjZVwiLFwic2VhcmNoXCIsXCJzbGljZVwiLFwic3BsaXRcIixcInN1YnN0clwiLFwic3Vic3RyaW5nXCIsXCJ0b0xvd2VyQ2FzZVwiLFwidG9VcHBlckNhc2VcIixcInRyaW1cIl0uY29uY2F0KGgpfTtkKHYpO3ZhciBfPXtBcnJheTpbXCJpc0FycmF5XCJdLE1hdGg6W1wiYWJzXCIsXCJhY29zXCIsXCJhc2luXCIsXCJhdGFuXCIsXCJjZWlsXCIsXCJjb3NcIixcImV4cFwiLFwiZmxvb3JcIixcImxvZ1wiLFwicm91bmRcIixcInNpblwiLFwic3FydFwiLFwidGFuXCIsXCJhdGFuMlwiLFwicG93XCIsXCJtYXhcIixcIm1pblwiXSxOdW1iZXI6W1wiaXNGaW5pdGVcIixcImlzTmFOXCJdLE9iamVjdDpbXCJjcmVhdGVcIixcImdldE93blByb3BlcnR5RGVzY3JpcHRvclwiLFwiZ2V0T3duUHJvcGVydHlOYW1lc1wiLFwiZ2V0UHJvdG90eXBlT2ZcIixcImlzRXh0ZW5zaWJsZVwiLFwiaXNGcm96ZW5cIixcImlzU2VhbGVkXCIsXCJrZXlzXCJdLFN0cmluZzpbXCJmcm9tQ2hhckNvZGVcIl19O2QoXyksZnVuY3Rpb24oZSl7c2UuREVGTUVUSE9EKFwiZXZhbHVhdGVcIixmdW5jdGlvbihlKXtpZighZS5vcHRpb24oXCJldmFsdWF0ZVwiKSlyZXR1cm4gdGhpczt2YXIgbj1bXSx0PXRoaXMuX2V2YWwoZSxuLDEpO3JldHVybiBuLmZvckVhY2goZnVuY3Rpb24oZSl7ZGVsZXRlIGUuX2V2YWx9KSwhdHx8dCBpbnN0YW5jZW9mIFJlZ0V4cD90OlwiZnVuY3Rpb25cIj09dHlwZW9mIHR8fFwib2JqZWN0XCI9PXR5cGVvZiB0P3RoaXM6dH0pO3ZhciBuPVcoXCIhIH4gLSArIHZvaWRcIik7c2UuREVGTUVUSE9EKFwiaXNfY29uc3RhbnRcIixmdW5jdGlvbigpe3JldHVybiB0aGlzIGluc3RhbmNlb2YgZ24/ISh0aGlzIGluc3RhbmNlb2Ygd24pOnRoaXMgaW5zdGFuY2VvZiBRZSYmdGhpcy5leHByZXNzaW9uIGluc3RhbmNlb2YgZ24mJm4odGhpcy5vcGVyYXRvcil9KSxlKHVlLGZ1bmN0aW9uKCl7dGhyb3cgbmV3IEVycm9yKFMoXCJDYW5ub3QgZXZhbHVhdGUgYSBzdGF0ZW1lbnQgW3tmaWxlfTp7bGluZX0se2NvbH1dXCIsdGhpcy5zdGFydCkpfSksZShrZSxDKSxlKHNlLEMpLGUoZ24sZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXRWYWx1ZSgpfSksZShGZSxmdW5jdGlvbihlKXtpZihlLm9wdGlvbihcInVuc2FmZVwiKSl7dmFyIG49ZnVuY3Rpb24oKXt9O3JldHVybiBuLm5vZGU9dGhpcyxuLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuXCJmdW5jdGlvbigpe31cIn0sbn1yZXR1cm4gdGhpc30pLGUob24sZnVuY3Rpb24oZSxuLHQpe2lmKGUub3B0aW9uKFwidW5zYWZlXCIpKXtmb3IodmFyIGk9W10scj0wLG89dGhpcy5lbGVtZW50cy5sZW5ndGg7cjxvO3IrKyl7dmFyIGE9dGhpcy5lbGVtZW50c1tyXSxzPWEuX2V2YWwoZSxuLHQpO2lmKGE9PT1zKXJldHVybiB0aGlzO2kucHVzaChzKX1yZXR1cm4gaX1yZXR1cm4gdGhpc30pLGUoYW4sZnVuY3Rpb24oZSxuLHQpe2lmKGUub3B0aW9uKFwidW5zYWZlXCIpKXtmb3IodmFyIGk9e30scj0wLG89dGhpcy5wcm9wZXJ0aWVzLmxlbmd0aDtyPG87cisrKXt2YXIgYT10aGlzLnByb3BlcnRpZXNbcl0scz1hLmtleTtpZihzIGluc3RhbmNlb2YgY24pcz1zLm5hbWU7ZWxzZSBpZihzIGluc3RhbmNlb2Ygc2UmJihzPXMuX2V2YWwoZSxuLHQpKT09PWEua2V5KXJldHVybiB0aGlzO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIE9iamVjdC5wcm90b3R5cGVbc10pcmV0dXJuIHRoaXM7aWYoIShhLnZhbHVlIGluc3RhbmNlb2YgRmUpJiYoaVtzXT1hLnZhbHVlLl9ldmFsKGUsbix0KSxpW3NdPT09YS52YWx1ZSkpcmV0dXJuIHRoaXN9cmV0dXJuIGl9cmV0dXJuIHRoaXN9KTt2YXIgcj1XKFwiISB0eXBlb2Ygdm9pZFwiKTtlKFFlLGZ1bmN0aW9uKGUsbix0KXt2YXIgaT10aGlzLmV4cHJlc3Npb247aWYoZS5vcHRpb24oXCJ0eXBlb2ZzXCIpJiZcInR5cGVvZlwiPT10aGlzLm9wZXJhdG9yJiYoaSBpbnN0YW5jZW9mIGtlfHxpIGluc3RhbmNlb2YgX24mJmkuZml4ZWRfdmFsdWUoKWluc3RhbmNlb2Yga2UpKXJldHVyblwiZnVuY3Rpb25cIjtpZihyKHRoaXMub3BlcmF0b3IpfHx0KyssKGk9aS5fZXZhbChlLG4sdCkpPT09dGhpcy5leHByZXNzaW9uKXJldHVybiB0aGlzO3N3aXRjaCh0aGlzLm9wZXJhdG9yKXtjYXNlXCIhXCI6cmV0dXJuIWk7Y2FzZVwidHlwZW9mXCI6cmV0dXJuIGkgaW5zdGFuY2VvZiBSZWdFeHA/dGhpczp0eXBlb2YgaTtjYXNlXCJ2b2lkXCI6cmV0dXJuO2Nhc2VcIn5cIjpyZXR1cm5+aTtjYXNlXCItXCI6cmV0dXJuLWk7Y2FzZVwiK1wiOnJldHVybitpfXJldHVybiB0aGlzfSk7dmFyIGE9VyhcIiYmIHx8ID09PSAhPT1cIik7ZShubixmdW5jdGlvbihlLG4sdCl7YSh0aGlzLm9wZXJhdG9yKXx8dCsrO3ZhciBpPXRoaXMubGVmdC5fZXZhbChlLG4sdCk7aWYoaT09PXRoaXMubGVmdClyZXR1cm4gdGhpczt2YXIgcixvPXRoaXMucmlnaHQuX2V2YWwoZSxuLHQpO2lmKG89PT10aGlzLnJpZ2h0KXJldHVybiB0aGlzO3N3aXRjaCh0aGlzLm9wZXJhdG9yKXtjYXNlXCImJlwiOnI9aSYmbzticmVhaztjYXNlXCJ8fFwiOnI9aXx8bzticmVhaztjYXNlXCJ8XCI6cj1pfG87YnJlYWs7Y2FzZVwiJlwiOnI9aSZvO2JyZWFrO2Nhc2VcIl5cIjpyPWlebzticmVhaztjYXNlXCIrXCI6cj1pK287YnJlYWs7Y2FzZVwiKlwiOnI9aSpvO2JyZWFrO2Nhc2VcIi9cIjpyPWkvbzticmVhaztjYXNlXCIlXCI6cj1pJW87YnJlYWs7Y2FzZVwiLVwiOnI9aS1vO2JyZWFrO2Nhc2VcIjw8XCI6cj1pPDxvO2JyZWFrO2Nhc2VcIj4+XCI6cj1pPj5vO2JyZWFrO2Nhc2VcIj4+PlwiOnI9aT4+Pm87YnJlYWs7Y2FzZVwiPT1cIjpyPWk9PW87YnJlYWs7Y2FzZVwiPT09XCI6cj1pPT09bzticmVhaztjYXNlXCIhPVwiOnI9aSE9bzticmVhaztjYXNlXCIhPT1cIjpyPWkhPT1vO2JyZWFrO2Nhc2VcIjxcIjpyPWk8bzticmVhaztjYXNlXCI8PVwiOnI9aTw9bzticmVhaztjYXNlXCI+XCI6cj1vPGk7YnJlYWs7Y2FzZVwiPj1cIjpyPW88PWk7YnJlYWs7ZGVmYXVsdDpyZXR1cm4gdGhpc31yZXR1cm4gaXNOYU4ocikmJmUuZmluZF9wYXJlbnQoeGUpP3RoaXM6cn0pLGUodG4sZnVuY3Rpb24oZSxuLHQpe3ZhciBpPXRoaXMuY29uZGl0aW9uLl9ldmFsKGUsbix0KTtpZihpPT09dGhpcy5jb25kaXRpb24pcmV0dXJuIHRoaXM7dmFyIHI9aT90aGlzLmNvbnNlcXVlbnQ6dGhpcy5hbHRlcm5hdGl2ZSxvPXIuX2V2YWwoZSxuLHQpO3JldHVybiBvPT09cj90aGlzOm99KSxlKF9uLGZ1bmN0aW9uKGUsbix0KXt2YXIgaSxyPXRoaXMuZml4ZWRfdmFsdWUoKTtpZighcilyZXR1cm4gdGhpcztpZigwPD1uLmluZGV4T2YocikpaT1yLl9ldmFsKCk7ZWxzZXtpZih0aGlzLl9ldmFsPUMsaT1yLl9ldmFsKGUsbix0KSxkZWxldGUgdGhpcy5fZXZhbCxpPT09cilyZXR1cm4gdGhpcztyLl9ldmFsPWZ1bmN0aW9uKCl7cmV0dXJuIGl9LG4ucHVzaChyKX1pZihpJiZcIm9iamVjdFwiPT10eXBlb2YgaSl7dmFyIG89dGhpcy5kZWZpbml0aW9uKCkuZXNjYXBlZDtpZihvJiZvPHQpcmV0dXJuIHRoaXN9cmV0dXJuIGl9KTt2YXIgcD17QXJyYXk6QXJyYXksTWF0aDpNYXRoLE51bWJlcjpOdW1iZXIsT2JqZWN0Ok9iamVjdCxTdHJpbmc6U3RyaW5nfSxzPXtNYXRoOltcIkVcIixcIkxOMTBcIixcIkxOMlwiLFwiTE9HMkVcIixcIkxPRzEwRVwiLFwiUElcIixcIlNRUlQxXzJcIixcIlNRUlQyXCJdLE51bWJlcjpbXCJNQVhfVkFMVUVcIixcIk1JTl9WQUxVRVwiLFwiTmFOXCIsXCJORUdBVElWRV9JTkZJTklUWVwiLFwiUE9TSVRJVkVfSU5GSU5JVFlcIl19O2QocyksZShHZSxmdW5jdGlvbihlLG4sdCl7aWYoZS5vcHRpb24oXCJ1bnNhZmVcIikpe3ZhciBpPXRoaXMucHJvcGVydHk7aWYoaSBpbnN0YW5jZW9mIHNlJiYoaT1pLl9ldmFsKGUsbix0KSk9PT10aGlzLnByb3BlcnR5KXJldHVybiB0aGlzO3ZhciByLG89dGhpcy5leHByZXNzaW9uO2lmKEgobykpe2lmKCEoc1tvLm5hbWVdfHxpZSkoaSkpcmV0dXJuIHRoaXM7cj1wW28ubmFtZV19ZWxzZXtpZighKHI9by5fZXZhbChlLG4sdCsxKSl8fHI9PT1vfHwhYWUocixpKSlyZXR1cm4gdGhpcztpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiByKXN3aXRjaChpKXtjYXNlXCJuYW1lXCI6cmV0dXJuIHIubm9kZS5uYW1lP3Iubm9kZS5uYW1lLm5hbWU6XCJcIjtjYXNlXCJsZW5ndGhcIjpyZXR1cm4gci5ub2RlLmFyZ25hbWVzLmxlbmd0aDtkZWZhdWx0OnJldHVybiB0aGlzfX1yZXR1cm4gcltpXX1yZXR1cm4gdGhpc30pLGUoWWUsZnVuY3Rpb24obixlLHQpe3ZhciBpPXRoaXMuZXhwcmVzc2lvbjtpZihuLm9wdGlvbihcInVuc2FmZVwiKSYmaSBpbnN0YW5jZW9mIEdlKXt2YXIgcixvPWkucHJvcGVydHk7aWYobyBpbnN0YW5jZW9mIHNlJiYobz1vLl9ldmFsKG4sZSx0KSk9PT1pLnByb3BlcnR5KXJldHVybiB0aGlzO3ZhciBhPWkuZXhwcmVzc2lvbjtpZihIKGEpKXtpZighKF9bYS5uYW1lXXx8aWUpKG8pKXJldHVybiB0aGlzO3I9cFthLm5hbWVdfWVsc2UgaWYoKHI9YS5fZXZhbChuLGUsdCsxKSk9PT1hfHwhKHImJnZbci5jb25zdHJ1Y3Rvci5uYW1lXXx8aWUpKG8pKXJldHVybiB0aGlzO2Zvcih2YXIgcz1bXSx1PTAsYz10aGlzLmFyZ3MubGVuZ3RoO3U8Yzt1Kyspe3ZhciBmPXRoaXMuYXJnc1t1XSxsPWYuX2V2YWwobixlLHQpO2lmKGY9PT1sKXJldHVybiB0aGlzO3MucHVzaChsKX10cnl7cmV0dXJuIHJbb10uYXBwbHkocixzKX1jYXRjaChlKXtuLndhcm4oXCJFcnJvciBldmFsdWF0aW5nIHtjb2RlfSBbe2ZpbGV9OntsaW5lfSx7Y29sfV1cIix7Y29kZTp0aGlzLnByaW50X3RvX3N0cmluZygpLGZpbGU6dGhpcy5zdGFydC5maWxlLGxpbmU6dGhpcy5zdGFydC5saW5lLGNvbDp0aGlzLnN0YXJ0LmNvbH0pfX1yZXR1cm4gdGhpc30pLGUoSmUsQyl9KGZ1bmN0aW9uKGUsbil7ZS5ERUZNRVRIT0QoXCJfZXZhbFwiLG4pfSksZnVuY3Rpb24oZSl7ZnVuY3Rpb24gbyhlKXtyZXR1cm4gWChRZSxlLHtvcGVyYXRvcjpcIiFcIixleHByZXNzaW9uOmV9KX1mdW5jdGlvbiByKGUsbix0KXt2YXIgaT1vKGUpO2lmKHQpe3ZhciByPVgobGUsbix7Ym9keTpufSk7cmV0dXJuIHgoaSxyKT09PXI/bjppfXJldHVybiB4KGksbil9ZShzZSxmdW5jdGlvbigpe3JldHVybiBvKHRoaXMpfSksZSh1ZSxmdW5jdGlvbigpe3Rocm93IG5ldyBFcnJvcihcIkNhbm5vdCBuZWdhdGUgYSBzdGF0ZW1lbnRcIil9KSxlKEZlLGZ1bmN0aW9uKCl7cmV0dXJuIG8odGhpcyl9KSxlKFFlLGZ1bmN0aW9uKCl7cmV0dXJuXCIhXCI9PXRoaXMub3BlcmF0b3I/dGhpcy5leHByZXNzaW9uOm8odGhpcyl9KSxlKFdlLGZ1bmN0aW9uKGUpe3ZhciBuPXRoaXMuZXhwcmVzc2lvbnMuc2xpY2UoKTtyZXR1cm4gbi5wdXNoKG4ucG9wKCkubmVnYXRlKGUpKSxNKHRoaXMsbil9KSxlKHRuLGZ1bmN0aW9uKGUsbil7dmFyIHQ9dGhpcy5jbG9uZSgpO3JldHVybiB0LmNvbnNlcXVlbnQ9dC5jb25zZXF1ZW50Lm5lZ2F0ZShlKSx0LmFsdGVybmF0aXZlPXQuYWx0ZXJuYXRpdmUubmVnYXRlKGUpLHIodGhpcyx0LG4pfSksZShubixmdW5jdGlvbihlLG4pe3ZhciB0PXRoaXMuY2xvbmUoKSxpPXRoaXMub3BlcmF0b3I7aWYoZS5vcHRpb24oXCJ1bnNhZmVfY29tcHNcIikpc3dpdGNoKGkpe2Nhc2VcIjw9XCI6cmV0dXJuIHQub3BlcmF0b3I9XCI+XCIsdDtjYXNlXCI8XCI6cmV0dXJuIHQub3BlcmF0b3I9XCI+PVwiLHQ7Y2FzZVwiPj1cIjpyZXR1cm4gdC5vcGVyYXRvcj1cIjxcIix0O2Nhc2VcIj5cIjpyZXR1cm4gdC5vcGVyYXRvcj1cIjw9XCIsdH1zd2l0Y2goaSl7Y2FzZVwiPT1cIjpyZXR1cm4gdC5vcGVyYXRvcj1cIiE9XCIsdDtjYXNlXCIhPVwiOnJldHVybiB0Lm9wZXJhdG9yPVwiPT1cIix0O2Nhc2VcIj09PVwiOnJldHVybiB0Lm9wZXJhdG9yPVwiIT09XCIsdDtjYXNlXCIhPT1cIjpyZXR1cm4gdC5vcGVyYXRvcj1cIj09PVwiLHQ7Y2FzZVwiJiZcIjpyZXR1cm4gdC5vcGVyYXRvcj1cInx8XCIsdC5sZWZ0PXQubGVmdC5uZWdhdGUoZSxuKSx0LnJpZ2h0PXQucmlnaHQubmVnYXRlKGUpLHIodGhpcyx0LG4pO2Nhc2VcInx8XCI6cmV0dXJuIHQub3BlcmF0b3I9XCImJlwiLHQubGVmdD10LmxlZnQubmVnYXRlKGUsbiksdC5yaWdodD10LnJpZ2h0Lm5lZ2F0ZShlKSxyKHRoaXMsdCxuKX1yZXR1cm4gbyh0aGlzKX0pfShmdW5jdGlvbihlLHQpe2UuREVGTUVUSE9EKFwibmVnYXRlXCIsZnVuY3Rpb24oZSxuKXtyZXR1cm4gdC5jYWxsKHRoaXMsZSxuKX0pfSk7dmFyIG09VyhcIkJvb2xlYW4gZGVjb2RlVVJJIGRlY29kZVVSSUNvbXBvbmVudCBEYXRlIGVuY29kZVVSSSBlbmNvZGVVUklDb21wb25lbnQgRXJyb3IgZXNjYXBlIEV2YWxFcnJvciBpc0Zpbml0ZSBpc05hTiBOdW1iZXIgT2JqZWN0IHBhcnNlRmxvYXQgcGFyc2VJbnQgUmFuZ2VFcnJvciBSZWZlcmVuY2VFcnJvciBTdHJpbmcgU3ludGF4RXJyb3IgVHlwZUVycm9yIHVuZXNjYXBlIFVSSUVycm9yXCIpO2Z1bmN0aW9uIEEoZSl7cmV0dXJuIGUmJmUuYWJvcnRzKCl9WWUuREVGTUVUSE9EKFwiaXNfZXhwcl9wdXJlXCIsZnVuY3Rpb24oZSl7aWYoZS5vcHRpb24oXCJ1bnNhZmVcIikpe3ZhciBuPXRoaXMuZXhwcmVzc2lvbjtpZihIKG4pJiZtKG4ubmFtZSkpcmV0dXJuITA7aWYobiBpbnN0YW5jZW9mIFhlJiZIKG4uZXhwcmVzc2lvbikmJihfW24uZXhwcmVzc2lvbi5uYW1lXXx8aWUpKG4ucHJvcGVydHkpKXJldHVybiEwfXJldHVybiB0aGlzLnB1cmV8fCFlLnB1cmVfZnVuY3ModGhpcyl9KSxzZS5ERUZNRVRIT0QoXCJpc19jYWxsX3B1cmVcIixpZSksWGUuREVGTUVUSE9EKFwiaXNfY2FsbF9wdXJlXCIsZnVuY3Rpb24oZSl7aWYoZS5vcHRpb24oXCJ1bnNhZmVcIikpe3ZhciBuPXRoaXMuZXhwcmVzc2lvbix0PWllO3JldHVybiBuIGluc3RhbmNlb2Ygb24/dD12LkFycmF5Om4uaXNfYm9vbGVhbigpP3Q9di5Cb29sZWFuOm4uaXNfbnVtYmVyKGUpP3Q9di5OdW1iZXI6biBpbnN0YW5jZW9mIHduP3Q9di5SZWdFeHA6bi5pc19zdHJpbmcoZSk/dD12LlN0cmluZzp0aGlzLm1heV90aHJvd19vbl9hY2Nlc3MoZSl8fCh0PXYuT2JqZWN0KSx0KHRoaXMucHJvcGVydHkpfX0pLGZ1bmN0aW9uKGUpe2Z1bmN0aW9uIG4oZSxuKXtmb3IodmFyIHQ9ZS5sZW5ndGg7MDw9LS10OylpZihlW3RdLmhhc19zaWRlX2VmZmVjdHMobikpcmV0dXJuITA7cmV0dXJuITF9ZShzZSxKKSxlKGhlLGllKSxlKGduLGllKSxlKG1uLGllKSxlKHBlLGZ1bmN0aW9uKGUpe3JldHVybiBuKHRoaXMuYm9keSxlKX0pLGUoWWUsZnVuY3Rpb24oZSl7cmV0dXJuISh0aGlzLmlzX2V4cHJfcHVyZShlKXx8dGhpcy5leHByZXNzaW9uLmlzX2NhbGxfcHVyZShlKSYmIXRoaXMuZXhwcmVzc2lvbi5oYXNfc2lkZV9lZmZlY3RzKGUpKXx8bih0aGlzLmFyZ3MsZSl9KSxlKHFlLGZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmV4cHJlc3Npb24uaGFzX3NpZGVfZWZmZWN0cyhlKXx8bih0aGlzLmJvZHksZSl9KSxlKEhlLGZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmV4cHJlc3Npb24uaGFzX3NpZGVfZWZmZWN0cyhlKXx8bih0aGlzLmJvZHksZSl9KSxlKFJlLGZ1bmN0aW9uKGUpe3JldHVybiBuKHRoaXMuYm9keSxlKXx8dGhpcy5iY2F0Y2gmJnRoaXMuYmNhdGNoLmhhc19zaWRlX2VmZmVjdHMoZSl8fHRoaXMuYmZpbmFsbHkmJnRoaXMuYmZpbmFsbHkuaGFzX3NpZGVfZWZmZWN0cyhlKX0pLGUoTWUsZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuY29uZGl0aW9uLmhhc19zaWRlX2VmZmVjdHMoZSl8fHRoaXMuYm9keSYmdGhpcy5ib2R5Lmhhc19zaWRlX2VmZmVjdHMoZSl8fHRoaXMuYWx0ZXJuYXRpdmUmJnRoaXMuYWx0ZXJuYXRpdmUuaGFzX3NpZGVfZWZmZWN0cyhlKX0pLGUodmUsZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuYm9keS5oYXNfc2lkZV9lZmZlY3RzKGUpfSksZShsZSxmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5ib2R5Lmhhc19zaWRlX2VmZmVjdHMoZSl9KSxlKGtlLGllKSxlKG5uLGZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmxlZnQuaGFzX3NpZGVfZWZmZWN0cyhlKXx8dGhpcy5yaWdodC5oYXNfc2lkZV9lZmZlY3RzKGUpfSksZShybixKKSxlKHRuLGZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmNvbmRpdGlvbi5oYXNfc2lkZV9lZmZlY3RzKGUpfHx0aGlzLmNvbnNlcXVlbnQuaGFzX3NpZGVfZWZmZWN0cyhlKXx8dGhpcy5hbHRlcm5hdGl2ZS5oYXNfc2lkZV9lZmZlY3RzKGUpfSksZShLZSxmdW5jdGlvbihlKXtyZXR1cm4gZih0aGlzLm9wZXJhdG9yKXx8dGhpcy5leHByZXNzaW9uLmhhc19zaWRlX2VmZmVjdHMoZSl9KSxlKF9uLGZ1bmN0aW9uKGUpe3JldHVybiF0aGlzLmlzX2RlY2xhcmVkKGUpfSksZShmbixpZSksZShhbixmdW5jdGlvbihlKXtyZXR1cm4gbih0aGlzLnByb3BlcnRpZXMsZSl9KSxlKHNuLGZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnZhbHVlLmhhc19zaWRlX2VmZmVjdHMoZSl9KSxlKG9uLGZ1bmN0aW9uKGUpe3JldHVybiBuKHRoaXMuZWxlbWVudHMsZSl9KSxlKFhlLGZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmV4cHJlc3Npb24ubWF5X3Rocm93X29uX2FjY2VzcyhlKXx8dGhpcy5leHByZXNzaW9uLmhhc19zaWRlX2VmZmVjdHMoZSl9KSxlKFplLGZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmV4cHJlc3Npb24ubWF5X3Rocm93X29uX2FjY2VzcyhlKXx8dGhpcy5leHByZXNzaW9uLmhhc19zaWRlX2VmZmVjdHMoZSl8fHRoaXMucHJvcGVydHkuaGFzX3NpZGVfZWZmZWN0cyhlKX0pLGUoV2UsZnVuY3Rpb24oZSl7cmV0dXJuIG4odGhpcy5leHByZXNzaW9ucyxlKX0pLGUoVWUsZnVuY3Rpb24oZSl7cmV0dXJuIG4odGhpcy5kZWZpbml0aW9ucyxlKX0pLGUoVmUsZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMudmFsdWV9KX0oZnVuY3Rpb24oZSxuKXtlLkRFRk1FVEhPRChcImhhc19zaWRlX2VmZmVjdHNcIixuKX0pLGZ1bmN0aW9uKGUpe2Z1bmN0aW9uIG4oZSxuKXtmb3IodmFyIHQ9ZS5sZW5ndGg7MDw9LS10OylpZihlW3RdLm1heV90aHJvdyhuKSlyZXR1cm4hMDtyZXR1cm4hMX1lKHNlLEopLGUoZ24saWUpLGUoaGUsaWUpLGUoa2UsaWUpLGUoZm4saWUpLGUobW4saWUpLGUob24sZnVuY3Rpb24oZSl7cmV0dXJuIG4odGhpcy5lbGVtZW50cyxlKX0pLGUocm4sZnVuY3Rpb24oZSl7cmV0dXJuISF0aGlzLnJpZ2h0Lm1heV90aHJvdyhlKXx8ISghZS5oYXNfZGlyZWN0aXZlKFwidXNlIHN0cmljdFwiKSYmXCI9XCI9PXRoaXMub3BlcmF0b3ImJnRoaXMubGVmdCBpbnN0YW5jZW9mIF9uKSYmdGhpcy5sZWZ0Lm1heV90aHJvdyhlKX0pLGUobm4sZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMubGVmdC5tYXlfdGhyb3coZSl8fHRoaXMucmlnaHQubWF5X3Rocm93KGUpfSksZShwZSxmdW5jdGlvbihlKXtyZXR1cm4gbih0aGlzLmJvZHksZSl9KSxlKFllLGZ1bmN0aW9uKGUpe3JldHVybiEhbih0aGlzLmFyZ3MsZSl8fCF0aGlzLmlzX2V4cHJfcHVyZShlKSYmKCEhdGhpcy5leHByZXNzaW9uLm1heV90aHJvdyhlKXx8KCEodGhpcy5leHByZXNzaW9uIGluc3RhbmNlb2Yga2UpfHxuKHRoaXMuZXhwcmVzc2lvbi5ib2R5LGUpKSl9KSxlKEhlLGZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmV4cHJlc3Npb24ubWF5X3Rocm93KGUpfHxuKHRoaXMuYm9keSxlKX0pLGUodG4sZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuY29uZGl0aW9uLm1heV90aHJvdyhlKXx8dGhpcy5jb25zZXF1ZW50Lm1heV90aHJvdyhlKXx8dGhpcy5hbHRlcm5hdGl2ZS5tYXlfdGhyb3coZSl9KSxlKFVlLGZ1bmN0aW9uKGUpe3JldHVybiBuKHRoaXMuZGVmaW5pdGlvbnMsZSl9KSxlKFhlLGZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmV4cHJlc3Npb24ubWF5X3Rocm93X29uX2FjY2VzcyhlKXx8dGhpcy5leHByZXNzaW9uLm1heV90aHJvdyhlKX0pLGUoTWUsZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuY29uZGl0aW9uLm1heV90aHJvdyhlKXx8dGhpcy5ib2R5JiZ0aGlzLmJvZHkubWF5X3Rocm93KGUpfHx0aGlzLmFsdGVybmF0aXZlJiZ0aGlzLmFsdGVybmF0aXZlLm1heV90aHJvdyhlKX0pLGUodmUsZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuYm9keS5tYXlfdGhyb3coZSl9KSxlKGFuLGZ1bmN0aW9uKGUpe3JldHVybiBuKHRoaXMucHJvcGVydGllcyxlKX0pLGUoc24sZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMudmFsdWUubWF5X3Rocm93KGUpfSksZShUZSxmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy52YWx1ZSYmdGhpcy52YWx1ZS5tYXlfdGhyb3coZSl9KSxlKFdlLGZ1bmN0aW9uKGUpe3JldHVybiBuKHRoaXMuZXhwcmVzc2lvbnMsZSl9KSxlKGxlLGZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmJvZHkubWF5X3Rocm93KGUpfSksZShaZSxmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5leHByZXNzaW9uLm1heV90aHJvd19vbl9hY2Nlc3MoZSl8fHRoaXMuZXhwcmVzc2lvbi5tYXlfdGhyb3coZSl8fHRoaXMucHJvcGVydHkubWF5X3Rocm93KGUpfSksZShxZSxmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5leHByZXNzaW9uLm1heV90aHJvdyhlKXx8bih0aGlzLmJvZHksZSl9KSxlKF9uLGZ1bmN0aW9uKGUpe3JldHVybiF0aGlzLmlzX2RlY2xhcmVkKGUpfSksZShSZSxmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5iY2F0Y2g/dGhpcy5iY2F0Y2gubWF5X3Rocm93KGUpOm4odGhpcy5ib2R5LGUpfHx0aGlzLmJmaW5hbGx5JiZ0aGlzLmJmaW5hbGx5Lm1heV90aHJvdyhlKX0pLGUoS2UsZnVuY3Rpb24oZSl7cmV0dXJuIShcInR5cGVvZlwiPT10aGlzLm9wZXJhdG9yJiZ0aGlzLmV4cHJlc3Npb24gaW5zdGFuY2VvZiBfbikmJnRoaXMuZXhwcmVzc2lvbi5tYXlfdGhyb3coZSl9KSxlKFZlLGZ1bmN0aW9uKGUpe3JldHVybiEhdGhpcy52YWx1ZSYmdGhpcy52YWx1ZS5tYXlfdGhyb3coZSl9KX0oZnVuY3Rpb24oZSxuKXtlLkRFRk1FVEhPRChcIm1heV90aHJvd1wiLG4pfSksZnVuY3Rpb24oZSl7ZnVuY3Rpb24gbihlKXtmb3IodmFyIG49ZS5sZW5ndGg7MDw9LS1uOylpZighZVtuXS5pc19jb25zdGFudF9leHByZXNzaW9uKCkpcmV0dXJuITE7cmV0dXJuITB9ZShzZSxpZSksZShnbixKKSxlKGtlLGZ1bmN0aW9uKGkpe3ZhciByPXRoaXMsbz0hMDtyZXR1cm4gci53YWxrKG5ldyBTbihmdW5jdGlvbihlKXtpZighbylyZXR1cm4hMDtpZihlIGluc3RhbmNlb2YgX24pe2lmKHIuaW5saW5lZClyZXR1cm4hKG89ITEpO3ZhciBuPWUuZGVmaW5pdGlvbigpO2lmKHRlKG4sci5lbmNsb3NlZCkmJiFyLnZhcmlhYmxlcy5oYXMobi5uYW1lKSl7aWYoaSl7dmFyIHQ9aS5maW5kX3ZhcmlhYmxlKGUpO2lmKG4udW5kZWNsYXJlZD8hdDp0PT09bilyZXR1cm4gbz1cImZcIiwhMH1vPSExfXJldHVybiEwfX0pKSxvfSksZShLZSxmdW5jdGlvbigpe3JldHVybiB0aGlzLmV4cHJlc3Npb24uaXNfY29uc3RhbnRfZXhwcmVzc2lvbigpfSksZShubixmdW5jdGlvbigpe3JldHVybiB0aGlzLmxlZnQuaXNfY29uc3RhbnRfZXhwcmVzc2lvbigpJiZ0aGlzLnJpZ2h0LmlzX2NvbnN0YW50X2V4cHJlc3Npb24oKX0pLGUob24sZnVuY3Rpb24oKXtyZXR1cm4gbih0aGlzLmVsZW1lbnRzKX0pLGUoYW4sZnVuY3Rpb24oKXtyZXR1cm4gbih0aGlzLnByb3BlcnRpZXMpfSksZShzbixmdW5jdGlvbigpe3JldHVybiB0aGlzLnZhbHVlLmlzX2NvbnN0YW50X2V4cHJlc3Npb24oKX0pfShmdW5jdGlvbihlLG4pe2UuREVGTUVUSE9EKFwiaXNfY29uc3RhbnRfZXhwcmVzc2lvblwiLG4pfSksZnVuY3Rpb24oZSl7ZnVuY3Rpb24gbigpe3ZhciBlPXRoaXMuYm9keS5sZW5ndGg7cmV0dXJuIDA8ZSYmQSh0aGlzLmJvZHlbZS0xXSl9ZSh1ZSxCKSxlKEJlLEMpLGUoZGUsbiksZShqZSxuKSxlKE1lLGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYWx0ZXJuYXRpdmUmJkEodGhpcy5ib2R5KSYmQSh0aGlzLmFsdGVybmF0aXZlKSYmdGhpc30pfShmdW5jdGlvbihlLG4pe2UuREVGTUVUSE9EKFwiYWJvcnRzXCIsbil9KSxlKGZlLGZ1bmN0aW9uKGUsbil7cmV0dXJuIG4uaGFzX2RpcmVjdGl2ZShlLnZhbHVlKSE9PWU/WChoZSxlKTplfSksZShjZSxmdW5jdGlvbihlLG4pe3JldHVybiBuLm9wdGlvbihcImRyb3BfZGVidWdnZXJcIik/WChoZSxlKTplfSksZSh2ZSxmdW5jdGlvbihlLG4pe3JldHVybiBlLmJvZHkgaW5zdGFuY2VvZiAkZSYmbi5sb29wY29udHJvbF90YXJnZXQoZS5ib2R5KT09PWUuYm9keT9YKGhlLGUpOjA9PWUubGFiZWwucmVmZXJlbmNlcy5sZW5ndGg/ZS5ib2R5OmV9KSxlKHBlLGZ1bmN0aW9uKGUsbil7cmV0dXJuIHUoZS5ib2R5LG4pLGV9KSxlKGRlLGZ1bmN0aW9uKGUsbil7c3dpdGNoKHUoZS5ib2R5LG4pLGUuYm9keS5sZW5ndGgpe2Nhc2UgMTpyZXR1cm4gZS5ib2R5WzBdO2Nhc2UgMDpyZXR1cm4gWChoZSxlKX1yZXR1cm4gZX0pLGUoa2UsZnVuY3Rpb24oZSxuKXtyZXR1cm4gdShlLmJvZHksbiksbi5vcHRpb24oXCJzaWRlX2VmZmVjdHNcIikmJjE9PWUuYm9keS5sZW5ndGgmJmUuYm9keVswXT09PW4uaGFzX2RpcmVjdGl2ZShcInVzZSBzdHJpY3RcIikmJihlLmJvZHkubGVuZ3RoPTApLGV9KSxBZS5ERUZNRVRIT0QoXCJkcm9wX3VudXNlZFwiLGZ1bmN0aW9uKGIpe2lmKGIub3B0aW9uKFwidW51c2VkXCIpJiYhYi5oYXNfZGlyZWN0aXZlKFwidXNlIGFzbVwiKSl7dmFyIHk9dGhpcztpZigheS51c2VzX2V2YWwmJiF5LnVzZXNfd2l0aCl7dmFyIHc9ISh5IGluc3RhbmNlb2YgRWUpfHxiLnRvcGxldmVsLmZ1bmNzLHg9ISh5IGluc3RhbmNlb2YgRWUpfHxiLnRvcGxldmVsLnZhcnMsQT0va2VlcF9hc3NpZ24vLnRlc3QoYi5vcHRpb24oXCJ1bnVzZWRcIikpP2llOmZ1bmN0aW9uKGUsbil7dmFyIHQ7aWYoZSBpbnN0YW5jZW9mIHJuJiYoZS53cml0ZV9vbmx5fHxcIj1cIj09ZS5vcGVyYXRvcik/dD1lLmxlZnQ6ZSBpbnN0YW5jZW9mIEtlJiZlLndyaXRlX29ubHkmJih0PWUuZXhwcmVzc2lvbiksL3N0cmljdC8udGVzdChiLm9wdGlvbihcInB1cmVfZ2V0dGVyc1wiKSkpZm9yKDt0IGluc3RhbmNlb2YgR2UmJiF0LmV4cHJlc3Npb24ubWF5X3Rocm93X29uX2FjY2VzcyhiKTspdCBpbnN0YW5jZW9mIFplJiZuLnVuc2hpZnQodC5wcm9wZXJ0eSksdD10LmV4cHJlc3Npb247cmV0dXJuIHR9LHM9W10sRT1PYmplY3QuY3JlYXRlKG51bGwpLGs9T2JqZWN0LmNyZWF0ZShudWxsKSx1PU9iamVjdC5jcmVhdGUobnVsbCksYz1PYmplY3QuY3JlYXRlKG51bGwpO3kgaW5zdGFuY2VvZiBFZSYmYi50b3BfcmV0YWluJiZ5LnZhcmlhYmxlcy5lYWNoKGZ1bmN0aW9uKGUpeyFiLnRvcF9yZXRhaW4oZSl8fGUuaWQgaW4gRXx8KEVbZS5pZF09ITAscy5wdXNoKGUpKX0pO3ZhciBEPW5ldyBPLGk9bmV3IE8sRj10aGlzLGY9bmV3IFNuKGZ1bmN0aW9uKGUsbil7aWYoZSE9PXkpe2lmKGUgaW5zdGFuY2VvZiBDZSl7dmFyIHQ9ZS5uYW1lLmRlZmluaXRpb24oKTtyZXR1cm4gd3x8RiE9PXl8fHQuaWQgaW4gRXx8KEVbdC5pZF09ITAscy5wdXNoKHQpKSxpLmFkZCh0LmlkLGUpLCEwfXJldHVybiBlIGluc3RhbmNlb2YgcG4mJkY9PT15JiZELmFkZChlLmRlZmluaXRpb24oKS5pZCxlKSxlIGluc3RhbmNlb2YgVWUmJkY9PT15PyhlLmRlZmluaXRpb25zLmZvckVhY2goZnVuY3Rpb24oZSl7dmFyIG49ZS5uYW1lLmRlZmluaXRpb24oKTtlLm5hbWUgaW5zdGFuY2VvZiBsbiYmRC5hZGQobi5pZCxlKSx4fHxuLmlkIGluIEV8fChFW24uaWRdPSEwLHMucHVzaChuKSksZS52YWx1ZSYmKGkuYWRkKG4uaWQsZS52YWx1ZSksZS52YWx1ZS5oYXNfc2lkZV9lZmZlY3RzKGIpJiZlLnZhbHVlLndhbGsoZiksbi5jaGFpbmVkfHxlLm5hbWUuZml4ZWRfdmFsdWUoKSE9PWUudmFsdWV8fChrW24uaWRdPWUpKX0pLCEwKTpyKGUsbil9fSk7eS53YWxrKGYpLGY9bmV3IFNuKHIpO2Zvcih2YXIgZT0wO2U8cy5sZW5ndGg7ZSsrKXt2YXIgbj1pLmdldChzW2VdLmlkKTtuJiZuLmZvckVhY2goZnVuY3Rpb24oZSl7ZS53YWxrKGYpfSl9dmFyIEM9bmV3IFhuKGZ1bmN0aW9uKGEsZSxuKXt2YXIgdD1DLnBhcmVudCgpO2lmKHgpe3ZhciBpPVtdO2lmKChsPUEoYSxpKSlpbnN0YW5jZW9mIF9uKXt2YXIgcj0ocz1sLmRlZmluaXRpb24oKSkuaWQgaW4gRSxvPW51bGw7aWYoYSBpbnN0YW5jZW9mIHJuPyghcnx8YS5sZWZ0PT09bCYmcy5pZCBpbiBrJiZrW3MuaWRdIT09YSkmJihvPWEucmlnaHQpOnJ8fChvPVgoeW4sYSx7dmFsdWU6MH0pKSxvKXJldHVybiBpLnB1c2gobyksWih0LGEsTShhLGkubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlLnRyYW5zZm9ybShDKX0pKSl9fWlmKEY9PT15KXt2YXIgcztpZihhIGluc3RhbmNlb2YgRmUmJmEubmFtZSYmIWIub3B0aW9uKFwia2VlcF9mbmFtZXNcIikpKHM9YS5uYW1lLmRlZmluaXRpb24oKSkuaWQgaW4gRSYmISgxPHMub3JpZy5sZW5ndGgpfHwoYS5uYW1lPW51bGwpO2lmKGEgaW5zdGFuY2VvZiBrZSYmIShhIGluc3RhbmNlb2YgRGUpKWZvcih2YXIgdT0hYi5vcHRpb24oXCJrZWVwX2ZhcmdzXCIpLGM9YS5hcmduYW1lcyxmPWMubGVuZ3RoOzA8PS0tZjspe3ZhciBsOyhsPWNbZl0pLmRlZmluaXRpb24oKS5pZCBpbiBFP3U9ITE6KGwuX191bnVzZWQ9ITAsdSYmKGMucG9wKCksYltsLnVucmVmZXJlbmNlZCgpP1wid2FyblwiOlwiaW5mb1wiXShcIkRyb3BwaW5nIHVudXNlZCBmdW5jdGlvbiBhcmd1bWVudCB7bmFtZX0gW3tmaWxlfTp7bGluZX0se2NvbH1dXCIsZyhsKSkpKX1pZih3JiZhIGluc3RhbmNlb2YgQ2UmJmEhPT15KWlmKCEoKHM9YS5uYW1lLmRlZmluaXRpb24oKSkuaWQgaW4gRSkpcmV0dXJuIGJbYS5uYW1lLnVucmVmZXJlbmNlZCgpP1wid2FyblwiOlwiaW5mb1wiXShcIkRyb3BwaW5nIHVudXNlZCBmdW5jdGlvbiB7bmFtZX0gW3tmaWxlfTp7bGluZX0se2NvbH1dXCIsZyhhLm5hbWUpKSxzLmVsaW1pbmF0ZWQrKyxYKGhlLGEpO2lmKGEgaW5zdGFuY2VvZiBVZSYmISh0IGluc3RhbmNlb2Ygd2UmJnQuaW5pdD09PWEpKXt2YXIgcD1bXSxkPVtdLGg9W10sdj1bXTtzd2l0Y2goYS5kZWZpbml0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKGUpe2UudmFsdWUmJihlLnZhbHVlPWUudmFsdWUudHJhbnNmb3JtKEMpKTt2YXIgbj1lLm5hbWUuZGVmaW5pdGlvbigpO2lmKCF4fHxuLmlkIGluIEUpe2lmKGUudmFsdWUmJm4uaWQgaW4gayYma1tuLmlkXSE9PWUmJihlLnZhbHVlPWUudmFsdWUuZHJvcF9zaWRlX2VmZmVjdF9mcmVlKGIpKSxlLm5hbWUgaW5zdGFuY2VvZiBsbil7dmFyIHQ9RC5nZXQobi5pZCk7aWYoMTx0Lmxlbmd0aCYmKCFlLnZhbHVlfHxuLm9yaWcuaW5kZXhPZihlLm5hbWUpPm4uZWxpbWluYXRlZCkpe2lmKGIud2FybihcIkRyb3BwaW5nIGR1cGxpY2F0ZWQgZGVmaW5pdGlvbiBvZiB2YXJpYWJsZSB7bmFtZX0gW3tmaWxlfTp7bGluZX0se2NvbH1dXCIsZyhlLm5hbWUpKSxlLnZhbHVlKXt2YXIgaT1YKF9uLGUubmFtZSxlLm5hbWUpO24ucmVmZXJlbmNlcy5wdXNoKGkpO3ZhciByPVgocm4sZSx7b3BlcmF0b3I6XCI9XCIsbGVmdDppLHJpZ2h0OmUudmFsdWV9KTtrW24uaWRdPT09ZSYmKGtbbi5pZF09ciksdi5wdXNoKHIudHJhbnNmb3JtKEMpKX1yZXR1cm4gVCh0LGUpLHZvaWQgbi5lbGltaW5hdGVkKyt9fWUudmFsdWU/KDA8di5sZW5ndGgmJigwPGgubGVuZ3RoPyh2LnB1c2goZS52YWx1ZSksZS52YWx1ZT1NKGUudmFsdWUsdikpOnAucHVzaChYKGxlLGEse2JvZHk6TShhLHYpfSkpLHY9W10pLGgucHVzaChlKSk6ZC5wdXNoKGUpfWVsc2UgaWYobi5vcmlnWzBdaW5zdGFuY2VvZiB2bil7KG89ZS52YWx1ZSYmZS52YWx1ZS5kcm9wX3NpZGVfZWZmZWN0X2ZyZWUoYikpJiZ2LnB1c2gobyksZS52YWx1ZT1udWxsLGQucHVzaChlKX1lbHNle3ZhciBvOyhvPWUudmFsdWUmJmUudmFsdWUuZHJvcF9zaWRlX2VmZmVjdF9mcmVlKGIpKT8oYi53YXJuKFwiU2lkZSBlZmZlY3RzIGluIGluaXRpYWxpemF0aW9uIG9mIHVudXNlZCB2YXJpYWJsZSB7bmFtZX0gW3tmaWxlfTp7bGluZX0se2NvbH1dXCIsZyhlLm5hbWUpKSx2LnB1c2gobykpOmJbZS5uYW1lLnVucmVmZXJlbmNlZCgpP1wid2FyblwiOlwiaW5mb1wiXShcIkRyb3BwaW5nIHVudXNlZCB2YXJpYWJsZSB7bmFtZX0gW3tmaWxlfTp7bGluZX0se2NvbH1dXCIsZyhlLm5hbWUpKSxuLmVsaW1pbmF0ZWQrK319KSwoMDxkLmxlbmd0aHx8MDxoLmxlbmd0aCkmJihhLmRlZmluaXRpb25zPWQuY29uY2F0KGgpLHAucHVzaChhKSksMDx2Lmxlbmd0aCYmcC5wdXNoKFgobGUsYSx7Ym9keTpNKGEsdil9KSkscC5sZW5ndGgpe2Nhc2UgMDpyZXR1cm4gbj9yZS5za2lwOlgoaGUsYSk7Y2FzZSAxOnJldHVybiBwWzBdO2RlZmF1bHQ6cmV0dXJuIG4/cmUuc3BsaWNlKHApOlgoZGUsYSx7Ym9keTpwfSl9fWlmKGEgaW5zdGFuY2VvZiB5ZSlyZXR1cm4gZShhLHRoaXMpLGEuaW5pdCBpbnN0YW5jZW9mIGRlJiYoXz1hLmluaXQsYS5pbml0PV8uYm9keS5wb3AoKSxfLmJvZHkucHVzaChhKSksYS5pbml0IGluc3RhbmNlb2YgbGU/YS5pbml0PWEuaW5pdC5ib2R5OmooYS5pbml0KSYmKGEuaW5pdD1udWxsKSxfP24/cmUuc3BsaWNlKF8uYm9keSk6XzphO2lmKGEgaW5zdGFuY2VvZiB2ZSYmYS5ib2R5IGluc3RhbmNlb2YgeWUpe2lmKGUoYSx0aGlzKSxhLmJvZHkgaW5zdGFuY2VvZiBkZSl7dmFyIF89YS5ib2R5O3JldHVybiBhLmJvZHk9Xy5ib2R5LnBvcCgpLF8uYm9keS5wdXNoKGEpLG4/cmUuc3BsaWNlKF8uYm9keSk6X31yZXR1cm4gYX1pZihhIGluc3RhbmNlb2YgQWUpe3ZhciBtPUY7cmV0dXJuIGUoRj1hLHRoaXMpLEY9bSxhfX1mdW5jdGlvbiBnKGUpe3JldHVybntuYW1lOmUubmFtZSxmaWxlOmUuc3RhcnQuZmlsZSxsaW5lOmUuc3RhcnQubGluZSxjb2w6ZS5zdGFydC5jb2x9fX0pO3kudHJhbnNmb3JtKEMpfX1mdW5jdGlvbiBsKGUsbix0KXtlLmlkIGluIEV8fChuJiZ0PyhFW2UuaWRdPSEwLHMucHVzaChlKSk6KHVbZS5pZF09bixjW2UuaWRdPXQpKX1mdW5jdGlvbiByKGUsbil7dmFyIHQsaT1bXSxyPUEoZSxpKTtpZihyIGluc3RhbmNlb2YgX24mJnkudmFyaWFibGVzLmdldChyLm5hbWUpPT09KHQ9ci5kZWZpbml0aW9uKCkpKXtpZihpLmZvckVhY2goZnVuY3Rpb24oZSl7ZS53YWxrKGYpfSksZSBpbnN0YW5jZW9mIHJuKWlmKGUucmlnaHQud2FsayhmKSxlLmxlZnQ9PT1yKXQuY2hhaW5lZHx8ci5maXhlZF92YWx1ZSgpIT09ZS5yaWdodHx8KGtbdC5pZF09ZSksZS53cml0ZV9vbmx5fHxsKHQsITAsY1t0LmlkXSk7ZWxzZXt2YXIgbz1yLmZpeGVkX3ZhbHVlKCk7byYmby5pc19jb25zdGFudCgpfHxsKHQsdVt0LmlkXSwhMCl9cmV0dXJuITB9aWYoZSBpbnN0YW5jZW9mIF9uKXJldHVybih0PWUuZGVmaW5pdGlvbigpKS5pZCBpbiBFfHwoRVt0LmlkXT0hMCxzLnB1c2godCkpLCEwO2lmKGUgaW5zdGFuY2VvZiBBZSl7dmFyIGE9RjtyZXR1cm4gRj1lLG4oKSxGPWEsITB9fX0pLEFlLkRFRk1FVEhPRChcImhvaXN0X2RlY2xhcmF0aW9uc1wiLGZ1bmN0aW9uKHIpe3ZhciBvPXRoaXM7aWYoci5oYXNfZGlyZWN0aXZlKFwidXNlIGFzbVwiKSlyZXR1cm4gbzt2YXIgYT1yLm9wdGlvbihcImhvaXN0X2Z1bnNcIikscz1yLm9wdGlvbihcImhvaXN0X3ZhcnNcIik7aWYoYXx8cyl7dmFyIHU9W10sYz1bXSxmPW5ldyBPLGw9MCxuPTA7by53YWxrKG5ldyBTbihmdW5jdGlvbihlKXtyZXR1cm4gZSBpbnN0YW5jZW9mIEFlJiZlIT09b3x8KGUgaW5zdGFuY2VvZiBMZT8oKytuLCEwKTp2b2lkIDApfSkpLHM9cyYmMTxuO3ZhciBwPW5ldyBYbihmdW5jdGlvbihlKXtpZihlIT09byl7aWYoZSBpbnN0YW5jZW9mIGZlKXJldHVybiB1LnB1c2goZSksWChoZSxlKTtpZihhJiZlIGluc3RhbmNlb2YgQ2UmJihwLnBhcmVudCgpPT09b3x8IXIuaGFzX2RpcmVjdGl2ZShcInVzZSBzdHJpY3RcIikpKXJldHVybiBjLnB1c2goZSksWChoZSxlKTtpZihzJiZlIGluc3RhbmNlb2YgTGUpe2UuZGVmaW5pdGlvbnMuZm9yRWFjaChmdW5jdGlvbihlKXtmLnNldChlLm5hbWUubmFtZSxlKSwrK2x9KTt2YXIgbj1lLnRvX2Fzc2lnbm1lbnRzKHIpLHQ9cC5wYXJlbnQoKTtpZih0IGluc3RhbmNlb2Ygd2UmJnQuaW5pdD09PWUpe2lmKG51bGw9PW4pe3ZhciBpPWUuZGVmaW5pdGlvbnNbMF0ubmFtZTtyZXR1cm4gWChfbixpLGkpfXJldHVybiBufXJldHVybiB0IGluc3RhbmNlb2YgeWUmJnQuaW5pdD09PWU/bjpuP1gobGUsZSx7Ym9keTpufSk6WChoZSxlKX1pZihlIGluc3RhbmNlb2YgQWUpcmV0dXJuIGV9fSk7aWYobz1vLnRyYW5zZm9ybShwKSwwPGwpe3ZhciB0PVtdO2lmKGYuZWFjaChmdW5jdGlvbihuLGUpe28gaW5zdGFuY2VvZiBrZSYmVihmdW5jdGlvbihlKXtyZXR1cm4gZS5uYW1lPT1uLm5hbWUubmFtZX0sby5hcmduYW1lcyk/Zi5kZWwoZSk6KChuPW4uY2xvbmUoKSkudmFsdWU9bnVsbCx0LnB1c2gobiksZi5zZXQoZSxuKSl9KSwwPHQubGVuZ3RoKXtmb3IodmFyIGU9MDtlPG8uYm9keS5sZW5ndGg7KXtpZihvLmJvZHlbZV1pbnN0YW5jZW9mIGxlKXt2YXIgaSxkLGg9by5ib2R5W2VdLmJvZHk7aWYoaCBpbnN0YW5jZW9mIHJuJiZcIj1cIj09aC5vcGVyYXRvciYmKGk9aC5sZWZ0KWluc3RhbmNlb2YgY24mJmYuaGFzKGkubmFtZSkpe2lmKCh2PWYuZ2V0KGkubmFtZSkpLnZhbHVlKWJyZWFrO3YudmFsdWU9aC5yaWdodCxUKHQsdiksdC5wdXNoKHYpLG8uYm9keS5zcGxpY2UoZSwxKTtjb250aW51ZX1pZihoIGluc3RhbmNlb2YgV2UmJihkPWguZXhwcmVzc2lvbnNbMF0paW5zdGFuY2VvZiBybiYmXCI9XCI9PWQub3BlcmF0b3ImJihpPWQubGVmdClpbnN0YW5jZW9mIGNuJiZmLmhhcyhpLm5hbWUpKXt2YXIgdjtpZigodj1mLmdldChpLm5hbWUpKS52YWx1ZSlicmVhazt2LnZhbHVlPWQucmlnaHQsVCh0LHYpLHQucHVzaCh2KSxvLmJvZHlbZV0uYm9keT1NKGgsaC5leHByZXNzaW9ucy5zbGljZSgxKSk7Y29udGludWV9fWlmKG8uYm9keVtlXWluc3RhbmNlb2YgaGUpby5ib2R5LnNwbGljZShlLDEpO2Vsc2V7aWYoIShvLmJvZHlbZV1pbnN0YW5jZW9mIGRlKSlicmVhazt2YXIgXz1bZSwxXS5jb25jYXQoby5ib2R5W2VdLmJvZHkpO28uYm9keS5zcGxpY2UuYXBwbHkoby5ib2R5LF8pfX10PVgoTGUsbyx7ZGVmaW5pdGlvbnM6dH0pLGMucHVzaCh0KX19by5ib2R5PXUuY29uY2F0KGMsby5ib2R5KX1yZXR1cm4gb30pLEFlLkRFRk1FVEhPRChcInZhcl9uYW1lc1wiLGZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fdmFyX25hbWVzO3JldHVybiB0fHwodGhpcy5fdmFyX25hbWVzPXQ9T2JqZWN0LmNyZWF0ZShudWxsKSx0aGlzLmVuY2xvc2VkLmZvckVhY2goZnVuY3Rpb24oZSl7dFtlLm5hbWVdPSEwfSksdGhpcy52YXJpYWJsZXMuZWFjaChmdW5jdGlvbihlLG4pe3Rbbl09ITB9KSksdH0pLEFlLkRFRk1FVEhPRChcIm1ha2VfdmFyX25hbWVcIixmdW5jdGlvbihlKXtmb3IodmFyIG49dGhpcy52YXJfbmFtZXMoKSx0PWU9ZS5yZXBsYWNlKC8oPzpeW15hLXpfJF18W15hLXowLTlfJF0pL2dpLFwiX1wiKSxpPTA7blt0XTtpKyspdD1lK1wiJFwiK2k7cmV0dXJuIG5bdF09ITAsdH0pLEFlLkRFRk1FVEhPRChcImhvaXN0X3Byb3BlcnRpZXNcIixmdW5jdGlvbihlKXt2YXIgdT10aGlzO2lmKCFlLm9wdGlvbihcImhvaXN0X3Byb3BzXCIpfHxlLmhhc19kaXJlY3RpdmUoXCJ1c2UgYXNtXCIpKXJldHVybiB1O3ZhciBpPXUgaW5zdGFuY2VvZiBFZSYmZS50b3BfcmV0YWlufHxpZSxjPU9iamVjdC5jcmVhdGUobnVsbCk7cmV0dXJuIHUudHJhbnNmb3JtKG5ldyBYbihmdW5jdGlvbihyLGUpe3ZhciBuO2lmKHIgaW5zdGFuY2VvZiBWZSYmKChzPXIubmFtZSkuc2NvcGU9PT11JiYxIT0odD1zLmRlZmluaXRpb24oKSkuZXNjYXBlZCYmIXQuc2luZ2xlX3VzZSYmIXQuZGlyZWN0X2FjY2VzcyYmIWkodCkmJihuPXMuZml4ZWRfdmFsdWUoKSk9PT1yLnZhbHVlJiZuIGluc3RhbmNlb2YgYW4pKXtlKHIsdGhpcyk7dmFyIG89bmV3IE8sYT1bXTtyZXR1cm4gbi5wcm9wZXJ0aWVzLmZvckVhY2goZnVuY3Rpb24oZSl7dmFyIG4sdCxpO2EucHVzaChYKFZlLHIse25hbWU6KG49ZS5rZXksdD1YKHMuQ1RPUixzLHtuYW1lOnUubWFrZV92YXJfbmFtZShzLm5hbWUrXCJfXCIrbiksc2NvcGU6dX0pLGk9dS5kZWZfdmFyaWFibGUodCksby5zZXQobixpKSx1LmVuY2xvc2VkLnB1c2goaSksdCksdmFsdWU6ZS52YWx1ZX0pKX0pLGNbdC5pZF09byxyZS5zcGxpY2UoYSl9aWYociBpbnN0YW5jZW9mIEdlJiZyLmV4cHJlc3Npb24gaW5zdGFuY2VvZiBfbiYmKG89Y1tyLmV4cHJlc3Npb24uZGVmaW5pdGlvbigpLmlkXSkpe3ZhciBzLHQ9by5nZXQocChyLnByb3BlcnR5KSk7cmV0dXJuKHM9WChfbixyLHtuYW1lOnQubmFtZSxzY29wZTpyLmV4cHJlc3Npb24uc2NvcGUsdGhlZGVmOnR9KSkucmVmZXJlbmNlKHt9KSxzfX0pKX0pLGZ1bmN0aW9uKGUpe2Z1bmN0aW9uIGEoZSxuLHQpe3ZhciBpPWUubGVuZ3RoO2lmKCFpKXJldHVybiBudWxsO2Zvcih2YXIgcj1bXSxvPSExLGE9MDthPGk7YSsrKXt2YXIgcz1lW2FdLmRyb3Bfc2lkZV9lZmZlY3RfZnJlZShuLHQpO298PXMhPT1lW2FdLHMmJihyLnB1c2gocyksdD0hMSl9cmV0dXJuIG8/ci5sZW5ndGg/cjpudWxsOmV9ZShzZSxDKSxlKGduLEIpLGUobW4sQiksZShZZSxmdW5jdGlvbihuLGUpe2lmKCF0aGlzLmlzX2V4cHJfcHVyZShuKSl7aWYodGhpcy5leHByZXNzaW9uLmlzX2NhbGxfcHVyZShuKSl7dmFyIHQ9dGhpcy5hcmdzLnNsaWNlKCk7cmV0dXJuIHQudW5zaGlmdCh0aGlzLmV4cHJlc3Npb24uZXhwcmVzc2lvbiksKHQ9YSh0LG4sZSkpJiZNKHRoaXMsdCl9aWYodGhpcy5leHByZXNzaW9uIGluc3RhbmNlb2YgRmUmJighdGhpcy5leHByZXNzaW9uLm5hbWV8fCF0aGlzLmV4cHJlc3Npb24ubmFtZS5kZWZpbml0aW9uKCkucmVmZXJlbmNlcy5sZW5ndGgpKXt2YXIgaT10aGlzLmNsb25lKCkscj1pLmV4cHJlc3Npb247cmV0dXJuIHIucHJvY2Vzc19leHByZXNzaW9uKCExLG4pLHIud2FsayhuZXcgU24oZnVuY3Rpb24oZSl7cmV0dXJuIGUgaW5zdGFuY2VvZiBUZSYmZS52YWx1ZT8oZS52YWx1ZT1lLnZhbHVlLmRyb3Bfc2lkZV9lZmZlY3RfZnJlZShuKSwhMCk6ZSBpbnN0YW5jZW9mIEFlJiZlIT09cnx8dm9pZCAwfSkpLGl9cmV0dXJuIHRoaXN9dGhpcy5wdXJlJiZuLndhcm4oXCJEcm9wcGluZyBfX1BVUkVfXyBjYWxsIFt7ZmlsZX06e2xpbmV9LHtjb2x9XVwiLHRoaXMuc3RhcnQpO3ZhciBvPWEodGhpcy5hcmdzLG4sZSk7cmV0dXJuIG8mJk0odGhpcyxvKX0pLGUoRGUsQiksZShGZSxCKSxlKG5uLGZ1bmN0aW9uKGUsbil7dmFyIHQ9dGhpcy5yaWdodC5kcm9wX3NpZGVfZWZmZWN0X2ZyZWUoZSk7aWYoIXQpcmV0dXJuIHRoaXMubGVmdC5kcm9wX3NpZGVfZWZmZWN0X2ZyZWUoZSxuKTtpZihlZSh0aGlzLm9wZXJhdG9yKSl7aWYodD09PXRoaXMucmlnaHQpcmV0dXJuIHRoaXM7dmFyIGk9dGhpcy5jbG9uZSgpO3JldHVybiBpLnJpZ2h0PXQsaX12YXIgcj10aGlzLmxlZnQuZHJvcF9zaWRlX2VmZmVjdF9mcmVlKGUsbik7cmV0dXJuIHI/TSh0aGlzLFtyLHRdKTp0aGlzLnJpZ2h0LmRyb3Bfc2lkZV9lZmZlY3RfZnJlZShlLG4pfSksZShybixmdW5jdGlvbihlKXt2YXIgbj10aGlzLmxlZnQ7cmV0dXJuIG4uaGFzX3NpZGVfZWZmZWN0cyhlKXx8ZS5oYXNfZGlyZWN0aXZlKFwidXNlIHN0cmljdFwiKSYmbiBpbnN0YW5jZW9mIEdlJiZuLmV4cHJlc3Npb24uaXNfY29uc3RhbnQoKT90aGlzOih0aGlzLndyaXRlX29ubHk9ITAsSyhuKS5pc19jb25zdGFudF9leHByZXNzaW9uKGUuZmluZF9wYXJlbnQoQWUpKT90aGlzLnJpZ2h0LmRyb3Bfc2lkZV9lZmZlY3RfZnJlZShlKTp0aGlzKX0pLGUodG4sZnVuY3Rpb24oZSl7dmFyIG49dGhpcy5jb25zZXF1ZW50LmRyb3Bfc2lkZV9lZmZlY3RfZnJlZShlKSx0PXRoaXMuYWx0ZXJuYXRpdmUuZHJvcF9zaWRlX2VmZmVjdF9mcmVlKGUpO2lmKG49PT10aGlzLmNvbnNlcXVlbnQmJnQ9PT10aGlzLmFsdGVybmF0aXZlKXJldHVybiB0aGlzO2lmKCFuKXJldHVybiB0P1gobm4sdGhpcyx7b3BlcmF0b3I6XCJ8fFwiLGxlZnQ6dGhpcy5jb25kaXRpb24scmlnaHQ6dH0pOnRoaXMuY29uZGl0aW9uLmRyb3Bfc2lkZV9lZmZlY3RfZnJlZShlKTtpZighdClyZXR1cm4gWChubix0aGlzLHtvcGVyYXRvcjpcIiYmXCIsbGVmdDp0aGlzLmNvbmRpdGlvbixyaWdodDpufSk7dmFyIGk9dGhpcy5jbG9uZSgpO3JldHVybiBpLmNvbnNlcXVlbnQ9bixpLmFsdGVybmF0aXZlPXQsaX0pLGUoS2UsZnVuY3Rpb24oZSxuKXtpZihmKHRoaXMub3BlcmF0b3IpKXJldHVybiB0aGlzLndyaXRlX29ubHk9IXRoaXMuZXhwcmVzc2lvbi5oYXNfc2lkZV9lZmZlY3RzKGUpLHRoaXM7aWYoXCJ0eXBlb2ZcIj09dGhpcy5vcGVyYXRvciYmdGhpcy5leHByZXNzaW9uIGluc3RhbmNlb2YgX24pcmV0dXJuIG51bGw7dmFyIHQ9dGhpcy5leHByZXNzaW9uLmRyb3Bfc2lkZV9lZmZlY3RfZnJlZShlLG4pO3JldHVybiBuJiZ0JiZOKHQpP3Q9PT10aGlzLmV4cHJlc3Npb24mJlwiIVwiPT10aGlzLm9wZXJhdG9yP3RoaXM6dC5uZWdhdGUoZSxuKTp0fSksZShfbixmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5pc19kZWNsYXJlZChlKT9udWxsOnRoaXN9KSxlKGFuLGZ1bmN0aW9uKGUsbil7dmFyIHQ9YSh0aGlzLnByb3BlcnRpZXMsZSxuKTtyZXR1cm4gdCYmTSh0aGlzLHQpfSksZShzbixmdW5jdGlvbihlLG4pe3JldHVybiB0aGlzLnZhbHVlLmRyb3Bfc2lkZV9lZmZlY3RfZnJlZShlLG4pfSksZShvbixmdW5jdGlvbihlLG4pe3ZhciB0PWEodGhpcy5lbGVtZW50cyxlLG4pO3JldHVybiB0JiZNKHRoaXMsdCl9KSxlKFhlLGZ1bmN0aW9uKGUsbil7cmV0dXJuIHRoaXMuZXhwcmVzc2lvbi5tYXlfdGhyb3dfb25fYWNjZXNzKGUpP3RoaXM6dGhpcy5leHByZXNzaW9uLmRyb3Bfc2lkZV9lZmZlY3RfZnJlZShlLG4pfSksZShaZSxmdW5jdGlvbihlLG4pe2lmKHRoaXMuZXhwcmVzc2lvbi5tYXlfdGhyb3dfb25fYWNjZXNzKGUpKXJldHVybiB0aGlzO3ZhciB0PXRoaXMuZXhwcmVzc2lvbi5kcm9wX3NpZGVfZWZmZWN0X2ZyZWUoZSxuKTtpZighdClyZXR1cm4gdGhpcy5wcm9wZXJ0eS5kcm9wX3NpZGVfZWZmZWN0X2ZyZWUoZSxuKTt2YXIgaT10aGlzLnByb3BlcnR5LmRyb3Bfc2lkZV9lZmZlY3RfZnJlZShlKTtyZXR1cm4gaT9NKHRoaXMsW3QsaV0pOnR9KSxlKFdlLGZ1bmN0aW9uKGUpe3ZhciBuPXRoaXMudGFpbF9ub2RlKCksdD1uLmRyb3Bfc2lkZV9lZmZlY3RfZnJlZShlKTtpZih0PT09bilyZXR1cm4gdGhpczt2YXIgaT10aGlzLmV4cHJlc3Npb25zLnNsaWNlKDAsLTEpO3JldHVybiB0JiZpLnB1c2godCksTSh0aGlzLGkpfSl9KGZ1bmN0aW9uKGUsbil7ZS5ERUZNRVRIT0QoXCJkcm9wX3NpZGVfZWZmZWN0X2ZyZWVcIixuKX0pLGUobGUsZnVuY3Rpb24oZSxuKXtpZihuLm9wdGlvbihcInNpZGVfZWZmZWN0c1wiKSl7dmFyIHQ9ZS5ib2R5LGk9dC5kcm9wX3NpZGVfZWZmZWN0X2ZyZWUobiwhMCk7aWYoIWkpcmV0dXJuIG4ud2FybihcIkRyb3BwaW5nIHNpZGUtZWZmZWN0LWZyZWUgc3RhdGVtZW50IFt7ZmlsZX06e2xpbmV9LHtjb2x9XVwiLGUuc3RhcnQpLFgoaGUsZSk7aWYoaSE9PXQpcmV0dXJuIFgobGUsZSx7Ym9keTppfSl9cmV0dXJuIGV9KSxlKGJlLGZ1bmN0aW9uKGUsbil7cmV0dXJuIG4ub3B0aW9uKFwibG9vcHNcIik/WCh5ZSxlLGUpLm9wdGltaXplKG4pOmV9KSxlKGdlLGZ1bmN0aW9uKG4sZSl7aWYoIWUub3B0aW9uKFwibG9vcHNcIikpcmV0dXJuIG47dmFyIHQ9bi5jb25kaXRpb24uaXNfdHJ1dGh5KCl8fG4uY29uZGl0aW9uLnRhaWxfbm9kZSgpLmV2YWx1YXRlKGUpO2lmKCEodCBpbnN0YW5jZW9mIHNlKSl7aWYodClyZXR1cm4gWCh5ZSxuLHtib2R5OlgoZGUsbi5ib2R5LHtib2R5OltuLmJvZHksWChsZSxuLmNvbmRpdGlvbix7Ym9keTpuLmNvbmRpdGlvbn0pXX0pfSkub3B0aW1pemUoZSk7dmFyIGk9ITEscj1uZXcgU24oZnVuY3Rpb24oZSl7cmV0dXJuISEoZSBpbnN0YW5jZW9mIEFlfHxpKXx8KGUgaW5zdGFuY2VvZiBPZSYmci5sb29wY29udHJvbF90YXJnZXQoZSk9PT1uP2k9ITA6dm9pZCAwKX0pLG89ZS5wYXJlbnQoKTtpZigobyBpbnN0YW5jZW9mIHZlP286bikud2FsayhyKSwhaSlyZXR1cm4gWChkZSxuLmJvZHkse2JvZHk6W24uYm9keSxYKGxlLG4uY29uZGl0aW9uLHtib2R5Om4uY29uZGl0aW9ufSldfSkub3B0aW1pemUoZSl9cmV0dXJuIG4uYm9keSBpbnN0YW5jZW9mIGxlP1goeWUsbix7Y29uZGl0aW9uOk0obi5jb25kaXRpb24sW24uYm9keS5ib2R5LG4uY29uZGl0aW9uXSksYm9keTpYKGhlLG4pfSkub3B0aW1pemUoZSk6bn0pLGUoeWUsZnVuY3Rpb24oZSxuKXtpZighbi5vcHRpb24oXCJsb29wc1wiKSlyZXR1cm4gZTtpZihuLm9wdGlvbihcInNpZGVfZWZmZWN0c1wiKSYmZS5pbml0JiYoZS5pbml0PWUuaW5pdC5kcm9wX3NpZGVfZWZmZWN0X2ZyZWUobikpLGUuY29uZGl0aW9uKXt2YXIgdD1lLmNvbmRpdGlvbi5ldmFsdWF0ZShuKTtpZighKHQgaW5zdGFuY2VvZiBzZSkpaWYodCllLmNvbmRpdGlvbj1udWxsO2Vsc2UgaWYoIW4ub3B0aW9uKFwiZGVhZF9jb2RlXCIpKXt2YXIgaT1lLmNvbmRpdGlvbjtlLmNvbmRpdGlvbj1xKHQsZS5jb25kaXRpb24pLGUuY29uZGl0aW9uPXgoZS5jb25kaXRpb24udHJhbnNmb3JtKG4pLGkpfWlmKHQgaW5zdGFuY2VvZiBzZSYmKHQ9ZS5jb25kaXRpb24uaXNfdHJ1dGh5KCl8fGUuY29uZGl0aW9uLnRhaWxfbm9kZSgpLmV2YWx1YXRlKG4pKSx0KSFlLmNvbmRpdGlvbnx8dCBpbnN0YW5jZW9mIHNlfHwoZS5ib2R5PVgoZGUsZS5ib2R5LHtib2R5OltYKGxlLGUuY29uZGl0aW9uLHtib2R5OmUuY29uZGl0aW9ufSksZS5ib2R5XX0pLGUuY29uZGl0aW9uPW51bGwpO2Vsc2UgaWYobi5vcHRpb24oXCJkZWFkX2NvZGVcIikpe3ZhciByPVtdO3JldHVybiB3KG4sZS5ib2R5LHIpLGUuaW5pdCBpbnN0YW5jZW9mIHVlP3IucHVzaChlLmluaXQpOmUuaW5pdCYmci5wdXNoKFgobGUsZS5pbml0LHtib2R5OmUuaW5pdH0pKSxyLnB1c2goWChsZSxlLmNvbmRpdGlvbix7Ym9keTplLmNvbmRpdGlvbn0pKSxYKGRlLGUse2JvZHk6cn0pLm9wdGltaXplKG4pfX1yZXR1cm4gZnVuY3Rpb24gbih0LGkpe3ZhciBlPXQuYm9keSBpbnN0YW5jZW9mIGRlP3QuYm9keS5ib2R5WzBdOnQuYm9keTtpZihpLm9wdGlvbihcImRlYWRfY29kZVwiKSYmbyhlKSl7dmFyIHI9W107cmV0dXJuIHQuaW5pdCBpbnN0YW5jZW9mIHVlP3IucHVzaCh0LmluaXQpOnQuaW5pdCYmci5wdXNoKFgobGUsdC5pbml0LHtib2R5OnQuaW5pdH0pKSx0LmNvbmRpdGlvbiYmci5wdXNoKFgobGUsdC5jb25kaXRpb24se2JvZHk6dC5jb25kaXRpb259KSksdyhpLHQuYm9keSxyKSxYKGRlLHQse2JvZHk6cn0pfXJldHVybiBlIGluc3RhbmNlb2YgTWUmJihvKGUuYm9keSk/KHQuY29uZGl0aW9uP3QuY29uZGl0aW9uPVgobm4sdC5jb25kaXRpb24se2xlZnQ6dC5jb25kaXRpb24sb3BlcmF0b3I6XCImJlwiLHJpZ2h0OmUuY29uZGl0aW9uLm5lZ2F0ZShpKX0pOnQuY29uZGl0aW9uPWUuY29uZGl0aW9uLm5lZ2F0ZShpKSxhKGUuYWx0ZXJuYXRpdmUpKTpvKGUuYWx0ZXJuYXRpdmUpJiYodC5jb25kaXRpb24/dC5jb25kaXRpb249WChubix0LmNvbmRpdGlvbix7bGVmdDp0LmNvbmRpdGlvbixvcGVyYXRvcjpcIiYmXCIscmlnaHQ6ZS5jb25kaXRpb259KTp0LmNvbmRpdGlvbj1lLmNvbmRpdGlvbixhKGUuYm9keSkpKSx0O2Z1bmN0aW9uIG8oZSl7cmV0dXJuIGUgaW5zdGFuY2VvZiAkZSYmaS5sb29wY29udHJvbF90YXJnZXQoZSk9PT1pLnNlbGYoKX1mdW5jdGlvbiBhKGUpe2U9YihlKSx0LmJvZHkgaW5zdGFuY2VvZiBkZT8odC5ib2R5PXQuYm9keS5jbG9uZSgpLHQuYm9keS5ib2R5PWUuY29uY2F0KHQuYm9keS5ib2R5LnNsaWNlKDEpKSx0LmJvZHk9dC5ib2R5LnRyYW5zZm9ybShpKSk6dC5ib2R5PVgoZGUsdC5ib2R5LHtib2R5OmV9KS50cmFuc2Zvcm0oaSksdD1uKHQsaSl9fShlLG4pfSksZShNZSxmdW5jdGlvbihlLG4pe2lmKGooZS5hbHRlcm5hdGl2ZSkmJihlLmFsdGVybmF0aXZlPW51bGwpLCFuLm9wdGlvbihcImNvbmRpdGlvbmFsc1wiKSlyZXR1cm4gZTt2YXIgdD1lLmNvbmRpdGlvbi5ldmFsdWF0ZShuKTtpZighKG4ub3B0aW9uKFwiZGVhZF9jb2RlXCIpfHx0IGluc3RhbmNlb2Ygc2UpKXt2YXIgaT1lLmNvbmRpdGlvbjtlLmNvbmRpdGlvbj1xKHQsaSksZS5jb25kaXRpb249eChlLmNvbmRpdGlvbi50cmFuc2Zvcm0obiksaSl9aWYobi5vcHRpb24oXCJkZWFkX2NvZGVcIikpe2lmKHQgaW5zdGFuY2VvZiBzZSYmKHQ9ZS5jb25kaXRpb24uaXNfdHJ1dGh5KCl8fGUuY29uZGl0aW9uLnRhaWxfbm9kZSgpLmV2YWx1YXRlKG4pKSwhdCl7bi53YXJuKFwiQ29uZGl0aW9uIGFsd2F5cyBmYWxzZSBbe2ZpbGV9OntsaW5lfSx7Y29sfV1cIixlLmNvbmRpdGlvbi5zdGFydCk7dmFyIHI9W107cmV0dXJuIHcobixlLmJvZHksciksci5wdXNoKFgobGUsZS5jb25kaXRpb24se2JvZHk6ZS5jb25kaXRpb259KSksZS5hbHRlcm5hdGl2ZSYmci5wdXNoKGUuYWx0ZXJuYXRpdmUpLFgoZGUsZSx7Ym9keTpyfSkub3B0aW1pemUobil9aWYoISh0IGluc3RhbmNlb2Ygc2UpKXtuLndhcm4oXCJDb25kaXRpb24gYWx3YXlzIHRydWUgW3tmaWxlfTp7bGluZX0se2NvbH1dXCIsZS5jb25kaXRpb24uc3RhcnQpO3I9W107cmV0dXJuIGUuYWx0ZXJuYXRpdmUmJncobixlLmFsdGVybmF0aXZlLHIpLHIucHVzaChYKGxlLGUuY29uZGl0aW9uLHtib2R5OmUuY29uZGl0aW9ufSkpLHIucHVzaChlLmJvZHkpLFgoZGUsZSx7Ym9keTpyfSkub3B0aW1pemUobil9fXZhciBvPWUuY29uZGl0aW9uLm5lZ2F0ZShuKSxhPWUuY29uZGl0aW9uLnByaW50X3RvX3N0cmluZygpLmxlbmd0aCxzPW8ucHJpbnRfdG9fc3RyaW5nKCkubGVuZ3RoLHU9czxhO2lmKGUuYWx0ZXJuYXRpdmUmJnUpe3U9ITEsZS5jb25kaXRpb249bzt2YXIgYz1lLmJvZHk7ZS5ib2R5PWUuYWx0ZXJuYXRpdmV8fFgoaGUsZSksZS5hbHRlcm5hdGl2ZT1jfWlmKGooZS5ib2R5KSYmaihlLmFsdGVybmF0aXZlKSlyZXR1cm4gWChsZSxlLmNvbmRpdGlvbix7Ym9keTplLmNvbmRpdGlvbi5jbG9uZSgpfSkub3B0aW1pemUobik7aWYoZS5ib2R5IGluc3RhbmNlb2YgbGUmJmUuYWx0ZXJuYXRpdmUgaW5zdGFuY2VvZiBsZSlyZXR1cm4gWChsZSxlLHtib2R5OlgodG4sZSx7Y29uZGl0aW9uOmUuY29uZGl0aW9uLGNvbnNlcXVlbnQ6ZS5ib2R5LmJvZHksYWx0ZXJuYXRpdmU6ZS5hbHRlcm5hdGl2ZS5ib2R5fSl9KS5vcHRpbWl6ZShuKTtpZihqKGUuYWx0ZXJuYXRpdmUpJiZlLmJvZHkgaW5zdGFuY2VvZiBsZSlyZXR1cm4gYT09PXMmJiF1JiZlLmNvbmRpdGlvbiBpbnN0YW5jZW9mIG5uJiZcInx8XCI9PWUuY29uZGl0aW9uLm9wZXJhdG9yJiYodT0hMCksdT9YKGxlLGUse2JvZHk6WChubixlLHtvcGVyYXRvcjpcInx8XCIsbGVmdDpvLHJpZ2h0OmUuYm9keS5ib2R5fSl9KS5vcHRpbWl6ZShuKTpYKGxlLGUse2JvZHk6WChubixlLHtvcGVyYXRvcjpcIiYmXCIsbGVmdDplLmNvbmRpdGlvbixyaWdodDplLmJvZHkuYm9keX0pfSkub3B0aW1pemUobik7aWYoZS5ib2R5IGluc3RhbmNlb2YgaGUmJmUuYWx0ZXJuYXRpdmUgaW5zdGFuY2VvZiBsZSlyZXR1cm4gWChsZSxlLHtib2R5Olgobm4sZSx7b3BlcmF0b3I6XCJ8fFwiLGxlZnQ6ZS5jb25kaXRpb24scmlnaHQ6ZS5hbHRlcm5hdGl2ZS5ib2R5fSl9KS5vcHRpbWl6ZShuKTtpZihlLmJvZHkgaW5zdGFuY2VvZiBTZSYmZS5hbHRlcm5hdGl2ZSBpbnN0YW5jZW9mIFNlJiZlLmJvZHkuVFlQRT09ZS5hbHRlcm5hdGl2ZS5UWVBFKXJldHVybiBYKGUuYm9keS5DVE9SLGUse3ZhbHVlOlgodG4sZSx7Y29uZGl0aW9uOmUuY29uZGl0aW9uLGNvbnNlcXVlbnQ6ZS5ib2R5LnZhbHVlfHxYKEVuLGUuYm9keSksYWx0ZXJuYXRpdmU6ZS5hbHRlcm5hdGl2ZS52YWx1ZXx8WChFbixlLmFsdGVybmF0aXZlKX0pLnRyYW5zZm9ybShuKX0pLm9wdGltaXplKG4pO2lmKGUuYm9keSBpbnN0YW5jZW9mIE1lJiYhZS5ib2R5LmFsdGVybmF0aXZlJiYhZS5hbHRlcm5hdGl2ZSYmKGU9WChNZSxlLHtjb25kaXRpb246WChubixlLmNvbmRpdGlvbix7b3BlcmF0b3I6XCImJlwiLGxlZnQ6ZS5jb25kaXRpb24scmlnaHQ6ZS5ib2R5LmNvbmRpdGlvbn0pLGJvZHk6ZS5ib2R5LmJvZHksYWx0ZXJuYXRpdmU6bnVsbH0pKSxBKGUuYm9keSkmJmUuYWx0ZXJuYXRpdmUpe3ZhciBmPWUuYWx0ZXJuYXRpdmU7cmV0dXJuIGUuYWx0ZXJuYXRpdmU9bnVsbCxYKGRlLGUse2JvZHk6W2UsZl19KS5vcHRpbWl6ZShuKX1pZihBKGUuYWx0ZXJuYXRpdmUpKXtyPWUuYm9keTtyZXR1cm4gZS5ib2R5PWUuYWx0ZXJuYXRpdmUsZS5jb25kaXRpb249dT9vOmUuY29uZGl0aW9uLm5lZ2F0ZShuKSxlLmFsdGVybmF0aXZlPW51bGwsWChkZSxlLHtib2R5OltlLHJdfSkub3B0aW1pemUobil9cmV0dXJuIGV9KSxlKHFlLGZ1bmN0aW9uKG4sdCl7aWYoIXQub3B0aW9uKFwic3dpdGNoZXNcIikpcmV0dXJuIG47dmFyIGUsaT1uLmV4cHJlc3Npb24uZXZhbHVhdGUodCk7aWYoIShpIGluc3RhbmNlb2Ygc2UpKXt2YXIgcj1uLmV4cHJlc3Npb247bi5leHByZXNzaW9uPXEoaSxyKSxuLmV4cHJlc3Npb249eChuLmV4cHJlc3Npb24udHJhbnNmb3JtKHQpLHIpfWlmKCF0Lm9wdGlvbihcImRlYWRfY29kZVwiKSlyZXR1cm4gbjtpIGluc3RhbmNlb2Ygc2UmJihpPW4uZXhwcmVzc2lvbi50YWlsX25vZGUoKS5ldmFsdWF0ZSh0KSk7Zm9yKHZhciBvLGEscz1bXSx1PVtdLGM9MCxmPW4uYm9keS5sZW5ndGg7YzxmJiYhYTtjKyspe2lmKChlPW4uYm9keVtjXSlpbnN0YW5jZW9mIE5lKW8/ZyhlLHVbdS5sZW5ndGgtMV0pOm89ZTtlbHNlIGlmKCEoaSBpbnN0YW5jZW9mIHNlKSl7aWYoISgoXz1lLmV4cHJlc3Npb24uZXZhbHVhdGUodCkpaW5zdGFuY2VvZiBzZSkmJl8hPT1pKXtnKGUsdVt1Lmxlbmd0aC0xXSk7Y29udGludWV9aWYoXyBpbnN0YW5jZW9mIHNlJiYoXz1lLmV4cHJlc3Npb24udGFpbF9ub2RlKCkuZXZhbHVhdGUodCkpLF89PT1pJiYoYT1lLG8pKXt2YXIgbD11LmluZGV4T2Yobyk7dS5zcGxpY2UobCwxKSxnKG8sdVtsLTFdKSxvPW51bGx9fWlmKEEoZSkpe3ZhciBwPXVbdS5sZW5ndGgtMV07QShwKSYmcC5ib2R5Lmxlbmd0aD09ZS5ib2R5Lmxlbmd0aCYmWChkZSxwLHApLmVxdWl2YWxlbnRfdG8oWChkZSxlLGUpKSYmKHAuYm9keT1bXSl9dS5wdXNoKGUpfWZvcig7YzxmOylnKG4uYm9keVtjKytdLHVbdS5sZW5ndGgtMV0pO2ZvcigwPHUubGVuZ3RoJiYodVswXS5ib2R5PXMuY29uY2F0KHVbMF0uYm9keSkpLG4uYm9keT11O2U9dVt1Lmxlbmd0aC0xXTspe3ZhciBkPWUuYm9keVtlLmJvZHkubGVuZ3RoLTFdO2lmKGQgaW5zdGFuY2VvZiAkZSYmdC5sb29wY29udHJvbF90YXJnZXQoZCk9PT1uJiZlLmJvZHkucG9wKCksZS5ib2R5Lmxlbmd0aHx8ZSBpbnN0YW5jZW9mIEhlJiYob3x8ZS5leHByZXNzaW9uLmhhc19zaWRlX2VmZmVjdHModCkpKWJyZWFrO3UucG9wKCk9PT1vJiYobz1udWxsKX1pZigwPT11Lmxlbmd0aClyZXR1cm4gWChkZSxuLHtib2R5OnMuY29uY2F0KFgobGUsbi5leHByZXNzaW9uLHtib2R5Om4uZXhwcmVzc2lvbn0pKX0pLm9wdGltaXplKHQpO2lmKDE9PXUubGVuZ3RoJiYodVswXT09PWF8fHVbMF09PT1vKSl7dmFyIGg9ITEsdj1uZXcgU24oZnVuY3Rpb24oZSl7aWYoaHx8ZSBpbnN0YW5jZW9mIGtlfHxlIGluc3RhbmNlb2YgbGUpcmV0dXJuITA7ZSBpbnN0YW5jZW9mICRlJiZ2Lmxvb3Bjb250cm9sX3RhcmdldChlKT09PW4mJihoPSEwKX0pO2lmKG4ud2Fsayh2KSwhaCl7dmFyIF8sbT11WzBdLmJvZHkuc2xpY2UoKTtyZXR1cm4oXz11WzBdLmV4cHJlc3Npb24pJiZtLnVuc2hpZnQoWChsZSxfLHtib2R5Ol99KSksbS51bnNoaWZ0KFgobGUsbi5leHByZXNzaW9uLHtib2R5Om4uZXhwcmVzc2lvbn0pKSxYKGRlLG4se2JvZHk6bX0pLm9wdGltaXplKHQpfX1yZXR1cm4gbjtmdW5jdGlvbiBnKGUsbil7biYmIUEobik/bi5ib2R5PW4uYm9keS5jb25jYXQoZS5ib2R5KTp3KHQsZSxzKX19KSxlKFJlLGZ1bmN0aW9uKGUsbil7aWYodShlLmJvZHksbiksZS5iY2F0Y2gmJmUuYmZpbmFsbHkmJm9lKGUuYmZpbmFsbHkuYm9keSxqKSYmKGUuYmZpbmFsbHk9bnVsbCksbi5vcHRpb24oXCJkZWFkX2NvZGVcIikmJm9lKGUuYm9keSxqKSl7dmFyIHQ9W107cmV0dXJuIGUuYmNhdGNoJiYodyhuLGUuYmNhdGNoLHQpLHQuZm9yRWFjaChmdW5jdGlvbihlKXtlIGluc3RhbmNlb2YgVWUmJmUuZGVmaW5pdGlvbnMuZm9yRWFjaChmdW5jdGlvbihlKXt2YXIgbj1lLm5hbWUuZGVmaW5pdGlvbigpLnJlZGVmaW5lZCgpO24mJihlLm5hbWU9ZS5uYW1lLmNsb25lKCksZS5uYW1lLnRoZWRlZj1uKX0pfSkpLGUuYmZpbmFsbHkmJih0PXQuY29uY2F0KGUuYmZpbmFsbHkuYm9keSkpLFgoZGUsZSx7Ym9keTp0fSkub3B0aW1pemUobil9cmV0dXJuIGV9KSxVZS5ERUZNRVRIT0QoXCJyZW1vdmVfaW5pdGlhbGl6ZXJzXCIsZnVuY3Rpb24oKXt0aGlzLmRlZmluaXRpb25zLmZvckVhY2goZnVuY3Rpb24oZSl7ZS52YWx1ZT1udWxsfSl9KSxVZS5ERUZNRVRIT0QoXCJ0b19hc3NpZ25tZW50c1wiLGZ1bmN0aW9uKGUpe3ZhciBpPWUub3B0aW9uKFwicmVkdWNlX3ZhcnNcIiksbj10aGlzLmRlZmluaXRpb25zLnJlZHVjZShmdW5jdGlvbihlLG4pe2lmKG4udmFsdWUpe3ZhciB0PVgoX24sbi5uYW1lLG4ubmFtZSk7ZS5wdXNoKFgocm4sbix7b3BlcmF0b3I6XCI9XCIsbGVmdDp0LHJpZ2h0Om4udmFsdWV9KSksaSYmKHQuZGVmaW5pdGlvbigpLmZpeGVkPSExKX1yZXR1cm4obj1uLm5hbWUuZGVmaW5pdGlvbigpKS5lbGltaW5hdGVkKyssbi5yZXBsYWNlZC0tLGV9LFtdKTtyZXR1cm4gMD09bi5sZW5ndGg/bnVsbDpNKHRoaXMsbil9KSxlKFVlLGZ1bmN0aW9uKGUsbil7cmV0dXJuIDA9PWUuZGVmaW5pdGlvbnMubGVuZ3RoP1goaGUsZSk6ZX0pLGUoWWUsZnVuY3Rpb24ocyxyKXt2YXIgZT1zLmV4cHJlc3Npb24scD1lO3Iub3B0aW9uKFwicmVkdWNlX3ZhcnNcIikmJnAgaW5zdGFuY2VvZiBfbiYmKHA9cC5maXhlZF92YWx1ZSgpKTt2YXIgbj1wIGluc3RhbmNlb2Yga2U7aWYoci5vcHRpb24oXCJ1bnVzZWRcIikmJm4mJiFwLnVzZXNfYXJndW1lbnRzJiYhcC51c2VzX2V2YWwpe2Zvcih2YXIgdD0wLGk9MCxvPTAsYT1zLmFyZ3MubGVuZ3RoO288YTtvKyspe3ZhciB1PW8+PXAuYXJnbmFtZXMubGVuZ3RoO2lmKHV8fHAuYXJnbmFtZXNbb10uX191bnVzZWQpe2lmKGQ9cy5hcmdzW29dLmRyb3Bfc2lkZV9lZmZlY3RfZnJlZShyKSlzLmFyZ3NbdCsrXT1kO2Vsc2UgaWYoIXUpe3MuYXJnc1t0KytdPVgoeW4scy5hcmdzW29dLHt2YWx1ZTowfSk7Y29udGludWV9fWVsc2Ugcy5hcmdzW3QrK109cy5hcmdzW29dO2k9dH1zLmFyZ3MubGVuZ3RoPWl9aWYoci5vcHRpb24oXCJ1bnNhZmVcIikpaWYoSChlKSlzd2l0Y2goZS5uYW1lKXtjYXNlXCJBcnJheVwiOmlmKDEhPXMuYXJncy5sZW5ndGgpcmV0dXJuIFgob24scyx7ZWxlbWVudHM6cy5hcmdzfSkub3B0aW1pemUocik7YnJlYWs7Y2FzZVwiT2JqZWN0XCI6aWYoMD09cy5hcmdzLmxlbmd0aClyZXR1cm4gWChhbixzLHtwcm9wZXJ0aWVzOltdfSk7YnJlYWs7Y2FzZVwiU3RyaW5nXCI6aWYoMD09cy5hcmdzLmxlbmd0aClyZXR1cm4gWChibixzLHt2YWx1ZTpcIlwifSk7aWYocy5hcmdzLmxlbmd0aDw9MSlyZXR1cm4gWChubixzLHtsZWZ0OnMuYXJnc1swXSxvcGVyYXRvcjpcIitcIixyaWdodDpYKGJuLHMse3ZhbHVlOlwiXCJ9KX0pLm9wdGltaXplKHIpO2JyZWFrO2Nhc2VcIk51bWJlclwiOmlmKDA9PXMuYXJncy5sZW5ndGgpcmV0dXJuIFgoeW4scyx7dmFsdWU6MH0pO2lmKDE9PXMuYXJncy5sZW5ndGgpcmV0dXJuIFgoUWUscyx7ZXhwcmVzc2lvbjpzLmFyZ3NbMF0sb3BlcmF0b3I6XCIrXCJ9KS5vcHRpbWl6ZShyKTtjYXNlXCJCb29sZWFuXCI6aWYoMD09cy5hcmdzLmxlbmd0aClyZXR1cm4gWChDbixzKTtpZigxPT1zLmFyZ3MubGVuZ3RoKXJldHVybiBYKFFlLHMse2V4cHJlc3Npb246WChRZSxzLHtleHByZXNzaW9uOnMuYXJnc1swXSxvcGVyYXRvcjpcIiFcIn0pLG9wZXJhdG9yOlwiIVwifSkub3B0aW1pemUocik7YnJlYWs7Y2FzZVwiUmVnRXhwXCI6dmFyIGM9W107aWYob2Uocy5hcmdzLGZ1bmN0aW9uKGUpe3ZhciBuPWUuZXZhbHVhdGUocik7cmV0dXJuIGMudW5zaGlmdChuKSxlIT09bn0pKXRyeXtyZXR1cm4gSShyLHMsWCh3bixzLHt2YWx1ZTpSZWdFeHAuYXBwbHkoUmVnRXhwLGMpfSkpfWNhdGNoKGUpe3Iud2FybihcIkVycm9yIGNvbnZlcnRpbmcge2V4cHJ9IFt7ZmlsZX06e2xpbmV9LHtjb2x9XVwiLHtleHByOnMucHJpbnRfdG9fc3RyaW5nKCksZmlsZTpzLnN0YXJ0LmZpbGUsbGluZTpzLnN0YXJ0LmxpbmUsY29sOnMuc3RhcnQuY29sfSl9fWVsc2UgaWYoZSBpbnN0YW5jZW9mIFhlKXN3aXRjaChlLnByb3BlcnR5KXtjYXNlXCJ0b1N0cmluZ1wiOmlmKDA9PXMuYXJncy5sZW5ndGgmJiFlLmV4cHJlc3Npb24ubWF5X3Rocm93X29uX2FjY2VzcyhyKSlyZXR1cm4gWChubixzLHtsZWZ0OlgoYm4scyx7dmFsdWU6XCJcIn0pLG9wZXJhdG9yOlwiK1wiLHJpZ2h0OmUuZXhwcmVzc2lvbn0pLm9wdGltaXplKHIpO2JyZWFrO2Nhc2VcImpvaW5cIjp2YXIgZjtpZihlLmV4cHJlc3Npb24gaW5zdGFuY2VvZiBvbilpZighKDA8cy5hcmdzLmxlbmd0aCYmKGY9cy5hcmdzWzBdLmV2YWx1YXRlKHIpKT09PXMuYXJnc1swXSkpe3ZhciBsLGQsaD1bXSx2PVtdO3JldHVybiBlLmV4cHJlc3Npb24uZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbihlKXt2YXIgbj1lLmV2YWx1YXRlKHIpO24hPT1lP3YucHVzaChuKTooMDx2Lmxlbmd0aCYmKGgucHVzaChYKGJuLHMse3ZhbHVlOnYuam9pbihmKX0pKSx2Lmxlbmd0aD0wKSxoLnB1c2goZSkpfSksMDx2Lmxlbmd0aCYmaC5wdXNoKFgoYm4scyx7dmFsdWU6di5qb2luKGYpfSkpLDA9PWgubGVuZ3RoP1goYm4scyx7dmFsdWU6XCJcIn0pOjE9PWgubGVuZ3RoP2hbMF0uaXNfc3RyaW5nKHIpP2hbMF06WChubixoWzBdLHtvcGVyYXRvcjpcIitcIixsZWZ0OlgoYm4scyx7dmFsdWU6XCJcIn0pLHJpZ2h0OmhbMF19KTpcIlwiPT1mPyhsPWhbMF0uaXNfc3RyaW5nKHIpfHxoWzFdLmlzX3N0cmluZyhyKT9oLnNoaWZ0KCk6WChibixzLHt2YWx1ZTpcIlwifSksaC5yZWR1Y2UoZnVuY3Rpb24oZSxuKXtyZXR1cm4gWChubixuLHtvcGVyYXRvcjpcIitcIixsZWZ0OmUscmlnaHQ6bn0pfSxsKS5vcHRpbWl6ZShyKSk6KChkPXMuY2xvbmUoKSkuZXhwcmVzc2lvbj1kLmV4cHJlc3Npb24uY2xvbmUoKSxkLmV4cHJlc3Npb24uZXhwcmVzc2lvbj1kLmV4cHJlc3Npb24uZXhwcmVzc2lvbi5jbG9uZSgpLGQuZXhwcmVzc2lvbi5leHByZXNzaW9uLmVsZW1lbnRzPWgsSShyLHMsZCkpfWJyZWFrO2Nhc2VcImNoYXJBdFwiOmlmKGUuZXhwcmVzc2lvbi5pc19zdHJpbmcocikpe3ZhciBfPXMuYXJnc1swXSxtPV8/Xy5ldmFsdWF0ZShyKTowO2lmKG0hPT1fKXJldHVybiBYKFplLGUse2V4cHJlc3Npb246ZS5leHByZXNzaW9uLHByb3BlcnR5OnEoMHxtLF98fGUpfSkub3B0aW1pemUocil9YnJlYWs7Y2FzZVwiYXBwbHlcIjppZigyPT1zLmFyZ3MubGVuZ3RoJiZzLmFyZ3NbMV1pbnN0YW5jZW9mIG9uKXJldHVybihrPXMuYXJnc1sxXS5lbGVtZW50cy5zbGljZSgpKS51bnNoaWZ0KHMuYXJnc1swXSksWChZZSxzLHtleHByZXNzaW9uOlgoWGUsZSx7ZXhwcmVzc2lvbjplLmV4cHJlc3Npb24scHJvcGVydHk6XCJjYWxsXCJ9KSxhcmdzOmt9KS5vcHRpbWl6ZShyKTticmVhaztjYXNlXCJjYWxsXCI6dmFyIGc9ZS5leHByZXNzaW9uO2lmKGcgaW5zdGFuY2VvZiBfbiYmKGc9Zy5maXhlZF92YWx1ZSgpKSxnIGluc3RhbmNlb2Yga2UmJiFnLmNvbnRhaW5zX3RoaXMoKSlyZXR1cm4gTSh0aGlzLFtzLmFyZ3NbMF0sWChZZSxzLHtleHByZXNzaW9uOmUuZXhwcmVzc2lvbixhcmdzOnMuYXJncy5zbGljZSgxKX0pXSkub3B0aW1pemUocil9aWYoci5vcHRpb24oXCJ1bnNhZmVfRnVuY3Rpb25cIikmJkgoZSkmJlwiRnVuY3Rpb25cIj09ZS5uYW1lKXtpZigwPT1zLmFyZ3MubGVuZ3RoKXJldHVybiBYKEZlLHMse2FyZ25hbWVzOltdLGJvZHk6W119KTtpZihvZShzLmFyZ3MsZnVuY3Rpb24oZSl7cmV0dXJuIGUgaW5zdGFuY2VvZiBibn0pKXRyeXt2YXIgYj1HbihBPVwibihmdW5jdGlvbihcIitzLmFyZ3Muc2xpY2UoMCwtMSkubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlLnZhbHVlfSkuam9pbihcIixcIikrXCIpe1wiK3MuYXJnc1tzLmFyZ3MubGVuZ3RoLTFdLnZhbHVlK1wifSlcIikseT17aWU4OnIub3B0aW9uKFwiaWU4XCIpfTtiLmZpZ3VyZV9vdXRfc2NvcGUoeSk7dmFyIHcseD1uZXcgZXQoci5vcHRpb25zKTsoYj1iLnRyYW5zZm9ybSh4KSkuZmlndXJlX291dF9zY29wZSh5KSxiLmNvbXB1dGVfY2hhcl9mcmVxdWVuY3koeSksYi5tYW5nbGVfbmFtZXMoeSksYi53YWxrKG5ldyBTbihmdW5jdGlvbihlKXtyZXR1cm4hIXd8fChlIGluc3RhbmNlb2Yga2U/KHc9ZSwhMCk6dm9pZCAwKX0pKTt2YXIgQT1RbigpO3JldHVybiBkZS5wcm90b3R5cGUuX2NvZGVnZW4uY2FsbCh3LHcsQSkscy5hcmdzPVtYKGJuLHMse3ZhbHVlOncuYXJnbmFtZXMubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlLnByaW50X3RvX3N0cmluZygpfSkuam9pbihcIixcIil9KSxYKGJuLHMuYXJnc1tzLmFyZ3MubGVuZ3RoLTFdLHt2YWx1ZTpBLmdldCgpLnJlcGxhY2UoL15cXHt8XFx9JC9nLFwiXCIpfSldLHN9Y2F0Y2goZSl7aWYoIShlIGluc3RhbmNlb2YgSG4pKXRocm93IGU7ci53YXJuKFwiRXJyb3IgcGFyc2luZyBjb2RlIHBhc3NlZCB0byBuZXcgRnVuY3Rpb24gW3tmaWxlfTp7bGluZX0se2NvbH1dXCIscy5hcmdzW3MuYXJncy5sZW5ndGgtMV0uc3RhcnQpLHIud2FybihlLnRvU3RyaW5nKCkpfX12YXIgRT1uJiZwLmJvZHlbMF07aWYoci5vcHRpb24oXCJpbmxpbmVcIikmJkUgaW5zdGFuY2VvZiBUZSYmKCEoRj1FLnZhbHVlKXx8Ri5pc19jb25zdGFudF9leHByZXNzaW9uKCkpKXt2YXIgaz1zLmFyZ3MuY29uY2F0KEZ8fFgoRW4scykpO3JldHVybiBNKHMsaykub3B0aW1pemUocil9aWYobil7dmFyIEQsRixDLEIsUz0tMTtpZihyLm9wdGlvbihcImlubGluZVwiKSYmIXAudXNlc19hcmd1bWVudHMmJiFwLnVzZXNfZXZhbCYmIShwLm5hbWUmJnAgaW5zdGFuY2VvZiBGZSkmJihGPWZ1bmN0aW9uKGUpe3ZhciBuPXAuYm9keS5sZW5ndGg7aWYoci5vcHRpb24oXCJpbmxpbmVcIik8MylyZXR1cm4gMT09biYmJChlKTtlPW51bGw7Zm9yKHZhciB0PTA7dDxuO3QrKyl7dmFyIGk9cC5ib2R5W3RdO2lmKGkgaW5zdGFuY2VvZiBMZSl7aWYoZSYmIW9lKGkuZGVmaW5pdGlvbnMsZnVuY3Rpb24oZSl7cmV0dXJuIWUudmFsdWV9KSlyZXR1cm4hMX1lbHNle2lmKGkgaW5zdGFuY2VvZiBoZSljb250aW51ZTtpZihlKXJldHVybiExO2U9aX19cmV0dXJuICQoZSl9KEUpKSYmKGU9PT1wfHxyLm9wdGlvbihcInVudXNlZFwiKSYmMT09KEQ9ZS5kZWZpbml0aW9uKCkpLnJlZmVyZW5jZXMubGVuZ3RoJiYhUChyLEQpJiZwLmlzX2NvbnN0YW50X2V4cHJlc3Npb24oZS5zY29wZSkpJiYhcy5wdXJlJiYhcC5jb250YWluc190aGlzKCkmJmZ1bmN0aW9uKCl7dmFyIGU9T2JqZWN0LmNyZWF0ZShudWxsKTtkb3tpZigoQz1yLnBhcmVudCgrK1MpKWluc3RhbmNlb2YgSWUpZVtDLmFyZ25hbWUubmFtZV09ITA7ZWxzZSBpZihDIGluc3RhbmNlb2YgX2UpQj1bXTtlbHNlIGlmKEMgaW5zdGFuY2VvZiBfbiYmQy5maXhlZF92YWx1ZSgpaW5zdGFuY2VvZiBBZSlyZXR1cm4hMX13aGlsZSghKEMgaW5zdGFuY2VvZiBBZSkpO3ZhciBuPSEoQyBpbnN0YW5jZW9mIEVlKXx8ci50b3BsZXZlbC52YXJzLHQ9ci5vcHRpb24oXCJpbmxpbmVcIik7cmV0dXJuISghZnVuY3Rpb24oZSxuKXtmb3IodmFyIHQ9cC5ib2R5Lmxlbmd0aCxpPTA7aTx0O2krKyl7dmFyIHI9cC5ib2R5W2ldO2lmKHIgaW5zdGFuY2VvZiBMZSl7aWYoIW4pcmV0dXJuITE7Zm9yKHZhciBvPXIuZGVmaW5pdGlvbnMubGVuZ3RoOzA8PS0tbzspe3ZhciBhPXIuZGVmaW5pdGlvbnNbb10ubmFtZTtpZihlW2EubmFtZV18fFIoYS5uYW1lKXx8Qy52YXJfbmFtZXMoKVthLm5hbWVdKXJldHVybiExO0ImJkIucHVzaChhLmRlZmluaXRpb24oKSl9fX1yZXR1cm4hMH0oZSwzPD10JiZuKXx8IWZ1bmN0aW9uKGUsbil7Zm9yKHZhciB0PTAsaT1wLmFyZ25hbWVzLmxlbmd0aDt0PGk7dCsrKXt2YXIgcj1wLmFyZ25hbWVzW3RdO2lmKCFyLl9fdW51c2VkKXtpZighbnx8ZVtyLm5hbWVdfHxSKHIubmFtZSl8fEMudmFyX25hbWVzKClbci5uYW1lXSlyZXR1cm4hMTtCJiZCLnB1c2goci5kZWZpbml0aW9uKCkpfX1yZXR1cm4hMH0oZSwyPD10JiZuKXx8QiYmMCE9Qi5sZW5ndGgmJlUocCxCKSl9KCkpcmV0dXJuIHAuX3NxdWVlemVkPSEwLE0ocyxmdW5jdGlvbigpe3ZhciBlPVtdLG49W107KGZ1bmN0aW9uKGUsbil7Zm9yKHZhciB0PXAuYXJnbmFtZXMubGVuZ3RoLGk9cy5hcmdzLmxlbmd0aDstLWk+PXQ7KW4ucHVzaChzLmFyZ3NbaV0pO2ZvcihpPXQ7MDw9LS1pOyl7dmFyIHI9cC5hcmduYW1lc1tpXSxvPXMuYXJnc1tpXTtpZihyLl9fdW51c2VkfHxDLnZhcl9uYW1lcygpW3IubmFtZV0pbyYmbi5wdXNoKG8pO2Vsc2V7dmFyIGE9WChsbixyLHIpO3IuZGVmaW5pdGlvbigpLm9yaWcucHVzaChhKSwhbyYmQiYmKG89WChFbixzKSkseihlLG4sYSxvKX19ZS5yZXZlcnNlKCksbi5yZXZlcnNlKCl9KShlLG4pLGZ1bmN0aW9uKGUsbil7Zm9yKHZhciB0PW4ubGVuZ3RoLGk9MCxyPXAuYm9keS5sZW5ndGg7aTxyO2krKyl7dmFyIG89cC5ib2R5W2ldO2lmKG8gaW5zdGFuY2VvZiBMZSlmb3IodmFyIGE9MCxzPW8uZGVmaW5pdGlvbnMubGVuZ3RoO2E8czthKyspe3ZhciB1PW8uZGVmaW5pdGlvbnNbYV0sYz11Lm5hbWU7aWYoeihlLG4sYyx1LnZhbHVlKSxCKXt2YXIgZj1jLmRlZmluaXRpb24oKSxsPVgoX24sYyxjKTtmLnJlZmVyZW5jZXMucHVzaChsKSxuLnNwbGljZSh0KyssMCxYKHJuLHUse29wZXJhdG9yOlwiPVwiLGxlZnQ6bCxyaWdodDpYKEVuLGMpfSkpfX19fShlLG4pLG4ucHVzaChGKSxlLmxlbmd0aCYmKG89Qy5ib2R5LmluZGV4T2Yoci5wYXJlbnQoUy0xKSkrMSxDLmJvZHkuc3BsaWNlKG8sMCxYKExlLHAse2RlZmluaXRpb25zOmV9KSkpO3JldHVybiBufSgpKS5vcHRpbWl6ZShyKTtpZihyLm9wdGlvbihcInNpZGVfZWZmZWN0c1wiKSYmb2UocC5ib2R5LGopKXtrPXMuYXJncy5jb25jYXQoWChFbixzKSk7cmV0dXJuIE0ocyxrKS5vcHRpbWl6ZShyKX19aWYoci5vcHRpb24oXCJkcm9wX2NvbnNvbGVcIikmJmUgaW5zdGFuY2VvZiBHZSl7Zm9yKHZhciBUPWUuZXhwcmVzc2lvbjtULmV4cHJlc3Npb247KVQ9VC5leHByZXNzaW9uO2lmKEgoVCkmJlwiY29uc29sZVwiPT1ULm5hbWUpcmV0dXJuIFgoRW4scykub3B0aW1pemUocil9aWYoci5vcHRpb24oXCJuZWdhdGVfaWlmZVwiKSYmci5wYXJlbnQoKWluc3RhbmNlb2YgbGUmJk4ocykpcmV0dXJuIHMubmVnYXRlKHIsITApO3ZhciBPPXMuZXZhbHVhdGUocik7cmV0dXJuIE8hPT1zPyhPPXEoTyxzKS5vcHRpbWl6ZShyKSxJKHIsTyxzKSk6cztmdW5jdGlvbiAkKGUpe3JldHVybiBlP2UgaW5zdGFuY2VvZiBUZT9lLnZhbHVlP2UudmFsdWUuY2xvbmUoITApOlgoRW4scyk6ZSBpbnN0YW5jZW9mIGxlP1goUWUsZSx7b3BlcmF0b3I6XCJ2b2lkXCIsZXhwcmVzc2lvbjplLmJvZHkuY2xvbmUoITApfSk6dm9pZCAwOlgoRW4scyl9ZnVuY3Rpb24geihlLG4sdCxpKXt2YXIgcj10LmRlZmluaXRpb24oKTtDLnZhcmlhYmxlcy5zZXQodC5uYW1lLHIpLEMuZW5jbG9zZWQucHVzaChyKSxDLnZhcl9uYW1lcygpW3QubmFtZV18fChDLnZhcl9uYW1lcygpW3QubmFtZV09ITAsZS5wdXNoKFgoVmUsdCx7bmFtZTp0LHZhbHVlOm51bGx9KSkpO3ZhciBvPVgoX24sdCx0KTtyLnJlZmVyZW5jZXMucHVzaChvKSxpJiZuLnB1c2goWChybixzLHtvcGVyYXRvcjpcIj1cIixsZWZ0Om8scmlnaHQ6aX0pKX19KSxlKEplLGZ1bmN0aW9uKGUsbil7aWYobi5vcHRpb24oXCJ1bnNhZmVcIikpe3ZhciB0PWUuZXhwcmVzc2lvbjtpZihIKHQpKXN3aXRjaCh0Lm5hbWUpe2Nhc2VcIk9iamVjdFwiOmNhc2VcIlJlZ0V4cFwiOmNhc2VcIkZ1bmN0aW9uXCI6Y2FzZVwiRXJyb3JcIjpjYXNlXCJBcnJheVwiOnJldHVybiBYKFllLGUsZSkudHJhbnNmb3JtKG4pfX1yZXR1cm4gZX0pLGUoV2UsZnVuY3Rpb24oZSx0KXtpZighdC5vcHRpb24oXCJzaWRlX2VmZmVjdHNcIikpcmV0dXJuIGU7dmFyIGkscixvPVtdO2k9JCh0KSxyPWUuZXhwcmVzc2lvbnMubGVuZ3RoLTEsZS5leHByZXNzaW9ucy5mb3JFYWNoKGZ1bmN0aW9uKGUsbil7bjxyJiYoZT1lLmRyb3Bfc2lkZV9lZmZlY3RfZnJlZSh0LGkpKSxlJiYobChvLGUpLGk9ITEpfSk7dmFyIG49by5sZW5ndGgtMTtyZXR1cm4gZnVuY3Rpb24oKXtmb3IoOzA8biYmZyhvW25dLHQpOyluLS07bjxvLmxlbmd0aC0xJiYob1tuXT1YKFFlLGUse29wZXJhdG9yOlwidm9pZFwiLGV4cHJlc3Npb246b1tuXX0pLG8ubGVuZ3RoPW4rMSl9KCksMD09bj8oZT1aKHQucGFyZW50KCksdC5zZWxmKCksb1swXSkpaW5zdGFuY2VvZiBXZXx8KGU9ZS5vcHRpbWl6ZSh0KSk6ZS5leHByZXNzaW9ucz1vLGV9KSxLZS5ERUZNRVRIT0QoXCJsaWZ0X3NlcXVlbmNlc1wiLGZ1bmN0aW9uKGUpe2lmKGUub3B0aW9uKFwic2VxdWVuY2VzXCIpJiZ0aGlzLmV4cHJlc3Npb24gaW5zdGFuY2VvZiBXZSl7dmFyIG49dGhpcy5leHByZXNzaW9uLmV4cHJlc3Npb25zLnNsaWNlKCksdD10aGlzLmNsb25lKCk7cmV0dXJuIHQuZXhwcmVzc2lvbj1uLnBvcCgpLG4ucHVzaCh0KSxNKHRoaXMsbikub3B0aW1pemUoZSl9cmV0dXJuIHRoaXN9KSxlKGVuLGZ1bmN0aW9uKGUsbil7cmV0dXJuIGUubGlmdF9zZXF1ZW5jZXMobil9KSxlKFFlLGZ1bmN0aW9uKGUsbil7dmFyIHQ9ZS5leHByZXNzaW9uO2lmKFwiZGVsZXRlXCI9PWUub3BlcmF0b3ImJiEodCBpbnN0YW5jZW9mIF9ufHx0IGluc3RhbmNlb2YgR2V8fFEodCkpKXJldHVybiB0IGluc3RhbmNlb2YgV2U/KCh0PXQuZXhwcmVzc2lvbnMuc2xpY2UoKSkucHVzaChYKEJuLGUpKSxNKGUsdCkub3B0aW1pemUobikpOk0oZSxbdCxYKEJuLGUpXSkub3B0aW1pemUobik7dmFyIGk9ZS5saWZ0X3NlcXVlbmNlcyhuKTtpZihpIT09ZSlyZXR1cm4gaTtpZihuLm9wdGlvbihcInNpZGVfZWZmZWN0c1wiKSYmXCJ2b2lkXCI9PWUub3BlcmF0b3IpcmV0dXJuKHQ9dC5kcm9wX3NpZGVfZWZmZWN0X2ZyZWUobikpPyhlLmV4cHJlc3Npb249dCxlKTpYKEVuLGUpLm9wdGltaXplKG4pO2lmKG4ub3B0aW9uKFwiYm9vbGVhbnNcIikpe2lmKFwiIVwiPT1lLm9wZXJhdG9yJiZ0LmlzX3RydXRoeSgpKXJldHVybiBNKGUsW3QsWChDbixlKV0pLm9wdGltaXplKG4pO2lmKG4uaW5fYm9vbGVhbl9jb250ZXh0KCkpc3dpdGNoKGUub3BlcmF0b3Ipe2Nhc2VcIiFcIjppZih0IGluc3RhbmNlb2YgUWUmJlwiIVwiPT10Lm9wZXJhdG9yKXJldHVybiB0LmV4cHJlc3Npb247dCBpbnN0YW5jZW9mIG5uJiYoZT1JKG4sZSx0Lm5lZ2F0ZShuLCQobikpKSk7YnJlYWs7Y2FzZVwidHlwZW9mXCI6cmV0dXJuIG4ud2FybihcIkJvb2xlYW4gZXhwcmVzc2lvbiBhbHdheXMgdHJ1ZSBbe2ZpbGV9OntsaW5lfSx7Y29sfV1cIixlLnN0YXJ0KSwodCBpbnN0YW5jZW9mIF9uP1goQm4sZSk6TShlLFt0LFgoQm4sZSldKSkub3B0aW1pemUobil9fWlmKFwiLVwiPT1lLm9wZXJhdG9yJiZ0IGluc3RhbmNlb2YgRG4mJih0PXQudHJhbnNmb3JtKG4pKSx0IGluc3RhbmNlb2Ygbm4mJihcIitcIj09ZS5vcGVyYXRvcnx8XCItXCI9PWUub3BlcmF0b3IpJiYoXCIqXCI9PXQub3BlcmF0b3J8fFwiL1wiPT10Lm9wZXJhdG9yfHxcIiVcIj09dC5vcGVyYXRvcikpcmV0dXJuIFgobm4sZSx7b3BlcmF0b3I6dC5vcGVyYXRvcixsZWZ0OlgoUWUsdC5sZWZ0LHtvcGVyYXRvcjplLm9wZXJhdG9yLGV4cHJlc3Npb246dC5sZWZ0fSkscmlnaHQ6dC5yaWdodH0pO2lmKFwiLVwiIT1lLm9wZXJhdG9yfHwhKHQgaW5zdGFuY2VvZiB5bnx8dCBpbnN0YW5jZW9mIERuKSl7dmFyIHI9ZS5ldmFsdWF0ZShuKTtpZihyIT09ZSlyZXR1cm4gSShuLHI9cShyLGUpLm9wdGltaXplKG4pLGUpfXJldHVybiBlfSksbm4uREVGTUVUSE9EKFwibGlmdF9zZXF1ZW5jZXNcIixmdW5jdGlvbihlKXtpZihlLm9wdGlvbihcInNlcXVlbmNlc1wiKSl7aWYodGhpcy5sZWZ0IGluc3RhbmNlb2YgV2Upe3ZhciBuPXRoaXMubGVmdC5leHByZXNzaW9ucy5zbGljZSgpO3JldHVybih0PXRoaXMuY2xvbmUoKSkubGVmdD1uLnBvcCgpLG4ucHVzaCh0KSxNKHRoaXMsbikub3B0aW1pemUoZSl9aWYodGhpcy5yaWdodCBpbnN0YW5jZW9mIFdlJiYhdGhpcy5sZWZ0Lmhhc19zaWRlX2VmZmVjdHMoZSkpe2Zvcih2YXIgdCxpPVwiPVwiPT10aGlzLm9wZXJhdG9yJiZ0aGlzLmxlZnQgaW5zdGFuY2VvZiBfbixyPShuPXRoaXMucmlnaHQuZXhwcmVzc2lvbnMpLmxlbmd0aC0xLG89MDtvPHImJihpfHwhbltvXS5oYXNfc2lkZV9lZmZlY3RzKGUpKTtvKyspO2lmKG89PXIpcmV0dXJuIG49bi5zbGljZSgpLCh0PXRoaXMuY2xvbmUoKSkucmlnaHQ9bi5wb3AoKSxuLnB1c2godCksTSh0aGlzLG4pLm9wdGltaXplKGUpO2lmKDA8bylyZXR1cm4odD10aGlzLmNsb25lKCkpLnJpZ2h0PU0odGhpcy5yaWdodCxuLnNsaWNlKG8pKSwobj1uLnNsaWNlKDAsbykpLnB1c2godCksTSh0aGlzLG4pLm9wdGltaXplKGUpfX1yZXR1cm4gdGhpc30pO3ZhciBFPVcoXCI9PSA9PT0gIT0gIT09ICogJiB8IF5cIik7ZnVuY3Rpb24gUChlLG4pe2Zvcih2YXIgdCxpPTA7dD1lLnBhcmVudChpKTtpKyspaWYodCBpbnN0YW5jZW9mIGtlKXt2YXIgcj10Lm5hbWU7aWYociYmci5kZWZpbml0aW9uKCk9PT1uKWJyZWFrfXJldHVybiB0fWZ1bmN0aW9uIGsoZSxuKXtyZXR1cm4gZSBpbnN0YW5jZW9mIF9ufHxlLlRZUEU9PT1uLlRZUEV9ZnVuY3Rpb24gVSh0LG4pe3ZhciBpPSExLHI9bmV3IFNuKGZ1bmN0aW9uKGUpe3JldHVybiEhaXx8KGUgaW5zdGFuY2VvZiBfbiYmdGUoZS5kZWZpbml0aW9uKCksbik/aT0hMDp2b2lkIDApfSksbz1uZXcgU24oZnVuY3Rpb24oZSl7aWYoaSlyZXR1cm4hMDtpZihlIGluc3RhbmNlb2YgQWUmJmUhPT10KXt2YXIgbj1vLnBhcmVudCgpO2lmKG4gaW5zdGFuY2VvZiBZZSYmbi5leHByZXNzaW9uPT09ZSlyZXR1cm47cmV0dXJuIGUud2FsayhyKSwhMH19KTtyZXR1cm4gdC53YWxrKG8pLGl9ZShubixmdW5jdGlvbih0LG4pe2Z1bmN0aW9uIGkoKXtyZXR1cm4gdC5sZWZ0LmlzX2NvbnN0YW50KCl8fHQucmlnaHQuaXNfY29uc3RhbnQoKXx8IXQubGVmdC5oYXNfc2lkZV9lZmZlY3RzKG4pJiYhdC5yaWdodC5oYXNfc2lkZV9lZmZlY3RzKG4pfWZ1bmN0aW9uIGUoZSl7aWYoaSgpKXtlJiYodC5vcGVyYXRvcj1lKTt2YXIgbj10LmxlZnQ7dC5sZWZ0PXQucmlnaHQsdC5yaWdodD1ufX1pZihFKHQub3BlcmF0b3IpJiZ0LnJpZ2h0LmlzX2NvbnN0YW50KCkmJiF0LmxlZnQuaXNfY29uc3RhbnQoKSYmKHQubGVmdCBpbnN0YW5jZW9mIG5uJiZKblt0LmxlZnQub3BlcmF0b3JdPj1Kblt0Lm9wZXJhdG9yXXx8ZSgpKSx0PXQubGlmdF9zZXF1ZW5jZXMobiksbi5vcHRpb24oXCJjb21wYXJpc29uc1wiKSlzd2l0Y2godC5vcGVyYXRvcil7Y2FzZVwiPT09XCI6Y2FzZVwiIT09XCI6dmFyIHI9ITA7KHQubGVmdC5pc19zdHJpbmcobikmJnQucmlnaHQuaXNfc3RyaW5nKG4pfHx0LmxlZnQuaXNfbnVtYmVyKG4pJiZ0LnJpZ2h0LmlzX251bWJlcihuKXx8dC5sZWZ0LmlzX2Jvb2xlYW4oKSYmdC5yaWdodC5pc19ib29sZWFuKCl8fHQubGVmdC5lcXVpdmFsZW50X3RvKHQucmlnaHQpKSYmKHQub3BlcmF0b3I9dC5vcGVyYXRvci5zdWJzdHIoMCwyKSk7Y2FzZVwiPT1cIjpjYXNlXCIhPVwiOmlmKCFyJiZnKHQubGVmdCxuKSl0LmxlZnQ9WCh4bix0LmxlZnQpO2Vsc2UgaWYobi5vcHRpb24oXCJ0eXBlb2ZzXCIpJiZ0LmxlZnQgaW5zdGFuY2VvZiBibiYmXCJ1bmRlZmluZWRcIj09dC5sZWZ0LnZhbHVlJiZ0LnJpZ2h0IGluc3RhbmNlb2YgUWUmJlwidHlwZW9mXCI9PXQucmlnaHQub3BlcmF0b3Ipe3ZhciBvPXQucmlnaHQuZXhwcmVzc2lvbjsobyBpbnN0YW5jZW9mIF9uPyFvLmlzX2RlY2xhcmVkKG4pOm8gaW5zdGFuY2VvZiBHZSYmbi5vcHRpb24oXCJpZThcIikpfHwodC5yaWdodD1vLHQubGVmdD1YKEVuLHQubGVmdCkub3B0aW1pemUobiksMj09dC5vcGVyYXRvci5sZW5ndGgmJih0Lm9wZXJhdG9yKz1cIj1cIikpfWVsc2UgaWYodC5sZWZ0IGluc3RhbmNlb2YgX24mJnQucmlnaHQgaW5zdGFuY2VvZiBfbiYmdC5sZWZ0LmRlZmluaXRpb24oKT09PXQucmlnaHQuZGVmaW5pdGlvbigpJiYoKHU9dC5sZWZ0LmZpeGVkX3ZhbHVlKCkpaW5zdGFuY2VvZiBvbnx8dSBpbnN0YW5jZW9mIGtlfHx1IGluc3RhbmNlb2YgYW4pKXJldHVybiBYKFwiPVwiPT10Lm9wZXJhdG9yWzBdP0JuOkNuLHQpO2JyZWFrO2Nhc2VcIiYmXCI6Y2FzZVwifHxcIjp2YXIgYT10LmxlZnQ7aWYoYS5vcGVyYXRvcj09dC5vcGVyYXRvciYmKGE9YS5yaWdodCksYSBpbnN0YW5jZW9mIG5uJiZhLm9wZXJhdG9yPT0oXCImJlwiPT10Lm9wZXJhdG9yP1wiIT09XCI6XCI9PT1cIikmJnQucmlnaHQgaW5zdGFuY2VvZiBubiYmYS5vcGVyYXRvcj09dC5yaWdodC5vcGVyYXRvciYmKGcoYS5sZWZ0LG4pJiZ0LnJpZ2h0LmxlZnQgaW5zdGFuY2VvZiB4bnx8YS5sZWZ0IGluc3RhbmNlb2YgeG4mJmcodC5yaWdodC5sZWZ0LG4pKSYmIWEucmlnaHQuaGFzX3NpZGVfZWZmZWN0cyhuKSYmYS5yaWdodC5lcXVpdmFsZW50X3RvKHQucmlnaHQucmlnaHQpKXt2YXIgcz1YKG5uLHQse29wZXJhdG9yOmEub3BlcmF0b3Iuc2xpY2UoMCwtMSksbGVmdDpYKHhuLHQpLHJpZ2h0OmEucmlnaHR9KTtyZXR1cm4gYSE9PXQubGVmdCYmKHM9WChubix0LHtvcGVyYXRvcjp0Lm9wZXJhdG9yLGxlZnQ6dC5sZWZ0LmxlZnQscmlnaHQ6c30pKSxzfX12YXIgdTtpZihuLm9wdGlvbihcImJvb2xlYW5zXCIpJiZcIitcIj09dC5vcGVyYXRvciYmbi5pbl9ib29sZWFuX2NvbnRleHQoKSl7dmFyIGM9dC5sZWZ0LmV2YWx1YXRlKG4pLGY9dC5yaWdodC5ldmFsdWF0ZShuKTtpZihjJiZcInN0cmluZ1wiPT10eXBlb2YgYylyZXR1cm4gbi53YXJuKFwiKyBpbiBib29sZWFuIGNvbnRleHQgYWx3YXlzIHRydWUgW3tmaWxlfTp7bGluZX0se2NvbH1dXCIsdC5zdGFydCksTSh0LFt0LnJpZ2h0LFgoQm4sdCldKS5vcHRpbWl6ZShuKTtpZihmJiZcInN0cmluZ1wiPT10eXBlb2YgZilyZXR1cm4gbi53YXJuKFwiKyBpbiBib29sZWFuIGNvbnRleHQgYWx3YXlzIHRydWUgW3tmaWxlfTp7bGluZX0se2NvbH1dXCIsdC5zdGFydCksTSh0LFt0LmxlZnQsWChCbix0KV0pLm9wdGltaXplKG4pfWlmKG4ub3B0aW9uKFwiY29tcGFyaXNvbnNcIikmJnQuaXNfYm9vbGVhbigpKXtpZighKG4ucGFyZW50KClpbnN0YW5jZW9mIG5uKXx8bi5wYXJlbnQoKWluc3RhbmNlb2Ygcm4pe3ZhciBsPVgoUWUsdCx7b3BlcmF0b3I6XCIhXCIsZXhwcmVzc2lvbjp0Lm5lZ2F0ZShuLCQobikpfSk7dD1JKG4sdCxsKX1zd2l0Y2godC5vcGVyYXRvcil7Y2FzZVwiPlwiOmUoXCI8XCIpO2JyZWFrO2Nhc2VcIj49XCI6ZShcIjw9XCIpfX1pZihcIitcIj09dC5vcGVyYXRvcil7aWYodC5yaWdodCBpbnN0YW5jZW9mIGJuJiZcIlwiPT10LnJpZ2h0LmdldFZhbHVlKCkmJnQubGVmdC5pc19zdHJpbmcobikpcmV0dXJuIHQubGVmdDtpZih0LmxlZnQgaW5zdGFuY2VvZiBibiYmXCJcIj09dC5sZWZ0LmdldFZhbHVlKCkmJnQucmlnaHQuaXNfc3RyaW5nKG4pKXJldHVybiB0LnJpZ2h0O2lmKHQubGVmdCBpbnN0YW5jZW9mIG5uJiZcIitcIj09dC5sZWZ0Lm9wZXJhdG9yJiZ0LmxlZnQubGVmdCBpbnN0YW5jZW9mIGJuJiZcIlwiPT10LmxlZnQubGVmdC5nZXRWYWx1ZSgpJiZ0LnJpZ2h0LmlzX3N0cmluZyhuKSlyZXR1cm4gdC5sZWZ0PXQubGVmdC5yaWdodCx0LnRyYW5zZm9ybShuKX1pZihuLm9wdGlvbihcImV2YWx1YXRlXCIpKXtzd2l0Y2godC5vcGVyYXRvcil7Y2FzZVwiJiZcIjppZighKGM9bSh0LmxlZnQpKSlyZXR1cm4gbi53YXJuKFwiQ29uZGl0aW9uIGxlZnQgb2YgJiYgYWx3YXlzIGZhbHNlIFt7ZmlsZX06e2xpbmV9LHtjb2x9XVwiLHQuc3RhcnQpLFoobi5wYXJlbnQoKSxuLnNlbGYoKSx0LmxlZnQpLm9wdGltaXplKG4pO2lmKCEoYyBpbnN0YW5jZW9mIHNlKSlyZXR1cm4gbi53YXJuKFwiQ29uZGl0aW9uIGxlZnQgb2YgJiYgYWx3YXlzIHRydWUgW3tmaWxlfTp7bGluZX0se2NvbH1dXCIsdC5zdGFydCksTSh0LFt0LmxlZnQsdC5yaWdodF0pLm9wdGltaXplKG4pO2lmKGY9dC5yaWdodC5ldmFsdWF0ZShuKSl7aWYoIShmIGluc3RhbmNlb2Ygc2UpKXtpZihcIiYmXCI9PShwPW4ucGFyZW50KCkpLm9wZXJhdG9yJiZwLmxlZnQ9PT1uLnNlbGYoKXx8bi5vcHRpb24oXCJib29sZWFuc1wiKSYmbi5pbl9ib29sZWFuX2NvbnRleHQoKSlyZXR1cm4gbi53YXJuKFwiRHJvcHBpbmcgc2lkZS1lZmZlY3QtZnJlZSAmJiBbe2ZpbGV9OntsaW5lfSx7Y29sfV1cIix0LnN0YXJ0KSx0LmxlZnQub3B0aW1pemUobil9fWVsc2V7aWYobi5vcHRpb24oXCJib29sZWFuc1wiKSYmbi5pbl9ib29sZWFuX2NvbnRleHQoKSlyZXR1cm4gbi53YXJuKFwiQm9vbGVhbiAmJiBhbHdheXMgZmFsc2UgW3tmaWxlfTp7bGluZX0se2NvbH1dXCIsdC5zdGFydCksTSh0LFt0LmxlZnQsWChDbix0KV0pLm9wdGltaXplKG4pO3QuZmFsc3k9ITB9aWYoXCJ8fFwiPT10LmxlZnQub3BlcmF0b3IpaWYoIShkPXQubGVmdC5yaWdodC5ldmFsdWF0ZShuKSkpcmV0dXJuIFgodG4sdCx7Y29uZGl0aW9uOnQubGVmdC5sZWZ0LGNvbnNlcXVlbnQ6dC5yaWdodCxhbHRlcm5hdGl2ZTp0LmxlZnQucmlnaHR9KS5vcHRpbWl6ZShuKTticmVhaztjYXNlXCJ8fFwiOnZhciBwLGQ7aWYoIShjPW0odC5sZWZ0KSkpcmV0dXJuIG4ud2FybihcIkNvbmRpdGlvbiBsZWZ0IG9mIHx8IGFsd2F5cyBmYWxzZSBbe2ZpbGV9OntsaW5lfSx7Y29sfV1cIix0LnN0YXJ0KSxNKHQsW3QubGVmdCx0LnJpZ2h0XSkub3B0aW1pemUobik7aWYoIShjIGluc3RhbmNlb2Ygc2UpKXJldHVybiBuLndhcm4oXCJDb25kaXRpb24gbGVmdCBvZiB8fCBhbHdheXMgdHJ1ZSBbe2ZpbGV9OntsaW5lfSx7Y29sfV1cIix0LnN0YXJ0KSxaKG4ucGFyZW50KCksbi5zZWxmKCksdC5sZWZ0KS5vcHRpbWl6ZShuKTtpZihmPXQucmlnaHQuZXZhbHVhdGUobikpe2lmKCEoZiBpbnN0YW5jZW9mIHNlKSl7aWYobi5vcHRpb24oXCJib29sZWFuc1wiKSYmbi5pbl9ib29sZWFuX2NvbnRleHQoKSlyZXR1cm4gbi53YXJuKFwiQm9vbGVhbiB8fCBhbHdheXMgdHJ1ZSBbe2ZpbGV9OntsaW5lfSx7Y29sfV1cIix0LnN0YXJ0KSxNKHQsW3QubGVmdCxYKEJuLHQpXSkub3B0aW1pemUobik7dC50cnV0aHk9ITB9fWVsc2UgaWYoXCJ8fFwiPT0ocD1uLnBhcmVudCgpKS5vcGVyYXRvciYmcC5sZWZ0PT09bi5zZWxmKCl8fG4ub3B0aW9uKFwiYm9vbGVhbnNcIikmJm4uaW5fYm9vbGVhbl9jb250ZXh0KCkpcmV0dXJuIG4ud2FybihcIkRyb3BwaW5nIHNpZGUtZWZmZWN0LWZyZWUgfHwgW3tmaWxlfTp7bGluZX0se2NvbH1dXCIsdC5zdGFydCksdC5sZWZ0Lm9wdGltaXplKG4pO2lmKFwiJiZcIj09dC5sZWZ0Lm9wZXJhdG9yKWlmKChkPXQubGVmdC5yaWdodC5ldmFsdWF0ZShuKSkmJiEoZCBpbnN0YW5jZW9mIHNlKSlyZXR1cm4gWCh0bix0LHtjb25kaXRpb246dC5sZWZ0LmxlZnQsY29uc2VxdWVudDp0LmxlZnQucmlnaHQsYWx0ZXJuYXRpdmU6dC5yaWdodH0pLm9wdGltaXplKG4pfXZhciBoPSEwO3N3aXRjaCh0Lm9wZXJhdG9yKXtjYXNlXCIrXCI6aWYodC5sZWZ0IGluc3RhbmNlb2YgZ24mJnQucmlnaHQgaW5zdGFuY2VvZiBubiYmXCIrXCI9PXQucmlnaHQub3BlcmF0b3ImJnQucmlnaHQubGVmdCBpbnN0YW5jZW9mIGduJiZ0LnJpZ2h0LmlzX3N0cmluZyhuKSYmKHQ9WChubix0LHtvcGVyYXRvcjpcIitcIixsZWZ0OlgoYm4sdC5sZWZ0LHt2YWx1ZTpcIlwiK3QubGVmdC5nZXRWYWx1ZSgpK3QucmlnaHQubGVmdC5nZXRWYWx1ZSgpLHN0YXJ0OnQubGVmdC5zdGFydCxlbmQ6dC5yaWdodC5sZWZ0LmVuZH0pLHJpZ2h0OnQucmlnaHQucmlnaHR9KSksdC5yaWdodCBpbnN0YW5jZW9mIGduJiZ0LmxlZnQgaW5zdGFuY2VvZiBubiYmXCIrXCI9PXQubGVmdC5vcGVyYXRvciYmdC5sZWZ0LnJpZ2h0IGluc3RhbmNlb2YgZ24mJnQubGVmdC5pc19zdHJpbmcobikmJih0PVgobm4sdCx7b3BlcmF0b3I6XCIrXCIsbGVmdDp0LmxlZnQubGVmdCxyaWdodDpYKGJuLHQucmlnaHQse3ZhbHVlOlwiXCIrdC5sZWZ0LnJpZ2h0LmdldFZhbHVlKCkrdC5yaWdodC5nZXRWYWx1ZSgpLHN0YXJ0OnQubGVmdC5yaWdodC5zdGFydCxlbmQ6dC5yaWdodC5lbmR9KX0pKSx0LmxlZnQgaW5zdGFuY2VvZiBubiYmXCIrXCI9PXQubGVmdC5vcGVyYXRvciYmdC5sZWZ0LmlzX3N0cmluZyhuKSYmdC5sZWZ0LnJpZ2h0IGluc3RhbmNlb2YgZ24mJnQucmlnaHQgaW5zdGFuY2VvZiBubiYmXCIrXCI9PXQucmlnaHQub3BlcmF0b3ImJnQucmlnaHQubGVmdCBpbnN0YW5jZW9mIGduJiZ0LnJpZ2h0LmlzX3N0cmluZyhuKSYmKHQ9WChubix0LHtvcGVyYXRvcjpcIitcIixsZWZ0Olgobm4sdC5sZWZ0LHtvcGVyYXRvcjpcIitcIixsZWZ0OnQubGVmdC5sZWZ0LHJpZ2h0OlgoYm4sdC5sZWZ0LnJpZ2h0LHt2YWx1ZTpcIlwiK3QubGVmdC5yaWdodC5nZXRWYWx1ZSgpK3QucmlnaHQubGVmdC5nZXRWYWx1ZSgpLHN0YXJ0OnQubGVmdC5yaWdodC5zdGFydCxlbmQ6dC5yaWdodC5sZWZ0LmVuZH0pfSkscmlnaHQ6dC5yaWdodC5yaWdodH0pKSx0LnJpZ2h0IGluc3RhbmNlb2YgUWUmJlwiLVwiPT10LnJpZ2h0Lm9wZXJhdG9yJiZ0LmxlZnQuaXNfbnVtYmVyKG4pKXt0PVgobm4sdCx7b3BlcmF0b3I6XCItXCIsbGVmdDp0LmxlZnQscmlnaHQ6dC5yaWdodC5leHByZXNzaW9ufSk7YnJlYWt9aWYodC5sZWZ0IGluc3RhbmNlb2YgUWUmJlwiLVwiPT10LmxlZnQub3BlcmF0b3ImJmkoKSYmdC5yaWdodC5pc19udW1iZXIobikpe3Q9WChubix0LHtvcGVyYXRvcjpcIi1cIixsZWZ0OnQucmlnaHQscmlnaHQ6dC5sZWZ0LmV4cHJlc3Npb259KTticmVha31jYXNlXCIqXCI6aD1uLm9wdGlvbihcInVuc2FmZV9tYXRoXCIpO2Nhc2VcIiZcIjpjYXNlXCJ8XCI6Y2FzZVwiXlwiOmlmKHQubGVmdC5pc19udW1iZXIobikmJnQucmlnaHQuaXNfbnVtYmVyKG4pJiZpKCkmJiEodC5sZWZ0IGluc3RhbmNlb2Ygbm4mJnQubGVmdC5vcGVyYXRvciE9dC5vcGVyYXRvciYmSm5bdC5sZWZ0Lm9wZXJhdG9yXT49Sm5bdC5vcGVyYXRvcl0pKXt2YXIgdj1YKG5uLHQse29wZXJhdG9yOnQub3BlcmF0b3IsbGVmdDp0LnJpZ2h0LHJpZ2h0OnQubGVmdH0pO3Q9dC5yaWdodCBpbnN0YW5jZW9mIGduJiYhKHQubGVmdCBpbnN0YW5jZW9mIGduKT9JKG4sdix0KTpJKG4sdCx2KX1oJiZ0LmlzX251bWJlcihuKSYmKHQucmlnaHQgaW5zdGFuY2VvZiBubiYmdC5yaWdodC5vcGVyYXRvcj09dC5vcGVyYXRvciYmKHQ9WChubix0LHtvcGVyYXRvcjp0Lm9wZXJhdG9yLGxlZnQ6WChubix0LmxlZnQse29wZXJhdG9yOnQub3BlcmF0b3IsbGVmdDp0LmxlZnQscmlnaHQ6dC5yaWdodC5sZWZ0LHN0YXJ0OnQubGVmdC5zdGFydCxlbmQ6dC5yaWdodC5sZWZ0LmVuZH0pLHJpZ2h0OnQucmlnaHQucmlnaHR9KSksdC5yaWdodCBpbnN0YW5jZW9mIGduJiZ0LmxlZnQgaW5zdGFuY2VvZiBubiYmdC5sZWZ0Lm9wZXJhdG9yPT10Lm9wZXJhdG9yJiYodC5sZWZ0LmxlZnQgaW5zdGFuY2VvZiBnbj90PVgobm4sdCx7b3BlcmF0b3I6dC5vcGVyYXRvcixsZWZ0Olgobm4sdC5sZWZ0LHtvcGVyYXRvcjp0Lm9wZXJhdG9yLGxlZnQ6dC5sZWZ0LmxlZnQscmlnaHQ6dC5yaWdodCxzdGFydDp0LmxlZnQubGVmdC5zdGFydCxlbmQ6dC5yaWdodC5lbmR9KSxyaWdodDp0LmxlZnQucmlnaHR9KTp0LmxlZnQucmlnaHQgaW5zdGFuY2VvZiBnbiYmKHQ9WChubix0LHtvcGVyYXRvcjp0Lm9wZXJhdG9yLGxlZnQ6WChubix0LmxlZnQse29wZXJhdG9yOnQub3BlcmF0b3IsbGVmdDp0LmxlZnQucmlnaHQscmlnaHQ6dC5yaWdodCxzdGFydDp0LmxlZnQucmlnaHQuc3RhcnQsZW5kOnQucmlnaHQuZW5kfSkscmlnaHQ6dC5sZWZ0LmxlZnR9KSkpLHQubGVmdCBpbnN0YW5jZW9mIG5uJiZ0LmxlZnQub3BlcmF0b3I9PXQub3BlcmF0b3ImJnQubGVmdC5yaWdodCBpbnN0YW5jZW9mIGduJiZ0LnJpZ2h0IGluc3RhbmNlb2Ygbm4mJnQucmlnaHQub3BlcmF0b3I9PXQub3BlcmF0b3ImJnQucmlnaHQubGVmdCBpbnN0YW5jZW9mIGduJiYodD1YKG5uLHQse29wZXJhdG9yOnQub3BlcmF0b3IsbGVmdDpYKG5uLHQubGVmdCx7b3BlcmF0b3I6dC5vcGVyYXRvcixsZWZ0Olgobm4sdC5sZWZ0LmxlZnQse29wZXJhdG9yOnQub3BlcmF0b3IsbGVmdDp0LmxlZnQucmlnaHQscmlnaHQ6dC5yaWdodC5sZWZ0LHN0YXJ0OnQubGVmdC5yaWdodC5zdGFydCxlbmQ6dC5yaWdodC5sZWZ0LmVuZH0pLHJpZ2h0OnQubGVmdC5sZWZ0fSkscmlnaHQ6dC5yaWdodC5yaWdodH0pKSl9fWlmKHQucmlnaHQgaW5zdGFuY2VvZiBubiYmdC5yaWdodC5vcGVyYXRvcj09dC5vcGVyYXRvciYmKGVlKHQub3BlcmF0b3IpfHxcIitcIj09dC5vcGVyYXRvciYmKHQucmlnaHQubGVmdC5pc19zdHJpbmcobil8fHQubGVmdC5pc19zdHJpbmcobikmJnQucmlnaHQucmlnaHQuaXNfc3RyaW5nKG4pKSkpcmV0dXJuIHQubGVmdD1YKG5uLHQubGVmdCx7b3BlcmF0b3I6dC5vcGVyYXRvcixsZWZ0OnQubGVmdCxyaWdodDp0LnJpZ2h0LmxlZnR9KSx0LnJpZ2h0PXQucmlnaHQucmlnaHQsdC50cmFuc2Zvcm0obik7dmFyIF89dC5ldmFsdWF0ZShuKTtyZXR1cm4gXyE9PXQ/KF89cShfLHQpLm9wdGltaXplKG4pLEkobixfLHQpKTp0O2Z1bmN0aW9uIG0oZSl7cmV0dXJuISFlLnRydXRoeXx8IWUuZmFsc3kmJighIWUuaXNfdHJ1dGh5KCl8fGUuZXZhbHVhdGUobikpfX0pLGUoX24sZnVuY3Rpb24oZSxuKXt2YXIgdCxpPWUucmVzb2x2ZV9kZWZpbmVzKG4pO2lmKGkpcmV0dXJuIGkub3B0aW1pemUobik7aWYoIW4ub3B0aW9uKFwiaWU4XCIpJiZIKGUpJiYoIWUuc2NvcGUudXNlc193aXRofHwhbi5maW5kX3BhcmVudCh4ZSkpKXN3aXRjaChlLm5hbWUpe2Nhc2VcInVuZGVmaW5lZFwiOnJldHVybiBYKEVuLGUpLm9wdGltaXplKG4pO2Nhc2VcIk5hTlwiOnJldHVybiBYKEFuLGUpLm9wdGltaXplKG4pO2Nhc2VcIkluZmluaXR5XCI6cmV0dXJuIFgoRG4sZSkub3B0aW1pemUobil9aWYobi5vcHRpb24oXCJyZWR1Y2VfdmFyc1wiKSYmbmUoZSxuLnBhcmVudCgpKSE9PWUpe3ZhciByPWUuZGVmaW5pdGlvbigpLG89ZS5maXhlZF92YWx1ZSgpLGE9ci5zaW5nbGVfdXNlO2lmKGEmJm8gaW5zdGFuY2VvZiBrZSlpZihyLnNjb3BlPT09ZS5zY29wZXx8bi5vcHRpb24oXCJyZWR1Y2VfZnVuY3NcIikmJjEhPXIuZXNjYXBlZCYmIW8uaW5saW5lZCl7aWYoUChuLHIpKWE9ITE7ZWxzZSBpZigoci5zY29wZSE9PWUuc2NvcGV8fHIub3JpZ1swXWluc3RhbmNlb2YgcG4pJiZcImZcIj09KGE9by5pc19jb25zdGFudF9leHByZXNzaW9uKGUuc2NvcGUpKSlmb3IodmFyIHM9ZS5zY29wZTsocyBpbnN0YW5jZW9mIENlfHxzIGluc3RhbmNlb2YgRmUpJiYocy5pbmxpbmVkPSEwKSxzPXMucGFyZW50X3Njb3BlOyk7fWVsc2UgYT0hMTtpZihhJiZvKXt2YXIgdTtpZihvIGluc3RhbmNlb2YgQ2UmJihvLl9zcXVlZXplZD0hMCxvPVgoRmUsbyxvKSksMDxyLnJlY3Vyc2l2ZV9yZWZzJiZvLm5hbWUgaW5zdGFuY2VvZiBkbil7dmFyIGM9KHU9by5jbG9uZSghMCkpLm5hbWUuZGVmaW5pdGlvbigpLGY9dS52YXJpYWJsZXMuZ2V0KHUubmFtZS5uYW1lKSxsPWYmJmYub3JpZ1swXTtsIGluc3RhbmNlb2YgaG58fCgoKGw9WChobix1Lm5hbWUsdS5uYW1lKSkuc2NvcGU9dSkubmFtZT1sLGY9dS5kZWZfZnVuY3Rpb24obCkpLHUud2FsayhuZXcgU24oZnVuY3Rpb24oZSl7ZSBpbnN0YW5jZW9mIF9uJiZlLmRlZmluaXRpb24oKT09PWMmJihlLnRoZWRlZj1mKS5yZWZlcmVuY2VzLnB1c2goZSl9KSl9ZWxzZSh1PW8ub3B0aW1pemUobikpPT09byYmKHU9by5jbG9uZSghMCkpO3JldHVybiB1fWlmKG8mJnZvaWQgMD09PXIuc2hvdWxkX3JlcGxhY2Upe3ZhciBwO2lmKG8gaW5zdGFuY2VvZiBtbilyLm9yaWdbMF1pbnN0YW5jZW9mIHBufHwhb2Uoci5yZWZlcmVuY2VzLGZ1bmN0aW9uKGUpe3JldHVybiByLnNjb3BlPT09ZS5zY29wZX0pfHwocD1vKTtlbHNle3ZhciBkPW8uZXZhbHVhdGUobik7ZD09PW98fCFuLm9wdGlvbihcInVuc2FmZV9yZWdleHBcIikmJmQgaW5zdGFuY2VvZiBSZWdFeHB8fChwPXEoZCxvKSl9aWYocCl7dmFyIGgsdj1wLm9wdGltaXplKG4pLnByaW50X3RvX3N0cmluZygpLmxlbmd0aDtvLndhbGsobmV3IFNuKGZ1bmN0aW9uKGUpe2lmKGUgaW5zdGFuY2VvZiBfbiYmKHQ9ITApLHQpcmV0dXJuITB9KSksdD9oPWZ1bmN0aW9uKCl7dmFyIGU9cC5vcHRpbWl6ZShuKTtyZXR1cm4gZT09PXA/ZS5jbG9uZSghMCk6ZX06KHY9TWF0aC5taW4odixvLnByaW50X3RvX3N0cmluZygpLmxlbmd0aCksaD1mdW5jdGlvbigpe3ZhciBlPXgocC5vcHRpbWl6ZShuKSxvKTtyZXR1cm4gZT09PXB8fGU9PT1vP2UuY2xvbmUoITApOmV9KTt2YXIgXz1yLm5hbWUubGVuZ3RoLG09MDtuLm9wdGlvbihcInVudXNlZFwiKSYmIW4uZXhwb3NlZChyKSYmKG09KF8rMit2KS8oci5yZWZlcmVuY2VzLmxlbmd0aC1yLmFzc2lnbm1lbnRzKSksci5zaG91bGRfcmVwbGFjZT12PD1fK20mJmh9ZWxzZSByLnNob3VsZF9yZXBsYWNlPSExfWlmKHIuc2hvdWxkX3JlcGxhY2UpcmV0dXJuIHIuc2hvdWxkX3JlcGxhY2UoKX1yZXR1cm4gZX0pLGUoRW4sZnVuY3Rpb24oZSxuKXtpZihuLm9wdGlvbihcInVuc2FmZV91bmRlZmluZWRcIikpe3ZhciB0PW8obixcInVuZGVmaW5lZFwiKTtpZih0KXt2YXIgaT1YKF9uLGUse25hbWU6XCJ1bmRlZmluZWRcIixzY29wZTp0LnNjb3BlLHRoZWRlZjp0fSk7cmV0dXJuIGkuaXNfdW5kZWZpbmVkPSEwLGl9fXZhciByPW5lKG4uc2VsZigpLG4ucGFyZW50KCkpO3JldHVybiByJiZrKHIsZSk/ZTpYKFFlLGUse29wZXJhdG9yOlwidm9pZFwiLGV4cHJlc3Npb246WCh5bixlLHt2YWx1ZTowfSl9KX0pLGUoRG4sZnVuY3Rpb24oZSxuKXt2YXIgdD1uZShuLnNlbGYoKSxuLnBhcmVudCgpKTtyZXR1cm4gdCYmayh0LGUpP2U6IW4ub3B0aW9uKFwia2VlcF9pbmZpbml0eVwiKXx8dCYmIWsodCxlKXx8byhuLFwiSW5maW5pdHlcIik/WChubixlLHtvcGVyYXRvcjpcIi9cIixsZWZ0OlgoeW4sZSx7dmFsdWU6MX0pLHJpZ2h0OlgoeW4sZSx7dmFsdWU6MH0pfSk6ZX0pLGUoQW4sZnVuY3Rpb24oZSxuKXt2YXIgdD1uZShuLnNlbGYoKSxuLnBhcmVudCgpKTtyZXR1cm4gdCYmIWsodCxlKXx8byhuLFwiTmFOXCIpP1gobm4sZSx7b3BlcmF0b3I6XCIvXCIsbGVmdDpYKHluLGUse3ZhbHVlOjB9KSxyaWdodDpYKHluLGUse3ZhbHVlOjB9KX0pOmV9KTt2YXIgRD1bXCIrXCIsXCItXCIsXCIvXCIsXCIqXCIsXCIlXCIsXCI+PlwiLFwiPDxcIixcIj4+PlwiLFwifFwiLFwiXlwiLFwiJlwiXSxGPVtcIipcIixcInxcIixcIl5cIixcIiZcIl07ZShybixmdW5jdGlvbihhLHMpe3ZhciBlO2lmKHMub3B0aW9uKFwiZGVhZF9jb2RlXCIpJiZhLmxlZnQgaW5zdGFuY2VvZiBfbiYmKGU9YS5sZWZ0LmRlZmluaXRpb24oKSkuc2NvcGU9PT1zLmZpbmRfcGFyZW50KGtlKSl7dmFyIG4sdD0wLGk9YTtkb3tpZihuPWksKGk9cy5wYXJlbnQodCsrKSlpbnN0YW5jZW9mIFNlKXtpZihyKHQsaSkpYnJlYWs7aWYoVShlLnNjb3BlLFtlXSkpYnJlYWs7cmV0dXJuXCI9XCI9PWEub3BlcmF0b3I/YS5yaWdodDooZS5maXhlZD0hMSxYKG5uLGEse29wZXJhdG9yOmEub3BlcmF0b3Iuc2xpY2UoMCwtMSksbGVmdDphLmxlZnQscmlnaHQ6YS5yaWdodH0pLm9wdGltaXplKHMpKX19d2hpbGUoaSBpbnN0YW5jZW9mIG5uJiZpLnJpZ2h0PT09bnx8aSBpbnN0YW5jZW9mIFdlJiZpLnRhaWxfbm9kZSgpPT09bil9cmV0dXJuXCI9XCI9PShhPWEubGlmdF9zZXF1ZW5jZXMocykpLm9wZXJhdG9yJiZhLmxlZnQgaW5zdGFuY2VvZiBfbiYmYS5yaWdodCBpbnN0YW5jZW9mIG5uJiYoYS5yaWdodC5sZWZ0IGluc3RhbmNlb2YgX24mJmEucmlnaHQubGVmdC5uYW1lPT1hLmxlZnQubmFtZSYmdGUoYS5yaWdodC5vcGVyYXRvcixEKT8oYS5vcGVyYXRvcj1hLnJpZ2h0Lm9wZXJhdG9yK1wiPVwiLGEucmlnaHQ9YS5yaWdodC5yaWdodCk6YS5yaWdodC5yaWdodCBpbnN0YW5jZW9mIF9uJiZhLnJpZ2h0LnJpZ2h0Lm5hbWU9PWEubGVmdC5uYW1lJiZ0ZShhLnJpZ2h0Lm9wZXJhdG9yLEYpJiYhYS5yaWdodC5sZWZ0Lmhhc19zaWRlX2VmZmVjdHMocykmJihhLm9wZXJhdG9yPWEucmlnaHQub3BlcmF0b3IrXCI9XCIsYS5yaWdodD1hLnJpZ2h0LmxlZnQpKSxhO2Z1bmN0aW9uIHIoZSxuKXt2YXIgdD1hLnJpZ2h0O2EucmlnaHQ9WCh4bix0KTt2YXIgaT1uLm1heV90aHJvdyhzKTthLnJpZ2h0PXQ7Zm9yKHZhciByLG89YS5sZWZ0LmRlZmluaXRpb24oKS5zY29wZTsocj1zLnBhcmVudChlKyspKSE9PW87KWlmKHIgaW5zdGFuY2VvZiBSZSl7aWYoci5iZmluYWxseSlyZXR1cm4hMDtpZihpJiZyLmJjYXRjaClyZXR1cm4hMH19fSksZSh0bixmdW5jdGlvbihlLG4pe2lmKCFuLm9wdGlvbihcImNvbmRpdGlvbmFsc1wiKSlyZXR1cm4gZTtpZihlLmNvbmRpdGlvbiBpbnN0YW5jZW9mIFdlKXt2YXIgdD1lLmNvbmRpdGlvbi5leHByZXNzaW9ucy5zbGljZSgpO3JldHVybiBlLmNvbmRpdGlvbj10LnBvcCgpLHQucHVzaChlKSxNKGUsdCl9dmFyIGk9ZS5jb25kaXRpb24uaXNfdHJ1dGh5KCl8fGUuY29uZGl0aW9uLnRhaWxfbm9kZSgpLmV2YWx1YXRlKG4pO2lmKCFpKXJldHVybiBuLndhcm4oXCJDb25kaXRpb24gYWx3YXlzIGZhbHNlIFt7ZmlsZX06e2xpbmV9LHtjb2x9XVwiLGUuc3RhcnQpLE0oZSxbZS5jb25kaXRpb24sZS5hbHRlcm5hdGl2ZV0pLm9wdGltaXplKG4pO2lmKCEoaSBpbnN0YW5jZW9mIHNlKSlyZXR1cm4gbi53YXJuKFwiQ29uZGl0aW9uIGFsd2F5cyB0cnVlIFt7ZmlsZX06e2xpbmV9LHtjb2x9XVwiLGUuc3RhcnQpLE0oZSxbZS5jb25kaXRpb24sZS5jb25zZXF1ZW50XSkub3B0aW1pemUobik7dmFyIHI9aS5uZWdhdGUobiwkKG4pKTtJKG4saSxyKT09PXImJihlPVgodG4sZSx7Y29uZGl0aW9uOnIsY29uc2VxdWVudDplLmFsdGVybmF0aXZlLGFsdGVybmF0aXZlOmUuY29uc2VxdWVudH0pKTt2YXIgbyxhPWUuY29uZGl0aW9uLHM9ZS5jb25zZXF1ZW50LHU9ZS5hbHRlcm5hdGl2ZTtpZihhIGluc3RhbmNlb2YgX24mJnMgaW5zdGFuY2VvZiBfbiYmYS5kZWZpbml0aW9uKCk9PT1zLmRlZmluaXRpb24oKSlyZXR1cm4gWChubixlLHtvcGVyYXRvcjpcInx8XCIsbGVmdDphLHJpZ2h0OnV9KTtpZihzIGluc3RhbmNlb2Ygcm4mJnUgaW5zdGFuY2VvZiBybiYmcy5vcGVyYXRvcj09dS5vcGVyYXRvciYmcy5sZWZ0LmVxdWl2YWxlbnRfdG8odS5sZWZ0KSYmKCFlLmNvbmRpdGlvbi5oYXNfc2lkZV9lZmZlY3RzKG4pfHxcIj1cIj09cy5vcGVyYXRvciYmIXMubGVmdC5oYXNfc2lkZV9lZmZlY3RzKG4pKSlyZXR1cm4gWChybixlLHtvcGVyYXRvcjpzLm9wZXJhdG9yLGxlZnQ6cy5sZWZ0LHJpZ2h0OlgodG4sZSx7Y29uZGl0aW9uOmUuY29uZGl0aW9uLGNvbnNlcXVlbnQ6cy5yaWdodCxhbHRlcm5hdGl2ZTp1LnJpZ2h0fSl9KTtpZihzIGluc3RhbmNlb2YgWWUmJnUuVFlQRT09PXMuVFlQRSYmMDxzLmFyZ3MubGVuZ3RoJiZzLmFyZ3MubGVuZ3RoPT11LmFyZ3MubGVuZ3RoJiZzLmV4cHJlc3Npb24uZXF1aXZhbGVudF90byh1LmV4cHJlc3Npb24pJiYhZS5jb25kaXRpb24uaGFzX3NpZGVfZWZmZWN0cyhuKSYmIXMuZXhwcmVzc2lvbi5oYXNfc2lkZV9lZmZlY3RzKG4pJiZcIm51bWJlclwiPT10eXBlb2Yobz1mdW5jdGlvbigpe2Zvcih2YXIgZT1zLmFyZ3Msbj11LmFyZ3MsdD0wLGk9ZS5sZW5ndGg7dDxpO3QrKylpZighZVt0XS5lcXVpdmFsZW50X3RvKG5bdF0pKXtmb3IodmFyIHI9dCsxO3I8aTtyKyspaWYoIWVbcl0uZXF1aXZhbGVudF90byhuW3JdKSlyZXR1cm47cmV0dXJuIHR9fSgpKSl7dmFyIGM9cy5jbG9uZSgpO3JldHVybiBjLmFyZ3Nbb109WCh0bixlLHtjb25kaXRpb246ZS5jb25kaXRpb24sY29uc2VxdWVudDpzLmFyZ3Nbb10sYWx0ZXJuYXRpdmU6dS5hcmdzW29dfSksY31pZihzIGluc3RhbmNlb2YgdG4mJnMuYWx0ZXJuYXRpdmUuZXF1aXZhbGVudF90byh1KSlyZXR1cm4gWCh0bixlLHtjb25kaXRpb246WChubixlLHtsZWZ0OmUuY29uZGl0aW9uLG9wZXJhdG9yOlwiJiZcIixyaWdodDpzLmNvbmRpdGlvbn0pLGNvbnNlcXVlbnQ6cy5jb25zZXF1ZW50LGFsdGVybmF0aXZlOnV9KTtpZihzLmVxdWl2YWxlbnRfdG8odSkpcmV0dXJuIE0oZSxbZS5jb25kaXRpb24sc10pLm9wdGltaXplKG4pO2lmKChzIGluc3RhbmNlb2YgV2V8fHUgaW5zdGFuY2VvZiBXZSkmJnMudGFpbF9ub2RlKCkuZXF1aXZhbGVudF90byh1LnRhaWxfbm9kZSgpKSlyZXR1cm4gTShlLFtYKHRuLGUse2NvbmRpdGlvbjplLmNvbmRpdGlvbixjb25zZXF1ZW50OmgocyksYWx0ZXJuYXRpdmU6aCh1KX0pLHMudGFpbF9ub2RlKCldKS5vcHRpbWl6ZShuKTtpZihzIGluc3RhbmNlb2Ygbm4mJlwifHxcIj09cy5vcGVyYXRvciYmcy5yaWdodC5lcXVpdmFsZW50X3RvKHUpKXJldHVybiBYKG5uLGUse29wZXJhdG9yOlwifHxcIixsZWZ0Olgobm4sZSx7b3BlcmF0b3I6XCImJlwiLGxlZnQ6ZS5jb25kaXRpb24scmlnaHQ6cy5sZWZ0fSkscmlnaHQ6dX0pLm9wdGltaXplKG4pO3ZhciBmPW4ub3B0aW9uKFwiYm9vbGVhbnNcIikmJm4uaW5fYm9vbGVhbl9jb250ZXh0KCk7cmV0dXJuIHAoZS5jb25zZXF1ZW50KT9kKGUuYWx0ZXJuYXRpdmUpP2woZS5jb25kaXRpb24pOlgobm4sZSx7b3BlcmF0b3I6XCJ8fFwiLGxlZnQ6bChlLmNvbmRpdGlvbikscmlnaHQ6ZS5hbHRlcm5hdGl2ZX0pOmQoZS5jb25zZXF1ZW50KT9wKGUuYWx0ZXJuYXRpdmUpP2woZS5jb25kaXRpb24ubmVnYXRlKG4pKTpYKG5uLGUse29wZXJhdG9yOlwiJiZcIixsZWZ0OmwoZS5jb25kaXRpb24ubmVnYXRlKG4pKSxyaWdodDplLmFsdGVybmF0aXZlfSk6cChlLmFsdGVybmF0aXZlKT9YKG5uLGUse29wZXJhdG9yOlwifHxcIixsZWZ0OmwoZS5jb25kaXRpb24ubmVnYXRlKG4pKSxyaWdodDplLmNvbnNlcXVlbnR9KTpkKGUuYWx0ZXJuYXRpdmUpP1gobm4sZSx7b3BlcmF0b3I6XCImJlwiLGxlZnQ6bChlLmNvbmRpdGlvbikscmlnaHQ6ZS5jb25zZXF1ZW50fSk6ZTtmdW5jdGlvbiBsKGUpe3JldHVybiBlLmlzX2Jvb2xlYW4oKT9lOlgoUWUsZSx7b3BlcmF0b3I6XCIhXCIsZXhwcmVzc2lvbjplLm5lZ2F0ZShuKX0pfWZ1bmN0aW9uIHAoZSl7cmV0dXJuIGUgaW5zdGFuY2VvZiBCbnx8ZiYmZSBpbnN0YW5jZW9mIGduJiZlLmdldFZhbHVlKCl8fGUgaW5zdGFuY2VvZiBRZSYmXCIhXCI9PWUub3BlcmF0b3ImJmUuZXhwcmVzc2lvbiBpbnN0YW5jZW9mIGduJiYhZS5leHByZXNzaW9uLmdldFZhbHVlKCl9ZnVuY3Rpb24gZChlKXtyZXR1cm4gZSBpbnN0YW5jZW9mIENufHxmJiZlIGluc3RhbmNlb2YgZ24mJiFlLmdldFZhbHVlKCl8fGUgaW5zdGFuY2VvZiBRZSYmXCIhXCI9PWUub3BlcmF0b3ImJmUuZXhwcmVzc2lvbiBpbnN0YW5jZW9mIGduJiZlLmV4cHJlc3Npb24uZ2V0VmFsdWUoKX1mdW5jdGlvbiBoKGUpe3JldHVybiBlIGluc3RhbmNlb2YgV2U/TShlLGUuZXhwcmVzc2lvbnMuc2xpY2UoMCwtMSkpOlgoeW4sZSx7dmFsdWU6MH0pfX0pLGUoRm4sZnVuY3Rpb24oZSxuKXtpZighbi5vcHRpb24oXCJib29sZWFuc1wiKSlyZXR1cm4gZTtpZihuLmluX2Jvb2xlYW5fY29udGV4dCgpKXJldHVybiBYKHluLGUse3ZhbHVlOitlLnZhbHVlfSk7dmFyIHQ9bi5wYXJlbnQoKTtyZXR1cm4gdCBpbnN0YW5jZW9mIG5uJiYoXCI9PVwiPT10Lm9wZXJhdG9yfHxcIiE9XCI9PXQub3BlcmF0b3IpPyhuLndhcm4oXCJOb24tc3RyaWN0IGVxdWFsaXR5IGFnYWluc3QgYm9vbGVhbjoge29wZXJhdG9yfSB7dmFsdWV9IFt7ZmlsZX06e2xpbmV9LHtjb2x9XVwiLHtvcGVyYXRvcjp0Lm9wZXJhdG9yLHZhbHVlOmUudmFsdWUsZmlsZTp0LnN0YXJ0LmZpbGUsbGluZTp0LnN0YXJ0LmxpbmUsY29sOnQuc3RhcnQuY29sfSksWCh5bixlLHt2YWx1ZTorZS52YWx1ZX0pKTpYKFFlLGUse29wZXJhdG9yOlwiIVwiLGV4cHJlc3Npb246WCh5bixlLHt2YWx1ZToxLWUudmFsdWV9KX0pfSksZShaZSxmdW5jdGlvbihlLG4pe3ZhciB0LGk9ZS5leHByZXNzaW9uLHI9ZS5wcm9wZXJ0eTtpZihuLm9wdGlvbihcInByb3BlcnRpZXNcIikpe3ZhciBvPXIuZXZhbHVhdGUobik7aWYobyE9PXIpe2lmKFwic3RyaW5nXCI9PXR5cGVvZiBvKWlmKFwidW5kZWZpbmVkXCI9PW8pbz12b2lkIDA7ZWxzZShoPXBhcnNlRmxvYXQobykpLnRvU3RyaW5nKCk9PW8mJihvPWgpO3I9ZS5wcm9wZXJ0eT14KHIscShvLHIpLnRyYW5zZm9ybShuKSk7dmFyIGE9XCJcIitvO2lmKE5uKGEpJiZhLmxlbmd0aDw9ci5wcmludF90b19zdHJpbmcoKS5sZW5ndGgrMSlyZXR1cm4gWChYZSxlLHtleHByZXNzaW9uOmkscHJvcGVydHk6YX0pLm9wdGltaXplKG4pfX1pZihuZShlLG4ucGFyZW50KCkpKXJldHVybiBlO2lmKG8hPT1yKXt2YXIgcz1lLmZsYXR0ZW5fb2JqZWN0KGEsbik7cyYmKGk9ZS5leHByZXNzaW9uPXMuZXhwcmVzc2lvbixyPWUucHJvcGVydHk9cy5wcm9wZXJ0eSl9aWYobi5vcHRpb24oXCJwcm9wZXJ0aWVzXCIpJiZuLm9wdGlvbihcInNpZGVfZWZmZWN0c1wiKSYmciBpbnN0YW5jZW9mIHluJiZpIGluc3RhbmNlb2Ygb24pe3ZhciB1PXIuZ2V0VmFsdWUoKSxjPWkuZWxlbWVudHM7aWYodSBpbiBjKXtmb3IodmFyIGY9ITAsbD1bXSxwPWMubGVuZ3RoOy0tcD51Oyl7KGg9Y1twXS5kcm9wX3NpZGVfZWZmZWN0X2ZyZWUobikpJiYobC51bnNoaWZ0KGgpLGYmJmguaGFzX3NpZGVfZWZmZWN0cyhuKSYmKGY9ITEpKX12YXIgZD1jW3VdO2ZvcihkPWQgaW5zdGFuY2VvZiBrbj9YKEVuLGQpOmQsZnx8bC51bnNoaWZ0KGQpOzA8PS0tcDspe3ZhciBoOyhoPWNbcF0uZHJvcF9zaWRlX2VmZmVjdF9mcmVlKG4pKT9sLnVuc2hpZnQoaCk6dS0tfXJldHVybiBmPyhsLnB1c2goZCksTShlLGwpLm9wdGltaXplKG4pKTpYKFplLGUse2V4cHJlc3Npb246WChvbixpLHtlbGVtZW50czpsfSkscHJvcGVydHk6WCh5bixyLHt2YWx1ZTp1fSl9KX19aWYobi5vcHRpb24oXCJhcmd1bWVudHNcIikmJmkgaW5zdGFuY2VvZiBfbiYmXCJhcmd1bWVudHNcIj09aS5uYW1lJiYxPT1pLmRlZmluaXRpb24oKS5vcmlnLmxlbmd0aCYmKHQ9aS5zY29wZSlpbnN0YW5jZW9mIGtlJiZyIGluc3RhbmNlb2YgeW4pe3U9ci5nZXRWYWx1ZSgpO3ZhciB2PXQuYXJnbmFtZXNbdV07aWYoIXYmJiFuLm9wdGlvbihcImtlZXBfZmFyZ3NcIikpZm9yKDt1Pj10LmFyZ25hbWVzLmxlbmd0aDspdj1YKHBuLHQse25hbWU6dC5tYWtlX3Zhcl9uYW1lKFwiYXJndW1lbnRfXCIrdC5hcmduYW1lcy5sZW5ndGgpLHNjb3BlOnR9KSx0LmFyZ25hbWVzLnB1c2godiksdC5lbmNsb3NlZC5wdXNoKHQuZGVmX3ZhcmlhYmxlKHYpKTtpZih2KXt2YXIgXz1YKF9uLGUsdik7cmV0dXJuIF8ucmVmZXJlbmNlKHt9KSxffX12YXIgbT1lLmV2YWx1YXRlKG4pO3JldHVybiBtIT09ZT9JKG4sbT1xKG0sZSkub3B0aW1pemUobiksZSk6ZX0pLGtlLkRFRk1FVEhPRChcImNvbnRhaW5zX3RoaXNcIixmdW5jdGlvbigpe3ZhciBuLHQ9dGhpcztyZXR1cm4gdC53YWxrKG5ldyBTbihmdW5jdGlvbihlKXtyZXR1cm4hIW58fChlIGluc3RhbmNlb2YgbW4/bj0hMDplIT09dCYmZSBpbnN0YW5jZW9mIEFlfHx2b2lkIDApfSkpLG59KSxHZS5ERUZNRVRIT0QoXCJmbGF0dGVuX29iamVjdFwiLGZ1bmN0aW9uKGUsbil7aWYobi5vcHRpb24oXCJwcm9wZXJ0aWVzXCIpKXt2YXIgdD10aGlzLmV4cHJlc3Npb247aWYodCBpbnN0YW5jZW9mIGFuKWZvcih2YXIgaT10LnByb3BlcnRpZXMscj1pLmxlbmd0aDswPD0tLXI7KXt2YXIgbz1pW3JdO2lmKFwiXCIrby5rZXk9PWUpe2lmKCFvZShpLGZ1bmN0aW9uKGUpe3JldHVybiBlIGluc3RhbmNlb2YgdW59KSlicmVhazt2YXIgYT1vLnZhbHVlO2lmKGEgaW5zdGFuY2VvZiBGZSYmIShuLnBhcmVudCgpaW5zdGFuY2VvZiBKZSkmJmEuY29udGFpbnNfdGhpcygpKWJyZWFrO3JldHVybiBYKFplLHRoaXMse2V4cHJlc3Npb246WChvbix0LHtlbGVtZW50czppLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS52YWx1ZX0pfSkscHJvcGVydHk6WCh5bix0aGlzLHt2YWx1ZTpyfSl9KX19fX0pLGUoWGUsZnVuY3Rpb24oZSxuKXtcImFyZ3VtZW50c1wiIT1lLnByb3BlcnR5JiZcImNhbGxlclwiIT1lLnByb3BlcnR5fHxuLndhcm4oXCJGdW5jdGlvbi5wcm90b3lwZS57cHJvcH0gbm90IHN1cHBvcnRlZCBbe2ZpbGV9OntsaW5lfSx7Y29sfV1cIix7cHJvcDplLnByb3BlcnR5LGZpbGU6ZS5zdGFydC5maWxlLGxpbmU6ZS5zdGFydC5saW5lLGNvbDplLnN0YXJ0LmNvbH0pO3ZhciB0PWUucmVzb2x2ZV9kZWZpbmVzKG4pO2lmKHQpcmV0dXJuIHQub3B0aW1pemUobik7aWYobmUoZSxuLnBhcmVudCgpKSlyZXR1cm4gZTtpZihuLm9wdGlvbihcInVuc2FmZV9wcm90b1wiKSYmZS5leHByZXNzaW9uIGluc3RhbmNlb2YgWGUmJlwicHJvdG90eXBlXCI9PWUuZXhwcmVzc2lvbi5wcm9wZXJ0eSl7dmFyIGk9ZS5leHByZXNzaW9uLmV4cHJlc3Npb247aWYoSChpKSlzd2l0Y2goaS5uYW1lKXtjYXNlXCJBcnJheVwiOmUuZXhwcmVzc2lvbj1YKG9uLGUuZXhwcmVzc2lvbix7ZWxlbWVudHM6W119KTticmVhaztjYXNlXCJGdW5jdGlvblwiOmUuZXhwcmVzc2lvbj1YKEZlLGUuZXhwcmVzc2lvbix7YXJnbmFtZXM6W10sYm9keTpbXX0pO2JyZWFrO2Nhc2VcIk51bWJlclwiOmUuZXhwcmVzc2lvbj1YKHluLGUuZXhwcmVzc2lvbix7dmFsdWU6MH0pO2JyZWFrO2Nhc2VcIk9iamVjdFwiOmUuZXhwcmVzc2lvbj1YKGFuLGUuZXhwcmVzc2lvbix7cHJvcGVydGllczpbXX0pO2JyZWFrO2Nhc2VcIlJlZ0V4cFwiOmUuZXhwcmVzc2lvbj1YKHduLGUuZXhwcmVzc2lvbix7dmFsdWU6L3QvfSk7YnJlYWs7Y2FzZVwiU3RyaW5nXCI6ZS5leHByZXNzaW9uPVgoYm4sZS5leHByZXNzaW9uLHt2YWx1ZTpcIlwifSl9fXZhciByPWUuZmxhdHRlbl9vYmplY3QoZS5wcm9wZXJ0eSxuKTtpZihyKXJldHVybiByLm9wdGltaXplKG4pO3ZhciBvPWUuZXZhbHVhdGUobik7cmV0dXJuIG8hPT1lP0kobixvPXEobyxlKS5vcHRpbWl6ZShuKSxlKTplfSksZShUZSxmdW5jdGlvbihlLG4pe3JldHVybiBlLnZhbHVlJiZnKGUudmFsdWUsbikmJihlLnZhbHVlPW51bGwpLGV9KSxlKFZlLGZ1bmN0aW9uKGUsbil7dmFyIHQ9bi5vcHRpb24oXCJnbG9iYWxfZGVmc1wiKTtyZXR1cm4gdCYmYWUodCxlLm5hbWUubmFtZSkmJm4ud2FybihcImdsb2JhbF9kZWZzIFwiK2UubmFtZS5uYW1lK1wiIHJlZGVmaW5lZCBbe2ZpbGV9OntsaW5lfSx7Y29sfV1cIixlLnN0YXJ0KSxlfSl9KCksZnVuY3Rpb24oKXt2YXIgbj1mdW5jdGlvbihlKXtmb3IodmFyIG49ITAsdD0wO3Q8ZS5sZW5ndGg7dCsrKW4mJmVbdF1pbnN0YW5jZW9mIHVlJiZlW3RdLmJvZHkgaW5zdGFuY2VvZiBibj9lW3RdPW5ldyBmZSh7c3RhcnQ6ZVt0XS5zdGFydCxlbmQ6ZVt0XS5lbmQsdmFsdWU6ZVt0XS5ib2R5LnZhbHVlfSk6IW58fGVbdF1pbnN0YW5jZW9mIHVlJiZlW3RdLmJvZHkgaW5zdGFuY2VvZiBibnx8KG49ITEpO3JldHVybiBlfSxpPXtQcm9ncmFtOmZ1bmN0aW9uKGUpe3JldHVybiBuZXcgRWUoe3N0YXJ0OnMoZSksZW5kOnUoZSksYm9keTpuKGUuYm9keS5tYXAoYykpfSl9LEZ1bmN0aW9uRGVjbGFyYXRpb246ZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyBDZSh7c3RhcnQ6cyhlKSxlbmQ6dShlKSxuYW1lOmMoZS5pZCksYXJnbmFtZXM6ZS5wYXJhbXMubWFwKGMpLGJvZHk6bihjKGUuYm9keSkuYm9keSl9KX0sRnVuY3Rpb25FeHByZXNzaW9uOmZ1bmN0aW9uKGUpe3JldHVybiBuZXcgRmUoe3N0YXJ0OnMoZSksZW5kOnUoZSksbmFtZTpjKGUuaWQpLGFyZ25hbWVzOmUucGFyYW1zLm1hcChjKSxib2R5Om4oYyhlLmJvZHkpLmJvZHkpfSl9LEV4cHJlc3Npb25TdGF0ZW1lbnQ6ZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyBsZSh7c3RhcnQ6cyhlKSxlbmQ6dShlKSxib2R5OmMoZS5leHByZXNzaW9uKX0pfSxUcnlTdGF0ZW1lbnQ6ZnVuY3Rpb24oZSl7dmFyIG49ZS5oYW5kbGVyc3x8W2UuaGFuZGxlcl07aWYoMTxuLmxlbmd0aHx8ZS5ndWFyZGVkSGFuZGxlcnMmJmUuZ3VhcmRlZEhhbmRsZXJzLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJNdWx0aXBsZSBjYXRjaCBjbGF1c2VzIGFyZSBub3Qgc3VwcG9ydGVkLlwiKTtyZXR1cm4gbmV3IFJlKHtzdGFydDpzKGUpLGVuZDp1KGUpLGJvZHk6YyhlLmJsb2NrKS5ib2R5LGJjYXRjaDpjKG5bMF0pLGJmaW5hbGx5OmUuZmluYWxpemVyP25ldyBQZShjKGUuZmluYWxpemVyKSk6bnVsbH0pfSxQcm9wZXJ0eTpmdW5jdGlvbihlKXt2YXIgbj1lLmtleSx0PXtzdGFydDpzKG4pLGVuZDp1KGUudmFsdWUpLGtleTpcIklkZW50aWZpZXJcIj09bi50eXBlP24ubmFtZTpuLnZhbHVlLHZhbHVlOmMoZS52YWx1ZSl9O3JldHVyblwiaW5pdFwiPT1lLmtpbmQ/bmV3IHVuKHQpOih0LmtleT1uZXcgSyh7bmFtZTp0LmtleX0pLHQudmFsdWU9bmV3IERlKHQudmFsdWUpLFwiZ2V0XCI9PWUua2luZD9uZXcgWih0KTpcInNldFwiPT1lLmtpbmQ/bmV3IFgodCk6dm9pZCAwKX0sQXJyYXlFeHByZXNzaW9uOmZ1bmN0aW9uKGUpe3JldHVybiBuZXcgb24oe3N0YXJ0OnMoZSksZW5kOnUoZSksZWxlbWVudHM6ZS5lbGVtZW50cy5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIG51bGw9PT1lP25ldyBrbjpjKGUpfSl9KX0sT2JqZWN0RXhwcmVzc2lvbjpmdW5jdGlvbihlKXtyZXR1cm4gbmV3IGFuKHtzdGFydDpzKGUpLGVuZDp1KGUpLHByb3BlcnRpZXM6ZS5wcm9wZXJ0aWVzLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS50eXBlPVwiUHJvcGVydHlcIixjKGUpfSl9KX0sU2VxdWVuY2VFeHByZXNzaW9uOmZ1bmN0aW9uKGUpe3JldHVybiBuZXcgV2Uoe3N0YXJ0OnMoZSksZW5kOnUoZSksZXhwcmVzc2lvbnM6ZS5leHByZXNzaW9ucy5tYXAoYyl9KX0sTWVtYmVyRXhwcmVzc2lvbjpmdW5jdGlvbihlKXtyZXR1cm4gbmV3KGUuY29tcHV0ZWQ/WmU6WGUpKHtzdGFydDpzKGUpLGVuZDp1KGUpLHByb3BlcnR5OmUuY29tcHV0ZWQ/YyhlLnByb3BlcnR5KTplLnByb3BlcnR5Lm5hbWUsZXhwcmVzc2lvbjpjKGUub2JqZWN0KX0pfSxTd2l0Y2hDYXNlOmZ1bmN0aW9uKGUpe3JldHVybiBuZXcoZS50ZXN0P0hlOk5lKSh7c3RhcnQ6cyhlKSxlbmQ6dShlKSxleHByZXNzaW9uOmMoZS50ZXN0KSxib2R5OmUuY29uc2VxdWVudC5tYXAoYyl9KX0sVmFyaWFibGVEZWNsYXJhdGlvbjpmdW5jdGlvbihlKXtyZXR1cm4gbmV3IExlKHtzdGFydDpzKGUpLGVuZDp1KGUpLGRlZmluaXRpb25zOmUuZGVjbGFyYXRpb25zLm1hcChjKX0pfSxMaXRlcmFsOmZ1bmN0aW9uKGUpe3ZhciBuPWUudmFsdWUsdD17c3RhcnQ6cyhlKSxlbmQ6dShlKX07aWYobnVsbD09PW4pcmV0dXJuIG5ldyB4bih0KTtzd2l0Y2godHlwZW9mIG4pe2Nhc2VcInN0cmluZ1wiOnJldHVybiB0LnZhbHVlPW4sbmV3IGJuKHQpO2Nhc2VcIm51bWJlclwiOnJldHVybiB0LnZhbHVlPW4sbmV3IHluKHQpO2Nhc2VcImJvb2xlYW5cIjpyZXR1cm4gbmV3KG4/Qm46Q24pKHQpO2RlZmF1bHQ6dmFyIGk9ZS5yZWdleDtyZXR1cm4gaSYmaS5wYXR0ZXJuP3QudmFsdWU9bmV3IFJlZ0V4cChpLnBhdHRlcm4saS5mbGFncykudG9TdHJpbmcoKTp0LnZhbHVlPWUucmVnZXgmJmUucmF3P2UucmF3Om4sbmV3IHduKHQpfX0sSWRlbnRpZmllcjpmdW5jdGlvbihlKXt2YXIgbj1vW28ubGVuZ3RoLTJdO3JldHVybiBuZXcoXCJMYWJlbGVkU3RhdGVtZW50XCI9PW4udHlwZT9ROlwiVmFyaWFibGVEZWNsYXJhdG9yXCI9PW4udHlwZSYmbi5pZD09PWU/bG46XCJGdW5jdGlvbkV4cHJlc3Npb25cIj09bi50eXBlP24uaWQ9PT1lP2huOnBuOlwiRnVuY3Rpb25EZWNsYXJhdGlvblwiPT1uLnR5cGU/bi5pZD09PWU/ZG46cG46XCJDYXRjaENsYXVzZVwiPT1uLnR5cGU/dm46XCJCcmVha1N0YXRlbWVudFwiPT1uLnR5cGV8fFwiQ29udGludWVTdGF0ZW1lbnRcIj09bi50eXBlP2VlOl9uKSh7c3RhcnQ6cyhlKSxlbmQ6dShlKSxuYW1lOmUubmFtZX0pfX07ZnVuY3Rpb24gcihlKXtpZihcIkxpdGVyYWxcIj09ZS50eXBlKXJldHVybiBudWxsIT1lLnJhdz9lLnJhdzplLnZhbHVlK1wiXCJ9ZnVuY3Rpb24gcyhlKXt2YXIgbj1lLmxvYyx0PW4mJm4uc3RhcnQsaT1lLnJhbmdlO3JldHVybiBuZXcgRih7ZmlsZTpuJiZuLnNvdXJjZSxsaW5lOnQmJnQubGluZSxjb2w6dCYmdC5jb2x1bW4scG9zOmk/aVswXTplLnN0YXJ0LGVuZGxpbmU6dCYmdC5saW5lLGVuZGNvbDp0JiZ0LmNvbHVtbixlbmRwb3M6aT9pWzBdOmUuc3RhcnQscmF3OnIoZSl9KX1mdW5jdGlvbiB1KGUpe3ZhciBuPWUubG9jLHQ9biYmbi5lbmQsaT1lLnJhbmdlO3JldHVybiBuZXcgRih7ZmlsZTpuJiZuLnNvdXJjZSxsaW5lOnQmJnQubGluZSxjb2w6dCYmdC5jb2x1bW4scG9zOmk/aVsxXTplLmVuZCxlbmRsaW5lOnQmJnQubGluZSxlbmRjb2w6dCYmdC5jb2x1bW4sZW5kcG9zOmk/aVsxXTplLmVuZCxyYXc6cihlKX0pfWZ1bmN0aW9uIGUoZSxuLHQpe3ZhciBvPVwiZnVuY3Rpb24gRnJvbV9Nb3pfXCIrZStcIihNKXtcXG5cIjtvKz1cInJldHVybiBuZXcgVTIuXCIrbi5uYW1lK1wiKHtcXG5zdGFydDogbXlfc3RhcnRfdG9rZW4oTSksXFxuZW5kOiBteV9lbmRfdG9rZW4oTSlcIjt2YXIgYT1cImZ1bmN0aW9uIFRvX01vel9cIitlK1wiKE0pe1xcblwiO2ErPVwicmV0dXJuIHtcXG50eXBlOiBcIitKU09OLnN0cmluZ2lmeShlKSx0JiZ0LnNwbGl0KC9cXHMqLFxccyovKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3ZhciBuPS8oW2EtejAtOSRfXSspKD18QHw+fCUpKFthLXowLTkkX10rKS9pLmV4ZWMoZSk7aWYoIW4pdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgdW5kZXJzdGFuZCBwcm9wZXJ0eSBtYXA6IFwiK2UpO3ZhciB0PW5bMV0saT1uWzJdLHI9blszXTtzd2l0Y2gobys9XCIsXFxuXCIrcitcIjogXCIsYSs9XCIsXFxuXCIrdCtcIjogXCIsaSl7Y2FzZVwiQFwiOm8rPVwiTS5cIit0K1wiLm1hcChmcm9tX21veilcIixhKz1cIk0uXCIrcitcIi5tYXAodG9fbW96KVwiO2JyZWFrO2Nhc2VcIj5cIjpvKz1cImZyb21fbW96KE0uXCIrdCtcIilcIixhKz1cInRvX21veihNLlwiK3IrXCIpXCI7YnJlYWs7Y2FzZVwiPVwiOm8rPVwiTS5cIit0LGErPVwiTS5cIityO2JyZWFrO2Nhc2VcIiVcIjpvKz1cImZyb21fbW96KE0uXCIrdCtcIikuYm9keVwiLGErPVwidG9fbW96X2Jsb2NrKE0pXCI7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCB1bmRlcnN0YW5kIG9wZXJhdG9yIGluIHByb3BtYXA6IFwiK2UpfX0pLG8rPVwiXFxufSlcXG59XCIsYSs9XCJcXG59XFxufVwiLG89bmV3IEZ1bmN0aW9uKFwiVTJcIixcIm15X3N0YXJ0X3Rva2VuXCIsXCJteV9lbmRfdG9rZW5cIixcImZyb21fbW96XCIsXCJyZXR1cm4oXCIrbytcIilcIikoaCxzLHUsYyksYT1uZXcgRnVuY3Rpb24oXCJ0b19tb3pcIixcInRvX21vel9ibG9ja1wiLFwidG9fbW96X3Njb3BlXCIsXCJyZXR1cm4oXCIrYStcIilcIikobCxwLGQpLGlbZV09byxmKG4sYSl9aS5VcGRhdGVFeHByZXNzaW9uPWkuVW5hcnlFeHByZXNzaW9uPWZ1bmN0aW9uKGUpe3JldHVybiBuZXcoKFwicHJlZml4XCJpbiBlP2UucHJlZml4OlwiVW5hcnlFeHByZXNzaW9uXCI9PWUudHlwZSk/UWU6ZW4pKHtzdGFydDpzKGUpLGVuZDp1KGUpLG9wZXJhdG9yOmUub3BlcmF0b3IsZXhwcmVzc2lvbjpjKGUuYXJndW1lbnQpfSl9LGUoXCJFbXB0eVN0YXRlbWVudFwiLGhlKSxlKFwiQmxvY2tTdGF0ZW1lbnRcIixkZSxcImJvZHlAYm9keVwiKSxlKFwiSWZTdGF0ZW1lbnRcIixNZSxcInRlc3Q+Y29uZGl0aW9uLCBjb25zZXF1ZW50PmJvZHksIGFsdGVybmF0ZT5hbHRlcm5hdGl2ZVwiKSxlKFwiTGFiZWxlZFN0YXRlbWVudFwiLHZlLFwibGFiZWw+bGFiZWwsIGJvZHk+Ym9keVwiKSxlKFwiQnJlYWtTdGF0ZW1lbnRcIiwkZSxcImxhYmVsPmxhYmVsXCIpLGUoXCJDb250aW51ZVN0YXRlbWVudFwiLHplLFwibGFiZWw+bGFiZWxcIiksZShcIldpdGhTdGF0ZW1lbnRcIix4ZSxcIm9iamVjdD5leHByZXNzaW9uLCBib2R5PmJvZHlcIiksZShcIlN3aXRjaFN0YXRlbWVudFwiLHFlLFwiZGlzY3JpbWluYW50PmV4cHJlc3Npb24sIGNhc2VzQGJvZHlcIiksZShcIlJldHVyblN0YXRlbWVudFwiLFRlLFwiYXJndW1lbnQ+dmFsdWVcIiksZShcIlRocm93U3RhdGVtZW50XCIsRyxcImFyZ3VtZW50PnZhbHVlXCIpLGUoXCJXaGlsZVN0YXRlbWVudFwiLGJlLFwidGVzdD5jb25kaXRpb24sIGJvZHk+Ym9keVwiKSxlKFwiRG9XaGlsZVN0YXRlbWVudFwiLGdlLFwidGVzdD5jb25kaXRpb24sIGJvZHk+Ym9keVwiKSxlKFwiRm9yU3RhdGVtZW50XCIseWUsXCJpbml0PmluaXQsIHRlc3Q+Y29uZGl0aW9uLCB1cGRhdGU+c3RlcCwgYm9keT5ib2R5XCIpLGUoXCJGb3JJblN0YXRlbWVudFwiLHdlLFwibGVmdD5pbml0LCByaWdodD5vYmplY3QsIGJvZHk+Ym9keVwiKSxlKFwiRGVidWdnZXJTdGF0ZW1lbnRcIixjZSksZShcIlZhcmlhYmxlRGVjbGFyYXRvclwiLFZlLFwiaWQ+bmFtZSwgaW5pdD52YWx1ZVwiKSxlKFwiQ2F0Y2hDbGF1c2VcIixJZSxcInBhcmFtPmFyZ25hbWUsIGJvZHklYm9keVwiKSxlKFwiVGhpc0V4cHJlc3Npb25cIixtbiksZShcIkJpbmFyeUV4cHJlc3Npb25cIixubixcIm9wZXJhdG9yPW9wZXJhdG9yLCBsZWZ0PmxlZnQsIHJpZ2h0PnJpZ2h0XCIpLGUoXCJMb2dpY2FsRXhwcmVzc2lvblwiLG5uLFwib3BlcmF0b3I9b3BlcmF0b3IsIGxlZnQ+bGVmdCwgcmlnaHQ+cmlnaHRcIiksZShcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCIscm4sXCJvcGVyYXRvcj1vcGVyYXRvciwgbGVmdD5sZWZ0LCByaWdodD5yaWdodFwiKSxlKFwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCIsdG4sXCJ0ZXN0PmNvbmRpdGlvbiwgY29uc2VxdWVudD5jb25zZXF1ZW50LCBhbHRlcm5hdGU+YWx0ZXJuYXRpdmVcIiksZShcIk5ld0V4cHJlc3Npb25cIixKZSxcImNhbGxlZT5leHByZXNzaW9uLCBhcmd1bWVudHNAYXJnc1wiKSxlKFwiQ2FsbEV4cHJlc3Npb25cIixZZSxcImNhbGxlZT5leHByZXNzaW9uLCBhcmd1bWVudHNAYXJnc1wiKSxmKEVlLGZ1bmN0aW9uKGUpe3JldHVybiBkKFwiUHJvZ3JhbVwiLGUpfSksZihDZSxmdW5jdGlvbihlKXtyZXR1cm57dHlwZTpcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIixpZDpsKGUubmFtZSkscGFyYW1zOmUuYXJnbmFtZXMubWFwKGwpLGJvZHk6ZChcIkJsb2NrU3RhdGVtZW50XCIsZSl9fSksZihGZSxmdW5jdGlvbihlKXtyZXR1cm57dHlwZTpcIkZ1bmN0aW9uRXhwcmVzc2lvblwiLGlkOmwoZS5uYW1lKSxwYXJhbXM6ZS5hcmduYW1lcy5tYXAobCksYm9keTpkKFwiQmxvY2tTdGF0ZW1lbnRcIixlKX19KSxmKGZlLGZ1bmN0aW9uKGUpe3JldHVybnt0eXBlOlwiRXhwcmVzc2lvblN0YXRlbWVudFwiLGV4cHJlc3Npb246e3R5cGU6XCJMaXRlcmFsXCIsdmFsdWU6ZS52YWx1ZX19fSksZihsZSxmdW5jdGlvbihlKXtyZXR1cm57dHlwZTpcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIixleHByZXNzaW9uOmwoZS5ib2R5KX19KSxmKGplLGZ1bmN0aW9uKGUpe3JldHVybnt0eXBlOlwiU3dpdGNoQ2FzZVwiLHRlc3Q6bChlLmV4cHJlc3Npb24pLGNvbnNlcXVlbnQ6ZS5ib2R5Lm1hcChsKX19KSxmKFJlLGZ1bmN0aW9uKGUpe3JldHVybnt0eXBlOlwiVHJ5U3RhdGVtZW50XCIsYmxvY2s6cChlKSxoYW5kbGVyOmwoZS5iY2F0Y2gpLGd1YXJkZWRIYW5kbGVyczpbXSxmaW5hbGl6ZXI6bChlLmJmaW5hbGx5KX19KSxmKEllLGZ1bmN0aW9uKGUpe3JldHVybnt0eXBlOlwiQ2F0Y2hDbGF1c2VcIixwYXJhbTpsKGUuYXJnbmFtZSksZ3VhcmQ6bnVsbCxib2R5OnAoZSl9fSksZihVZSxmdW5jdGlvbihlKXtyZXR1cm57dHlwZTpcIlZhcmlhYmxlRGVjbGFyYXRpb25cIixraW5kOlwidmFyXCIsZGVjbGFyYXRpb25zOmUuZGVmaW5pdGlvbnMubWFwKGwpfX0pLGYoV2UsZnVuY3Rpb24oZSl7cmV0dXJue3R5cGU6XCJTZXF1ZW5jZUV4cHJlc3Npb25cIixleHByZXNzaW9uczplLmV4cHJlc3Npb25zLm1hcChsKX19KSxmKEdlLGZ1bmN0aW9uKGUpe3ZhciBuPWUgaW5zdGFuY2VvZiBaZTtyZXR1cm57dHlwZTpcIk1lbWJlckV4cHJlc3Npb25cIixvYmplY3Q6bChlLmV4cHJlc3Npb24pLGNvbXB1dGVkOm4scHJvcGVydHk6bj9sKGUucHJvcGVydHkpOnt0eXBlOlwiSWRlbnRpZmllclwiLG5hbWU6ZS5wcm9wZXJ0eX19fSksZihLZSxmdW5jdGlvbihlKXtyZXR1cm57dHlwZTpcIisrXCI9PWUub3BlcmF0b3J8fFwiLS1cIj09ZS5vcGVyYXRvcj9cIlVwZGF0ZUV4cHJlc3Npb25cIjpcIlVuYXJ5RXhwcmVzc2lvblwiLG9wZXJhdG9yOmUub3BlcmF0b3IscHJlZml4OmUgaW5zdGFuY2VvZiBRZSxhcmd1bWVudDpsKGUuZXhwcmVzc2lvbil9fSksZihubixmdW5jdGlvbihlKXtyZXR1cm57dHlwZTpcIiYmXCI9PWUub3BlcmF0b3J8fFwifHxcIj09ZS5vcGVyYXRvcj9cIkxvZ2ljYWxFeHByZXNzaW9uXCI6XCJCaW5hcnlFeHByZXNzaW9uXCIsbGVmdDpsKGUubGVmdCksb3BlcmF0b3I6ZS5vcGVyYXRvcixyaWdodDpsKGUucmlnaHQpfX0pLGYob24sZnVuY3Rpb24oZSl7cmV0dXJue3R5cGU6XCJBcnJheUV4cHJlc3Npb25cIixlbGVtZW50czplLmVsZW1lbnRzLm1hcChsKX19KSxmKGFuLGZ1bmN0aW9uKGUpe3JldHVybnt0eXBlOlwiT2JqZWN0RXhwcmVzc2lvblwiLHByb3BlcnRpZXM6ZS5wcm9wZXJ0aWVzLm1hcChsKX19KSxmKHNuLGZ1bmN0aW9uKGUpe3ZhciBuLHQ9e3R5cGU6XCJMaXRlcmFsXCIsdmFsdWU6ZS5rZXkgaW5zdGFuY2VvZiBLP2Uua2V5Lm5hbWU6ZS5rZXl9O3JldHVybiBlIGluc3RhbmNlb2YgdW4/bj1cImluaXRcIjplIGluc3RhbmNlb2YgWj9uPVwiZ2V0XCI6ZSBpbnN0YW5jZW9mIFgmJihuPVwic2V0XCIpLHt0eXBlOlwiUHJvcGVydHlcIixraW5kOm4sa2V5OnQsdmFsdWU6bChlLnZhbHVlKX19KSxmKGNuLGZ1bmN0aW9uKGUpe3ZhciBuPWUuZGVmaW5pdGlvbigpO3JldHVybnt0eXBlOlwiSWRlbnRpZmllclwiLG5hbWU6bj9uLm1hbmdsZWRfbmFtZXx8bi5uYW1lOmUubmFtZX19KSxmKHduLGZ1bmN0aW9uKGUpe3ZhciBuPWUudmFsdWU7cmV0dXJue3R5cGU6XCJMaXRlcmFsXCIsdmFsdWU6bixyYXc6bi50b1N0cmluZygpLHJlZ2V4OntwYXR0ZXJuOm4uc291cmNlLGZsYWdzOm4udG9TdHJpbmcoKS5tYXRjaCgvW2dpbXV5XSokLylbMF19fX0pLGYoZ24sZnVuY3Rpb24oZSl7dmFyIG49ZS52YWx1ZTtyZXR1cm5cIm51bWJlclwiPT10eXBlb2YgbiYmKG48MHx8MD09PW4mJjEvbjwwKT97dHlwZTpcIlVuYXJ5RXhwcmVzc2lvblwiLG9wZXJhdG9yOlwiLVwiLHByZWZpeDohMCxhcmd1bWVudDp7dHlwZTpcIkxpdGVyYWxcIix2YWx1ZTotbixyYXc6ZS5zdGFydC5yYXd9fTp7dHlwZTpcIkxpdGVyYWxcIix2YWx1ZTpuLHJhdzplLnN0YXJ0LnJhd319KSxmKGEsZnVuY3Rpb24oZSl7cmV0dXJue3R5cGU6XCJJZGVudGlmaWVyXCIsbmFtZTpTdHJpbmcoZS52YWx1ZSl9fSksRm4uREVGTUVUSE9EKFwidG9fbW96aWxsYV9hc3RcIixnbi5wcm90b3R5cGUudG9fbW96aWxsYV9hc3QpLHhuLkRFRk1FVEhPRChcInRvX21vemlsbGFfYXN0XCIsZ24ucHJvdG90eXBlLnRvX21vemlsbGFfYXN0KSxrbi5ERUZNRVRIT0QoXCJ0b19tb3ppbGxhX2FzdFwiLGZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9KSxwZS5ERUZNRVRIT0QoXCJ0b19tb3ppbGxhX2FzdFwiLGRlLnByb3RvdHlwZS50b19tb3ppbGxhX2FzdCksa2UuREVGTUVUSE9EKFwidG9fbW96aWxsYV9hc3RcIixGZS5wcm90b3R5cGUudG9fbW96aWxsYV9hc3QpO3ZhciBvPW51bGw7ZnVuY3Rpb24gYyhlKXtvLnB1c2goZSk7dmFyIG49bnVsbCE9ZT9pW2UudHlwZV0oZSk6bnVsbDtyZXR1cm4gby5wb3AoKSxufWZ1bmN0aW9uIGYoZSxyKXtlLkRFRk1FVEhPRChcInRvX21vemlsbGFfYXN0XCIsZnVuY3Rpb24oKXtyZXR1cm4gbj1yKGU9dGhpcyksdD1lLnN0YXJ0LGk9ZS5lbmQsbnVsbCE9dC5wb3MmJm51bGwhPWkuZW5kcG9zJiYobi5yYW5nZT1bdC5wb3MsaS5lbmRwb3NdKSx0LmxpbmUmJihuLmxvYz17c3RhcnQ6e2xpbmU6dC5saW5lLGNvbHVtbjp0LmNvbH0sZW5kOmkuZW5kbGluZT97bGluZTppLmVuZGxpbmUsY29sdW1uOmkuZW5kY29sfTpudWxsfSx0LmZpbGUmJihuLmxvYy5zb3VyY2U9dC5maWxlKSksbjt2YXIgZSxuLHQsaX0pfWZ1bmN0aW9uIGwoZSl7cmV0dXJuIG51bGwhPWU/ZS50b19tb3ppbGxhX2FzdCgpOm51bGx9ZnVuY3Rpb24gcChlKXtyZXR1cm57dHlwZTpcIkJsb2NrU3RhdGVtZW50XCIsYm9keTplLmJvZHkubWFwKGwpfX1mdW5jdGlvbiBkKGUsbil7dmFyIHQ9bi5ib2R5Lm1hcChsKTtyZXR1cm4gbi5ib2R5WzBdaW5zdGFuY2VvZiBsZSYmbi5ib2R5WzBdLmJvZHkgaW5zdGFuY2VvZiBibiYmdC51bnNoaWZ0KGwobmV3IGhlKG4uYm9keVswXSkpKSx7dHlwZTplLGJvZHk6dH19c2UuZnJvbV9tb3ppbGxhX2FzdD1mdW5jdGlvbihlKXt2YXIgbj1vO289W107dmFyIHQ9YyhlKTtyZXR1cm4gbz1uLHR9fSgpO3ZhciB5PVwidW5kZWZpbmVkXCI9PXR5cGVvZiBhdG9iP2Z1bmN0aW9uKGUpe3JldHVybiBuZXcgQnVmZmVyKGUsXCJiYXNlNjRcIikudG9TdHJpbmcoKX06YXRvYix3PVwidW5kZWZpbmVkXCI9PXR5cGVvZiBidG9hP2Z1bmN0aW9uKGUpe3JldHVybiBuZXcgQnVmZmVyKGUpLnRvU3RyaW5nKFwiYmFzZTY0XCIpfTpidG9hO2Z1bmN0aW9uIHgobix0LGUpe3Rbbl0mJmUuZm9yRWFjaChmdW5jdGlvbihlKXt0W2VdJiYoXCJvYmplY3RcIiE9dHlwZW9mIHRbZV0mJih0W2VdPXt9KSxuIGluIHRbZV18fCh0W2VdW25dPXRbbl0pKX0pfWZ1bmN0aW9uIEEoZSl7ZSYmKFwicHJvcHNcImluIGU/ZS5wcm9wcyBpbnN0YW5jZW9mIE98fChlLnByb3BzPU8uZnJvbU9iamVjdChlLnByb3BzKSk6ZS5wcm9wcz1uZXcgTyl9ZnVuY3Rpb24gRShlKXtyZXR1cm57cHJvcHM6ZS5wcm9wcy50b09iamVjdCgpfX1oLkRpY3Rpb25hcnk9TyxoLlRyZWVXYWxrZXI9U24saC5UcmVlVHJhbnNmb3JtZXI9WG4saC5taW5pZnk9ZnVuY3Rpb24oZSxuKXt2YXIgdCxpLHI9c2Uud2Fybl9mdW5jdGlvbjt0cnl7dmFyIG8sYT0obj1ZKG4se2NvbXByZXNzOnt9LGllODohMSxrZWVwX2ZuYW1lczohMSxtYW5nbGU6e30sbmFtZUNhY2hlOm51bGwsb3V0cHV0Ont9LHBhcnNlOnt9LHJlbmFtZTp2b2lkIDAsc291cmNlTWFwOiExLHRpbWluZ3M6ITEsdG9wbGV2ZWw6ITEsd2FybmluZ3M6ITEsd3JhcDohMX0sITApKS50aW1pbmdzJiZ7c3RhcnQ6RGF0ZS5ub3coKX07dm9pZCAwPT09bi5yZW5hbWUmJihuLnJlbmFtZT1uLmNvbXByZXNzJiZuLm1hbmdsZSkseChcImllOFwiLG4sW1wiY29tcHJlc3NcIixcIm1hbmdsZVwiLFwib3V0cHV0XCJdKSx4KFwia2VlcF9mbmFtZXNcIixuLFtcImNvbXByZXNzXCIsXCJtYW5nbGVcIl0pLHgoXCJ0b3BsZXZlbFwiLG4sW1wiY29tcHJlc3NcIixcIm1hbmdsZVwiXSkseChcIndhcm5pbmdzXCIsbixbXCJjb21wcmVzc1wiXSksbi5tYW5nbGUmJihuLm1hbmdsZT1ZKG4ubWFuZ2xlLHtjYWNoZTpuLm5hbWVDYWNoZSYmKG4ubmFtZUNhY2hlLnZhcnN8fHt9KSxldmFsOiExLGllODohMSxrZWVwX2ZuYW1lczohMSxwcm9wZXJ0aWVzOiExLHJlc2VydmVkOltdLHRvcGxldmVsOiExfSwhMCksbi5tYW5nbGUucHJvcGVydGllcyYmKFwib2JqZWN0XCIhPXR5cGVvZiBuLm1hbmdsZS5wcm9wZXJ0aWVzJiYobi5tYW5nbGUucHJvcGVydGllcz17fSksbi5tYW5nbGUucHJvcGVydGllcy5rZWVwX3F1b3RlZCYmKG89bi5tYW5nbGUucHJvcGVydGllcy5yZXNlcnZlZCxBcnJheS5pc0FycmF5KG8pfHwobz1bXSksbi5tYW5nbGUucHJvcGVydGllcy5yZXNlcnZlZD1vKSwhbi5uYW1lQ2FjaGV8fFwiY2FjaGVcImluIG4ubWFuZ2xlLnByb3BlcnRpZXN8fChuLm1hbmdsZS5wcm9wZXJ0aWVzLmNhY2hlPW4ubmFtZUNhY2hlLnByb3BzfHx7fSkpLEEobi5tYW5nbGUuY2FjaGUpLEEobi5tYW5nbGUucHJvcGVydGllcy5jYWNoZSkpLG4uc291cmNlTWFwJiYobi5zb3VyY2VNYXA9WShuLnNvdXJjZU1hcCx7Y29udGVudDpudWxsLGZpbGVuYW1lOm51bGwsaW5jbHVkZVNvdXJjZXM6ITEscm9vdDpudWxsLHVybDpudWxsfSwhMCkpO3ZhciBzLHU9W107aWYobi53YXJuaW5ncyYmIXNlLndhcm5fZnVuY3Rpb24mJihzZS53YXJuX2Z1bmN0aW9uPWZ1bmN0aW9uKGUpe3UucHVzaChlKX0pLGEmJihhLnBhcnNlPURhdGUubm93KCkpLGUgaW5zdGFuY2VvZiBFZSlzPWU7ZWxzZXtmb3IodmFyIGMgaW5cInN0cmluZ1wiPT10eXBlb2YgZSYmKGU9W2VdKSxuLnBhcnNlPW4ucGFyc2V8fHt9LG4ucGFyc2UudG9wbGV2ZWw9bnVsbCxlKWlmKGFlKGUsYykmJihuLnBhcnNlLmZpbGVuYW1lPWMsbi5wYXJzZS50b3BsZXZlbD1HbihlW2NdLG4ucGFyc2UpLG4uc291cmNlTWFwJiZcImlubGluZVwiPT1uLnNvdXJjZU1hcC5jb250ZW50KSl7aWYoMTxPYmplY3Qua2V5cyhlKS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiaW5saW5lIHNvdXJjZSBtYXAgb25seSB3b3JrcyB3aXRoIHNpbmd1bGFyIGlucHV0XCIpO24uc291cmNlTWFwLmNvbnRlbnQ9KHQ9ZVtjXSwoaT0vXFxuXFwvXFwvIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb25cXC9qc29uKDsuKj8pPztiYXNlNjQsKC4qKS8uZXhlYyh0KSk/eShpWzJdKTooc2Uud2FybihcImlubGluZSBzb3VyY2UgbWFwIG5vdCBmb3VuZFwiKSxudWxsKSl9cz1uLnBhcnNlLnRvcGxldmVsfW8mJmZ1bmN0aW9uKGUsbil7ZnVuY3Rpb24gdChlKXt2KG4sZSl9ZS53YWxrKG5ldyBTbihmdW5jdGlvbihlKXtlIGluc3RhbmNlb2YgdW4mJmUucXVvdGU/dChlLmtleSk6ZSBpbnN0YW5jZW9mIFplJiZiKGUucHJvcGVydHksdCl9KSl9KHMsbyksbi53cmFwJiYocz1zLndyYXBfY29tbW9uanMobi53cmFwKSksYSYmKGEucmVuYW1lPURhdGUubm93KCkpLG4ucmVuYW1lJiYocy5maWd1cmVfb3V0X3Njb3BlKG4ubWFuZ2xlKSxzLmV4cGFuZF9uYW1lcyhuLm1hbmdsZSkpLGEmJihhLmNvbXByZXNzPURhdGUubm93KCkpLG4uY29tcHJlc3MmJihzPW5ldyBldChuLmNvbXByZXNzKS5jb21wcmVzcyhzKSksYSYmKGEuc2NvcGU9RGF0ZS5ub3coKSksbi5tYW5nbGUmJnMuZmlndXJlX291dF9zY29wZShuLm1hbmdsZSksYSYmKGEubWFuZ2xlPURhdGUubm93KCkpLG4ubWFuZ2xlJiYocy5jb21wdXRlX2NoYXJfZnJlcXVlbmN5KG4ubWFuZ2xlKSxzLm1hbmdsZV9uYW1lcyhuLm1hbmdsZSkpLGEmJihhLnByb3BlcnRpZXM9RGF0ZS5ub3coKSksbi5tYW5nbGUmJm4ubWFuZ2xlLnByb3BlcnRpZXMmJihzPWQocyxuLm1hbmdsZS5wcm9wZXJ0aWVzKSksYSYmKGEub3V0cHV0PURhdGUubm93KCkpO3ZhciBmPXt9O2lmKG4ub3V0cHV0LmFzdCYmKGYuYXN0PXMpLCFhZShuLm91dHB1dCxcImNvZGVcIil8fG4ub3V0cHV0LmNvZGUpe2lmKG4uc291cmNlTWFwJiYoXCJzdHJpbmdcIj09dHlwZW9mIG4uc291cmNlTWFwLmNvbnRlbnQmJihuLnNvdXJjZU1hcC5jb250ZW50PUpTT04ucGFyc2Uobi5zb3VyY2VNYXAuY29udGVudCkpLG4ub3V0cHV0LnNvdXJjZV9tYXA9ZnVuY3Rpb24ocyl7cz1ZKHMse2ZpbGU6bnVsbCxyb290Om51bGwsb3JpZzpudWxsLG9yaWdfbGluZV9kaWZmOjAsZGVzdF9saW5lX2RpZmY6MH0pO3ZhciB1PW5ldyBNT1pfU291cmNlTWFwLlNvdXJjZU1hcEdlbmVyYXRvcih7ZmlsZTpzLmZpbGUsc291cmNlUm9vdDpzLnJvb3R9KSxjPXMub3JpZyYmbmV3IE1PWl9Tb3VyY2VNYXAuU291cmNlTWFwQ29uc3VtZXIocy5vcmlnKTtyZXR1cm4gYyYmQXJyYXkuaXNBcnJheShzLm9yaWcuc291cmNlcykmJmMuX3NvdXJjZXMudG9BcnJheSgpLmZvckVhY2goZnVuY3Rpb24oZSl7dmFyIG49Yy5zb3VyY2VDb250ZW50Rm9yKGUsITApO24mJnUuc2V0U291cmNlQ29udGVudChlLG4pfSkse2FkZDpmdW5jdGlvbihlLG4sdCxpLHIsbyl7aWYoYyl7dmFyIGE9Yy5vcmlnaW5hbFBvc2l0aW9uRm9yKHtsaW5lOmksY29sdW1uOnJ9KTtpZihudWxsPT09YS5zb3VyY2UpcmV0dXJuO2U9YS5zb3VyY2UsaT1hLmxpbmUscj1hLmNvbHVtbixvPWEubmFtZXx8b311LmFkZE1hcHBpbmcoe2dlbmVyYXRlZDp7bGluZTpuK3MuZGVzdF9saW5lX2RpZmYsY29sdW1uOnR9LG9yaWdpbmFsOntsaW5lOmkrcy5vcmlnX2xpbmVfZGlmZixjb2x1bW46cn0sc291cmNlOmUsbmFtZTpvfSl9LGdldDpmdW5jdGlvbigpe3JldHVybiB1fSx0b1N0cmluZzpmdW5jdGlvbigpe3JldHVybiBKU09OLnN0cmluZ2lmeSh1LnRvSlNPTigpKX19fSh7ZmlsZTpuLnNvdXJjZU1hcC5maWxlbmFtZSxvcmlnOm4uc291cmNlTWFwLmNvbnRlbnQscm9vdDpuLnNvdXJjZU1hcC5yb290fSksbi5zb3VyY2VNYXAuaW5jbHVkZVNvdXJjZXMpKXtpZihlIGluc3RhbmNlb2YgRWUpdGhyb3cgbmV3IEVycm9yKFwib3JpZ2luYWwgc291cmNlIGNvbnRlbnQgdW5hdmFpbGFibGVcIik7Zm9yKHZhciBjIGluIGUpYWUoZSxjKSYmbi5vdXRwdXQuc291cmNlX21hcC5nZXQoKS5zZXRTb3VyY2VDb250ZW50KGMsZVtjXSl9ZGVsZXRlIG4ub3V0cHV0LmFzdCxkZWxldGUgbi5vdXRwdXQuY29kZTt2YXIgbD1RbihuLm91dHB1dCk7cy5wcmludChsKSxmLmNvZGU9bC5nZXQoKSxuLnNvdXJjZU1hcCYmKGYubWFwPW4ub3V0cHV0LnNvdXJjZV9tYXAudG9TdHJpbmcoKSxcImlubGluZVwiPT1uLnNvdXJjZU1hcC51cmw/Zi5jb2RlKz1cIlxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxcIit3KGYubWFwKTpuLnNvdXJjZU1hcC51cmwmJihmLmNvZGUrPVwiXFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9XCIrbi5zb3VyY2VNYXAudXJsKSl9cmV0dXJuIG4ubmFtZUNhY2hlJiZuLm1hbmdsZSYmKG4ubWFuZ2xlLmNhY2hlJiYobi5uYW1lQ2FjaGUudmFycz1FKG4ubWFuZ2xlLmNhY2hlKSksbi5tYW5nbGUucHJvcGVydGllcyYmbi5tYW5nbGUucHJvcGVydGllcy5jYWNoZSYmKG4ubmFtZUNhY2hlLnByb3BzPUUobi5tYW5nbGUucHJvcGVydGllcy5jYWNoZSkpKSxhJiYoYS5lbmQ9RGF0ZS5ub3coKSxmLnRpbWluZ3M9e3BhcnNlOi4wMDEqKGEucmVuYW1lLWEucGFyc2UpLHJlbmFtZTouMDAxKihhLmNvbXByZXNzLWEucmVuYW1lKSxjb21wcmVzczouMDAxKihhLnNjb3BlLWEuY29tcHJlc3MpLHNjb3BlOi4wMDEqKGEubWFuZ2xlLWEuc2NvcGUpLG1hbmdsZTouMDAxKihhLnByb3BlcnRpZXMtYS5tYW5nbGUpLHByb3BlcnRpZXM6LjAwMSooYS5vdXRwdXQtYS5wcm9wZXJ0aWVzKSxvdXRwdXQ6LjAwMSooYS5lbmQtYS5vdXRwdXQpLHRvdGFsOi4wMDEqKGEuZW5kLWEuc3RhcnQpfSksdS5sZW5ndGgmJihmLndhcm5pbmdzPXUpLGZ9Y2F0Y2goZSl7cmV0dXJue2Vycm9yOmV9fWZpbmFsbHl7c2Uud2Fybl9mdW5jdGlvbj1yfX0saC5wYXJzZT1HbixoLl9wdXNoX3VuaXE9dn0oXCJ1bmRlZmluZWRcIj09dHlwZW9mIFVnbGlmeUpTP1VnbGlmeUpTPXt9OlVnbGlmeUpTKTttb2R1bGUuZXhwb3J0cyA9IGdsb2JhbC5VZ2xpZnlKU1xuZGVsZXRlIGdsb2JhbC5VZ2xpZnlKU1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvdWdsaWZ5anMtYnJvd3Nlci9idWlsZC5qc1xuLy8gbW9kdWxlIGlkID0gMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///18\n");

/***/ }),
/* 19 */
/*!*************************************************!*\
  !*** ./src/components/raw-textarea/raw-text.js ***!
  \*************************************************/
/*! exports provided: default */
/*! exports used: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_js_base64__ = __webpack_require__(/*! js-base64 */ 0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_js_base64___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_js_base64__);\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n// Import Base64\n\n\nvar _wp$element = wp.element,\n    Component = _wp$element.Component,\n    Fragment = _wp$element.Fragment;\nvar TextControl = wp.components.TextControl;\n\nvar RawTextControl = function (_Component) {\n  _inherits(RawTextControl, _Component);\n\n  function RawTextControl() {\n    _classCallCheck(this, RawTextControl);\n\n    return _possibleConstructorReturn(this, (RawTextControl.__proto__ || Object.getPrototypeOf(RawTextControl)).apply(this, arguments));\n  }\n\n  _createClass(RawTextControl, [{\n    key: 'render',\n    value: function render() {\n      var _this2 = this;\n\n      return wp.element.createElement(\n        Fragment,\n        null,\n        wp.element.createElement(\n          'div',\n          { className: 'components-base-control mcw-textarea-comp' },\n          wp.element.createElement(\n            'label',\n            null,\n            this.props.label\n          ),\n          wp.element.createElement(\n            'div',\n            { className: 'mcw-textarea-comp-inner' },\n            wp.element.createElement(\n              'p',\n              { className: 'mcw-textarea-def' },\n              this.props.beginning\n            ),\n            wp.element.createElement(TextControl, {\n              type: 'string',\n              placeholder: 'name=\"viewport\" content=\"width=device-width,initial-scale=1.0\"',\n              value: __WEBPACK_IMPORTED_MODULE_0_js_base64__[\"Base64\"].decode(this.props.value),\n              onChange: function onChange(value) {\n                return _this2.props.onChange(__WEBPACK_IMPORTED_MODULE_0_js_base64__[\"Base64\"].encode(value));\n              }\n            }),\n            wp.element.createElement(\n              'p',\n              { className: 'mcw-textarea-def' },\n              this.props.ending\n            )\n          )\n        )\n      );\n    }\n  }]);\n\n  return RawTextControl;\n}(Component);\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (RawTextControl);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9yYXctdGV4dGFyZWEvcmF3LXRleHQuanM/ODA1ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbi8vIEltcG9ydCBCYXNlNjRcbmltcG9ydCB7IEJhc2U2NCB9IGZyb20gJ2pzLWJhc2U2NCc7XG5cbnZhciBfd3AkZWxlbWVudCA9IHdwLmVsZW1lbnQsXG4gICAgQ29tcG9uZW50ID0gX3dwJGVsZW1lbnQuQ29tcG9uZW50LFxuICAgIEZyYWdtZW50ID0gX3dwJGVsZW1lbnQuRnJhZ21lbnQ7XG52YXIgVGV4dENvbnRyb2wgPSB3cC5jb21wb25lbnRzLlRleHRDb250cm9sO1xuXG52YXIgUmF3VGV4dENvbnRyb2wgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoUmF3VGV4dENvbnRyb2wsIF9Db21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFJhd1RleHRDb250cm9sKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSYXdUZXh0Q29udHJvbCk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFJhd1RleHRDb250cm9sLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoUmF3VGV4dENvbnRyb2wpKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhSYXdUZXh0Q29udHJvbCwgW3tcbiAgICBrZXk6ICdyZW5kZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgcmV0dXJuIHdwLmVsZW1lbnQuY3JlYXRlRWxlbWVudChcbiAgICAgICAgRnJhZ21lbnQsXG4gICAgICAgIG51bGwsXG4gICAgICAgIHdwLmVsZW1lbnQuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICB7IGNsYXNzTmFtZTogJ2NvbXBvbmVudHMtYmFzZS1jb250cm9sIG1jdy10ZXh0YXJlYS1jb21wJyB9LFxuICAgICAgICAgIHdwLmVsZW1lbnQuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICdsYWJlbCcsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgdGhpcy5wcm9wcy5sYWJlbFxuICAgICAgICAgICksXG4gICAgICAgICAgd3AuZWxlbWVudC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICB7IGNsYXNzTmFtZTogJ21jdy10ZXh0YXJlYS1jb21wLWlubmVyJyB9LFxuICAgICAgICAgICAgd3AuZWxlbWVudC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAncCcsXG4gICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiAnbWN3LXRleHRhcmVhLWRlZicgfSxcbiAgICAgICAgICAgICAgdGhpcy5wcm9wcy5iZWdpbm5pbmdcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICB3cC5lbGVtZW50LmNyZWF0ZUVsZW1lbnQoVGV4dENvbnRyb2wsIHtcbiAgICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICAgIHBsYWNlaG9sZGVyOiAnbmFtZT1cInZpZXdwb3J0XCIgY29udGVudD1cIndpZHRoPWRldmljZS13aWR0aCxpbml0aWFsLXNjYWxlPTEuMFwiJyxcbiAgICAgICAgICAgICAgdmFsdWU6IEJhc2U2NC5kZWNvZGUodGhpcy5wcm9wcy52YWx1ZSksXG4gICAgICAgICAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiBvbkNoYW5nZSh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczIucHJvcHMub25DaGFuZ2UoQmFzZTY0LmVuY29kZSh2YWx1ZSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHdwLmVsZW1lbnQuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgJ3AnLFxuICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogJ21jdy10ZXh0YXJlYS1kZWYnIH0sXG4gICAgICAgICAgICAgIHRoaXMucHJvcHMuZW5kaW5nXG4gICAgICAgICAgICApXG4gICAgICAgICAgKVxuICAgICAgICApXG4gICAgICApO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBSYXdUZXh0Q29udHJvbDtcbn0oQ29tcG9uZW50KTtcblxuZXhwb3J0IGRlZmF1bHQgUmF3VGV4dENvbnRyb2w7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvY29tcG9uZW50cy9yYXctdGV4dGFyZWEvcmF3LXRleHQuanNcbi8vIG1vZHVsZSBpZCA9IDE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///19\n");

/***/ }),
/* 20 */
/*!*************************************************************************!*\
  !*** ./src/components/block-with-description/block-with-description.js ***!
  \*************************************************************************/
/*! exports provided: default */
/*! exports used: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _wp$element = wp.element,\n    Component = _wp$element.Component,\n    Fragment = _wp$element.Fragment;\n\nvar BlockWithDescription = function (_Component) {\n  _inherits(BlockWithDescription, _Component);\n\n  function BlockWithDescription() {\n    _classCallCheck(this, BlockWithDescription);\n\n    return _possibleConstructorReturn(this, (BlockWithDescription.__proto__ || Object.getPrototypeOf(BlockWithDescription)).apply(this, arguments));\n  }\n\n  _createClass(BlockWithDescription, [{\n    key: 'render',\n    value: function render() {\n      return wp.element.createElement(\n        Fragment,\n        null,\n        this.props.children,\n        wp.element.createElement(\n          'div',\n          { className: 'components-base-control mcw-js-css-desc' },\n          this.props.description\n        )\n      );\n    }\n  }]);\n\n  return BlockWithDescription;\n}(Component);\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (BlockWithDescription);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9ibG9jay13aXRoLWRlc2NyaXB0aW9uL2Jsb2NrLXdpdGgtZGVzY3JpcHRpb24uanM/MDY3OSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBfd3AkZWxlbWVudCA9IHdwLmVsZW1lbnQsXG4gICAgQ29tcG9uZW50ID0gX3dwJGVsZW1lbnQuQ29tcG9uZW50LFxuICAgIEZyYWdtZW50ID0gX3dwJGVsZW1lbnQuRnJhZ21lbnQ7XG5cbnZhciBCbG9ja1dpdGhEZXNjcmlwdGlvbiA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhCbG9ja1dpdGhEZXNjcmlwdGlvbiwgX0NvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gQmxvY2tXaXRoRGVzY3JpcHRpb24oKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJsb2NrV2l0aERlc2NyaXB0aW9uKTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoQmxvY2tXaXRoRGVzY3JpcHRpb24uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihCbG9ja1dpdGhEZXNjcmlwdGlvbikpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEJsb2NrV2l0aERlc2NyaXB0aW9uLCBbe1xuICAgIGtleTogJ3JlbmRlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHJldHVybiB3cC5lbGVtZW50LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgIEZyYWdtZW50LFxuICAgICAgICBudWxsLFxuICAgICAgICB0aGlzLnByb3BzLmNoaWxkcmVuLFxuICAgICAgICB3cC5lbGVtZW50LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgeyBjbGFzc05hbWU6ICdjb21wb25lbnRzLWJhc2UtY29udHJvbCBtY3ctanMtY3NzLWRlc2MnIH0sXG4gICAgICAgICAgdGhpcy5wcm9wcy5kZXNjcmlwdGlvblxuICAgICAgICApXG4gICAgICApO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBCbG9ja1dpdGhEZXNjcmlwdGlvbjtcbn0oQ29tcG9uZW50KTtcblxuZXhwb3J0IGRlZmF1bHQgQmxvY2tXaXRoRGVzY3JpcHRpb247XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvY29tcG9uZW50cy9ibG9jay13aXRoLWRlc2NyaXB0aW9uL2Jsb2NrLXdpdGgtZGVzY3JpcHRpb24uanNcbi8vIG1vZHVsZSBpZCA9IDIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///20\n");

/***/ }),
/* 21 */
/*!***************************************!*\
  !*** ./src/components/modal/modal.js ***!
  \***************************************/
/*! exports provided: default */
/*! exports used: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\r\n * BLOCK: FullPage Wrapper\r\n */\n\nvar _wp$element = wp.element,\n    Component = _wp$element.Component,\n    Fragment = _wp$element.Fragment;\nvar _wp$components = wp.components,\n    Button = _wp$components.Button,\n    Modal = _wp$components.Modal;\n\nvar ModalSettings = function (_Component) {\n  _inherits(ModalSettings, _Component);\n\n  function ModalSettings() {\n    _classCallCheck(this, ModalSettings);\n\n    var _this = _possibleConstructorReturn(this, (ModalSettings.__proto__ || Object.getPrototypeOf(ModalSettings)).apply(this, arguments));\n\n    _this.state = {\n      isOpen: false\n    };\n    return _this;\n  }\n\n  _createClass(ModalSettings, [{\n    key: 'render',\n    value: function render() {\n      var _this2 = this;\n\n      var isOpen = this.state.isOpen;\n\n\n      return wp.element.createElement(\n        Fragment,\n        null,\n        wp.element.createElement(\n          Button,\n          {\n            className: 'mcw-modal-button',\n            isDefault: true,\n            onClick: function onClick() {\n              return _this2.setState({ isOpen: true });\n            }\n          },\n          this.props.buttonText\n        ),\n        isOpen && wp.element.createElement(\n          Modal,\n          {\n            title: this.props.modalTitle,\n            shouldCloseOnClickOutside: false,\n            className: 'mcw-modal-component',\n            onRequestClose: function onRequestClose() {\n              _this2.setState({ isOpen: false });\n            }\n          },\n          this.props.children,\n          wp.element.createElement(\n            Button,\n            {\n              isDefault: true,\n              isPrimary: true,\n              onClick: function onClick() {\n                return _this2.setState({ isOpen: false });\n              }\n            },\n            this.props.modalButtonText\n          )\n        )\n      );\n    }\n  }]);\n\n  return ModalSettings;\n}(Component);\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (ModalSettings);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9tb2RhbC9tb2RhbC5qcz85NmMwIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLyoqXHJcbiAqIEJMT0NLOiBGdWxsUGFnZSBXcmFwcGVyXHJcbiAqL1xuXG52YXIgX3dwJGVsZW1lbnQgPSB3cC5lbGVtZW50LFxuICAgIENvbXBvbmVudCA9IF93cCRlbGVtZW50LkNvbXBvbmVudCxcbiAgICBGcmFnbWVudCA9IF93cCRlbGVtZW50LkZyYWdtZW50O1xudmFyIF93cCRjb21wb25lbnRzID0gd3AuY29tcG9uZW50cyxcbiAgICBCdXR0b24gPSBfd3AkY29tcG9uZW50cy5CdXR0b24sXG4gICAgTW9kYWwgPSBfd3AkY29tcG9uZW50cy5Nb2RhbDtcblxudmFyIE1vZGFsU2V0dGluZ3MgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoTW9kYWxTZXR0aW5ncywgX0NvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gTW9kYWxTZXR0aW5ncygpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTW9kYWxTZXR0aW5ncyk7XG5cbiAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoTW9kYWxTZXR0aW5ncy5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKE1vZGFsU2V0dGluZ3MpKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcblxuICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgaXNPcGVuOiBmYWxzZVxuICAgIH07XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKE1vZGFsU2V0dGluZ3MsIFt7XG4gICAga2V5OiAncmVuZGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBpc09wZW4gPSB0aGlzLnN0YXRlLmlzT3BlbjtcblxuXG4gICAgICByZXR1cm4gd3AuZWxlbWVudC5jcmVhdGVFbGVtZW50KFxuICAgICAgICBGcmFnbWVudCxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgd3AuZWxlbWVudC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgIEJ1dHRvbixcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjbGFzc05hbWU6ICdtY3ctbW9kYWwtYnV0dG9uJyxcbiAgICAgICAgICAgIGlzRGVmYXVsdDogdHJ1ZSxcbiAgICAgICAgICAgIG9uQ2xpY2s6IGZ1bmN0aW9uIG9uQ2xpY2soKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpczIuc2V0U3RhdGUoeyBpc09wZW46IHRydWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICB0aGlzLnByb3BzLmJ1dHRvblRleHRcbiAgICAgICAgKSxcbiAgICAgICAgaXNPcGVuICYmIHdwLmVsZW1lbnQuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICBNb2RhbCxcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aXRsZTogdGhpcy5wcm9wcy5tb2RhbFRpdGxlLFxuICAgICAgICAgICAgc2hvdWxkQ2xvc2VPbkNsaWNrT3V0c2lkZTogZmFsc2UsXG4gICAgICAgICAgICBjbGFzc05hbWU6ICdtY3ctbW9kYWwtY29tcG9uZW50JyxcbiAgICAgICAgICAgIG9uUmVxdWVzdENsb3NlOiBmdW5jdGlvbiBvblJlcXVlc3RDbG9zZSgpIHtcbiAgICAgICAgICAgICAgX3RoaXMyLnNldFN0YXRlKHsgaXNPcGVuOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHRoaXMucHJvcHMuY2hpbGRyZW4sXG4gICAgICAgICAgd3AuZWxlbWVudC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgQnV0dG9uLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpc0RlZmF1bHQ6IHRydWUsXG4gICAgICAgICAgICAgIGlzUHJpbWFyeTogdHJ1ZSxcbiAgICAgICAgICAgICAgb25DbGljazogZnVuY3Rpb24gb25DbGljaygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMyLnNldFN0YXRlKHsgaXNPcGVuOiBmYWxzZSB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRoaXMucHJvcHMubW9kYWxCdXR0b25UZXh0XG4gICAgICAgICAgKVxuICAgICAgICApXG4gICAgICApO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBNb2RhbFNldHRpbmdzO1xufShDb21wb25lbnQpO1xuXG5leHBvcnQgZGVmYXVsdCBNb2RhbFNldHRpbmdzO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2NvbXBvbmVudHMvbW9kYWwvbW9kYWwuanNcbi8vIG1vZHVsZSBpZCA9IDIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///21\n");

/***/ }),
/* 22 */
/*!***************************!*\
  !*** ./src/block/save.js ***!
  \***************************/
/*! exports provided: default */
/*! exports used: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_js_base64__ = __webpack_require__(/*! js-base64 */ 0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_js_base64___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_js_base64__);\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\r\n * BLOCK: FullPage Wrapper\r\n */\n\n/* Import Base64 */\n\n\nvar _wp$element = wp.element,\n    Fragment = _wp$element.Fragment,\n    Component = _wp$element.Component;\n\nvar CustomJsAndCssSave = function (_Component) {\n  _inherits(CustomJsAndCssSave, _Component);\n\n  function CustomJsAndCssSave() {\n    _classCallCheck(this, CustomJsAndCssSave);\n\n    return _possibleConstructorReturn(this, (CustomJsAndCssSave.__proto__ || Object.getPrototypeOf(CustomJsAndCssSave)).apply(this, arguments));\n  }\n\n  _createClass(CustomJsAndCssSave, [{\n    key: \"render\",\n    value: function render() {\n      var _props$attributes = this.props.attributes,\n          jsInlineParams = _props$attributes.jsInlineParams,\n          cssInlineParams = _props$attributes.cssInlineParams;\n\n\n      return wp.element.createElement(\n        Fragment,\n        null,\n        cssInlineParams[0].min && cssInlineParams[0].min.length !== 0 && wp.element.createElement(\n          \"style\",\n          { type: \"text/css\" },\n          __WEBPACK_IMPORTED_MODULE_0_js_base64__[\"Base64\"].decode(cssInlineParams[0].min)\n        ),\n        jsInlineParams[0].min && jsInlineParams[0].min.length !== 0 && wp.element.createElement(\n          \"script\",\n          { type: \"text/javascript\" },\n          __WEBPACK_IMPORTED_MODULE_0_js_base64__[\"Base64\"].decode(jsInlineParams[0].min)\n        )\n      );\n    }\n  }]);\n\n  return CustomJsAndCssSave;\n}(Component);\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (CustomJsAndCssSave);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYmxvY2svc2F2ZS5qcz9jNGQ0Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLyoqXHJcbiAqIEJMT0NLOiBGdWxsUGFnZSBXcmFwcGVyXHJcbiAqL1xuXG4vKiBJbXBvcnQgQmFzZTY0ICovXG5pbXBvcnQgeyBCYXNlNjQgfSBmcm9tICdqcy1iYXNlNjQnO1xuXG52YXIgX3dwJGVsZW1lbnQgPSB3cC5lbGVtZW50LFxuICAgIEZyYWdtZW50ID0gX3dwJGVsZW1lbnQuRnJhZ21lbnQsXG4gICAgQ29tcG9uZW50ID0gX3dwJGVsZW1lbnQuQ29tcG9uZW50O1xuXG52YXIgQ3VzdG9tSnNBbmRDc3NTYXZlID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgX2luaGVyaXRzKEN1c3RvbUpzQW5kQ3NzU2F2ZSwgX0NvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gQ3VzdG9tSnNBbmRDc3NTYXZlKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDdXN0b21Kc0FuZENzc1NhdmUpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChDdXN0b21Kc0FuZENzc1NhdmUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihDdXN0b21Kc0FuZENzc1NhdmUpKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhDdXN0b21Kc0FuZENzc1NhdmUsIFt7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgX3Byb3BzJGF0dHJpYnV0ZXMgPSB0aGlzLnByb3BzLmF0dHJpYnV0ZXMsXG4gICAgICAgICAganNJbmxpbmVQYXJhbXMgPSBfcHJvcHMkYXR0cmlidXRlcy5qc0lubGluZVBhcmFtcyxcbiAgICAgICAgICBjc3NJbmxpbmVQYXJhbXMgPSBfcHJvcHMkYXR0cmlidXRlcy5jc3NJbmxpbmVQYXJhbXM7XG5cblxuICAgICAgcmV0dXJuIHdwLmVsZW1lbnQuY3JlYXRlRWxlbWVudChcbiAgICAgICAgRnJhZ21lbnQsXG4gICAgICAgIG51bGwsXG4gICAgICAgIGNzc0lubGluZVBhcmFtc1swXS5taW4gJiYgY3NzSW5saW5lUGFyYW1zWzBdLm1pbi5sZW5ndGggIT09IDAgJiYgd3AuZWxlbWVudC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgIFwic3R5bGVcIixcbiAgICAgICAgICB7IHR5cGU6IFwidGV4dC9jc3NcIiB9LFxuICAgICAgICAgIEJhc2U2NC5kZWNvZGUoY3NzSW5saW5lUGFyYW1zWzBdLm1pbilcbiAgICAgICAgKSxcbiAgICAgICAganNJbmxpbmVQYXJhbXNbMF0ubWluICYmIGpzSW5saW5lUGFyYW1zWzBdLm1pbi5sZW5ndGggIT09IDAgJiYgd3AuZWxlbWVudC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgIFwic2NyaXB0XCIsXG4gICAgICAgICAgeyB0eXBlOiBcInRleHQvamF2YXNjcmlwdFwiIH0sXG4gICAgICAgICAgQmFzZTY0LmRlY29kZShqc0lubGluZVBhcmFtc1swXS5taW4pXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEN1c3RvbUpzQW5kQ3NzU2F2ZTtcbn0oQ29tcG9uZW50KTtcblxuZXhwb3J0IGRlZmF1bHQgQ3VzdG9tSnNBbmRDc3NTYXZlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2Jsb2NrL3NhdmUuanNcbi8vIG1vZHVsZSBpZCA9IDIyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///22\n");

/***/ })
/******/ ]);